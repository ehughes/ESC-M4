L 1 "..\..\..\..\..\..\COMMON\SRC\TEST\CM_TEST.c"
N#if (BOARD==0 || BOARD==1 || BOARD==2)
X#if (2==0 || 2==1 || 2==2)
N  
N	 #include "board.h"
L 1 "..\..\..\brd_xpresso54114\inc\board.h" 1
N/*
N * @brief NXP LPCXpresso LPC54114 board file
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __BOARD_H_
N#define __BOARD_H_
N
N#include "chip.h"
L 1 "..\..\..\chip_5411x\inc\chip.h" 1
N/*
N * @brief LPC5411x basic chip inclusion file
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __CHIP_H_
N#define __CHIP_H_
N
N#include "lpc_types.h"
L 1 "..\..\..\chip_5411x\inc\lpc_types.h" 1
N/*
N * @brief Common types used in LPC functions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __LPC_TYPES_H_
N#define __LPC_TYPES_H_
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 36 "..\..\..\chip_5411x\inc\lpc_types.h" 2
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060019
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 37 "..\..\..\chip_5411x\inc\lpc_types.h" 2
N
N/** @defgroup LPC_Types CHIP: LPC Common Types
N * @ingroup CHIP_Common
N * @{
N */
N
N/** @defgroup LPC_Types_Public_Types LPC Public Types
N * @{
N */
N
N/**
N * @brief Boolean Type definition
N */
Ntypedef enum {FALSE = 0, TRUE = !FALSE} Bool;
N
N/**
N * @brief Boolean Type definition
N */
N#if !defined(__cplusplus)
X#if !0L
N// typedef enum {false = 0, true = !false} bool;
N#endif
N
N/**
N * @brief Flag Status and Interrupt Flag Status type definition
N */
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, IntStatus, SetState;
N#define PARAM_SETSTATE(State) ((State == RESET) || (State == SET))
N
N/**
N * @brief Functional State Definition
N */
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define PARAM_FUNCTIONALSTATE(State) ((State == DISABLE) || (State == ENABLE))
N
N/**
N * @ Status type definition
N */
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} Status;
N
N/**
N * Read/Write transfer type mode (Block or non-block)
N */
Ntypedef enum {
N	NONE_BLOCKING = 0,		/**< None Blocking type */
N	BLOCKING,				/**< Blocking type */
N} TRANSFER_BLOCK_T;
N
N/** Pointer to Function returning Void (any number of parameters) */
Ntypedef void (*PFV)();
N
N/** Pointer to Function returning int32_t (any number of parameters) */
Ntypedef int32_t (*PFI)();
N
N/**
N * @}
N */
N
N/** @defgroup LPC_Types_Public_Macros  LPC Public Macros
N * @{
N */
N
N/* _BIT(n) sets the bit at position "n"
N * _BIT(n) is intended to be used in "OR" and "AND" expressions:
N * e.g., "(_BIT(3) | _BIT(7))".
N */
N#undef _BIT
N/* Set bit macro */
N#define _BIT(n) (1 << (n))
N
N/* _SBF(f,v) sets the bit field starting at position "f" to value "v".
N * _SBF(f,v) is intended to be used in "OR" and "AND" expressions:
N * e.g., "((_SBF(5,7) | _SBF(12,0xF)) & 0xFFFF)"
N */
N#undef _SBF
N/* Set bit field macro */
N#define _SBF(f, v) ((v) << (f))
N
N/* _BITMASK constructs a symbol with 'field_width' least significant
N * bits set.
N * e.g., _BITMASK(5) constructs '0x1F', _BITMASK(16) == 0xFFFF
N * The symbol is intended to be used to limit the bit field width
N * thusly:
N * <a_register> = (any_expression) & _BITMASK(x), where 0 < x <= 32.
N * If "any_expression" results in a value that is larger than can be
N * contained in 'x' bits, the bits above 'x - 1' are masked off.  When
N * used with the _SBF example above, the example would be written:
N * a_reg = ((_SBF(5,7) | _SBF(12,0xF)) & _BITMASK(16))
N * This ensures that the value written to a_reg is no wider than
N * 16 bits, and makes the code easier to read and understand.
N */
N#undef _BITMASK
N/* Bitmask creation macro */
N#define _BITMASK(field_width) ( _BIT(field_width) - 1)
N
N/* NULL pointer */
N#ifndef NULL
N#define NULL ((void *) 0)
N#endif
N
N/* Number of elements in an array */
N#define NELEMENTS(array)  (sizeof(array) / sizeof(array[0]))
N
N/* Static data/function define */
N#define STATIC static
N/* External data/function define */
N#define EXTERN extern
N
N#if !defined(MAX)
X#if !0L
N#define MAX(a, b) (((a) > (b)) ? (a) : (b))
N#endif
N#if !defined(MIN)
X#if !0L
N#define MIN(a, b) (((a) < (b)) ? (a) : (b))
N#endif
N
N/**
N * @}
N */
N
N/* Old Type Definition compatibility */
N/** @addtogroup LPC_Types_Public_Types
N * @{
N */
N
N/** LPC type for character type */
Ntypedef char CHAR;
N
N/** LPC type for 8 bit unsigned value */
Ntypedef uint8_t UNS_8;
N
N/** LPC type for 8 bit signed value */
Ntypedef int8_t INT_8;
N
N/** LPC type for 16 bit unsigned value */
Ntypedef uint16_t UNS_16;
N
N/** LPC type for 16 bit signed value */
Ntypedef int16_t INT_16;
N
N/** LPC type for 32 bit unsigned value */
Ntypedef uint32_t UNS_32;
N
N/** LPC type for 32 bit signed value */
Ntypedef int32_t INT_32;
N
N/** LPC type for 64 bit signed value */
Ntypedef int64_t INT_64;
N
N/** LPC type for 64 bit unsigned value */
Ntypedef uint64_t UNS_64;
N
N#ifdef __CODE_RED
S#define BOOL_32 bool
S#define BOOL_16 bool
S#define BOOL_8  bool
N#else
N/** 32 bit boolean type */
Ntypedef bool BOOL_32;
Xtypedef _Bool BOOL_32;
N
N/** 16 bit boolean type */
Ntypedef bool BOOL_16;
Xtypedef _Bool BOOL_16;
N
N/** 8 bit boolean type */
Ntypedef bool BOOL_8;
Xtypedef _Bool BOOL_8;
N#endif
N
N#ifdef __CC_ARM
N#define INLINE  __inline
N#else
S#define INLINE inline
N#endif
N
N#ifdef __ICCARM__
S#define ALIGNSTR(x) # x
S#define ALIGN(x) _Pragma(ALIGNSTR(data_alignment = x))
S#define WEAK    __weak
N#else /* __CC_ARM || __GNUC__ */
N#define ALIGN(x) __attribute__ ((aligned(x)))
N#define WEAK __attribute__((weak))
N#endif
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#endif /* __LPC_TYPES_H_ */
L 36 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "cmsis.h"
L 1 "..\..\..\chip_5411x\inc\cmsis.h" 1
N/*
N * @brief LPC5411x selective CMSIS inclusion file
N *
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __CMSIS_H_
N#define __CMSIS_H_
N
N#include "lpc_types.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Select correct CMSIS include file based on CORE_* definition */
N#if defined(CORE_M4)
X#if 1L
N#include "cmsis_5411x.h"
L 1 "..\..\..\chip_5411x\inc\cmsis_5411x.h" 1
N/*
N * @brief Basic CMSIS include file for LPC5411x M4 core
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __CMSIS_5411X_H_
N#define __CMSIS_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup CMSIS_5411X_M4 CHIP: LPC5411X M4 core CMSIS include file
N * @ingroup CHIP_5411X_CMSIS_DRIVERS
N * @{
N */
N
N#if defined(__ARMCC_VERSION)
X#if 1L
N// Kill warning "#pragma push with no matching #pragma pop"
N  #pragma diag_suppress 2525
N  #pragma push
N  #pragma anon_unions
N#elif defined(__CWCC__)
S  #pragma push
S  #pragma cpp_extensions on
S#elif defined(__GNUC__)
S/* anonymous unions are enabled by default */
S#elif defined(__IAR_SYSTEMS_ICC__)
S//  #pragma push // FIXME not usable for IAR
S  #pragma language=extended
S#else
S  #error Not supported compiler type
N#endif
N
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N */
N
N#if !defined(CORE_M4)
X#if !1L
S#error "CORE_M4 is not defined"
N#endif
N
N/** @defgroup CMSIS_5411X_M4_IRQ CHIP_5411X: LPC5411X M4 core peripheral interrupt numbers
N * @{
N */
N
Ntypedef enum {
N	/******  Cortex-M4 Processor Exceptions Numbers ***************************************************/
N	Reset_IRQn                    = -15,    /*!< 1  Reset Vector, invoked on Power up and warm reset */
N	NonMaskableInt_IRQn           = -14,    /*!< 2  Non maskable Interrupt, cannot be stopped or preempted */
N	HardFault_IRQn                = -13,    /*!< 3  Hard Fault, all classes of Fault */
N	MemoryManagement_IRQn         = -12,    /*!< 4  Memory Management, MPU mismatch, including Access Violation and No Match */
N	BusFault_IRQn                 = -11,    /*!< 5  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory related Fault */
N	UsageFault_IRQn               = -10,    /*!< 6  Usage Fault, i.e. Undef Instruction, Illegal State Transition */
N	SVCall_IRQn                   =  -5,    /*!< 11  System Service Call via SVC instruction */
N	DebugMonitor_IRQn             =  -4,    /*!< 12  Debug Monitor                    */
N	PendSV_IRQn                   =  -2,    /*!< 14  Pendable request for system service */
N	SysTick_IRQn                  =  -1,    /*!< 15  System Tick Timer                */
N
N	/******  LPC5411X Specific Interrupt Numbers ********************************************************/
N	WDTBOD_IRQn,        /*!< WWDT                                             */
N	DMA_IRQn,           /*!< DMA                                              */
N	GINT0_IRQn,         /*!< GINT0                                            */
N	GINT1_IRQn,         /*!< GINT1                                            */
N	PIN_INT0_IRQn,      /*!< PININT0                                          */
N	PIN_INT1_IRQn,      /*!< PININT1                                          */
N	PIN_INT2_IRQn,      /*!< PININT2                                          */
N	PIN_INT3_IRQn,      /*!< PININT3                                          */
N	UTICK_IRQn,         /*!< Micro-tick Timer interrupt                       */
N	MRT_IRQn,           /*!< Multi-rate timer interrupt                       */
N	CT32B0_IRQn,        /*!< CTMR0                                            */
N	CT32B1_IRQn,        /*!< CTMR1                                            */
N	SCT0_IRQn,          /*!< SCT                                              */
N	CT32B3_IRQn,        /*!< CTMR3                                            */
N	FLEXCOMM0_IRQn,     /*!< FLEXCOMM0                                        */
N	FLEXCOMM1_IRQn,     /*!< FLEXCOMM1                                        */
N	FLEXCOMM2_IRQn,     /*!< FLEXCOMM2                                        */
N	FLEXCOMM3_IRQn,     /*!< FLEXCOMM3                                        */
N	FLEXCOMM4_IRQn,     /*!< FLEXCOMM4                                        */
N	FLEXCOMM5_IRQn,     /*!< FLEXCOMM5                                        */
N	FLEXCOMM6_IRQn,     /*!< FLEXCOMM6                                        */
N	FLEXCOMM7_IRQn,     /*!< FLEXCOMM7                                        */
N	ADC_SEQA_IRQn,      /*!< ADC0 sequence A completion                       */
N	ADC_SEQB_IRQn,      /*!< ADC0 sequence B completion                       */
N	ADC_THCMP_IRQn,     /*!< ADC0 threshold compare and error                 */
N	DMIC_IRQn,          /*!< Digital Mic                                      */
N	HWVAD_IRQn,         /*!< Hardware Voice acitivity detect                  */
N	USBACT_IRQn,        /*!< USB Activity                                     */
N	USB_IRQn,           /*!< USB                                              */
N	RTC_IRQn,           /*!< RTC alarm and wake-up interrupts                 */
N	Reserved_IRQn,      /*!< Reserved Interrupt                               */
N	MAILBOX_IRQn,       /*!< Mailbox                                          */
N	PIN_INT4_IRQn,      /*!< External Interrupt 4                             */
N	PIN_INT5_IRQn,      /*!< External Interrupt 5                             */
N	PIN_INT6_IRQn,      /*!< External Interrupt 6                             */
N	PIN_INT7_IRQn,      /*!< External Interrupt 7                             */
N	CT32B2_IRQn,        /*!< CTMR2                                            */
N	CT32B4_IRQn,        /*!< CTMR4                                            */
N	Reserved1_IRQn,     /*!< Reserved Interrupt                               */
N	SPIFI_IRQn,         /*!< SPI Flash interface                              */
N} LPC5411X_IRQn_Type;
N
N/**
N * @}
N */
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/** @defgroup CMSIS_5411X_M4_COMMON CHIP: LPC5411X M4 core Cortex CMSIS definitions
N * @{
N */
N
N/* Configuration of the Cortex-M4 Processor and Core Peripherals */
N#define __CM4_REV                 0x0001	/*!< Cortex-M4 Core Revision                          */
N#define __MPU_PRESENT             1			/*!< MPU present or not                               */
N#define __NVIC_PRIO_BITS          3			/*!< Number of Bits used for Priority Levels          */
N#define __Vendor_SysTickConfig    0			/*!< Set to 1 if different SysTick Config is used     */
N#define __FPU_PRESENT             1
N
N/** @brief interrupt Alias */
N#define TIMER0_IRQn CT32B0_IRQn
N#define TIMER1_IRQn CT32B1_IRQn
N#define TIMER2_IRQn CT32B2_IRQn
N#define TIMER3_IRQn CT32B3_IRQn
N#define TIMER4_IRQn CT32B4_IRQn
N#define SCT_IRQn SCT0_IRQn
N#define ADC0_SEQA_IRQn ADC_SEQA_IRQn
N#define ADC0_SEQB_IRQn ADC_SEQB_IRQn
N#define ADC0_THCMP_IRQn ADC_THCMP_IRQn
N
N/** @brief	Interrupt handler Alias */
N#define TIMER0_IRQHandler CT32B0_IRQHandler
N#define TIMER1_IRQHandler CT32B1_IRQHandler
N#define TIMER2_IRQHandler CT32B2_IRQHandler
N#define TIMER3_IRQHandler CT32B3_IRQHandler
N#define TIMER4_IRQHandler CT32B4_IRQHandler
N#define SCT_IRQHandler SCT0_IRQHandler
N#define ADC0_SEQA_IRQHandler ADC_SEQA_IRQHandler
N#define ADC0_SEQB_IRQHandler ADC_SEQB_IRQHandler
N#define ADC0_THCMP_IRQHandler ADC_THCMP_IRQHandler
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CMSIS_5411X_H_ */
L 41 "..\..\..\chip_5411x\inc\cmsis.h" 2
Ntypedef LPC5411X_IRQn_Type IRQn_Type;
N#include "core_cm4.h"					/*!< Cortex-M4 processor and core peripherals      */
L 1 "..\..\..\chip_5411x\inc\core_cm4.h" 1
N/**************************************************************************//**
N * @file     core_cm4.h
N * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
N * @version  V3.20
N * @date     25. February 2013
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2013 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM4_H_GENERIC
N#define __CORE_CM4_H_GENERIC
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M4
N  @{
N */
N
N/*  CMSIS CM4 definitions */
N#define __CM4_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM4_CMSIS_VERSION_SUB   (0x20)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM4_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16) |                                     __CM4_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x04)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not. For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
N*/
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 1L
N    #if (__FPU_PRESENT == 1)
X    #if (1 == 1)
N      #define __FPU_USED       1
N    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
N    #endif
N  #else
S    #define __FPU_USED         0
N  #endif
N
N#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "..\..\..\chip_5411x\inc\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V3.20
N * @date     05. March 2013
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2013 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060422 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/** \brief  Breakpoint
N
N    This function causes the processor to enter Debug state.
N    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N
N    \param [in]    value  is ignored by the processor.
N                   If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x04) >= 0x03)
N
N/** \brief  Reverse bit order of value
N
N    This function reverses the bit order of the given value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __RBIT                            __rbit
N
N
N/** \brief  LDR Exclusive (8 bit)
N
N    This function performs a exclusive LDR command for 8 bit value.
N
N    \param [in]    ptr  Pointer to data
N    \return             value of type uint8_t at (*ptr)
N */
N#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (16 bit)
N
N    This function performs a exclusive LDR command for 16 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint16_t at (*ptr)
N */
N#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (32 bit)
N
N    This function performs a exclusive LDR command for 32 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint32_t at (*ptr)
N */
N#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
N
N
N/** \brief  STR Exclusive (8 bit)
N
N    This function performs a exclusive STR command for 8 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXB(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (16 bit)
N
N    This function performs a exclusive STR command for 16 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXH(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (32 bit)
N
N    This function performs a exclusive STR command for 32 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  Remove the exclusive lock
N
N    This function removes the exclusive lock which is created by LDREX.
N
N */
N#define __CLREX                           __clrex
N
N
N/** \brief  Signed Saturate
N
N    This function saturates a signed value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (1..32)
N    \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/** \brief  Unsigned Saturate
N
N    This function saturates an unsigned value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (0..31)
N    \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/** \brief  Count leading zeros
N
N    This function counts the number of leading zeros of a data value.
N
N    \param [in]  value  Value to count the leading zeros
N    \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/* Define macros for porting to both thumb1 and thumb2.
S * For thumb1, use low register (r0-r7), specified by constrant "l"
S * Otherwise, use general registers, specified by constrant "r" */
S#if defined (__thumb__) && !defined (__thumb2__)
S#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
S#define __CMSIS_GCC_USE_REG(r) "l" (r)
S#else
S#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
S#define __CMSIS_GCC_USE_REG(r) "r" (r)
S#endif
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
S  return __builtin_bswap32(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S  return (short)__builtin_bswap16(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S  return (op1 >> op2) | (op1 << (32 - op2)); 
S}
S
S
S/** \brief  Breakpoint
S
S    This function causes the processor to enter Debug state.
S    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
S
S    \param [in]    value  is ignored by the processor.
S                   If required, a debugger can use it to store additional information about the breakpoint.
S */
S#define __BKPT(value)                       __ASM volatile ("bkpt "#value)
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex" ::: "memory");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
S{
S   uint32_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 170 "..\..\..\chip_5411x\inc\core_cm4.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "..\..\..\chip_5411x\inc\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V3.20
N * @date     25. February 2013
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2013 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060422 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x04) >= 0x03)
N
N/** \brief  Enable FIQ
N
N    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/** \brief  Disable FIQ
N
N    This function disables FIQ interrupts by setting the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/** \brief  Get Base Priority
N
N    This function returns the current value of the Base Priority register.
N
N    \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/** \brief  Set Base Priority
N
N    This function assigns the given value to the Base Priority register.
N
N    \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xff);
N}
N
N
N/** \brief  Get Fault Mask
N
N    This function returns the current value of the Fault Mask register.
N
N    \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/** \brief  Set Fault Mask
N
N    This function assigns the given value to the Fault Mask register.
N
N    \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1);
N}
N
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x04) == 0x04)
N
N/** \brief  Get FPSCR
N
N    This function returns the current value of the Floating Point Status/Control register.
N
N    \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
X#if (1 == 1) && (1 == 1)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  return(__regfpscr);
N#else
S   return(0);
N#endif
N}
N
N
N/** \brief  Set FPSCR
N
N    This function assigns the given value to the Floating Point Status/Control register.
N
N    \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
X#if (1 == 1) && (1 == 1)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  __regfpscr = (fpscr);
N#endif
N}
N
N#endif /* (__CORTEX_M == 0x04) */
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i" : : : "memory");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i" : : : "memory");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f" : : : "memory");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f" : : : "memory");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  __ASM volatile ("");
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
S  __ASM volatile ("");
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N#endif /* __CORE_CMFUNC_H */
L 171 "..\..\..\chip_5411x\inc\core_cm4.h" 2
N#include <core_cm4_simd.h>               /* Compiler specific SIMD Intrinsics               */
L 1 "..\..\..\chip_5411x\inc\core_cm4_simd.h" 1
N/**************************************************************************//**
N * @file     core_cm4_simd.h
N * @brief    CMSIS Cortex-M4 SIMD Header File
N * @version  V3.20
N * @date     25. February 2013
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2013 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM4_SIMD_H
N#define __CORE_CM4_SIMD_H
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
N#define __SADD8                           __sadd8
N#define __QADD8                           __qadd8
N#define __SHADD8                          __shadd8
N#define __UADD8                           __uadd8
N#define __UQADD8                          __uqadd8
N#define __UHADD8                          __uhadd8
N#define __SSUB8                           __ssub8
N#define __QSUB8                           __qsub8
N#define __SHSUB8                          __shsub8
N#define __USUB8                           __usub8
N#define __UQSUB8                          __uqsub8
N#define __UHSUB8                          __uhsub8
N#define __SADD16                          __sadd16
N#define __QADD16                          __qadd16
N#define __SHADD16                         __shadd16
N#define __UADD16                          __uadd16
N#define __UQADD16                         __uqadd16
N#define __UHADD16                         __uhadd16
N#define __SSUB16                          __ssub16
N#define __QSUB16                          __qsub16
N#define __SHSUB16                         __shsub16
N#define __USUB16                          __usub16
N#define __UQSUB16                         __uqsub16
N#define __UHSUB16                         __uhsub16
N#define __SASX                            __sasx
N#define __QASX                            __qasx
N#define __SHASX                           __shasx
N#define __UASX                            __uasx
N#define __UQASX                           __uqasx
N#define __UHASX                           __uhasx
N#define __SSAX                            __ssax
N#define __QSAX                            __qsax
N#define __SHSAX                           __shsax
N#define __USAX                            __usax
N#define __UQSAX                           __uqsax
N#define __UHSAX                           __uhsax
N#define __USAD8                           __usad8
N#define __USADA8                          __usada8
N#define __SSAT16                          __ssat16
N#define __USAT16                          __usat16
N#define __UXTB16                          __uxtb16
N#define __UXTAB16                         __uxtab16
N#define __SXTB16                          __sxtb16
N#define __SXTAB16                         __sxtab16
N#define __SMUAD                           __smuad
N#define __SMUADX                          __smuadx
N#define __SMLAD                           __smlad
N#define __SMLADX                          __smladx
N#define __SMLALD                          __smlald
N#define __SMLALDX                         __smlaldx
N#define __SMUSD                           __smusd
N#define __SMUSDX                          __smusdx
N#define __SMLSD                           __smlsd
N#define __SMLSDX                          __smlsdx
N#define __SMLSLD                          __smlsld
N#define __SMLSLDX                         __smlsldx
N#define __SEL                             __sel
N#define __QADD                            __qadd
N#define __QSUB                            __qsub
N
N#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
N                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
N
N#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
N                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
N
N#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
N                                                      ((int64_t)(ARG3) << 32)      ) >> 32))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32)      ) >> 32))
N
N/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
N
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
S#include <cmsis_iar.h>
S
S/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
S
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
S#include <cmsis_ccs.h>
S
S/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
S
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("ssub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("usub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("ssub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("usub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("ssax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("usax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USAD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("usad8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USADA8(uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("usada8 %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S#define __SSAT16(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT16(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S#define __USAT16(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT16(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UXTB16(uint32_t op1)
S{
S  uint32_t result;
S
S  __ASM volatile ("uxtb16 %0, %1" : "=r" (result) : "r" (op1));
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UXTAB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SXTB16(uint32_t op1)
S{
S  uint32_t result;
S
S  __ASM volatile ("sxtb16 %0, %1" : "=r" (result) : "r" (op1));
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SXTAB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUAD  (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("smuad %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUADX (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("smuadx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLAD (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("smlad %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLADX (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("smladx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S#define __SMLALD(ARG1,ARG2,ARG3) \
S({ \
S  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((uint64_t)(ARG3) >> 32), __ARG3_L = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL); \
S  __ASM volatile ("smlald %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
S  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
S })
X#define __SMLALD(ARG1,ARG2,ARG3) ({   uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((uint64_t)(ARG3) >> 32), __ARG3_L = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL);   __ASM volatile ("smlald %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) );   (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L);  })
S
S#define __SMLALDX(ARG1,ARG2,ARG3) \
S({ \
S  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((uint64_t)(ARG3) >> 32), __ARG3_L = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL); \
S  __ASM volatile ("smlaldx %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
S  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
S })
X#define __SMLALDX(ARG1,ARG2,ARG3) ({   uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((uint64_t)(ARG3) >> 32), __ARG3_L = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL);   __ASM volatile ("smlaldx %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) );   (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L);  })
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUSD  (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("smusd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUSDX (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("smusdx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLSD (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("smlsd %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLSDX (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("smlsdx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S#define __SMLSLD(ARG1,ARG2,ARG3) \
S({ \
S  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((ARG3) >> 32), __ARG3_L = (uint32_t)((ARG3) & 0xFFFFFFFFUL); \
S  __ASM volatile ("smlsld %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
S  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
S })
X#define __SMLSLD(ARG1,ARG2,ARG3) ({   uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((ARG3) >> 32), __ARG3_L = (uint32_t)((ARG3) & 0xFFFFFFFFUL);   __ASM volatile ("smlsld %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) );   (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L);  })
S
S#define __SMLSLDX(ARG1,ARG2,ARG3) \
S({ \
S  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((ARG3) >> 32), __ARG3_L = (uint32_t)((ARG3) & 0xFFFFFFFFUL); \
S  __ASM volatile ("smlsldx %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
S  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
S })
X#define __SMLSLDX(ARG1,ARG2,ARG3) ({   uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((ARG3) >> 32), __ARG3_L = (uint32_t)((ARG3) & 0xFFFFFFFFUL);   __ASM volatile ("smlsldx %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) );   (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L);  })
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SEL  (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sel %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qadd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qsub %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S#define __PKHBT(ARG1,ARG2,ARG3) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
S  __ASM ("pkhbt %0, %1, %2, lsl %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
S  __RES; \
S })
X#define __PKHBT(ARG1,ARG2,ARG3) ({                            uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2);   __ASM ("pkhbt %0, %1, %2, lsl %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  );   __RES;  })
S
S#define __PKHTB(ARG1,ARG2,ARG3) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
S  if (ARG3 == 0) \
S    __ASM ("pkhtb %0, %1, %2" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2)  ); \
S  else \
S    __ASM ("pkhtb %0, %1, %2, asr %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
S  __RES; \
S })
X#define __PKHTB(ARG1,ARG2,ARG3) ({                            uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2);   if (ARG3 == 0)     __ASM ("pkhtb %0, %1, %2" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2)  );   else     __ASM ("pkhtb %0, %1, %2, asr %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  );   __RES;  })
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMMLA (int32_t op1, int32_t op2, int32_t op3)
S{
S int32_t result;
S
S __ASM volatile ("smmla %0, %1, %2, %3" : "=r" (result): "r"  (op1), "r" (op2), "r" (op3) );
S return(result);
S}
S
S/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
S
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S
S/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
S/* not yet supported */
S/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
S
S
N#endif
N
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CORE_CM4_SIMD_H */
N
N#ifdef __cplusplus
S}
N#endif
L 172 "..\..\..\chip_5411x\inc\core_cm4.h" 2
N
N#endif /* __CORE_CM4_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM4_H_DEPENDANT
N#define __CORE_CM4_H_DEPENDANT
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM4_REV
S    #define __CM4_REV               0x0000
S    #warning "__CM4_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __FPU_PRESENT
S    #define __FPU_PRESENT             0
S    #warning "__FPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M4 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N  - Core FPU Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x04) != 0x04)
S    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
N    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
N    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x04) != 0x04)
S    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
N    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
N    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[8];                  
N       uint32_t RESERVED0[24];
N  __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register         */
X  volatile uint32_t ICER[8];                  
N       uint32_t RSERVED1[24];
N  __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register          */
X  volatile uint32_t ISPR[8];                  
N       uint32_t RESERVED2[24];
N  __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register        */
X  volatile uint32_t ICPR[8];                  
N       uint32_t RESERVED3[24];
N  __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register           */
X  volatile uint32_t IABR[8];                  
N       uint32_t RESERVED4[56];
N  __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240];                  
N       uint32_t RESERVED5[644];
N  __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register     */
X  volatile  uint32_t STIR;                     
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0                                          /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL << NVIC_STIR_INTID_Pos)            /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
X  volatile uint32_t VTOR;                     
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N  __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12];                  
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N  __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register                    */
X  volatile uint32_t CFSR;                     
N  __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  HardFault Status Register                             */
X  volatile uint32_t HFSR;                     
N  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                     
N  __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register                      */
X  volatile uint32_t MMFAR;                    
N  __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  BusFault Address Register                             */
X  volatile uint32_t BFAR;                     
N  __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register                       */
X  volatile uint32_t AFSR;                     
N  __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register                            */
X  volatile const  uint32_t PFR[2];                   
N  __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register                                */
X  volatile const  uint32_t DFR;                      
N  __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register                            */
X  volatile const  uint32_t ADR;                      
N  __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register                         */
X  volatile const  uint32_t MMFR[4];                  
N  __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register                   */
X  volatile const  uint32_t ISAR[5];                  
N       uint32_t RESERVED0[5];
N  __IO uint32_t CPACR;                   /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register                   */
X  volatile uint32_t CPACR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Registers Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Registers Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N    \brief      Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/** \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N       uint32_t RESERVED0[1];
N  __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register      */
X  volatile const  uint32_t ICTR;                     
N  __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register              */
X  volatile uint32_t ACTLR;                    
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0                                          /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL << SCnSCB_ICTR_INTLINESNUM_Pos)      /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#define SCnSCB_ACTLR_DISOOFP_Pos            9                                          /*!< ACTLR: DISOOFP Position */
N#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
N
N#define SCnSCB_ACTLR_DISFPCA_Pos            8                                          /*!< ACTLR: DISFPCA Position */
N#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2                                          /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1                                          /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0                                          /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL << SCnSCB_ACTLR_DISMCYCINT_Pos)        /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N    \brief      Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __O  union
X  volatile  union
N  {
N    __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit                   */
X    volatile  uint8_t    u8;                   
N    __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit                  */
X    volatile  uint16_t   u16;                  
N    __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit                  */
X    volatile  uint32_t   u32;                  
N  }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers               */
N       uint32_t RESERVED0[864];
N  __IO uint32_t TER;                     /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register                 */
X  volatile uint32_t TER;                      
N       uint32_t RESERVED1[15];
N  __IO uint32_t TPR;                     /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register              */
X  volatile uint32_t TPR;                      
N       uint32_t RESERVED2[15];
N  __IO uint32_t TCR;                     /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register                */
X  volatile uint32_t TCR;                      
N       uint32_t RESERVED3[29];
N  __O  uint32_t IWR;                     /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register            */
X  volatile  uint32_t IWR;                      
N  __I  uint32_t IRR;                     /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register             */
X  volatile const  uint32_t IRR;                      
N  __IO uint32_t IMCR;                    /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register     */
X  volatile uint32_t IMCR;                     
N       uint32_t RESERVED4[43];
N  __O  uint32_t LAR;                     /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register                  */
X  volatile  uint32_t LAR;                      
N  __I  uint32_t LSR;                     /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register                  */
X  volatile const  uint32_t LSR;                      
N       uint32_t RESERVED5[6];
N  __I  uint32_t PID4;                    /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                     
N  __I  uint32_t PID5;                    /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                     
N  __I  uint32_t PID6;                    /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                     
N  __I  uint32_t PID7;                    /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                     
N  __I  uint32_t PID0;                    /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                     
N  __I  uint32_t PID1;                    /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                     
N  __I  uint32_t PID2;                    /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                     
N  __I  uint32_t PID3;                    /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                     
N  __I  uint32_t CID0;                    /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                     
N  __I  uint32_t CID1;                    /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                     
N  __I  uint32_t CID2;                    /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                     
N  __I  uint32_t CID3;                    /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                     
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16                                             /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10                                             /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N    \brief      Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/** \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  Control Register                          */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t CYCCNT;                  /*!< Offset: 0x004 (R/W)  Cycle Count Register                      */
X  volatile uint32_t CYCCNT;                   
N  __IO uint32_t CPICNT;                  /*!< Offset: 0x008 (R/W)  CPI Count Register                        */
X  volatile uint32_t CPICNT;                   
N  __IO uint32_t EXCCNT;                  /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register         */
X  volatile uint32_t EXCCNT;                   
N  __IO uint32_t SLEEPCNT;                /*!< Offset: 0x010 (R/W)  Sleep Count Register                      */
X  volatile uint32_t SLEEPCNT;                 
N  __IO uint32_t LSUCNT;                  /*!< Offset: 0x014 (R/W)  LSU Count Register                        */
X  volatile uint32_t LSUCNT;                   
N  __IO uint32_t FOLDCNT;                 /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register         */
X  volatile uint32_t FOLDCNT;                  
N  __I  uint32_t PCSR;                    /*!< Offset: 0x01C (R/ )  Program Counter Sample Register           */
X  volatile const  uint32_t PCSR;                     
N  __IO uint32_t COMP0;                   /*!< Offset: 0x020 (R/W)  Comparator Register 0                     */
X  volatile uint32_t COMP0;                    
N  __IO uint32_t MASK0;                   /*!< Offset: 0x024 (R/W)  Mask Register 0                           */
X  volatile uint32_t MASK0;                    
N  __IO uint32_t FUNCTION0;               /*!< Offset: 0x028 (R/W)  Function Register 0                       */
X  volatile uint32_t FUNCTION0;                
N       uint32_t RESERVED0[1];
N  __IO uint32_t COMP1;                   /*!< Offset: 0x030 (R/W)  Comparator Register 1                     */
X  volatile uint32_t COMP1;                    
N  __IO uint32_t MASK1;                   /*!< Offset: 0x034 (R/W)  Mask Register 1                           */
X  volatile uint32_t MASK1;                    
N  __IO uint32_t FUNCTION1;               /*!< Offset: 0x038 (R/W)  Function Register 1                       */
X  volatile uint32_t FUNCTION1;                
N       uint32_t RESERVED1[1];
N  __IO uint32_t COMP2;                   /*!< Offset: 0x040 (R/W)  Comparator Register 2                     */
X  volatile uint32_t COMP2;                    
N  __IO uint32_t MASK2;                   /*!< Offset: 0x044 (R/W)  Mask Register 2                           */
X  volatile uint32_t MASK2;                    
N  __IO uint32_t FUNCTION2;               /*!< Offset: 0x048 (R/W)  Function Register 2                       */
X  volatile uint32_t FUNCTION2;                
N       uint32_t RESERVED2[1];
N  __IO uint32_t COMP3;                   /*!< Offset: 0x050 (R/W)  Comparator Register 3                     */
X  volatile uint32_t COMP3;                    
N  __IO uint32_t MASK3;                   /*!< Offset: 0x054 (R/W)  Mask Register 3                           */
X  volatile uint32_t MASK3;                    
N  __IO uint32_t FUNCTION3;               /*!< Offset: 0x058 (R/W)  Function Register 3                       */
X  volatile uint32_t FUNCTION3;                
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28                                          /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27                                          /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26                                          /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25                                          /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24                                          /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22                                          /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21                                          /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20                                          /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19                                          /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18                                          /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17                                          /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16                                          /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12                                          /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10                                          /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9                                          /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5                                          /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1                                          /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0                                          /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL << DWT_CTRL_CYCCNTENA_Pos)           /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0                                          /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL << DWT_CPICNT_CPICNT_Pos)           /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0                                          /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL << DWT_EXCCNT_EXCCNT_Pos)           /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0                                          /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL << DWT_SLEEPCNT_SLEEPCNT_Pos)       /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0                                          /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL << DWT_LSUCNT_LSUCNT_Pos)           /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0                                          /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL << DWT_FOLDCNT_FOLDCNT_Pos)         /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0                                          /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL << DWT_MASK_MASK_Pos)               /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24                                          /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16                                          /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12                                          /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10                                          /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9                                          /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8                                          /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7                                          /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5                                          /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0                                          /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL << DWT_FUNCTION_FUNCTION_Pos)        /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N    \brief      Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/** \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IO uint32_t SSPSR;                   /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register     */
X  volatile uint32_t SSPSR;                    
N  __IO uint32_t CSPSR;                   /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                    
N       uint32_t RESERVED0[2];
N  __IO uint32_t ACPR;                    /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                     
N       uint32_t RESERVED1[55];
N  __IO uint32_t SPPR;                    /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                     
N       uint32_t RESERVED2[131];
N  __I  uint32_t FFSR;                    /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                     
N  __IO uint32_t FFCR;                    /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                     
N  __I  uint32_t FSCR;                    /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                     
N       uint32_t RESERVED3[759];
N  __I  uint32_t TRIGGER;                 /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                  
N  __I  uint32_t FIFO0;                   /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                    
N  __I  uint32_t ITATBCTR2;               /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;                
N       uint32_t RESERVED4[1];
N  __I  uint32_t ITATBCTR0;               /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;                
N  __I  uint32_t FIFO1;                   /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                    
N  __IO uint32_t ITCTRL;                  /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                   
N       uint32_t RESERVED5[39];
N  __IO uint32_t CLAIMSET;                /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                 
N  __IO uint32_t CLAIMCLR;                /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                 
N       uint32_t RESERVED7[8];
N  __I  uint32_t DEVID;                   /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                    
N  __I  uint32_t DEVTYPE;                 /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                  
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0                                          /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL << TPI_ACPR_PRESCALER_Pos)        /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0                                          /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL << TPI_SPPR_TXMODE_Pos)              /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3                                          /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2                                          /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1                                          /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0                                          /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL << TPI_FFSR_FlInProg_Pos)            /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8                                          /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1                                          /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0                                          /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL << TPI_TRIGGER_TRIGGER_Pos)          /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27                                          /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24                                          /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16                                          /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8                                          /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0                                          /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL << TPI_FIFO0_ETM0_Pos)              /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0                                          /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL << TPI_ITATBCTR2_ATREADY_Pos)        /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27                                          /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24                                          /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16                                          /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8                                          /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0                                          /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL << TPI_FIFO1_ITM0_Pos)              /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0                                          /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL << TPI_ITATBCTR0_ATREADY_Pos)        /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0                                          /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL << TPI_ITCTRL_Mode_Pos)              /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11                                          /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10                                          /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9                                          /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6                                          /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5                                          /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0                                          /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL << TPI_DEVID_NrTraceInput_Pos)      /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_SubType_Pos             0                                          /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL << TPI_DEVTYPE_SubType_Pos)          /*!< TPI DEVTYPE: SubType Mask */
N
N#define TPI_DEVTYPE_MajorType_Pos           4                                          /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N    \brief      Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/** \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
X  volatile const  uint32_t TYPE;                     
N  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
X  volatile uint32_t RNR;                      
N  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
X  volatile uint32_t RBAR;                     
N  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
X  volatile uint32_t RASR;                     
N  __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register       */
X  volatile uint32_t RBAR_A1;                  
N  __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                  
N  __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register       */
X  volatile uint32_t RBAR_A2;                  
N  __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                  
N  __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register       */
X  volatile uint32_t RBAR_A3;                  
N  __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                  
N} MPU_Type;
N
N/* MPU Type Register */
N#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register */
N#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register */
N#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register */
N#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register */
N#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N#if (__FPU_PRESENT == 1)
X#if (1 == 1)
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_FPU     Floating Point Unit (FPU)
N    \brief      Type definitions for the Floating Point Unit (FPU)
N  @{
N */
N
N/** \brief  Structure type to access the Floating Point Unit (FPU).
N */
Ntypedef struct
N{
N       uint32_t RESERVED0[1];
N  __IO uint32_t FPCCR;                   /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register               */
X  volatile uint32_t FPCCR;                    
N  __IO uint32_t FPCAR;                   /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register               */
X  volatile uint32_t FPCAR;                    
N  __IO uint32_t FPDSCR;                  /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register        */
X  volatile uint32_t FPDSCR;                   
N  __I  uint32_t MVFR0;                   /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0                       */
X  volatile const  uint32_t MVFR0;                    
N  __I  uint32_t MVFR1;                   /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1                       */
X  volatile const  uint32_t MVFR1;                    
N} FPU_Type;
N
N/* Floating-Point Context Control Register */
N#define FPU_FPCCR_ASPEN_Pos                31                                             /*!< FPCCR: ASPEN bit Position */
N#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
N
N#define FPU_FPCCR_LSPEN_Pos                30                                             /*!< FPCCR: LSPEN Position */
N#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
N
N#define FPU_FPCCR_MONRDY_Pos                8                                             /*!< FPCCR: MONRDY Position */
N#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
N
N#define FPU_FPCCR_BFRDY_Pos                 6                                             /*!< FPCCR: BFRDY Position */
N#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
N
N#define FPU_FPCCR_MMRDY_Pos                 5                                             /*!< FPCCR: MMRDY Position */
N#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
N
N#define FPU_FPCCR_HFRDY_Pos                 4                                             /*!< FPCCR: HFRDY Position */
N#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
N
N#define FPU_FPCCR_THREAD_Pos                3                                             /*!< FPCCR: processor mode bit Position */
N#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
N
N#define FPU_FPCCR_USER_Pos                  1                                             /*!< FPCCR: privilege level bit Position */
N#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
N
N#define FPU_FPCCR_LSPACT_Pos                0                                             /*!< FPCCR: Lazy state preservation active bit Position */
N#define FPU_FPCCR_LSPACT_Msk               (1UL << FPU_FPCCR_LSPACT_Pos)                  /*!< FPCCR: Lazy state preservation active bit Mask */
N
N/* Floating-Point Context Address Register */
N#define FPU_FPCAR_ADDRESS_Pos               3                                             /*!< FPCAR: ADDRESS bit Position */
N#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
N
N/* Floating-Point Default Status Control Register */
N#define FPU_FPDSCR_AHP_Pos                 26                                             /*!< FPDSCR: AHP bit Position */
N#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
N
N#define FPU_FPDSCR_DN_Pos                  25                                             /*!< FPDSCR: DN bit Position */
N#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
N
N#define FPU_FPDSCR_FZ_Pos                  24                                             /*!< FPDSCR: FZ bit Position */
N#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
N
N#define FPU_FPDSCR_RMode_Pos               22                                             /*!< FPDSCR: RMode bit Position */
N#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
N
N/* Media and FP Feature Register 0 */
N#define FPU_MVFR0_FP_rounding_modes_Pos    28                                             /*!< MVFR0: FP rounding modes bits Position */
N#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
N
N#define FPU_MVFR0_Short_vectors_Pos        24                                             /*!< MVFR0: Short vectors bits Position */
N#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
N
N#define FPU_MVFR0_Square_root_Pos          20                                             /*!< MVFR0: Square root bits Position */
N#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
N
N#define FPU_MVFR0_Divide_Pos               16                                             /*!< MVFR0: Divide bits Position */
N#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
N
N#define FPU_MVFR0_FP_excep_trapping_Pos    12                                             /*!< MVFR0: FP exception trapping bits Position */
N#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
N
N#define FPU_MVFR0_Double_precision_Pos      8                                             /*!< MVFR0: Double-precision bits Position */
N#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
N
N#define FPU_MVFR0_Single_precision_Pos      4                                             /*!< MVFR0: Single-precision bits Position */
N#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
N
N#define FPU_MVFR0_A_SIMD_registers_Pos      0                                             /*!< MVFR0: A_SIMD registers bits Position */
N#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL << FPU_MVFR0_A_SIMD_registers_Pos)      /*!< MVFR0: A_SIMD registers bits Mask */
N
N/* Media and FP Feature Register 1 */
N#define FPU_MVFR1_FP_fused_MAC_Pos         28                                             /*!< MVFR1: FP fused MAC bits Position */
N#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
N
N#define FPU_MVFR1_FP_HPFP_Pos              24                                             /*!< MVFR1: FP HPFP bits Position */
N#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
N
N#define FPU_MVFR1_D_NaN_mode_Pos            4                                             /*!< MVFR1: D_NaN mode bits Position */
N#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
N
N#define FPU_MVFR1_FtZ_mode_Pos              0                                             /*!< MVFR1: FtZ mode bits Position */
N#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL << FPU_MVFR1_FtZ_mode_Pos)              /*!< MVFR1: FtZ mode bits Mask */
N
N/*@} end of group CMSIS_FPU */
N#endif
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Type definitions for the Core Debug Registers
N  @{
N */
N
N/** \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                    
N  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                    
N  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                    
N  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                    
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M4 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address  */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address                   */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address                   */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address                   */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address            */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address               */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                  */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address  */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct           */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct           */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct           */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct    */
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
N#endif
N
N#if (__FPU_PRESENT == 1)
X#if (1 == 1)
N  #define FPU_BASE          (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit                */
N  #define FPU               ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit                */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/** \brief  Set Priority Grouping
N
N  The function sets the priority grouping field using the required unlock sequence.
N  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N  Only values from 0..7 are used.
N  In case of a conflict between priority grouping and available
N  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N
N    \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
X  reg_value &= ~((0xFFFFUL << 16) | (7UL << 8));              
N  reg_value  =  (reg_value                                 |
N                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FA << 16) |
N                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/** \brief  Get Priority Grouping
N
N  The function reads the priority grouping field from the NVIC Interrupt Controller.
N
N    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
X  return ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) >> 8);    
N}
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
N  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F));  
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Get Active Interrupt
N
N    The function reads the active register in NVIC and returns the active bit.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not active.
N    \return             1  Interrupt status is active.
N */
N__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
X  return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - 3)) & 0xff); }  
N  else {
N    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[(uint32_t)(IRQn)] = ((priority << (8 - 3)) & 0xff);    }         
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M  system interrupts */
X    return((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - 3)));  }  
N  else {
N    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[(uint32_t)(IRQn)]           >> (8 - 3)));  }  
N}
N
N
N/** \brief  Encode Priority
N
N    The function encodes the priority for an interrupt with the given priority group,
N    preemptive priority value, and subpriority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS), the samllest possible priority group is set.
N
N    \param [in]     PriorityGroup  Used priority group.
N    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N    \param [in]       SubPriority  Subpriority value (starting from 0).
N    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 3) ? 3 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 3) < 7) ? 0 : PriorityGroupTmp - 7 + 3;
N
N  return (
N           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
N           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
N         );
N}
N
N
N/** \brief  Decode Priority
N
N    The function decodes an interrupt priority value with a given priority group to
N    preemptive priority value and subpriority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N
N    \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N    \param [in]     PriorityGroup  Used priority group.
N    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N    \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 3) ? 3 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 3) < 7) ? 0 : PriorityGroupTmp - 7 + 3;
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
N  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                 (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
X                 (1UL << 2));                    
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
X  if ((ticks - 1) > (0xFFFFFFUL << 0))  return (1);       
N
N  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = ticks - 1;                                   
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1<<3) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_core_DebugFunctions ITM Functions
N    \brief   Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters.                         */
N#define                 ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/** \brief  ITM Send Character
N
N    The function transmits a character via the ITM channel 0, and
N    \li Just returns when no debugger is connected that has booked the output.
N    \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N
N    \param [in]     ch  Character to transmit.
N
N    \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if ((ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
X  if ((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL << 0))                  &&       
N      (ITM->TER & (1UL << 0)        )                    )     /* ITM Port #0 enabled */
X      (((ITM_Type *) (0xE0000000UL) )->TER & (1UL << 0)        )                    )      
N  {
N    while (ITM->PORT[0].u32 == 0);
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0].u32 == 0);
N    ITM->PORT[0].u8 = (uint8_t) ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0].u8 = (uint8_t) ch;
N  }
N  return (ch);
N}
N
N
N/** \brief  ITM Receive Character
N
N    The function inputs a character via the external variable \ref ITM_RxBuffer.
N
N    \return             Received character.
N    \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void) {
Xstatic __inline int32_t ITM_ReceiveChar (void) {
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer != 0x5AA55AA5) {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5;        
N  }
N
N  return (ch);
N}
N
N
N/** \brief  ITM Check Character
N
N    The function checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N
N    \return          0  No character available.
N    \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void) {
Xstatic __inline int32_t ITM_CheckChar (void) {
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer == 0x5AA55AA5) {
N    return (0);                                 /* no character available */
N  } else {
N    return (1);                                 /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N#endif /* __CORE_CM4_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N#ifdef __cplusplus
S}
N#endif
L 43 "..\..\..\chip_5411x\inc\cmsis.h" 2
N#elif defined(CORE_M0PLUS)
S#include "cmsis_5411x_m0.h"
Stypedef LPC5411X_M0_IRQn_Type IRQn_Type;
S#include "core_cm0plus.h"				/*!< Cortex-M0 Plus processor and core peripherals  */
S#else
S#error "No CORE_* definition is defined"
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CMSIS_H_ */
L 37 "..\..\..\chip_5411x\inc\chip.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#ifndef CORE_M4
S#ifndef CORE_M0PLUS
S#error "CORE_M4 or CORE_M0PLUS is not defined for the LPC5411x architecture"
S#error "CORE_M4 or CORE_M0PLUS should be defined as part of your compiler define list"
S#endif
N#endif
N
N/* LPCXpresso macro LPCOpen macro defines */
N#ifdef __LPC5411X__
S#define CHIP_LPC5411X
N#endif
N
N#ifndef CHIP_LPC5411X
S#error "The LPC5411X Chip include path is used for this build, but"
S#error "CHIP_LPC5411X is not defined!"
N#endif
N
N#ifndef __DOXYGEN__
N/* Macros to append params */
N#define __APPEND30(x,y,z) x##y##z
N#define __APPEND3(x,y,z) __APPEND30(x,y,z)
N#endif
N
N/** @defgroup PERIPH_5411X_BASE CHIP: LPC5411X Peripheral addresses and register set declarations
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/* Main memory addresses */
N#define LPC_FLASHMEM_BASE          0x00000000UL
N#define LPC_SRAMX_BASE             0x04000000UL
N#define LPC_SRAM0_BASE             0x20000000UL
N#define LPC_SRAM1_BASE             0x20010000UL
N#define LPC_SRAM2_BASE             0x20018000UL
N#define LPC_ROM_BASE               0x03000000UL
N
N/* APB0 peripheral group addresses */
N#define LPC_SYSCON_BASE            0x40000000UL
N#define LPC_IOCON_BASE             0x40001000UL
N#define LPC_GPIO_GROUPINT0_BASE    0x40002000UL
N#define LPC_GPIO_GROUPINT1_BASE    0x40003000UL
N#define LPC_PIN_INT_BASE           0x40004000UL
N#define LPC_INMUX_BASE             0x40005000UL
N#define LPC_TIMER0_BASE            0x40008000UL
N#define LPC_TIMER1_BASE            0x40009000UL
N#define LPC_WWDT_BASE              0x4000C000UL
N#define LPC_MRT_BASE               0x4000D000UL
N#define LPC_UTICK_BASE             0x4000E000UL
N
N/* APB1 peripheral group address */
N#define LPC_PMU_BASE               0x40020000UL
N#define LPC_TIMER2_BASE            0x40028000UL
N#define LPC_RTC_BASE               0x4002C000UL
N#define LPC_FMC_BASE               0x40034000UL
N
N/* Asynchronous APB peripheral group addresses */
N#define LPC_ASYNC_SYSCON_BASE      0x40040000UL
N#define LPC_TIMER3_BASE            0x40048000UL
N#define LPC_TIMER4_BASE            0x40049000UL
N
N/* AHB Peripherals base address */
N#define LPC_SPIFI_BASE             0x40080000UL
N#define LPC_DMA_BASE               0x40082000UL
N#define LPC_USB_BASE               0x40084000UL
N#define LPC_SCT_BASE               0x40085000UL
N#define LPC_FLEXCOMM0_BASE         0x40086000UL
N#define LPC_FLEXCOMM1_BASE         0x40087000UL
N#define LPC_FLEXCOMM2_BASE         0x40088000UL
N#define LPC_FLEXCOMM3_BASE         0x40089000UL
N#define LPC_FLEXCOMM4_BASE         0x4008A000UL
N#define LPC_MBOX_BASE              0x4008B000UL
N#define LPC_GPIO_PORT_BASE         0x4008C000UL
N#define LPC_DMIC_BASE              0x40090000UL
N#define LPC_CRC_BASE               0x40095000UL
N#define LPC_FLEXCOMM5_BASE         0x40096000UL
N#define LPC_FLEXCOMM6_BASE         0x40097000UL
N#define LPC_FLEXCOMM7_BASE         0x40098000UL
N#define LPC_ISPAP_BASE             0x4009C000UL
N#define LPC_ADC_BASE               0x400A0000UL
N
N
N
N/* Main memory register access */
N#define LPC_GPIO           ((LPC_GPIO_T            *) LPC_GPIO_PORT_BASE)
N#define LPC_DMA            ((LPC_DMA_T             *) LPC_DMA_BASE)
N#define LPC_CRC            ((LPC_CRC_T             *) LPC_CRC_BASE)
N#define LPC_SCT            ((LPC_SCT_T             *) LPC_SCT_BASE)
N#define LPC_MBOX           ((LPC_MBOX_T            *) LPC_MBOX_BASE)
N#define LPC_ADC            ((LPC_ADC_T             *) LPC_ADC_BASE)
N#define LPC_PMU            ((LPC_PMU_T             *) LPC_PMU_BASE)
N#define LPC_DMIC           ((LPC_DMIC_T            *) LPC_DMIC_BASE)
N#define LPC_USB            ((LPC_USB_T             *) LPC_USB_BASE)
N
N/* APB0 peripheral group register access */
N#define LPC_SYSCON         ((LPC_SYSCON_T          *) LPC_SYSCON_BASE)
N#define LPC_TIMER2         ((LPC_TIMER_T           *) LPC_TIMER2_BASE)
N#define LPC_TIMER3         ((LPC_TIMER_T           *) LPC_TIMER3_BASE)
N#define LPC_TIMER4         ((LPC_TIMER_T           *) LPC_TIMER4_BASE)
N#define LPC_GINT           ((LPC_GPIOGROUPINT_T    *) LPC_GPIO_GROUPINT0_BASE)
N#define LPC_PININT         ((LPC_PIN_INT_T         *) LPC_PIN_INT_BASE)
N#define LPC_IOCON          ((LPC_IOCON_T           *) LPC_IOCON_BASE)
N#define LPC_UTICK          ((LPC_UTICK_T           *) LPC_UTICK_BASE)
N#define LPC_WWDT           ((LPC_WWDT_T            *) LPC_WWDT_BASE)
N#define LPC_RTC            ((LPC_RTC_T             *) LPC_RTC_BASE)
N
N/* APB1 peripheral group register access */
N#define LPC_ASYNC_SYSCON   ((LPC_ASYNC_SYSCON_T    *) LPC_ASYNC_SYSCON_BASE)
N#define LPC_TIMER0         ((LPC_TIMER_T           *) LPC_TIMER0_BASE)
N#define LPC_TIMER1         ((LPC_TIMER_T           *) LPC_TIMER1_BASE)
N#define LPC_INMUX          ((LPC_INMUX_T           *) LPC_INMUX_BASE)
N#define LPC_MRT            ((LPC_MRT_T             *) LPC_MRT_BASE)
N
N/**
N * @}
N */
N
N/** @ingroup CHIP_5411X_DRIVER_OPTIONS
N * @{
N */
N
N/**
N * @brief	Clock rate on the CLKIN pin
N * This value is defined externally to the chip layer and contains
N * the value in Hz for the CLKIN pin for the board. If this pin isn't used,
N * this rate can be 0.
N */
Nextern const uint32_t ExtClockIn;
N
N/**
N * @}
N */
N
N/* Include order is important! */
N#include "lpc_assert.h"
L 1 "..\..\..\chip_5411x\inc\lpc_assert.h" 1
N/*
N * @brief LPC5411x Assert file
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __LPC_ASSERT_H
N#define __LPC_ASSERT_H
N
N#if defined(__CC_ARM)
X#if 1L
N	#if (__OPTIMISE_LEVEL > 0)
X	#if (3 > 0)
N		#define LPC_ASSERT(cond,file,line) if(!(cond)){} /* Required to avoid unused variable warning */
N	#else
S		#define LPC_ASSERT(cond,file,line) if(!(cond)){__BKPT(line & 0xFF);}
N	#endif
N#elif defined(__ICCARM__)
S	#if defined(NDEBUG)
S		#define LPC_ASSERT(cond,file,line) if(!(cond)){} /* Required to avoid unused variable warning */
S	#else
S		#define LPC_ASSERT(cond,file,line) if(!(cond)){__BKPT(line);}
S	#endif
S#elif defined(__GNUC__)
S	#if defined(NDEBUG)
S		#define LPC_ASSERT(cond,file,line) if(!(cond)){} /* Required to avoid unused variable warning */
S	#else
S		#define LPC_ASSERT(cond,file,line) if(!(cond)){__BKPT(line);}
S	#endif
S#else
S	#define LPC_ASSERT(cond,file,line) if(!(cond)){} /* Required to avoid unused variable warning */
N#endif
N
N#endif /* __LPC_ASSERT_H */
N
L 176 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "romapi_5411x.h"
L 1 "..\..\..\chip_5411x\inc\romapi_5411x.h" 1
N/*
N * @brief LPC5411X ROM API declarations and functions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __ROMAPI_5411X_H_
N#define __ROMAPI_5411X_H_
N
N#include <stdint.h>
N#include "iap.h"
L 1 "..\..\..\chip_5411x\inc\iap.h" 1
N/*
N * @brief Common IAP support functions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2013
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licenser disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __IAP_H_
N#define __IAP_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup COMMON_IAP CHIP: Common Chip ISP/IAP commands and return codes
N * @ingroup CHIP_Common
N * @{
N */
N
N/* IAP command definitions */
N#define IAP_PREWRRITE_CMD           50	/*!< Prepare sector for write operation command */
N#define IAP_WRISECTOR_CMD           51	/*!< Write Sector command */
N#define IAP_ERSSECTOR_CMD           52	/*!< Erase Sector command */
N#define IAP_BLANK_CHECK_SECTOR_CMD  53	/*!< Blank check sector */
N#define IAP_REPID_CMD               54	/*!< Read PartID command */
N#define IAP_READ_BOOT_CODE_CMD      55	/*!< Read Boot code version */
N#define IAP_COMPARE_CMD             56	/*!< Compare two RAM address locations */
N#define IAP_REINVOKE_ISP_CMD        57	/*!< Reinvoke ISP */
N#define IAP_READ_UID_CMD            58	/*!< Read UID */
N#define IAP_ERASE_PAGE_CMD          59	/*!< Erase page */
N#define IAP_EEPROM_WRITE            61	/*!< EEPROM Write command */
N#define IAP_EEPROM_READ             62	/*!< EEPROM READ command */
N
N/* IAP response definitions */
N#define IAP_CMD_SUCCESS             0	/*!< Command is executed successfully */
N#define IAP_INVALID_COMMAND         1	/*!< Invalid command */
N#define IAP_SRC_ADDR_ERROR          2	/*!< Source address is not on word boundary */
N#define IAP_DST_ADDR_ERROR          3	/*!< Destination address is not on a correct boundary */
N#define IAP_SRC_ADDR_NOT_MAPPED     4	/*!< Source address is not mapped in the memory map */
N#define IAP_DST_ADDR_NOT_MAPPED     5	/*!< Destination address is not mapped in the memory map */
N#define IAP_COUNT_ERROR             6	/*!< Byte count is not multiple of 4 or is not a permitted value */
N#define IAP_INVALID_SECTOR          7	/*!< Sector number is invalid or end sector number is greater than start sector number */
N#define IAP_SECTOR_NOT_BLANK        8	/*!< Sector is not blank */
N#define IAP_SECTOR_NOT_PREPARED     9	/*!< Command to prepare sector for write operation was not executed */
N#define IAP_COMPARE_ERROR           10	/*!< Source and destination data not equal */
N#define IAP_BUSY                    11	/*!< Flash programming hardware interface is busy */
N#define IAP_PARAM_ERROR             12	/*!< nsufficient number of parameters or invalid parameter */
N#define IAP_ADDR_ERROR              13	/*!< Address is not on word boundary */
N#define IAP_ADDR_NOT_MAPPED         14	/*!< Address is not mapped in the memory map */
N#define IAP_CMD_LOCKED              15	/*!< Command is locked */
N#define IAP_INVALID_CODE            16	/*!< Unlock code is invalid */
N#define IAP_INVALID_BAUD_RATE       17	/*!< Invalid baud rate setting */
N#define IAP_INVALID_STOP_BIT        18	/*!< Invalid stop bit setting */
N#define IAP_CRP_ENABLED             19	/*!< Code read protection enabled */
N
N/* IAP_ENTRY API function type */
Ntypedef void (*IAP_ENTRY_T)(unsigned int[5], unsigned int[4]);
N
N/**
N * @brief	Prepare sector for write operation
N * @param	strSector	: Start sector number
N * @param	endSector	: End sector number
N * @return	Status code to indicate the command is executed successfully or not
N * @note	This command must be executed before executing "Copy RAM to flash"
N *			or "Erase Sector" command.
N *			The end sector must be greater than or equal to start sector number
N */
Nuint8_t Chip_IAP_PreSectorForReadWrite(uint32_t strSector, uint32_t endSector);
N
N/**
N * @brief	Copy RAM to flash
N * @param	dstAdd		: Destination flash address where data bytes are to be written
N * @param	srcAdd		: Source flash address where data bytes are to be read
N * @param	byteswrt	: Number of bytes to be written
N * @return	Status code to indicate the command is executed successfully or not
N * @note	The addresses should be a 256 byte boundary and the number of bytes
N *			should be 256 | 512 | 1024 | 4096
N */
Nuint8_t Chip_IAP_CopyRamToFlash(uint32_t dstAdd, uint32_t *srcAdd, uint32_t byteswrt);
N
N/**
N * @brief	Erase sector
N * @param	strSector	: Start sector number
N * @param	endSector	: End sector number
N * @return	Status code to indicate the command is executed successfully or not
N * @note	The end sector must be greater than or equal to start sector number
N */
Nuint8_t Chip_IAP_EraseSector(uint32_t strSector, uint32_t endSector);
N
N/**
N * @brief Blank check a sector or multiples sector of on-chip flash memory
N * @param	strSector	: Start sector number
N * @param	endSector	: End sector number
N * @return	Offset of the first non blank word location if the status code is SECTOR_NOT_BLANK
N * @note	The end sector must be greater than or equal to start sector number
N */
N// FIXME - There are two return value (result[0] & result[1]
N// Result0:Offset of the first non blank word location if the Status Code is
N// SECTOR_NOT_BLANK.
N// Result1:Contents of non blank word location.
Nuint8_t Chip_IAP_BlankCheckSector(uint32_t strSector, uint32_t endSector);
N
N/**
N * @brief	Read part identification number
N * @return	Part identification number
N */
Nuint32_t Chip_IAP_ReadPID(void);
N
N/**
N * @brief	Read boot code version number
N * @return	Boot code version number
N */
Nuint8_t Chip_IAP_ReadBootCode(void);
N
N/**
N * @brief	Compare the memory contents at two locations
N * @param	dstAdd		: Destination of the RAM address of data bytes to be compared
N * @param	srcAdd		: Source of the RAM address of data bytes to be compared
N * @param	bytescmp	: Number of bytes to be compared
N * @return	Offset of the first mismatch of the status code is COMPARE_ERROR
N * @note	The addresses should be a word boundary and number of bytes should be
N *			a multiply of 4
N */
Nuint8_t Chip_IAP_Compare(uint32_t dstAdd, uint32_t srcAdd, uint32_t bytescmp);
N
N/**
N * @brief	IAP reinvoke ISP to invoke the bootloader in ISP mode
N * @return	none
N */
Nuint8_t Chip_IAP_ReinvokeISP(void);
N
N/**
N * @brief	Read the unique ID
N * @return	Status code to indicate the command is executed successfully or not
N */
Nuint32_t Chip_IAP_ReadUID(void);
N
N/**
N * @brief	Erase a page or multiple papers of on-chip flash memory
N * @param	strPage	: Start page number
N * @param	endPage	: End page number
N * @return	Status code to indicate the command is executed successfully or not
N * @note	The page number must be greater than or equal to start page number
N */
N// FIXME - There are four return value
N// Result0:The first 32-bit word (at the lowest address)
N// Result1:The second 32-bit word.
N// Result2:The third 32-bit word.
N// Result3:The fourth 32-bit word.
Nuint8_t Chip_IAP_ErasePage(uint32_t strPage, uint32_t endPage);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __IAP_H_ */
L 37 "..\..\..\chip_5411x\inc\romapi_5411x.h" 2
N#include "error.h"
L 1 "..\..\..\chip_5411x\inc\error.h" 1
N/*
N * @brief Error code returned by Boot ROM drivers/library functions
N *
N *  This file contains unified error codes to be used across driver,
N *  middleware, applications, hal and demo software.
N *
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __LPC_ERROR_H__
N#define __LPC_ERROR_H__
N
N/** Error code returned by Boot ROM drivers/library functions
N *
N *  Error codes are a 32-bit value with :
N *      - The 16 MSB contains the peripheral code number
N *      - The 16 LSB contains an error code number associated to that peripheral
N *
N */
Ntypedef enum
N{
N  /**\b 0x00000000*/ LPC_OK=0, /**< enum value returned on Success */
N  /**\b 0xFFFFFFFF*/ ERR_FAILED = -1, /**< enum value returned on general failure */
N  /**\b 0xFFFFFFFE*/ ERR_TIME_OUT = -2, /**< enum value returned on general timeout */
N  /**\b 0xFFFFFFFD*/ ERR_BUSY = -3,	/**< enum value returned when resource is busy */
N
N  /* ISP related errors */
N  ERR_ISP_BASE = 0x00000000,
N  /*0x00000001*/ ERR_ISP_INVALID_COMMAND = ERR_ISP_BASE + 1,
N  /*0x00000002*/ ERR_ISP_SRC_ADDR_ERROR, /* Source address not on word boundary */
N  /*0x00000003*/ ERR_ISP_DST_ADDR_ERROR, /* Destination address not on word or 256 byte boundary */
N  /*0x00000004*/ ERR_ISP_SRC_ADDR_NOT_MAPPED,
N  /*0x00000005*/ ERR_ISP_DST_ADDR_NOT_MAPPED,
N  /*0x00000006*/ ERR_ISP_COUNT_ERROR, /* Byte count is not multiple of 4 or is not a permitted value */
N  /*0x00000007*/ ERR_ISP_INVALID_SECTOR,
N  /*0x00000008*/ ERR_ISP_SECTOR_NOT_BLANK,
N  /*0x00000009*/ ERR_ISP_SECTOR_NOT_PREPARED_FOR_WRITE_OPERATION,
N  /*0x0000000A*/ ERR_ISP_COMPARE_ERROR,
N  /*0x0000000B*/ ERR_ISP_BUSY, /* Flash programming hardware interface is busy */
N  /*0x0000000C*/ ERR_ISP_PARAM_ERROR, /* Insufficient number of parameters */
N  /*0x0000000D*/ ERR_ISP_ADDR_ERROR, /* Address not on word boundary */
N  /*0x0000000E*/ ERR_ISP_ADDR_NOT_MAPPED,
N  /*0x0000000F*/ ERR_ISP_CMD_LOCKED, /* Command is locked */
N  /*0x00000010*/ ERR_ISP_INVALID_CODE, /* Unlock code is invalid */
N  /*0x00000011*/ ERR_ISP_INVALID_BAUD_RATE,
N  /*0x00000012*/ ERR_ISP_INVALID_STOP_BIT,
N  /*0x00000013*/ ERR_ISP_CODE_READ_PROTECTION_ENABLED,
N  /*0x00000014*/ ERR_ISP_INVALID_FLASH_UNIT,
N  /*0x00000015*/ ERR_ISP_USER_CODE_CHECKSUM,
N  /*0x00000016*/ ERR_ISP_SETTING_ACTIVE_PARTITION,
N  /*0x00000017*/ ERR_ISP_IRC_NO_POWER,
N  /*0x00000018*/ ERR_ISP_FLASH_NO_POWER,
N  /*0x00000019*/ ERR_ISP_EEPROM_NO_POWER,
N  /*0x0000001A*/ ERR_ISP_EEPROM_NO_CLOCK,
N  /*0x0000001B*/ ERR_ISP_FLASH_NO_CLOCK,
N  /*0x0000001C*/ ERR_ISP_REINVOKE_ISP_CONFIG,
N  
N  /* ROM API related errors */
N  ERR_API_BASE = 0x00010000,
N  /**\b 0x00010001*/ ERR_API_INVALID_PARAMS = ERR_API_BASE + 1, /**< Invalid parameters*/
N  /**\b 0x00010002*/ ERR_API_INVALID_PARAM1, /**< PARAM1 is invalid */
N  /**\b 0x00010003*/ ERR_API_INVALID_PARAM2, /**< PARAM2 is invalid */
N  /**\b 0x00010004*/ ERR_API_INVALID_PARAM3, /**< PARAM3 is invalid */
N  /**\b 0x00010005*/ ERR_API_MOD_INIT, /**< API is called before module init */
N
N  /* SPIFI API related errors */
N  ERR_SPIFI_BASE = 0x00020000,
N  /*0x00020001*/ ERR_SPIFI_DEVICE_ERROR =ERR_SPIFI_BASE+1,  
N  /*0x00020002*/ ERR_SPIFI_INTERNAL_ERROR,		    
N  /*0x00020003*/ ERR_SPIFI_TIMEOUT,			    
N  /*0x00020004*/ ERR_SPIFI_OPERAND_ERROR,		    
N  /*0x00020005*/ ERR_SPIFI_STATUS_PROBLEM,		    
N  /*0x00020006*/ ERR_SPIFI_UNKNOWN_EXT, 		    
N  /*0x00020007*/ ERR_SPIFI_UNKNOWN_ID,  		    
N  /*0x00020008*/ ERR_SPIFI_UNKNOWN_TYPE,		    
N  /*0x00020009*/ ERR_SPIFI_UNKNOWN_MFG, 		    
N  /*0x0002000A*/ ERR_SPIFI_NO_DEVICE,
N  /*0x0002000B*/ ERR_SPIFI_ERASE_NEEDED, 		    
N
N  SEC_AES_NO_ERROR=0,
N  /* Security API related errors */
N  ERR_SEC_AES_BASE = 0x00030000,
N  /*0x00030001*/ ERR_SEC_AES_WRONG_CMD=ERR_SEC_AES_BASE+1,
N  /*0x00030002*/ ERR_SEC_AES_NOT_SUPPORTED,
N  /*0x00030003*/ ERR_SEC_AES_KEY_ALREADY_PROGRAMMED,
N  /*0x00030004*/ ERR_SEC_AES_DMA_CHANNEL_CFG,
N  /*0x00030005*/ ERR_SEC_AES_DMA_MUX_CFG,
N  /*0x00030006*/ SEC_AES_DMA_BUSY,      
N
N  /* USB device stack related errors */
N  ERR_USBD_BASE = 0x00040000,
N  /**\b 0x00040001*/ ERR_USBD_INVALID_REQ = ERR_USBD_BASE + 1, /**< invalid request */
N  /**\b 0x00040002*/ ERR_USBD_UNHANDLED, /**< Callback did not process the event */
N  /**\b 0x00040003*/ ERR_USBD_STALL,     /**< Stall the endpoint on which the call back is called */
N  /**\b 0x00040004*/ ERR_USBD_SEND_ZLP,  /**< Send ZLP packet on the endpoint on which the call back is called */
N  /**\b 0x00040005*/ ERR_USBD_SEND_DATA, /**< Send data packet on the endpoint on which the call back is called */
N  /**\b 0x00040006*/ ERR_USBD_BAD_DESC,  /**< Bad descriptor*/
N  /**\b 0x00040007*/ ERR_USBD_BAD_CFG_DESC,/**< Bad config descriptor*/
N  /**\b 0x00040008*/ ERR_USBD_BAD_INTF_DESC,/**< Bad interface descriptor*/
N  /**\b 0x00040009*/ ERR_USBD_BAD_EP_DESC,/**< Bad endpoint descriptor*/
N  /**\b 0x0004000a*/ ERR_USBD_BAD_MEM_BUF, /**< Bad alignment of buffer passed. */
N  /**\b 0x0004000b*/ ERR_USBD_TOO_MANY_CLASS_HDLR, /**< Too many class handlers. */
N
N  /* CGU  related errors */
N  ERR_CGU_BASE = 0x00050000,
N  /*0x00050001*/ ERR_CGU_NOT_IMPL=ERR_CGU_BASE+1,
N  /*0x00050002*/ ERR_CGU_INVALID_PARAM,
N  /*0x00050003*/ ERR_CGU_INVALID_SLICE,
N  /*0x00050004*/ ERR_CGU_OUTPUT_GEN,
N  /*0x00050005*/ ERR_CGU_DIV_SRC,
N  /*0x00050006*/ ERR_CGU_DIV_VAL,
N  /*0x00050007*/ ERR_CGU_SRC, 
N
N  /*  I2C related errors   */
N  ERR_I2C_BASE = 0x00060000,
N  /*0x00060000*/ ERR_I2C_BUSY = ERR_I2C_BASE,
N  /*0x00060001*/ ERR_I2C_NAK,
N  /*0x00060002*/ ERR_I2C_BUFFER_OVERFLOW,    
N  /*0x00060003*/ ERR_I2C_BYTE_COUNT_ERR,     
N  /*0x00060004*/ ERR_I2C_LOSS_OF_ARBRITRATION,    
N  /*0x00060005*/ ERR_I2C_SLAVE_NOT_ADDRESSED,     
N  /*0x00060006*/ ERR_I2C_LOSS_OF_ARBRITRATION_NAK_BIT,   
N  /*0x00060007*/ ERR_I2C_GENERAL_FAILURE,         
N  /*0x00060008*/ ERR_I2C_REGS_SET_TO_DEFAULT,
N  /*0x00060009*/ ERR_I2C_TIMEOUT,
N  /*0x0006000A*/ ERR_I2C_BUFFER_UNDERFLOW,
N  /*0x0006000B*/ ERR_I2C_PARAM,
N  
N   /* OTP  related errors */
N  ERR_OTP_BASE = 0x00070000,
N  /*0x00070001*/ ERR_OTP_WR_ENABLE_INVALID = ERR_OTP_BASE+1,
N  /*0x00070002*/ ERR_OTP_SOME_BITS_ALREADY_PROGRAMMED,
N  /*0x00070003*/ ERR_OTP_ALL_DATA_OR_MASK_ZERO,
N  /*0x00070004*/ ERR_OTP_WRITE_ACCESS_LOCKED,
N  /*0x00070005*/ ERR_OTP_READ_DATA_MISMATCH,
N  /*0x00070006*/ ERR_OTP_USB_ID_ENABLED,
N  /*0x00070007*/ ERR_OTP_ETH_MAC_ENABLED,
N  /*0x00070008*/ ERR_OTP_AES_KEYS_ENABLED,
N  /*0x00070009*/ ERR_OTP_ILLEGAL_BANK,
N
N  /*  UART related errors   */
N  ERR_UART_BASE = 0x00080000,
N  /*0x00080001*/ ERR_UART_RXD_BUSY = ERR_UART_BASE+1,   //UART rxd is busy
N  /*0x00080002*/ ERR_UART_TXD_BUSY,   //UART txd is busy
N  /*0x00080003*/ ERR_UART_OVERRUN_FRAME_PARITY_NOISE, //overrun err, frame err, parity err, RxNoise err
N  /*0x00080004*/ ERR_UART_UNDERRUN,    //underrun err    
N  /*0x00080005*/ ERR_UART_PARAM,       //parameter is error
N  /*0x00080006*/ ERR_UART_BAUDRATE,    //baudrate setting is error
N
N  /*  CAN related errors   */
N  ERR_CAN_BASE = 0x00090000,
N  /*0x00090001*/ ERR_CAN_BAD_MEM_BUF = ERR_CAN_BASE+1,
N  /*0x00090002*/ ERR_CAN_INIT_FAIL,
N  /*0x00090003*/ ERR_CANOPEN_INIT_FAIL,
N
N  /* SPIFI Lite API related errors */
N  ERR_SPIFI_LITE_BASE = 0x000A0000,
N  /*0x000A0001*/ ERR_SPIFI_LITE_INVALID_ARGUMENTS = ERR_SPIFI_LITE_BASE+1,  
N  /*0x000A0002*/ ERR_SPIFI_LITE_BUSY,		    
N  /*0x000A0003*/ ERR_SPIFI_LITE_MEMORY_MODE_ON,			    
N  /*0x000A0004*/ ERR_SPIFI_LITE_MEMORY_MODE_OFF,
N  /*0x000A0005*/ ERR_SPIFI_LITE_IN_DMA,
N  /*0x000A0006*/ ERR_SPIFI_LITE_NOT_IN_DMA,
N  /*0x000A0100*/ PENDING_SPIFI_LITE,
N
N  /* CLK related errors */
N  ERR_CLK_BASE = 0x000B0000,
N  /*0x000B0001*/ ERR_CLK_NOT_IMPL=ERR_CLK_BASE+1,
N  /*0x000B0002*/ ERR_CLK_INVALID_PARAM,
N  /*0x000B0003*/ ERR_CLK_INVALID_SLICE,
N  /*0x000B0004*/ ERR_CLK_OUTPUT_GEN,
N  /*0x000B0005*/ ERR_CLK_DIV_SRC,
N  /*0x000B0006*/ ERR_CLK_DIV_VAL,
N  /*0x000B0007*/ ERR_CLK_SRC,
N  /*0x000B0008*/ ERR_CLK_PLL_FIN_TOO_SMALL,
N  /*0x000B0009*/ ERR_CLK_PLL_FIN_TOO_LARGE,
N  /*0x000B000A*/ ERR_CLK_PLL_FOUT_TOO_SMALL,
N  /*0x000B000B*/ ERR_CLK_PLL_FOUT_TOO_LARGE,
N  /*0x000B000C*/ ERR_CLK_PLL_NO_SOLUTION,
N  /*0x000B000D*/ ERR_CLK_PLL_MIN_PCT,
N  /*0x000B000E*/ ERR_CLK_PLL_MAX_PCT,
N  /*0x000B000F*/ ERR_CLK_OSC_FREQ,
N  /*0x000B0010*/ ERR_CLK_CFG,
N  /*0x000B0011*/ ERR_CLK_TIMEOUT,
N  /*0x000B0012*/ ERR_CLK_BASE_OFF,
N  /*0x000B0013*/ ERR_CLK_OFF_DEADLOCK,
N    
N  /*Power API*/
N  ERR_PWR_BASE = 0x000C0000,
N  /*0x000C0001*/  PWR_ERROR_ILLEGAL_MODE=ERR_PWR_BASE+1,
N  /*0x000C0002*/  PWR_ERROR_CLOCK_FREQ_TOO_HIGH,
N  /*0x000C0003*/  PWR_ERROR_INVALID_STATE,
N  /*0x000C0004*/  PWR_ERROR_INVALID_CFG,
N  /*0x000C0005*/  PWR_ERROR_PVT_DETECT,
N
N  /* DMA related errors */
N  ERR_DMA_BASE = 0x000D0000,
N  /*0x000D0001*/	 ERR_DMA_ERROR_INT=ERR_DMA_BASE+1,
N  /*0x000D0002*/	 ERR_DMA_CHANNEL_NUMBER,
N  /*0x000D0003*/	 ERR_DMA_CHANNEL_DISABLED,
N  /*0x000D0004*/	 ERR_DMA_BUSY,
N  /*0x000D0005*/	 ERR_DMA_NOT_ALIGNMENT,
N  /*0x000D0006*/	 ERR_DMA_PING_PONG_EN,
N  /*0x000D0007*/	 ERR_DMA_CHANNEL_VALID_PENDING,
N  /*0x000D0008*/	 ERR_DMA_PARAM,
N  /*0x000D0009*/	 ERR_DMA_QUEUE_EMPTY,
N  /*0x000D000A*/	 ERR_DMA_GENERAL,
N
N  /* SPI related errors */
N  ERR_SPI_BASE = 0x000E0000,
N  /*0x000E0000*/	 ERR_SPI_BUSY=ERR_SPI_BASE,
N  /*0x000E0001*/	 ERR_SPI_RXOVERRUN,
N  /*0x000E0002*/	 ERR_SPI_TXUNDERRUN,
N  /*0x000E0003*/	 ERR_SPI_SELNASSERT,
N  /*0x000E0004*/	 ERR_SPI_SELNDEASSERT,
N  /*0x000E0005*/	 ERR_SPI_CLKSTALL,
N  /*0x000E0006*/	 ERR_SPI_PARAM,
N  /*0x000E0007*/	 ERR_SPI_INVALID_LENGTH,
N
N  /* ADC related errors */
N  ERR_ADC_BASE = 0x000F0000,
N  /*0x000F0001*/	 ERR_ADC_OVERRUN=ERR_ADC_BASE+1,
N  /*0x000F0002*/	 ERR_ADC_INVALID_CHANNEL,
N  /*0x000F0003*/	 ERR_ADC_INVALID_SEQUENCE,
N  /*0x000F0004*/	 ERR_ADC_INVALID_SETUP,
N  /*0x000F0005*/	 ERR_ADC_PARAM,
N  /*0x000F0006*/	 ERR_ADC_INVALID_LENGTH,
N  /*0x000F0007*/	 ERR_ADC_NO_POWER,
N
N  /* Debugger Mailbox related errors */
N  ERR_DM_BASE = 0x00100000,
N  /*0x00100001*/	 ERR_DM_NOT_ENTERED=ERR_DM_BASE+1,
N  /*0x00100002*/	 ERR_DM_UNKNOWN_CMD,
N  /*0x00100003*/	 ERR_DM_COMM_FAIL
N  
N} ErrorCode_t;
N
N#ifndef offsetof
N#define offsetof(s, m)   (int) &(((s *) 0)->m)
N#endif
N
N#define COMPILE_TIME_ASSERT(pred)    switch (0) { \
N	case 0:	\
N	case pred:; }
X#define COMPILE_TIME_ASSERT(pred)    switch (0) { 	case 0:		case pred:; }
N
N#endif /* __LPC_ERROR_H__ */
L 38 "..\..\..\chip_5411x\inc\romapi_5411x.h" 2
N#include "cmsis.h"
N
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup ROMAPI_5411X CHIP: LPC5411X ROM API declarations and functions
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/**
N * @brief High level ROM API structure
N */
Ntypedef struct {
N	const uint32_t usbdApiBase;				    /*!< USB API Base */
N	const uint32_t reserved_clib;				/*!< Reserved */
N	const uint32_t reserved_power;				/*!< Reserved */
N	const uint32_t reserved_div;				/*!< Reserved */
N	const uint32_t reserved_usart;				/*!< Reserved */
N	const uint32_t reserved_i2cm;				/*!< Reserved */
N	const uint32_t reserved_i2cs;				/*!< Reserved */
N	const uint32_t reserved_i2cmon;				/*!< Reserved */
N	const uint32_t reserved_spim;				/*!< Reserved */
N	const uint32_t reserved_spis;				/*!< Reserved */
N	const uint32_t reserved_dmaaltd;			/*!< Reserved */
N	const uint32_t reserved_adcaltd;            /*!< Reserved */
N	const uint32_t reserved_uartalt;            /*!< Reserved */
N	const uint32_t reserved_flexcomm;           /*!< Reserved */
N} LPC_ROM_API_T;
N
N/* Pointer to ROM API function address */
N#define LPC_ROM_API_BASE_LOC    0x03000200UL
N#define LPC_ROM_API     (*(LPC_ROM_API_T * *) LPC_ROM_API_BASE_LOC)
N
N/* Pointer to @ref PWRD_API_T functions in ROM */
N//#define LPC_PWRD_API    ((LPC_ROM_API)->pPWRD)
N
N/* Pointer to ROM IAP entry functions */
N#define IAP_ENTRY_LOCATION        0x03000205
N
N/**
N * @brief LPC5410x IAP_ENTRY API function type
N */
Nstatic INLINE void iap_entry(unsigned int cmd_param[5], unsigned int status_result[4])
Xstatic __inline void iap_entry(unsigned int cmd_param[5], unsigned int status_result[4])
N{
N	((IAP_ENTRY_T) IAP_ENTRY_LOCATION)(cmd_param, status_result);
X	((IAP_ENTRY_T) 0x03000205)(cmd_param, status_result);
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __ROMAPI_5411X_H_ */
L 177 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "syscon_5411x.h"
L 1 "..\..\..\chip_5411x\inc\syscon_5411x.h" 1
N/*
N * @brief LPC5411X System & Control driver inclusion file
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __SYSCON_5411X_H_
N#define __SYSCON_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup SYSCON_5411X CHIP: LPC5411X System and Control Driver
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/**
N * @brief LPC5411X Main system configuration register block structure
N */
Ntypedef struct {
N	__IO uint32_t SYSMEMREMAP;			/*!< System Remap register */
X	volatile uint32_t SYSMEMREMAP;			 
N	__I  uint32_t RESERVED0[3];
X	volatile const  uint32_t RESERVED0[3];
N	__IO uint32_t AHBMATPRIO;           /*!< AHB Martix priority register */
X	volatile uint32_t AHBMATPRIO;            
N	__I  uint32_t RESERVED1[11];
X	volatile const  uint32_t RESERVED1[11];
N	__IO uint32_t SYSTCKCAL;			/*!< System Tick Calibration register */
X	volatile uint32_t SYSTCKCAL;			 
N	__I  uint32_t RESERVED2[1];
X	volatile const  uint32_t RESERVED2[1];
N	__IO uint32_t NMISRC;				/*!< NMI Source select register */
X	volatile uint32_t NMISRC;				 
N	__IO uint32_t ASYNCAPBCTRL;			/*!< Asynch APB chiplet control register */
X	volatile uint32_t ASYNCAPBCTRL;			 
N	__I  uint32_t RESERVED3[28];
X	volatile const  uint32_t RESERVED3[28];
N	__I  uint32_t PIOPORCAP[2];         /*!< Power on Reset; port capture register */
X	volatile const  uint32_t PIOPORCAP[2];          
N	__I  uint32_t RESERVED4[2];
X	volatile const  uint32_t RESERVED4[2];
N	__I  uint32_t PIORESCAP[2];         /*!< Reset; port capture register */
X	volatile const  uint32_t PIORESCAP[2];          
N	__I  uint32_t RESERVED5[10];
X	volatile const  uint32_t RESERVED5[10];
N	__IO uint32_t PRESETCTRL[2];		/*!< Peripheral Reset control */
X	volatile uint32_t PRESETCTRL[2];		 
N	__I  uint32_t RESERVED6[6];
X	volatile const  uint32_t RESERVED6[6];
N	__O  uint32_t PRESETCTRLSET[2];     /*!< Peripheral Reset Control set */
X	volatile  uint32_t PRESETCTRLSET[2];      
N	__I  uint32_t RESERVED7[6];
X	volatile const  uint32_t RESERVED7[6];
N	__O  uint32_t PRESETCTRLCLR[2];     /*!< Peripheral Reset Control set */
X	volatile  uint32_t PRESETCTRLCLR[2];      
N	__I  uint32_t RESERVED8[42];
X	volatile const  uint32_t RESERVED8[42];
N	__IO uint32_t SYSRSTSTAT;			/*!< System Reset Stat register */
X	volatile uint32_t SYSRSTSTAT;			 
N	__I  uint32_t RESERVED9[3];
X	volatile const  uint32_t RESERVED9[3];
N	__IO uint32_t AHBCLKCTRL[2];        /*!< AHB Peripheral Clk Enable register */
X	volatile uint32_t AHBCLKCTRL[2];         
N	__I  uint32_t RESERVED10[6];
X	volatile const  uint32_t RESERVED10[6];
N	__O  uint32_t AHBCLKCTRLSET[2];     /*!< AHB Peripheral Clk Enable Set register */
X	volatile  uint32_t AHBCLKCTRLSET[2];      
N	__I  uint32_t RESERVED11[6];
X	volatile const  uint32_t RESERVED11[6];
N	__O  uint32_t AHBCLKCTRLCLR[2];     /*!< AHB Peripheral Clk Enable Clr register */
X	volatile  uint32_t AHBCLKCTRLCLR[2];      
N	__I  uint32_t RESERVED12[14];
X	volatile const  uint32_t RESERVED12[14];
N	__IO uint32_t MAINCLKSELA;			/*!< Main Clk sel Source Sel A register */
X	volatile uint32_t MAINCLKSELA;			 
N	__IO uint32_t MAINCLKSELB;			/*!< Main Clk sel Source Sel B register */
X	volatile uint32_t MAINCLKSELB;			 
N	__IO uint32_t CLKOUTSELA;			/*!< Clk Out Sel Source B register */
X	volatile uint32_t CLKOUTSELA;			 
N	__I  uint32_t RESERVED13;
X	volatile const  uint32_t RESERVED13;
N	__IO uint32_t SYSPLLCLKSEL;			/*!< System PLL Clk Selregister */
X	volatile uint32_t SYSPLLCLKSEL;			 
N	__I  uint32_t RESERVED14[3];
X	volatile const  uint32_t RESERVED14[3];
N	__IO uint32_t SPIFICLKSEL;          /*!< SPIFI clock selection register */
X	volatile uint32_t SPIFICLKSEL;           
N	__IO uint32_t ADCCLKSEL;			/*!< ADC Async Clk Sel register */
X	volatile uint32_t ADCCLKSEL;			 
N	__IO uint32_t USBCLKSEL;			/*!< USB Async Clk Sel register */
X	volatile uint32_t USBCLKSEL;			 
N	__I  uint32_t RESERVED15;
X	volatile const  uint32_t RESERVED15;
N	__IO uint32_t FXCOMCLKSEL[8];       /*!< FlexCOM CLK sel register */
X	volatile uint32_t FXCOMCLKSEL[8];        
N	__I  uint32_t RESERVED16[4];
X	volatile const  uint32_t RESERVED16[4];
N	__IO uint32_t MCLKCLKSEL;           /*!< MCLK Clock select register */
X	volatile uint32_t MCLKCLKSEL;            
N	__I  uint32_t RESERVED16A;
X	volatile const  uint32_t RESERVED16A;
N	__IO uint32_t FRGCLKSEL;            /*!< FRG Clock select register */
X	volatile uint32_t FRGCLKSEL;             
N	__IO uint32_t DMICCLKSEL;           /*!< DMIC Clock select register */
X	volatile uint32_t DMICCLKSEL;            
N	__I  uint32_t RESERVED17[4];
X	volatile const  uint32_t RESERVED17[4];
N	__IO uint32_t SYSTICKCLKDIV;		/*!< Systick Clock divider register */
X	volatile uint32_t SYSTICKCLKDIV;		 
N	__I  uint32_t RESERVED18[31];
X	volatile const  uint32_t RESERVED18[31];
N	__IO uint32_t AHBCLKDIV;            /*!< AHB Clock divider */
X	volatile uint32_t AHBCLKDIV;             
N	__IO uint32_t CLKOUTDIV;            /*!< CLKOUT divider */
X	volatile uint32_t CLKOUTDIV;             
N	__I  uint32_t RESERVED19[2];
X	volatile const  uint32_t RESERVED19[2];
N	__IO uint32_t SPIFICLKDIV;          /*!< SPIFI clock divider register */
X	volatile uint32_t SPIFICLKDIV;           
N	__IO uint32_t ADCCLKDIV;            /*!< ADC Clock divider register */
X	volatile uint32_t ADCCLKDIV;             
N	__IO uint32_t USBCLKDIV;            /*!< USB Clock divider register */
X	volatile uint32_t USBCLKDIV;             
N	__I  uint32_t RESERVED20;
X	volatile const  uint32_t RESERVED20;
N	__IO uint32_t FRGCTRL;				/*!< Fraction Rate Generator Ctrl register */
X	volatile uint32_t FRGCTRL;				 
N	__I  uint32_t RESERVED21;
X	volatile const  uint32_t RESERVED21;
N	__IO uint32_t DMICCLKDIV;            /*!< DMIC Clock divider register */
X	volatile uint32_t DMICCLKDIV;             
N	__IO uint32_t MCLKDIV;               /*!< I2S MClock divider register */
X	volatile uint32_t MCLKDIV;                
N	__I  uint32_t RESERVED22[20];
X	volatile const  uint32_t RESERVED22[20];
N	__IO uint32_t FLASHCFG;              /*!< Flash wait state configuration register */
X	volatile uint32_t FLASHCFG;               
N	__I  uint32_t RESERVED23[2];
X	volatile const  uint32_t RESERVED23[2];
N	__IO uint32_t USBCLKCTRL;            /*!< USB Clock control register */
X	volatile uint32_t USBCLKCTRL;             
N	__IO uint32_t USBCLKSTAT;            /*!< USB Clock Status register */
X	volatile uint32_t USBCLKSTAT;             
N	__I  uint32_t RESERVED24;
X	volatile const  uint32_t RESERVED24;
N	__IO uint32_t FREQMECTRL;            /*!< Frequency measure register */
X	volatile uint32_t FREQMECTRL;             
N	__I  uint32_t RESERVED25;
X	volatile const  uint32_t RESERVED25;
N	__IO uint32_t MCLKIO;                /*!< MCLK Input Output register */
X	volatile uint32_t MCLKIO;                 
N	__I  uint32_t RESERVED26[55];
X	volatile const  uint32_t RESERVED26[55];
N	__IO uint32_t FROCTRL;               /*!< FRO oscillator control register */
X	volatile uint32_t FROCTRL;                
N	__I  uint32_t RESERVED27;
X	volatile const  uint32_t RESERVED27;
N	__IO uint32_t WDTOSCCTRL;            /*!< Watchdog Oscillator control */
X	volatile uint32_t WDTOSCCTRL;             
N	__IO uint32_t RTCOSCCTRL;            /*!< RTC Oscillator control register */
X	volatile uint32_t RTCOSCCTRL;             
N	__I  uint32_t RESERVED28[28];
X	volatile const  uint32_t RESERVED28[28];
N	__IO uint32_t SYSPLLCTRL;            /*!< System PLL control register */
X	volatile uint32_t SYSPLLCTRL;             
N	__I  uint32_t SYSPLLSTAT;            /*!< System PLL status register */
X	volatile const  uint32_t SYSPLLSTAT;             
N	__IO uint32_t SYSPLLNDEC;            /*!< System PLL N-DEC register */
X	volatile uint32_t SYSPLLNDEC;             
N	__IO uint32_t SYSPLLPDEC;            /*!< System PLL P-DEC register */
X	volatile uint32_t SYSPLLPDEC;             
N	__IO uint32_t SYSPLLSSCTRL[2];       /*!< System PLL Spread-Spectrum control register */
X	volatile uint32_t SYSPLLSSCTRL[2];        
N	__I  uint32_t RESERVED29[30];
X	volatile const  uint32_t RESERVED29[30];
N	__IO uint32_t PDRUNCFG[2];           /*!< Power Down configuration registers */
X	volatile uint32_t PDRUNCFG[2];            
N	__I  uint32_t RESERVED30[2];
X	volatile const  uint32_t RESERVED30[2];
N	__O  uint32_t PDRUNCFGSET[2];        /*!< Power down configuartion set register */
X	volatile  uint32_t PDRUNCFGSET[2];         
N	__I  uint32_t RESERVED31[2];
X	volatile const  uint32_t RESERVED31[2];
N	__O  uint32_t PDRUNCFGCLR[2];        /*!< Power down configuartion clear register */
X	volatile  uint32_t PDRUNCFGCLR[2];         
N	__I  uint32_t RESERVED32[18];
X	volatile const  uint32_t RESERVED32[18];
N	__IO uint32_t STARTERP[2];           /*!< Start logic wakeup enable register */
X	volatile uint32_t STARTERP[2];            
N	__I  uint32_t RESERVED33[6];
X	volatile const  uint32_t RESERVED33[6];
N	__O  uint32_t STARTERPSET[2];        /*!< Start logic wakeup enable set register */
X	volatile  uint32_t STARTERPSET[2];         
N	__I  uint32_t RESERVED34[6];
X	volatile const  uint32_t RESERVED34[6];
N	__O  uint32_t STARTERPCLR[2];        /*!< Start logic wakeup enable clear register */
X	volatile  uint32_t STARTERPCLR[2];         
N	__I  uint32_t RESERVED35[78];
X	volatile const  uint32_t RESERVED35[78];
N	__IO uint32_t CPCTRL;                /*!< Coprocessor control register */
X	volatile uint32_t CPCTRL;                 
N	__IO uint32_t CPBOOT;                /*!< Coprocessor boot address */
X	volatile uint32_t CPBOOT;                 
N	__IO uint32_t CPSTACK;               /*!< Coprocessor stack address register */
X	volatile uint32_t CPSTACK;                
N	__I  uint32_t CPSTAT;                /*!< Coprocessor status register */
X	volatile const  uint32_t CPSTAT;                 
N	__I  uint32_t RESERVED36[381];
X	volatile const  uint32_t RESERVED36[381];
N    __IO uint32_t AUTOCGOR;
X    volatile uint32_t AUTOCGOR;
N    __I  uint32_t RESERVED37[123];
X    volatile const  uint32_t RESERVED37[123];
N	__I  uint32_t JTAGIDCODE;            /*!< JTAG ID Code register */
X	volatile const  uint32_t JTAGIDCODE;             
N	__I  uint32_t DEVICE_ID[2];           /*!< Device ID Registers */
X	volatile const  uint32_t DEVICE_ID[2];            
N} LPC_SYSCON_T;
N
N/**
N * @brief LPC5411X Asynchronous system configuration register block structure
N */
Ntypedef struct {
N	__IO uint32_t AYSNCPRESETCTRL;		/*!< peripheral reset register */
X	volatile uint32_t AYSNCPRESETCTRL;		 
N	__O  uint32_t ASYNCPRESETCTRLSET;	/*!< peripheral reset Set register */
X	volatile  uint32_t ASYNCPRESETCTRLSET;	 
N	__O  uint32_t ASYNCPRESETCTRLCLR;	/*!< peripheral reset Clr register */
X	volatile  uint32_t ASYNCPRESETCTRLCLR;	 
N	__I  uint32_t RESERVED0;
X	volatile const  uint32_t RESERVED0;
N	__IO uint32_t ASYNCAPBCLKCTRL;		/*!< clk enable register */
X	volatile uint32_t ASYNCAPBCLKCTRL;		 
N	__IO uint32_t ASYNCAPBCLKCTRLSET;	/*!< clk enable Set register */
X	volatile uint32_t ASYNCAPBCLKCTRLSET;	 
N	__IO uint32_t ASYNCAPBCLKCTRLCLR;	/*!< clk enable Clr register */
X	volatile uint32_t ASYNCAPBCLKCTRLCLR;	 
N	__I  uint32_t RESERVED1;
X	volatile const  uint32_t RESERVED1;
N	__IO uint32_t ASYNCAPBCLKSELA;		/*!< clk source mux A register */
X	volatile uint32_t ASYNCAPBCLKSELA;		 
N} LPC_ASYNC_SYSCON_T;
N
N
N/**
N * @brief	FROCTRL register bits
N */
N#define SYSCON_FROCTRL_MASK            ((1 << 15) | (0xF << 26))  /**< MASK for reserved bits in FROCTRL register */
N#define SYSCON_FROCTRL_WRTRIM          (1UL << 31)   /**< Enable Writes to FROCTRL register */
N#define SYSCON_FROCTRL_HSPDCLK         (1UL << 30)   /**< High speed clock (FROHF) enable bit */
N#define SYSCON_FROCTRL_USBMODCHG       (1UL << 25)   /**< When set Trim value is pending to be set by SOF from USB */
N#define SYSCON_FROCTRL_USBCLKADJ       (1UL << 24)   /**< Automatically adjust FRO trim value based on SOF from USB */
N#define SYSCON_FROCTRL_SEL96MHZ        (1UL << 14)   /**< When set FROHF will be 96MHz; else FROHF will be 48MHz */
N/**
N * System memory remap modes used to remap interrupt vectors
N */
Ntypedef enum CHIP_SYSCON_BOOT_MODE_REMAP {
N	REMAP_BOOT_LOADER_MODE,	/*!< Interrupt vectors are re-mapped to Boot ROM */
N	REMAP_USER_RAM_MODE,	/*!< Interrupt vectors are re-mapped to user Static RAM */
N	REMAP_USER_FLASH_MODE	/*!< Interrupt vectors are not re-mapped and reside in Flash */
N} CHIP_SYSCON_BOOT_MODE_REMAP_T;
N
N/**
N * @brief	Re-map interrupt vectors
N * @param	remap	: system memory map value
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SYSCON_Map(CHIP_SYSCON_BOOT_MODE_REMAP_T remap)
Xstatic __inline void Chip_SYSCON_Map(CHIP_SYSCON_BOOT_MODE_REMAP_T remap)
N{
N	LPC_SYSCON->SYSMEMREMAP = (uint32_t) remap;
X	((LPC_SYSCON_T *) 0x40000000UL)->SYSMEMREMAP = (uint32_t) remap;
N}
N
N/**
N * @brief	Get system remap setting
N * @return	System remap setting
N */
N__STATIC_INLINE CHIP_SYSCON_BOOT_MODE_REMAP_T Chip_SYSCON_GetMemoryMap(void)
Xstatic __inline CHIP_SYSCON_BOOT_MODE_REMAP_T Chip_SYSCON_GetMemoryMap(void)
N{
N	return (CHIP_SYSCON_BOOT_MODE_REMAP_T) LPC_SYSCON->SYSMEMREMAP;
X	return (CHIP_SYSCON_BOOT_MODE_REMAP_T) ((LPC_SYSCON_T *) 0x40000000UL)->SYSMEMREMAP;
N}
N
N/**
N * @brief	Set System tick timer calibration value
N * @param	sysCalVal	: System tick timer calibration value
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SYSCON_SetSYSTCKCAL(uint32_t sysCalVal)
Xstatic __inline void Chip_SYSCON_SetSYSTCKCAL(uint32_t sysCalVal)
N{
N	LPC_SYSCON->SYSTCKCAL = sysCalVal;
X	((LPC_SYSCON_T *) 0x40000000UL)->SYSTCKCAL = sysCalVal;
N}
N
N/**
N * Non-Maskable Interrupt Enable/Disable value
N */
N#define SYSCON_NMISRC_M0_ENABLE   ((uint32_t) 1 << 30)	/*!< Enable the Non-Maskable Interrupt M0 (NMI) source */
N#define SYSCON_NMISRC_M4_ENABLE   ((uint32_t) 1 << 31)	/*!< Enable the Non-Maskable Interrupt M4 (NMI) source */
N
N/**
N * @brief	Set source for non-maskable interrupt (NMI)
N * @param	intsrc	: IRQ number to assign to the NMI
N * @return	Nothing
N * @note	The NMI source will be disabled upon exiting this function. Use the
N * Chip_SYSCON_EnableNMISource() function to enable the NMI source.
N */
Nvoid Chip_SYSCON_SetNMISource(uint32_t intsrc);
N
N/**
N * @brief	Enable interrupt used for NMI source
N * @return	Nothing
N */
Nvoid Chip_SYSCON_EnableNMISource(void);
N
N/**
N * @brief	Disable interrupt used for NMI source
N * @return	Nothing
N */
Nvoid Chip_SYSCON_DisableNMISource(void);
N
N/**
N * @brief	Enable or disable asynchronous APB bridge and subsystem
N * @param	enable	: true to enable, false to disable
N * @return	Nothing
N * @note	This bridge must be enabled to access peripherals on the
N * associated bridge.
N */
Nvoid Chip_SYSCON_Enable_ASYNC_Syscon(bool enable);
Xvoid Chip_SYSCON_Enable_ASYNC_Syscon(_Bool enable);
N
N/**
N * @brief	Set UART Fractional divider value
N * @param	fmul	: Fractional multiplier value
N * @param	fdiv	: Fractional divider value (Must always be 0xFF)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SYSCON_SetUSARTFRGCtrl(uint8_t fmul, uint8_t fdiv)
Xstatic __inline void Chip_SYSCON_SetUSARTFRGCtrl(uint8_t fmul, uint8_t fdiv)
N{
N	LPC_SYSCON->FRGCTRL = ((uint32_t) fmul << 8) | fdiv;
X	((LPC_SYSCON_T *) 0x40000000UL)->FRGCTRL = ((uint32_t) fmul << 8) | fdiv;
N}
N
N/**
N * System reset status values
N */
N#define SYSCON_RST_POR    (1 << 0)	/*!< POR reset status */
N#define SYSCON_RST_EXTRST (1 << 1)	/*!< External reset status */
N#define SYSCON_RST_WDT    (1 << 2)	/*!< Watchdog reset status */
N#define SYSCON_RST_BOD    (1 << 3)	/*!< Brown-out detect reset status */
N#define SYSCON_RST_SYSRST (1 << 4)	/*!< software system reset status */
N
N/**
N * @brief	Get system reset status
N * @return	An Or'ed value of SYSCON_RST_*
N * @note	This function returns the detected reset source(s).
N */
N__STATIC_INLINE uint32_t Chip_SYSCON_GetSystemRSTStatus(void)
Xstatic __inline uint32_t Chip_SYSCON_GetSystemRSTStatus(void)
N{
N	return LPC_SYSCON->SYSRSTSTAT;
X	return ((LPC_SYSCON_T *) 0x40000000UL)->SYSRSTSTAT;
N}
N
N/**
N * @brief	Clear system reset status
N * @param	reset	: An Or'ed value of SYSCON_RST_* status to clear
N * @return	Nothing
N * @note	This function clears the specified reset source(s).
N */
N__STATIC_INLINE void Chip_SYSCON_ClearSystemRSTStatus(uint32_t reset)
Xstatic __inline void Chip_SYSCON_ClearSystemRSTStatus(uint32_t reset)
N{
N	LPC_SYSCON->SYSRSTSTAT = reset;
X	((LPC_SYSCON_T *) 0x40000000UL)->SYSRSTSTAT = reset;
N}
N
N/**
N * Peripheral reset identifiers
N */
Ntypedef enum {
N	/* Peripheral reset enables for PRESETCTRL0 */
N	RESET_FLASH = 7,                /*!< Flash Controller */
N	RESET_FMC,                      /*!< Flash Accelerator */
N	RESET_SPIFI = 10,               /*!< SPIFI Reset */
N	RESET_MUX,                      /*!< IO MUX Reset */
N	RESET_IOCON = 13,               /*!< IOCON Reset */
N	RESET_GPIO0,                    /*!< GPIO Port-0 Reset */
N	RESET_GPIO1,                    /*!< GPIO Port-1 Reset */
N	RESET_PINT = 18,                /*!< Pin Interrupt Reset */
N	RESET_GINT,                     /*!< Group Interrupt Reset */
N	RESET_DMA,                      /*!< DMA Reset */
N	RESET_CRC,                      /*!< CRC Engine Reset */
N	RESET_WWDT,                     /*!< Windowed watchdog timer */
N	RESET_ADC = 27,                 /*!< ADC Reset */
N	RESET_ADC0 = 27,                /*!< ADC Reset */
N
N	/* Peripheral reset enables for PRESETCTRL1 */
N	RESET_MRT = 32,                 /*!< Multirate Timer */
N	RESET_SCT0 = 32 + 2,            /*!< State configurable Timer */
N	RESET_SCT = 32 + 2,             /*!< State configurable Timer */
N	RESET_UTICK = 32 + 10,          /*!< Micro Tick Timer */
N	RESET_FLEXCOMM0,                /*!< FlexComm 0 */
N	RESET_FLEXCOMM1,                /*!< FlexComm 1 */
N	RESET_FLEXCOMM2,                /*!< FlexComm 2 */
N	RESET_FLEXCOMM3,                /*!< FlexComm 3 */
N	RESET_FLEXCOMM4,                /*!< FlexComm 4 */
N	RESET_FLEXCOMM5,                /*!< FlexComm 5 */
N	RESET_FLEXCOMM6,                /*!< FlexComm 6 */
N	RESET_FLEXCOMM7,                /*!< FlexComm 7 */
N	RESET_DMIC,                     /*!< Digital MIC */
N	RESET_TIMER2 = 32 + 22,         /*!< Timer2 Reset */
N	RESET_USB,                      /*!< USB Reset */
N	RESET_TIMER0,                   /*!< Timer0 Reset */
N	RESET_TIMER1,                   /*!< Timer1 Reset */
N
N	/* Async peripheral reset enables for ASYNCPRESETCTRL */
N	RESET_TIMER3 = 128 + 13,		/*!< TIMER0 */
N	RESET_TIMER4,					/*!< TIMER4 Reset*/
N} CHIP_SYSCON_PERIPH_RESET_T;
N
N/**
N * @brief	Resets a peripheral
N * @param	periph	:	Peripheral to reset (See #CHIP_SYSCON_PERIPH_RESET_T)
N * @return	Nothing
N * Will assert and de-assert reset for a peripheral.
N */
N__STATIC_INLINE void Chip_SYSCON_PeriphReset(CHIP_SYSCON_PERIPH_RESET_T periph)
Xstatic __inline void Chip_SYSCON_PeriphReset(CHIP_SYSCON_PERIPH_RESET_T periph)
N{
N	uint32_t val = (uint32_t) periph;
N	if (val < 128) {
N		LPC_SYSCON->PRESETCTRLSET[val >> 5] = 1 << (val & 31);
X		((LPC_SYSCON_T *) 0x40000000UL)->PRESETCTRLSET[val >> 5] = 1 << (val & 31);
N	} else {
N		LPC_ASYNC_SYSCON->ASYNCPRESETCTRLSET = 1 << (val - 128);
X		((LPC_ASYNC_SYSCON_T *) 0x40040000UL)->ASYNCPRESETCTRLSET = 1 << (val - 128);
N	}
N
N	__NOP();
X	__nop();
N	__NOP();
X	__nop();
N	__NOP();
X	__nop();
N	__NOP();
X	__nop();
N
N	if (val < 128) {
N		LPC_SYSCON->PRESETCTRLCLR[val >> 5] = 1 << (val & 31);
X		((LPC_SYSCON_T *) 0x40000000UL)->PRESETCTRLCLR[val >> 5] = 1 << (val & 31);
N	} else {
N		LPC_ASYNC_SYSCON->ASYNCPRESETCTRLCLR = 1 << (val - 128);
X		((LPC_ASYNC_SYSCON_T *) 0x40040000UL)->ASYNCPRESETCTRLCLR = 1 << (val - 128);
N	}
N}
N
N/**
N * @brief	Read POR captured PIO status
N * @param	port	: 0 for port 0 pins, 1 for port 1 pins, 2 for port 2 pins, etc.
N * @return	captured Power-On-Reset (POR) PIO status
N */
N__STATIC_INLINE uint32_t Chip_SYSCON_GetPORPIOStatus(uint8_t port)
Xstatic __inline uint32_t Chip_SYSCON_GetPORPIOStatus(uint8_t port)
N{
N	return LPC_SYSCON->PIOPORCAP[port];
X	return ((LPC_SYSCON_T *) 0x40000000UL)->PIOPORCAP[port];
N}
N
N/**
N * @brief	Read reset captured PIO status
N * @param	port	: 0 for port 0 pins, 1 for port 1 pins, 2 for port 2 pins, etc.
N * @return	captured reset PIO status
N * @note	Used when reset other than a Power-On-Reset (POR) occurs.
N */
N__STATIC_INLINE uint32_t Chip_SYSCON_GetResetPIOStatus(uint8_t port)
Xstatic __inline uint32_t Chip_SYSCON_GetResetPIOStatus(uint8_t port)
N{
N	return LPC_SYSCON->PIORESCAP[port];
X	return ((LPC_SYSCON_T *) 0x40000000UL)->PIORESCAP[port];
N}
N
N/**
N * @brief	Starts a frequency measurement cycle
N * @return	Nothing
N * @note	This function is meant to be used with the Chip_INMUX_SetFreqMeasRefClock()
N * and Chip_INMUX_SetFreqMeasTargClock() functions.
N */
N__STATIC_INLINE void Chip_SYSCON_StartFreqMeas(void)
Xstatic __inline void Chip_SYSCON_StartFreqMeas(void)
N{
N	LPC_SYSCON->FREQMECTRL = 0;
X	((LPC_SYSCON_T *) 0x40000000UL)->FREQMECTRL = 0;
N	LPC_SYSCON->FREQMECTRL = (1UL << 31);
X	((LPC_SYSCON_T *) 0x40000000UL)->FREQMECTRL = (1UL << 31);
N}
N
N/**
N * @brief	Indicates when a frequency measurement cycle is complete
N * @return	true if a measurement cycle is active, otherwise false
N */
N__STATIC_INLINE bool Chip_SYSCON_IsFreqMeasComplete(void)
Xstatic __inline _Bool Chip_SYSCON_IsFreqMeasComplete(void)
N{
N	return (bool) ((LPC_SYSCON->FREQMECTRL & (1UL << 31)) == 0);
X	return (_Bool) ((((LPC_SYSCON_T *) 0x40000000UL)->FREQMECTRL & (1UL << 31)) == 0);
N}
N
N/**
N * @brief	Returns the raw capture value for a frequency measurement cycle
N * @return	raw cpature value (this is not a frequency)
N */
N__STATIC_INLINE uint32_t Chip_SYSCON_GetRawFreqMeasCapval(void)
Xstatic __inline uint32_t Chip_SYSCON_GetRawFreqMeasCapval(void)
N{
N	return LPC_SYSCON->FREQMECTRL & 0x3FFF;
X	return ((LPC_SYSCON_T *) 0x40000000UL)->FREQMECTRL & 0x3FFF;
N}
N
N/**
N * @brief	Returns the computed value for a frequency measurement cycle
N * @param	refClockRate	: Reference clock rate used during the frequency measurement cycle
N * @return	Computed cpature value
N */
Nuint32_t Chip_SYSCON_GetCompFreqMeas(uint32_t refClockRate);
N
N/**
N * @brief FLASH Access time definitions
N */
Ntypedef enum {
N	SYSCON_FLASH_1CYCLE = 0,	/*!< Flash accesses use 1 CPU clock */
N	FLASHTIM_20MHZ_CPU = SYSCON_FLASH_1CYCLE,
N	SYSCON_FLASH_2CYCLE,		/*!< Flash accesses use 2 CPU clocks */
N	SYSCON_FLASH_3CYCLE,		/*!< Flash accesses use 3 CPU clocks */
N	SYSCON_FLASH_4CYCLE,		/*!< Flash accesses use 4 CPU clocks */
N	SYSCON_FLASH_5CYCLE,		/*!< Flash accesses use 5 CPU clocks */
N	SYSCON_FLASH_6CYCLE,		/*!< Flash accesses use 6 CPU clocks */
N	SYSCON_FLASH_7CYCLE,		/*!< Flash accesses use 7 CPU clocks */
N	SYSCON_FLASH_8CYCLE			/*!< Flash accesses use 8 CPU clocks */
N} SYSCON_FLASHTIM_T;
N
N/**
N * @brief	Set FLASH memory access time in clocks
N * @param	clks	: Clock cycles for FLASH access
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SYSCON_SetFLASHAccess(SYSCON_FLASHTIM_T clks)
Xstatic __inline void Chip_SYSCON_SetFLASHAccess(SYSCON_FLASHTIM_T clks)
N{
N	uint32_t tmp;
N
N	tmp = LPC_SYSCON->FLASHCFG & ~(0xF << 12);
X	tmp = ((LPC_SYSCON_T *) 0x40000000UL)->FLASHCFG & ~(0xF << 12);
N
N	/* Don't alter lower bits */
N	LPC_SYSCON->FLASHCFG = tmp | ((uint32_t) clks << 12);
X	((LPC_SYSCON_T *) 0x40000000UL)->FLASHCFG = tmp | ((uint32_t) clks << 12);
N}
N
N/**
N * Power control definition bits (0 = powered, 1 = powered down)
N */
N#define SYSCON_PDRUNCFG_PD_FRO           (1 << 4)		/*!< FRO oscillator */
N#define SYSCON_PDRUNCFG_PD_FLASH         (1 << 5)		/*!< Flash memory */
N#define SYSCON_PDRUNCFG_PD_TS            (1 << 6)		/*!< Temperature Sensor */
N#define SYSCON_PDRUNCFG_PD_BOD_RST       (1 << 7)		/*!< Brown-out Detect reset */
N#define SYSCON_PDRUNCFG_PD_BOD_INTR      (1 << 8)		/*!< Brown-out Detect interrupt */
N#define SYSCON_PDRUNCFG_PD_ADC0          (1 << 10)		/*!< ADC0 */
N#define SYSCON_PDRUNCFG_PD_VDDFLASH      (1 << 11)		/*!< Flash Vdd */
N#define SYSCON_PDRUNCFG_LP_VDDFLASH      (1 << 12)		/*!< Flash LP Vdd */
N#define SYSCON_PDRUNCFG_PD_SRAM0         (1 << 13)		/*!< SRAM0 */
N#define SYSCON_PDRUNCFG_PD_SRAM1         (1 << 14)		/*!< SRAM1 */
N#define SYSCON_PDRUNCFG_PD_SRAM2         (1 << 15)		/*!< SRAM2 */
N#define SYSCON_PDRUNCFG_PD_SRAMX         (1 << 16)		/*!< SRAMX */
N#define SYSCON_PDRUNCFG_PD_ROM           (1 << 17)		/*!< ROM */
N#define SYSCON_PDRUNCFG_PD_VDDHV_ENA     (1 << 18)		/*!< Vdd HV */
N#define SYSCON_PDRUNCFG_PD_VDDA_ENA      (1 << 19)		/*!< Vdda to the ADC, must be enabled for the ADC to work */
N#define SYSCON_PDRUNCFG_PD_WDT_OSC       (1 << 20)		/*!< Watchdog oscillator */
N#define SYSCON_PDRUNCFG_PD_USB_PHY       (1 << 21)      /*!< USB Phy */
N#define SYSCON_PDRUNCFG_PD_SYS_PLL       (1 << 22)		/*!< PLL0 */
N#define SYSCON_PDRUNCFG_PD_VREFP         (1 << 23)		/*!< Vrefp to the ADC, must be enabled for the ADC to work */
N
N/**
N * @brief	Power up one or more blocks or peripherals
N * @return	OR'ed values of SYSCON_PDRUNCFG_* values
N * @note	A high state indicates the peripheral is powered down.
N */
N__STATIC_INLINE uint32_t Chip_SYSCON_GetPowerStates(void)
Xstatic __inline uint32_t Chip_SYSCON_GetPowerStates(void)
N{
N	return LPC_SYSCON->PDRUNCFG[0];
X	return ((LPC_SYSCON_T *) 0x40000000UL)->PDRUNCFG[0];
N}
N
N/**
N * @brief	Power down one or more blocks or peripherals
N * @param	powerdownmask	: OR'ed values of SYSCON_PDRUNCFG_* values
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SYSCON_PowerDown(uint32_t powerdownmask)
Xstatic __inline void Chip_SYSCON_PowerDown(uint32_t powerdownmask)
N{
N	/* Disable peripheral states by setting high */
N	LPC_SYSCON->PDRUNCFGSET[0] = powerdownmask;
X	((LPC_SYSCON_T *) 0x40000000UL)->PDRUNCFGSET[0] = powerdownmask;
N}
N
N/**
N * @brief	Power up one or more blocks or peripherals
N * @param	powerupmask	: OR'ed values of SYSCON_PDRUNCFG_* values
N * @return	Nothing
N */
Nvoid Chip_SYSCON_PowerUp(uint32_t powerupmask);
N
N/**
N * Start enable enumerations - for enabling and disabling peripheral wakeup
N */
Ntypedef enum {
N	SYSCON_STARTER_WWDT_BOD = 0,
N	SYSCON_STARTER_DMA,
N	SYSCON_STARTER_GINT0,
N	SYSCON_STARTER_GINT1,
N	SYSCON_STARTER_PINT0,
N	SYSCON_STARTER_PINT1,
N	SYSCON_STARTER_PINT2,
N	SYSCON_STARTER_PINT3,
N	SYSCON_STARTER_UTICK,
N	SYSCON_STARTER_MRT,
N	SYSCON_STARTER_TIMER0,
N	SYSCON_STARTER_TIMER1,
N	SYSCON_STARTER_SCT0,
N	SYSCON_STARTER_TIMER3,
N	SYSCON_STARTER_FLEXCOMM0,
N	SYSCON_STARTER_FLEXCOMM1,
N	SYSCON_STARTER_FLEXCOMM2,
N	SYSCON_STARTER_FLEXCOMM3,
N	SYSCON_STARTER_FLEXCOMM4,
N	SYSCON_STARTER_FLEXCOMM5,
N	SYSCON_STARTER_FLEXCOMM6,
N	SYSCON_STARTER_FLEXCOMM7,
N	SYSCON_STARTER_ADC0_SEQA,
N	SYSCON_STARTER_ADC0_SEQB,
N	SYSCON_STARTER_ADC0_THCMP,
N	SYSCON_STARTER_DMIC,
N	SYSCON_STARTER_HWVAD,
N	SYSCON_STARTER_USBNEEDCLK,
N	SYSCON_STARTER_USB,
N	SYSCON_STARTER_RTC,
N	SYSCON_STARTER_RESERVED0,
N	SYSCON_STARTER_MAILBOX,
N	SYSCON_STARTER_PINT4,
N	SYSCON_STARTER_PINT5,
N	SYSCON_STARTER_PINT6,
N	SYSCON_STARTER_PINT7,
N	SYSCON_STARTER_TIMER2,
N	SYSCON_STARTER_TIMER4,
N} CHIP_SYSCON_WAKEUP_T;
N
N/**
N * @brief	Enables a pin's (PINT) wakeup logic
N * @param	periphId	: Peripheral identifier (See #CHIP_SYSCON_WAKEUP_T)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SYSCON_EnableWakeup(CHIP_SYSCON_WAKEUP_T periphId)
Xstatic __inline void Chip_SYSCON_EnableWakeup(CHIP_SYSCON_WAKEUP_T periphId)
N{
N	LPC_SYSCON->STARTERPSET[(uint32_t) periphId >> 5] = 1 << ((uint32_t) periphId & 31);
X	((LPC_SYSCON_T *) 0x40000000UL)->STARTERPSET[(uint32_t) periphId >> 5] = 1 << ((uint32_t) periphId & 31);
N}
N
N/**
N * @brief	Disables peripheral's wakeup logic
N * @param	periphId	: Peripheral identifier
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SYSCON_DisableWakeup(CHIP_SYSCON_WAKEUP_T periphId)
Xstatic __inline void Chip_SYSCON_DisableWakeup(CHIP_SYSCON_WAKEUP_T periphId)
N{
N	LPC_SYSCON->STARTERPCLR[(uint32_t) periphId >> 5] = 1 << ((uint32_t) periphId & 31);
X	((LPC_SYSCON_T *) 0x40000000UL)->STARTERPCLR[(uint32_t) periphId >> 5] = 1 << ((uint32_t) periphId & 31);
N}
N
N/**
N * @brief	Return the pointer to device ID registers
N * @return	Pointer to device ID registers
N */
N__STATIC_INLINE uint32_t Chip_SYSCON_GetDeviceID(void)
Xstatic __inline uint32_t Chip_SYSCON_GetDeviceID(void)
N{
N	return LPC_SYSCON->DEVICE_ID[0];
X	return ((LPC_SYSCON_T *) 0x40000000UL)->DEVICE_ID[0];
N}
N
N
N/**
N * Auto Clock Gating Overide definition bits
N */
N#define SYSCON_AUTOCGOR_RAM0X           (1 << 1)		/*!< RAM0 and RAMX overide */
N#define SYSCON_AUTOCGOR_RAM1            (1 << 2)		/*!< RAM1 overide */
N#define SYSCON_AUTOCGOR_RAM2            (1 << 3)		/*!< RAM2 overide */
N#define SYSCON_AUTOCGOR_MASK            (SYSCON_AUTOCGOR_RAM0X | SYSCON_AUTOCGOR_RAM1 | SYSCON_AUTOCGOR_RAM2)
N
N/**
N * @brief	Disables Auto clock gating for SRAM's
N * @param	mask	: Mask of RAM bits
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SYSCON_DisableAutoClocking(uint32_t mask)
Xstatic __inline void Chip_SYSCON_DisableAutoClocking(uint32_t mask)
N{
N	LPC_SYSCON->AUTOCGOR = (LPC_SYSCON->AUTOCGOR & SYSCON_AUTOCGOR_MASK) | mask;
X	((LPC_SYSCON_T *) 0x40000000UL)->AUTOCGOR = (((LPC_SYSCON_T *) 0x40000000UL)->AUTOCGOR & ((1 << 1) | (1 << 2) | (1 << 3))) | mask;
N}
N
N/**
N * @brief	Re-enables Auto clock gating for SRAM's
N * @param	mask	: Mask of RAM bits
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SYSCON_EnableAutoClocking(uint32_t mask)
Xstatic __inline void Chip_SYSCON_EnableAutoClocking(uint32_t mask)
N{
N	LPC_SYSCON->AUTOCGOR = (LPC_SYSCON->AUTOCGOR & SYSCON_AUTOCGOR_MASK & ~mask);
X	((LPC_SYSCON_T *) 0x40000000UL)->AUTOCGOR = (((LPC_SYSCON_T *) 0x40000000UL)->AUTOCGOR & ((1 << 1) | (1 << 2) | (1 << 3)) & ~mask);
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __SYSCON_5411X_H_ */
L 178 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "cpuctrl_5411x.h"
L 1 "..\..\..\chip_5411x\inc\cpuctrl_5411x.h" 1
N/*
N * @brief LPC5411X CPU multi-core support driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __CPUCTRL_5411X_H_
N#define __CPUCTRL_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup CPUCTRL_5411X CHIP: LPC5411X CPU multi-core support driver
N * @ingroup CHIP_5411X_DRIVERS
N * This driver helps with determine which MCU core the software is running,
N * whether the MCU core is in master or slave mode, and provides functions
N * for master and slave core control.<br>
N *
N * The functions for the driver are provided as part of the
N * @ref POWER_LIBRARY_5411X library. For more information on using the
N * LPC5411x LPCopen package with multi-core, see @ref CHIP_5411X_MULTICORE<br>.
N * @{
N */
N
N/**
N * @brief	Determine which MCU this code is running on
N * @return  true if executing on the CM4, or false if executing on the CM0+
N */
N__STATIC_INLINE bool Chip_CPU_IsM4Core(void) {
Xstatic __inline _Bool Chip_CPU_IsM4Core(void) {
N	/* M4 core is designated by values 0xC24 on bits 15..4 */
N	if (((SCB->CPUID >> 4) & 0xFFF) == 0xC24) {
X	if (((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->CPUID >> 4) & 0xFFF) == 0xC24) {
N		return true;
X		return 1;
N	}
N
N	return false;
X	return 0;
N}
N
N/* Core selection */
Ntypedef enum {
N	CORESELECT_M0PLUS = 0,
N	CORESELECT_M4
N} CORESELECT_T;
N
N/**
N * @brief	Select master core and system power control ownership
N * @return	Nothing
N * @note	This function can be used to select the master core and which
N * core can powerdown the system. The master core can be re-selected on
N * either the current master or slave core. Power control ownership is used
N * to select which core can place the system in DEEP SLEEP, POWERDOWN, and
N * DEEP POWERDOWN modes. (See @ref Chip_POWER_EnterPowerMode). Note both
N * the master and slave cores can used SLEEP mode, but only the master core
N * can use the other modes.
N */
Nvoid Chip_CPU_SelectMasterCore(CORESELECT_T master, CORESELECT_T ownerPower);
N
N/**
N * @brief	Determine if this core is a slave or master
N * @return  true if this MCU is operating as the master, or false if operating as a slave
N */
Nbool Chip_CPU_IsMasterCore(void);
X_Bool Chip_CPU_IsMasterCore(void);
N
N/**
N * @brief	Setup M0+ boot and reset M0+ core
N * @param	coentry		: Pointer to boot entry point for M0+ core
N * @param	costackptr	: Pointer to where stack should be located for M0+ core
N * @return  Nothing
N * @note	Will setup boot stack and entry point, enable M0+ clock and then
N * reset M0+ core.
N */
Nvoid Chip_CPU_CM0Boot(uint32_t *coentry, uint32_t *costackptr);
N
N/**
N * @brief	Setup M4 boot and reset M4 core
N * @param	coentry		: Pointer to boot entry point for M4 core
N * @param	costackptr	: Pointer to where stack should be located for M4 core
N * @return  Nothing
N * @note	Will setup boot stack and entry point, enable M4 clock and then
N * reset M0+ core.
N */
Nvoid Chip_CPU_CM4Boot(uint32_t *coentry, uint32_t *costackptr);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CPUCTRL_5411X_H_ */
L 179 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "clock_5411x.h"
L 1 "..\..\..\chip_5411x\inc\clock_5411x.h" 1
N/*
N * @brief LPC5411X clock driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licenser disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __CLOCK_5411X_H_
N#define __CLOCK_5411X_H_
N
N#include "pll_5411x.h"
L 1 "..\..\..\chip_5411x\inc\pll_5411x.h" 1
N/*
N * @brief LPC5411X PLL driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licenser disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __PLL_5411X_H_
N#define __PLL_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup PLL_5411X CHIP: LPC5411X PLL Driver
N * @ingroup CHIP_5411X_DRIVERS
N * The PLL in the LPC5411x is flexible, but can be complex to use. This driver
N * provides functions to help setup and use the PLL in it's various supported
N * modes.<br>
N *
N * This driver does not alter PLL clock source or system clocks outside the
N * PLL (like the main clock source) that may be referenced from the PLL. It
N * may optionally setup system voltages, wait for PLL lock, and power cycle
N * the PLL during setup based on setup flags.
N *
N * The driver works by first generating a PLL setup structure from a desired
N * PLL configuration structure. The PLL setup structure is then passed to the
N * PLL setup function to setup the PLL. In a user spplication, the PLL setup
N * structure can be pre-populated with PLL setup data to avoid using the PLL
N * configuration structure (or multiple PLL setup structures can be used to
N * more dynamically control PLL output rate).
N *
N * <b>How to use this driver</b><br>
N   @verbatim
N   // Setup PLL configuration
N   PLL_CONFIG_T pllConfig = {
N    75000000,		// desiredRate = 75MHz
N    0,				// InputRate = 0Hz (not used)
N    0				// No flags, function will determine best setup to get closest rate
N   };
N
N   // Get closest PLL setup to get the desired configuration
N   PLL_SETUP_T pllSetup;
N   uint32_t actualPllRate;
N   PLL_ERROR_T pllError;
N   pllError = Chip_Clock_SetupPLLData(&pllConfig, &pllSetup, &actualPllRate);
N   if (pllError != PLL_ERROR_SUCCESS) {
N    printf("PLL setup error #%x\r\n", (uint32_t) pllError);
N    while (1);
N   }
N   else {
N    printf("PLL config successful, actual config rate = %uHz\r\n", actualPllRate);
N   }
N
N   // Make sure main system clock is not using PLL, as the PLL setup
N   // function will power off and optionally power on the PLL
N   Chip_Clock_SetMainClockSource(SYSCON_MAINCLKSRC_IRC);
N
N   // Setup PLL source
N   Chip_Clock_SetSystemPLLSource(SYSCON_PLLCLKSRC_IRC);
N
N   // Now to apply the configuration to the PLL
N   pllSetup.flags = PLL_SETUPFLAG_WAITLOCK;
N   Chip_Clock_SetupSystemPLLPrec(&pllSetup);
N
N   // Switch main system clock to PLL
N   Chip_Clock_SetMainClockSource(SYSCON_MAINCLKSRC_PLLOUT);
N   @endverbatim
N *
N * @{
N */
N
N/**
N * Clock sources for system PLLs
N */
Ntypedef enum CHIP_SYSCON_PLLCLKSRC {
N	SYSCON_PLLCLKSRC_FRO12MHZ = 0,  /*!< 12MHz FRO */
N	SYSCON_PLLCLKSRC_CLKIN,         /*!< External clock input pin */
N	SYSCON_PLLCLKSRC_WDT,           /*!< Watchdog oscillator */
N	SYSCON_PLLCLKSRC_RTC,           /*!< RTC 32KHz oscillator */
N	SYSCON_PLLCLKSRC_DISABLED = 7   /*!< PLL input clock is disabled */
N} CHIP_SYSCON_PLLCLKSRC_T;
N
N/**
N * @brief	Set System PLL clock source
N * @param	src	: Clock source for system PLL
N * @return	Nothing
N * @note	The PLL should be pwoered down prior to changing the source.
N */
N__STATIC_INLINE void Chip_Clock_SetSystemPLLSource(CHIP_SYSCON_PLLCLKSRC_T src)
Xstatic __inline void Chip_Clock_SetSystemPLLSource(CHIP_SYSCON_PLLCLKSRC_T src)
N{
N	LPC_SYSCON->SYSPLLCLKSEL = (uint32_t) src;
X	((LPC_SYSCON_T *) 0x40000000UL)->SYSPLLCLKSEL = (uint32_t) src;
N}
N
N/**
N * @brief	Return System PLL input clock rate
N * @return	System PLL input clock rate
N */
Nuint32_t Chip_Clock_GetSystemPLLInClockRate(void);
N
N/**
N * @brief	Return System PLL output clock rate
N * @param	recompute	: Forces a PLL rate recomputation if true
N * @return	System PLL output clock rate
N * @note	The PLL rate is cached in the driver in a variable as
N * the rate computation function can take some time to perform. It
N * is recommended to use 'false' with the 'recompute' parameter.
N */
Nuint32_t Chip_Clock_GetSystemPLLOutClockRate(bool recompute);
Xuint32_t Chip_Clock_GetSystemPLLOutClockRate(_Bool recompute);
N
N/**
N * @brief	Enables and disables PLL bypass mode
N * @brief	bypass	: true to bypass PLL (PLL output = PLL input, false to disable bypass
N * @return	System PLL output clock rate
N */
Nvoid Chip_Clock_SetBypassPLL(bool bypass);
Xvoid Chip_Clock_SetBypassPLL(_Bool bypass);
N
N/**
N * @brief	Check if PLL is locked or not
N * @return	true if the PLL is locked, false if not locked
N */
N__STATIC_INLINE bool Chip_Clock_IsSystemPLLLocked(void)
Xstatic __inline _Bool Chip_Clock_IsSystemPLLLocked(void)
N{
N	return (bool) ((LPC_SYSCON->SYSPLLSTAT & 1) != 0);
X	return (_Bool) ((((LPC_SYSCON_T *) 0x40000000UL)->SYSPLLSTAT & 1) != 0);
N}
N
N/**
N * @brief	Get the rate of pll from the stored value
N * @return	Current rate of the PLL from the storage
N **/
Nuint32_t Chip_Clock_GetStoredPLLClockRate(void);
N
N/**
N * @brief Store the current PLL rate
N * @param	rate: Current rate of the PLL
N * @return	Nothing
N **/
Nvoid Chip_Clock_SetStoredPLLClockRate(uint32_t rate);
N
N
N/** @brief PLL configuration structure flags for 'flags' field
N * These flags control how the PLL configuration function sets up the PLL setup structure.<br>
N *
N * When the PLL_CONFIGFLAG_USEINRATE flag is selected, the 'InputRate' field in the
N * configuration structure must be assigned with the expected PLL frequency. If the
N * PLL_CONFIGFLAG_USEINRATE is not used, 'InputRate' is ignored in the configuration
N * function and the driver will determine the PLL rate from the currently selected
N * PLL source. This flag might be used to configure the PLL input clock more accurately
N * when using the WDT oscillator or a more dyanmic CLKIN source.<br>
N *
N * When the PLL_CONFIGFLAG_FORCENOFRACT flag is selected, the PLL hardware for the
N * automatic bandwidth selection, Spread Spectrum (SS) support, and fractional M-divider
N * are not used.<br>
N */
N#define PLL_CONFIGFLAG_USEINRATE    (1 << 0)	/*!< Flag to use InputRate in PLL configuration structure for setup */
N#define PLL_CONFIGFLAG_FORCENOFRACT (1 << 2)	/*!< Force non-fractional output mode, PLL output will not use the fractional, automatic bandwidth, or SS hardware */
N
N/** @brief PLL Spread Spectrum (SS) Programmable modulation frequency
N * See (MF) field in the SYSPLLSSCTRL1 register in the UM.
N */
Ntypedef enum {
N	SS_MF_512 = (0 << 20),		/*!< Nss = 512 (fm  3.9 - 7.8 kHz) */
N	SS_MF_384 = (1 << 20),		/*!< Nss = 384 (fm  5.2 - 10.4 kHz) */
N	SS_MF_256 = (2 << 20),		/*!< Nss = 256 (fm  7.8 - 15.6 kHz) */
N	SS_MF_128 = (3 << 20),		/*!< Nss = 128 (fm  15.6 - 31.3 kHz) */
N	SS_MF_64  = (4 << 20),		/*!< Nss = 64 (fm  32.3 - 64.5 kHz) */
N	SS_MF_32  = (5 << 20),		/*!< Nss = 32 (fm  62.5- 125 kHz) */
N	SS_MF_24  = (6 << 20),		/*!< Nss = 24 (fm  83.3- 166.6 kHz) */
N	SS_MF_16  = (7 << 20)		/*!< Nss = 16 (fm  125- 250 kHz) */
N} SS_PROGMODFM_T;
N
N/** @brief PLL Spread Spectrum (SS) Programmable frequency modulation depth
N * See (MR) field in the SYSPLLSSCTRL1 register in the UM.
N */
Ntypedef enum {
N	SS_MR_K0   = (0 << 23),		/*!< k = 0 (no spread spectrum) */
N	SS_MR_K1   = (1 << 23),		/*!< k = 1 */
N	SS_MR_K1_5 = (2 << 23),		/*!< k = 1.5 */
N	SS_MR_K2   = (3 << 23),		/*!< k = 2 */
N	SS_MR_K3   = (4 << 23),		/*!< k = 3 */
N	SS_MR_K4   = (5 << 23),		/*!< k = 4 */
N	SS_MR_K6   = (6 << 23),		/*!< k = 6 */
N	SS_MR_K8   = (7 << 23)		/*!< k = 8 */
N} SS_PROGMODDP_T;
N
N/** @brief PLL Spread Spectrum (SS) Modulation waveform control
N * See (MC) field in the SYSPLLSSCTRL1 register in the UM.<br>
N * Compensation for low pass filtering of the PLL to get a triangular
N * modulation at the output of the PLL, giving a flat frequency spectrum.
N */
Ntypedef enum {
N	SS_MC_NOC  = (0 << 26),		/*!< no compensation */
N	SS_MC_RECC = (2 << 26),		/*!< recommended setting */
N	SS_MC_MAXC = (3 << 26),		/*!< max. compensation */
N} SS_MODWVCTRL_T;
N
N/** @brief PLL configuration structure
N * This structure can be used to configure the settings for a PLL
N * setup structure. Fill in the desired configuration for the PLL
N * and call the PLL setup function to fill in a PLL setup structure.
N */
Ntypedef struct {
N	uint32_t        desiredRate;	/*!< Desired PLL rate in Hz */
N	uint32_t        InputRate;		/*!< PLL input clock in Hz, only used if PLL_CONFIGFLAG_USEINRATE flag is set */
N	uint32_t        flags;			/*!< PLL configuration flags, Or'ed value of PLL_CONFIGFLAG_* definitions */
N	SS_PROGMODFM_T  ss_mf;			/*!< SS Programmable modulation frequency, only applicable when not using PLL_CONFIGFLAG_FORCENOFRACT flag */
N	SS_PROGMODDP_T  ss_mr;			/*!< SS Programmable frequency modulation depth, only applicable when not using PLL_CONFIGFLAG_FORCENOFRACT flag */
N	SS_MODWVCTRL_T  ss_mc;			/*!< SS Modulation waveform control, only applicable when not using PLL_CONFIGFLAG_FORCENOFRACT flag */
N	bool            mfDither;		/*!< false for fixed modulation frequency or true for dithering, only applicable when not using PLL_CONFIGFLAG_FORCENOFRACT flag */
X	_Bool            mfDither;		 
N} PLL_CONFIG_T;
N
N/** @brief PLL setup structure flags for 'flags' field
N * These flags control how the PLL setup function sets up the PLL
N */
N#define PLL_SETUPFLAG_POWERUP       (1 << 0)	/*!< Setup will power on the PLL after setup */
N#define PLL_SETUPFLAG_WAITLOCK      (1 << 1)	/*!< Setup will wait for PLL lock, implies the PLL will be pwoered on */
N#define PLL_SETUPFLAG_ADGVOLT       (1 << 2)	/*!< Optimize system voltage for the new PLL rate */
N
N/** @brief PLL setup structure
N * This structure can be used to pre-build a PLL setup configuration
N * at run-time and quickly set the PLL to the configuration. It can be
N * populated with the PLL setup function. If powering up or waiting
N * for PLL lock, the PLL input clock source should be configured prior
N * to PLL setup.
N */
Ntypedef struct {
N	uint32_t    SYSPLLCTRL;			/*!< PLL control register */
N	uint32_t    SYSPLLNDEC;			/*!< PLL NDEC register */
N	uint32_t    SYSPLLPDEC;			/*!< PLL PDEC register */
N	uint32_t    SYSPLLSSCTRL[2];	/*!< PLL SSCTL registers */
N	uint32_t    pllRate;            /*!< Acutal PLL rate */
N	uint32_t    flags;				/*!< PLL setup flags, Or'ed value of PLL_SETUPFLAG_* definitions */
N} PLL_SETUP_T;
N
N/** @brief PLL status definitions
N */
Ntypedef enum {
N	PLL_ERROR_SUCCESS = 0,			/*!< PLL operation was successful */
N	PLL_ERROR_OUTPUT_TOO_LOW,		/*!< PLL output rate request was too low */
N	PLL_ERROR_OUTPUT_TOO_HIGH,		/*!< PLL output rate request was too high */
N	PLL_ERROR_INPUT_TOO_LOW,		/*!< PLL input rate is too low */
N	PLL_ERROR_INPUT_TOO_HIGH,		/*!< PLL input rate is too high */
N	PLL_ERROR_OUTSIDE_INTLIMIT		/*!< Requested output rate isn't possible */
N} PLL_ERROR_T;
N
N/**
N * @brief	Return System PLL output clock rate from setup structure
N * @param	pSetup	: Pointer to a PLL setup structure
N * @return	System PLL output clock rate the setup structure will generate
N */
Nuint32_t Chip_Clock_GetSystemPLLOutFromSetup(PLL_SETUP_T *pSetup);
N
N/**
N * @brief	Set PLL output based on the passed PLL setup data
N * @param	pControl	: Pointer to populated PLL control structure to generate setup with
N * @param	pSetup		: Pointer to PLL setup structure to be filled
N * @return	PLL_ERROR_SUCCESS on success, or PLL setup error code
N * @note	Actual frequency for setup may vary from the desired frequency based on the
N * accuracy of input clocks, rounding, non-fractional PLL mode, etc.
N */
NPLL_ERROR_T Chip_Clock_SetupPLLData(PLL_CONFIG_T *pControl, PLL_SETUP_T *pSetup);
N
N/**
N * @brief	Set PLL output from PLL setup structure (precise frequency)
N * @param	pSetup	: Pointer to populated PLL setup structure
N * @return	PLL_ERROR_SUCCESS on success, or PLL setup error code
N * @note	This function will power off the PLL, setup the PLL with the
N * new setup data, and then optionally powerup the PLL, wait for PLL lock,
N * and adjust system voltages to the new PLL rate. The function will not
N * alter any source clocks (ie, main systen clock) that may use the PLL,
N * so these should be setup prior to and after exiting the function.
N */
NPLL_ERROR_T Chip_Clock_SetupSystemPLLPrec(PLL_SETUP_T *pSetup);
N
N/**
N * @brief	Set PLL output from PLL setup structure (precise frequency)
N * @param	pSetup	: Pointer to populated PLL setup structure
N * @return	PLL_ERROR_SUCCESS on success, or PLL setup error code
N * @note	This function will power off the PLL, setup the PLL with the
N * new setup data, and then optionally powerup the PLL, wait for PLL lock,
N * and adjust system voltages to the new PLL rate. The function will not
N * alter any source clocks (ie, main systen clock) that may use the PLL,
N * so these should be setup prior to and after exiting the function.
N */
NPLL_ERROR_T Chip_Clock_SetPLLFreq(const PLL_SETUP_T *pSetup);
N
N/**
N * @brief	Set PLL output based on the multiplier and input frequency
N * @param	multiply_by	: multiplier
N * @param	input_freq	: Clock input frequency of the PLL
N * @return	Nothing
N * @note	Unlike the Chip_Clock_SetupSystemPLLPrec() function, this
N * function does not disable or enable PLL power, wait for PLL lock,
N * or adjust system voltages. These must be done in the application.
N * The function will not alter any source clocks (ie, main systen clock)
N * that may use the PLL, so these should be setup prior to and after
N * exiting the function.
N */
Nvoid Chip_Clock_SetupSystemPLL(uint32_t multiply_by, uint32_t input_freq);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __PLL_5411X_H_ */
L 36 "..\..\..\chip_5411x\inc\clock_5411x.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup CLOCK_5411X CHIP: LPC5411X Clock Driver
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/* Internal oscillator frequency */
N#define SYSCON_FRO12MHZ_FREQ     (12000000)
N#define SYSCON_FRO48MHZ_FREQ     (48000000)
N#define SYSCON_FRO96MHZ_FREQ     (96000000)
N#define SYSCON_WDTOSC_FREQ       (500000)
N#define SYSCON_RTC_FREQ          (32768)
N
N
N#define Chip_Clock_GetIntOscRate()      SYSCON_FRO12MHZ_FREQ
N
N/**
N * @brief	Returns the external clock input rate
N * @return	External clock input rate
N */
N__STATIC_INLINE uint32_t Chip_Clock_GetExtClockInRate(void)
Xstatic __inline uint32_t Chip_Clock_GetExtClockInRate(void)
N{
N	return ExtClockIn;
N}
N
N/**
N * @brief	Returns the RTC clock rate
N * @return	RTC oscillator clock rate in Hz
N */
N__STATIC_INLINE uint32_t Chip_Clock_GetRTCOscRate(void)
Xstatic __inline uint32_t Chip_Clock_GetRTCOscRate(void)
N{
N	return SYSCON_RTC_FREQ;
X	return (32768);
N}
N
N/** @brief	WDT Osc frequency value table */
Ntypedef enum {
N	WDT_FREQ_RESERVED, /*!< Reserved value */
N	WDT_FREQ_400000,   /*!< WDT Freq 400 KHz */
N	WDT_FREQ_600000,   /*!< WDT Freq 600 KHz */
N	WDT_FREQ_750000,   /*!< WDT Freq 750 KHz */
N	WDT_FREQ_900000,   /*!< WDT Freq 900 KHz */
N	WDT_FREQ_1000000,  /*!< WDT Freq 1.0 MHz */
N	WDT_FREQ_1200000,  /*!< WDT Freq 1.2 MHz */
N	WDT_FREQ_1300000,  /*!< WDT Freq 1.3 MHz */
N	WDT_FREQ_1400000,  /*!< WDT Freq 1.4 MHz */
N	WDT_FREQ_1500000,  /*!< WDT Freq 1.5 MHz */
N	WDT_FREQ_1600000,  /*!< WDT Freq 1.6 MHz */
N	WDT_FREQ_1700000,  /*!< WDT Freq 1.7 MHz */
N	WDT_FREQ_1800000,  /*!< WDT Freq 1.8 MHz */
N	WDT_FREQ_1900000,  /*!< WDT Freq 1.9 MHz */
N	WDT_FREQ_2000000,  /*!< WDT Freq 2.0 MHz */
N	WDT_FREQ_2050000,  /*!< WDT Freq 2.05 MHz */
N	WDT_FREQ_2100000,  /*!< WDT Freq 2.1 MHz */
N	WDT_FREQ_2200000,  /*!< WDT Freq 2.2 MHz */
N	WDT_FREQ_2250000,  /*!< WDT Freq 2.25 MHz */
N	WDT_FREQ_2300000,  /*!< WDT Freq 2.3 MHz */
N	WDT_FREQ_2400000,  /*!< WDT Freq 2.4 MHz */
N	WDT_FREQ_2450000,  /*!< WDT Freq 2.45 MHz */
N	WDT_FREQ_2500000,  /*!< WDT Freq 2.5 MHz */
N	WDT_FREQ_2600000,  /*!< WDT Freq 2.6 MHz */
N	WDT_FREQ_2650000,  /*!< WDT Freq 2.65 MHz */
N	WDT_FREQ_2700000,  /*!< WDT Freq 2.7 MHz */
N	WDT_FREQ_2800000,  /*!< WDT Freq 2.8 MHz */
N	WDT_FREQ_2850000,  /*!< WDT Freq 2.85 MHz */
N	WDT_FREQ_2900000,  /*!< WDT Freq 2.9 MHz */
N	WDT_FREQ_2950000,  /*!< WDT Freq 2.95 MHz */
N	WDT_FREQ_3000000,  /*!< WDT Freq 3.0 MHz */
N	WDT_FREQ_3050000,  /*!< WDT Freq 3.05 MHz */
N} WDT_OSC_FREQ_T;
N
N/**
N * @brief	Set the WDT Oscillator frequency and divider
N * @param	freq	: WDT OSC Frequency to set [See #WDT_OSC_FREQ_T]
N * @param	div		: Divider value [Valid values are 2, 4, 6, 8 ... 64]
N * @return	Nothing
N * @note	The actual frequency of the WDT Oscillator can be +/- 40% of
N * frequency set in @a freq.
N */
N__STATIC_INLINE void Chip_Clock_SetWDTOSCRate(WDT_OSC_FREQ_T freq, uint32_t div)
Xstatic __inline void Chip_Clock_SetWDTOSCRate(WDT_OSC_FREQ_T freq, uint32_t div)
N{
N	LPC_SYSCON->WDTOSCCTRL = (freq << 5) | (((div >> 1) - 1) & 0x1F);
X	((LPC_SYSCON_T *) 0x40000000UL)->WDTOSCCTRL = (freq << 5) | (((div >> 1) - 1) & 0x1F);
N}
N
N/**
N * @brief	Return estimated watchdog oscillator rate
N * @return	Estimated watchdog oscillator rate
N * @note	This rate is accurate to plus or minus 40%.
N */
Nuint32_t Chip_Clock_GetWDTOSCRate(void);
N
N/**
N * Clock source selections for only the main A system clock. The main A system
N * clock is used as an input into the main B system clock selector. Main clock A
N * only needs to be setup if the main clock A input is used in the main clock
N * system selector.
N */
Ntypedef enum {
N	SYSCON_MAIN_A_CLKSRC_FRO12MHZ = 0,  /*!< 12MHz FRO */
N	SYSCON_MAIN_A_CLKSRCA_CLKIN,        /*!< Crystal (main) oscillator in */
N	SYSCON_MAIN_A_CLKSRCA_WDTOSC,       /*!< Watchdog oscillator rate */
N	SYSCON_MAIN_A_CLKSRCA_FROHF,        /*!< 48MHz or 96MHz HF-FRO */
N} CHIP_SYSCON_MAIN_A_CLKSRC_T;
N
N/**
N * @brief	Gets the HF-FRO Frequency rate
N * @return	Nothing
N */
N__STATIC_INLINE uint32_t Chip_Clock_GetFROHFRate(void)
Xstatic __inline uint32_t Chip_Clock_GetFROHFRate(void)
N{
N	if (LPC_SYSCON->FROCTRL & SYSCON_FROCTRL_SEL96MHZ) {
X	if (((LPC_SYSCON_T *) 0x40000000UL)->FROCTRL & (1UL << 14)) {
N		return SYSCON_FRO96MHZ_FREQ;
X		return (96000000);
N	} else {
N		return SYSCON_FRO48MHZ_FREQ;
X		return (48000000);
N	}
N}
N
N/**
N * @brief	Set main A system clock source
N * @param	src	: Clock source for main A
N * @return	Nothing
N * @note	This function only needs to be setup if main clock A will be
N * selected in the Chip_Clock_GetMain_B_ClockRate() function.
N */
N__STATIC_INLINE void Chip_Clock_SetMain_A_ClockSource(CHIP_SYSCON_MAIN_A_CLKSRC_T src)
Xstatic __inline void Chip_Clock_SetMain_A_ClockSource(CHIP_SYSCON_MAIN_A_CLKSRC_T src)
N{
N	LPC_SYSCON->MAINCLKSELA = (uint32_t) src;
X	((LPC_SYSCON_T *) 0x40000000UL)->MAINCLKSELA = (uint32_t) src;
N}
N
N/**
N * @brief	USB Clock source
N */
Ntypedef enum {
N	SYSCON_USBCLKSRC_FROHF,           /**< High frequency FRO 48MHz or 96MHz */
N	SYSCON_USBCLKSRC_PLL,             /**< USB PLL */
N	SYSCON_USBCLKSRC_DISABLED = 7     /**< USB Clock disabled */
N} CHIP_SYSCON_USBCLKSRC_T;
N
N/**
N * @brief	Set USB clock source
N * @param	src	: Clock source for USB (See #CHIP_SYSCON_USBCLKSRC_T)
N * @param	div	: Value by which the clock must be divided (valid range: 1 - 256)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_Clock_SetUSBClockSource(CHIP_SYSCON_USBCLKSRC_T src, uint32_t div)
Xstatic __inline void Chip_Clock_SetUSBClockSource(CHIP_SYSCON_USBCLKSRC_T src, uint32_t div)
N{
N	LPC_SYSCON->USBCLKSEL = src;
X	((LPC_SYSCON_T *) 0x40000000UL)->USBCLKSEL = src;
N	// FIXME: Find the use for HALT and other bits
N	LPC_SYSCON->USBCLKDIV = (div - 1) & 0xFF;
X	((LPC_SYSCON_T *) 0x40000000UL)->USBCLKDIV = (div - 1) & 0xFF;
N}
N
N/**
N * @brief   Gets the clock source used by USB
N * @return	Returns which clock is used for USB
N */
N__STATIC_INLINE CHIP_SYSCON_USBCLKSRC_T Chip_Clock_GetUSBClockSource(void)
Xstatic __inline CHIP_SYSCON_USBCLKSRC_T Chip_Clock_GetUSBClockSource(void)
N{
N	return (CHIP_SYSCON_USBCLKSRC_T) (LPC_SYSCON->USBCLKSEL & 0x07);
X	return (CHIP_SYSCON_USBCLKSRC_T) (((LPC_SYSCON_T *) 0x40000000UL)->USBCLKSEL & 0x07);
N}
N
N/**
N * @brief   Gets the clock divider used by USB
N * @return	Returns clock divider used by USB
N */
N__STATIC_INLINE uint32_t Chip_Clock_GetUSBClockDiv(void)
Xstatic __inline uint32_t Chip_Clock_GetUSBClockDiv(void)
N{
N	return (LPC_SYSCON->USBCLKDIV & 0xFF)+1;
X	return (((LPC_SYSCON_T *) 0x40000000UL)->USBCLKDIV & 0xFF)+1;
N}
N
N/**
N * @brief	MCLK Clock sources
N */
Ntypedef enum {
N	SYSCON_MCLKSRC_FROHF,             /*!< HF-FRO 48MHz or 96MHz */
N	SYSCON_MCLKSRC_PLL,               /*!< Main pll */
N	SYSCON_MCLKSRC_MCLKIN,            /*!< MCLK INPUT Clock pin set by IOCON */
N	SYSCON_MCLKSRC_DISABLED = 7       /*!< Disable clock source to MCLK */
N} CHIP_SYSCON_MCLKSRC_T;
N
N/**
N * @brief	Set the MCLK clock source
N * @param	src: Clock Source for MCLK (see #CHIP_SYSCON_MCLKSRC_T)
N * @param	div: Value by which the source clock rate be divided (must be greater than 0)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_Clock_SetMCLKClockSource(CHIP_SYSCON_MCLKSRC_T src, uint32_t div)
Xstatic __inline void Chip_Clock_SetMCLKClockSource(CHIP_SYSCON_MCLKSRC_T src, uint32_t div)
N{
N	LPC_SYSCON->MCLKCLKSEL  = (uint32_t) src;
X	((LPC_SYSCON_T *) 0x40000000UL)->MCLKCLKSEL  = (uint32_t) src;
N	LPC_SYSCON->MCLKDIV     = (uint32_t) ((div-1) & 0xff);
X	((LPC_SYSCON_T *) 0x40000000UL)->MCLKDIV     = (uint32_t) ((div-1) & 0xff);
N}
N
N/**
N * @brief	Get MCLK clock div
N * @return	MCLK divider
N */
N__STATIC_INLINE uint32_t Chip_Clock_GetMCLKDiv(void)
Xstatic __inline uint32_t Chip_Clock_GetMCLKDiv(void)
N{
N	return (LPC_SYSCON->MCLKDIV & 0xff) + 1;
X	return (((LPC_SYSCON_T *) 0x40000000UL)->MCLKDIV & 0xff) + 1;
N}
N
N/**
N * @brief	Get MCLK clock source
N * @return	MCLK clock source
N */
N__STATIC_INLINE CHIP_SYSCON_MCLKSRC_T Chip_Clock_GetMCLKSource(void)
Xstatic __inline CHIP_SYSCON_MCLKSRC_T Chip_Clock_GetMCLKSource(void)
N{
N	return (CHIP_SYSCON_MCLKSRC_T) (LPC_SYSCON->MCLKCLKSEL & 0x07);
X	return (CHIP_SYSCON_MCLKSRC_T) (((LPC_SYSCON_T *) 0x40000000UL)->MCLKCLKSEL & 0x07);
N}
N
N/**
N * @brief	Set MCLK pin direction to INPUT
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_Clock_SetMCLKDirInput(void)
Xstatic __inline void Chip_Clock_SetMCLKDirInput(void)
N{
N	LPC_SYSCON->MCLKIO = 0;
X	((LPC_SYSCON_T *) 0x40000000UL)->MCLKIO = 0;
N}
N
N/**
N * @brief	Set MCLK pin direction to OUTPUT
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_Clock_SetMCLKDirOutput(void)
Xstatic __inline void Chip_Clock_SetMCLKDirOutput(void)
N{
N	LPC_SYSCON->MCLKIO = 1;
X	((LPC_SYSCON_T *) 0x40000000UL)->MCLKIO = 1;
N}
N
N/**
N * @brief	Set MCLK pin direction to INPUT or OUTPUT
N * @param	dir	:	0 => INPUT, anything else => OUTPUT
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_Clock_SetMCLKDir(int dir)
Xstatic __inline void Chip_Clock_SetMCLKDir(int dir)
N{
N	if (dir == 0) {
N		Chip_Clock_SetMCLKDirInput();
N	} else {
N		Chip_Clock_SetMCLKDirOutput();
N	}
N}
N
N__STATIC_INLINE int Chip_Clock_GetMCLKDir(void)
Xstatic __inline int Chip_Clock_GetMCLKDir(void)
N{
N	return (LPC_SYSCON->MCLKIO & 1);
X	return (((LPC_SYSCON_T *) 0x40000000UL)->MCLKIO & 1);
N}
N
N/**
N * @brief   Returns the main A clock source
N * @return	Returns which clock is used for the main A
N */
N__STATIC_INLINE CHIP_SYSCON_MAIN_A_CLKSRC_T Chip_Clock_GetMain_A_ClockSource(void)
Xstatic __inline CHIP_SYSCON_MAIN_A_CLKSRC_T Chip_Clock_GetMain_A_ClockSource(void)
N{
N	return (CHIP_SYSCON_MAIN_A_CLKSRC_T) (LPC_SYSCON->MAINCLKSELA & 0x3);
X	return (CHIP_SYSCON_MAIN_A_CLKSRC_T) (((LPC_SYSCON_T *) 0x40000000UL)->MAINCLKSELA & 0x3);
N}
N
N/**
N * @brief	Return main A clock rate
N * @return	main A clock rate in Hz
N */
Nuint32_t Chip_Clock_GetMain_A_ClockRate(void);
N
N/**
N * Clock sources for only main B system clock
N */
Ntypedef enum {
N	SYSCON_MAIN_B_CLKSRC_MAINCLKSELA = 0,   /*!< main clock A */
N	SYSCON_MAIN_B_CLKSRC_PLL = 2,           /*!< System PLL output */
N	SYSCON_MAIN_B_CLKSRC_RTC,               /*!< RTC oscillator 32KHz output */
N} CHIP_SYSCON_MAIN_B_CLKSRC_T;
N
N/**
N * @brief	Set main B system clock source
N * @param	src	: Clock source for main B
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_Clock_SetMain_B_ClockSource(CHIP_SYSCON_MAIN_B_CLKSRC_T src)
Xstatic __inline void Chip_Clock_SetMain_B_ClockSource(CHIP_SYSCON_MAIN_B_CLKSRC_T src)
N{
N	LPC_SYSCON->MAINCLKSELB = (uint32_t) src;
X	((LPC_SYSCON_T *) 0x40000000UL)->MAINCLKSELB = (uint32_t) src;
N}
N
N/**
N * @brief   Returns the main B clock source
N * @return	Returns which clock is used for the main B
N */
N__STATIC_INLINE CHIP_SYSCON_MAIN_B_CLKSRC_T Chip_Clock_GetMain_B_ClockSource(void)
Xstatic __inline CHIP_SYSCON_MAIN_B_CLKSRC_T Chip_Clock_GetMain_B_ClockSource(void)
N{
N	return (CHIP_SYSCON_MAIN_B_CLKSRC_T) (LPC_SYSCON->MAINCLKSELB);
X	return (CHIP_SYSCON_MAIN_B_CLKSRC_T) (((LPC_SYSCON_T *) 0x40000000UL)->MAINCLKSELB);
N}
N
N/**
N * @brief	Return main B clock rate
N * @return	main B clock rate
N */
Nuint32_t Chip_Clock_GetMain_B_ClockRate(void);
N
N/**
N * Clock sources for CLKOUT
N */
Ntypedef enum {
N	SYSCON_CLKOUTSRC_MAINCLK = 0,       /*!< Main system clock for CLKOUT */
N	SYSCON_CLKOUTSRC_CLKIN,             /*!< CLKIN for CLKOUT */
N	SYSCON_CLKOUTSRC_WDTOSC,            /*!< Watchdog oscillator for CLKOUT */
N	SYSCON_CLKOUTSRC_FROHF,             /*!< 48MHz or 96MHz FRO */
N	SYSCON_CLKOUTSRC_PLL,               /*!< Output of the PLL */
N	SYSCON_CLKOUTSRC_FRO12MHZ,          /*!< 12MHz FRO */
N	SYSCON_CLKOUTSRC_RTC,               /*!< RTC oscillator 32KHz for CLKOUT */
N	SYSCON_CLKOUTSRC_DISABLED           /*!< Disable clock source for CLKOUT */
N} CHIP_SYSCON_CLKOUTSRC_T;
N
N/**
N * @brief	Set CLKOUT clock source and divider
N * @param	src	: Clock source for CLKOUT (see #CHIP_SYSCON_CLKOUTSRC_T)
N * @param	div	: divider for CLKOUT clock [Valid range 1 to 256]
N * @return	Nothing
N * @note	The CLKOUT clock rate is the clock source divided by the divider.
N */
N__STATIC_INLINE void Chip_Clock_SetCLKOUTSource(CHIP_SYSCON_CLKOUTSRC_T src, uint32_t div)
Xstatic __inline void Chip_Clock_SetCLKOUTSource(CHIP_SYSCON_CLKOUTSRC_T src, uint32_t div)
N{
N	LPC_SYSCON->CLKOUTSELA = (uint32_t) src & 0x07;
X	((LPC_SYSCON_T *) 0x40000000UL)->CLKOUTSELA = (uint32_t) src & 0x07;
N	if (div)
N		LPC_SYSCON->CLKOUTDIV = (div - 1);
X		((LPC_SYSCON_T *) 0x40000000UL)->CLKOUTDIV = (div - 1);
N}
N
N/**
N * @brief	Get CLKOUT clock source
N * @return	Clock output source
N */
N__STATIC_INLINE CHIP_SYSCON_CLKOUTSRC_T Chip_Clock_GetCLKOUTSource(void)
Xstatic __inline CHIP_SYSCON_CLKOUTSRC_T Chip_Clock_GetCLKOUTSource(void)
N{
N	return (CHIP_SYSCON_CLKOUTSRC_T)(LPC_SYSCON->CLKOUTSELA & 0x07);
X	return (CHIP_SYSCON_CLKOUTSRC_T)(((LPC_SYSCON_T *) 0x40000000UL)->CLKOUTSELA & 0x07);
N}
N
N/**
N * @brief	Get CLKOUT clock divider
N * @return	Clock output source
N */
N__STATIC_INLINE uint32_t Chip_Clock_GetCLKOUTDiv(void)
Xstatic __inline uint32_t Chip_Clock_GetCLKOUTDiv(void)
N{
N	return ((LPC_SYSCON->CLKOUTDIV&0xff)+1);
X	return ((((LPC_SYSCON_T *) 0x40000000UL)->CLKOUTDIV&0xff)+1);
N}
N
N/**
N * System and peripheral clocks enum
N */
Ntypedef enum CHIP_SYSCON_CLOCK {
N	/* Peripheral clock enables for SYSAHBCLKCTRL0 */
N	SYSCON_CLOCK_ROM = 1,               /*!< ROM clock */
N	SYSCON_CLOCK_SRAM1 = 3,             /*!< SRAM1 clock */
N	SYSCON_CLOCK_SRAM2,                 /*!< SRAM2 clock */
N	SYSCON_CLOCK_SRAMX,                 /*!< SRAMX Clock */
N	SYSCON_CLOCK_FLASH = 7,             /*!< FLASH controller clock */
N	SYSCON_CLOCK_FMC,                   /*!< FMC clock */
N	SYSCON_CLOCK_SPIFI = 10,            /*!< SPIFI Clock */
N	SYSCON_CLOCK_INPUTMUX,              /*!< Input mux clock */
N	SYSCON_CLOCK_IOCON = 13,            /*!< IOCON clock */
N	SYSCON_CLOCK_GPIO0,                 /*!< GPIO0 clock */
N	SYSCON_CLOCK_GPIO1,                 /*!< GPIO1 clock */
N	SYSCON_CLOCK_PINT = 18,             /*!< PININT clock */
N	SYSCON_CLOCK_GINT,                  /*!< grouped pin interrupt block clock */
N	SYSCON_CLOCK_DMA,                   /*!< DMA clock */
N	SYSCON_CLOCK_CRC,                   /*!< CRC clock */
N	SYSCON_CLOCK_WWDT,                  /*!< WDT clock */
N	SYSCON_CLOCK_RTC,                   /*!< RTC clock */
N	SYSCON_CLOCK_MAILBOX = 26,          /*!< Mailbox clock */
N	SYSCON_CLOCK_ADC0,                  /*!< ADC0 clock */
N
N	/* Peripheral clock enables for SYSAHBCLKCTRL1 */
N	SYSCON_CLOCK_MRT = 32,              /*!< multi-rate timer clock */
N	SYSCON_CLOCK_SCT0 = 32 + 2,         /*!< SCT0 clock */
N	SYSCON_CLOCK_UTICK = 32 + 10,       /*!< UTICK clock */
N	SYSCON_CLOCK_FLEXCOMM0,             /*!< FLEXCOMM0 Clock */
N	SYSCON_CLOCK_FLEXCOMM1,             /*!< FLEXCOMM1 Clock */
N	SYSCON_CLOCK_FLEXCOMM2,             /*!< FLEXCOMM2 Clock */
N	SYSCON_CLOCK_FLEXCOMM3,             /*!< FLEXCOMM3 Clock */
N	SYSCON_CLOCK_FLEXCOMM4,             /*!< FLEXCOMM4 Clock */
N	SYSCON_CLOCK_FLEXCOMM5,             /*!< FLEXCOMM5 Clock */
N	SYSCON_CLOCK_FLEXCOMM6,             /*!< FLEXCOMM6 Clock */
N	SYSCON_CLOCK_FLEXCOMM7,             /*!< FLEXCOMM7 Clock */
N	SYSCON_CLOCK_DMIC,                  /*!< D-MIC Clock */
N	SYSCON_CLOCK_TIMER2 = 32 + 22,      /*!< TIMER2 clock */
N	SYSCON_CLOCK_USB = 32 + 25,         /*!< USB clock */
N	SYSCON_CLOCK_TIMER0,                /*!< TIMER0 clock */
N	SYSCON_CLOCK_TIMER1,                /*!< TIMER1 Clock */
N
N	/* Peripheral clock enables for ASYNCAPBCLKCTRLCLR */
N	SYSCON_CLOCK_TIMER3 = 128 + 13,     /*!< TIMER3 clock */
N	SYSCON_CLOCK_TIMER4,                /*!< TIMER4 clock */
N} CHIP_SYSCON_CLOCK_T;
N
N/**
N * @brief	Enable a system or peripheral clock
N * @param	clk	: Clock to enable
N * @return	Nothing
N */
Nvoid Chip_Clock_EnablePeriphClock(CHIP_SYSCON_CLOCK_T clk);
N
N/**
N * @brief	Disable a system or peripheral clock
N * @param	clk	: Clock to disable
N * @return	Nothing
N */
Nvoid Chip_Clock_DisablePeriphClock(CHIP_SYSCON_CLOCK_T clk);
N
N/**
N * @brief	Set system tick clock divider (external CLKIN as SYSTICK reference only)
N * @param	div	: divider for system clock
N * @return	Nothing
N * @note	Use 0 to disable, or a divider value of 1 to 255. The system tick
N * rate is the external CLKIN rate divided by this value. The extern CLKIN pin
N * signal, divided by the SYSTICKCLKDIV divider, is selected by clearing
N * CLKSOURCE bit 2 in the System Tick CSR register. The core clock must be at least
N * 2.5 times faster than the reference system tick clock otherwise the count
N * values are unpredictable.
N */
N__STATIC_INLINE void Chip_Clock_SetSysTickClockDiv(uint32_t div)
Xstatic __inline void Chip_Clock_SetSysTickClockDiv(uint32_t div)
N{
N	LPC_SYSCON->SYSTICKCLKDIV = div;
X	((LPC_SYSCON_T *) 0x40000000UL)->SYSTICKCLKDIV = div;
N}
N
N/**
N * @brief	Returns system tick clock divider
N * @return	system tick clock divider
N */
N__STATIC_INLINE uint32_t Chip_Clock_GetSysTickClockDiv(void)
Xstatic __inline uint32_t Chip_Clock_GetSysTickClockDiv(void)
N{
N	return (LPC_SYSCON->SYSTICKCLKDIV & 0xff);
X	return (((LPC_SYSCON_T *) 0x40000000UL)->SYSTICKCLKDIV & 0xff);
N}
N
N/**
N * @brief	Returns the system tick rate as used with the system tick divider
N * @return	the system tick rate
N */
Nuint32_t Chip_Clock_GetSysTickClockRate(void);
N
N/**
N * @brief	Set system clock divider
N * @param	div	: divider for system clock
N * @return	Nothing
N * @note	Use a divider value of 1 to 255. The system clock
N * rate is the main system clock divided by this value.
N */
N__STATIC_INLINE void Chip_Clock_SetSysClockDiv(uint32_t div)
Xstatic __inline void Chip_Clock_SetSysClockDiv(uint32_t div)
N{
N	LPC_SYSCON->AHBCLKDIV = (div - 1);
X	((LPC_SYSCON_T *) 0x40000000UL)->AHBCLKDIV = (div - 1);
N}
N
N/**
N * @brief	Get system clock divider
N * @param	None
N * @return	System clock divider
N */
N__STATIC_INLINE uint32_t Chip_Clock_GetSysClockDiv(void)
Xstatic __inline uint32_t Chip_Clock_GetSysClockDiv(void)
N{
N	return ((LPC_SYSCON->AHBCLKDIV & 0xff)+1);
X	return ((((LPC_SYSCON_T *) 0x40000000UL)->AHBCLKDIV & 0xff)+1);
N}
N
N/**
N * @brief	Set system tick clock divider
N * @param	div	: divider for system clock
N * @return	Nothing
N * @note	Use 0 to disable, or a divider value of 1 to 255. The system tick
N * rate is the main system clock divided by this value. Use caution when using
N * the CMSIS SysTick_Config() functions as they typically use SystemCoreClock
N * for setup.
N */
N__STATIC_INLINE void Chip_Clock_SetADCClockDiv(uint32_t div)
Xstatic __inline void Chip_Clock_SetADCClockDiv(uint32_t div)
N{
N	/* FIXME : Need to find the usage for HALT/RESET and other bits */
N	LPC_SYSCON->ADCCLKDIV = (div & 0xFF);
X	((LPC_SYSCON_T *) 0x40000000UL)->ADCCLKDIV = (div & 0xFF);
N}
N
N/**
N * @brief	Returns ADC clock divider
N * @return	ADC clock divider, 0 = disabled
N */
N__STATIC_INLINE uint32_t Chip_Clock_GetADCClockDiv(void)
Xstatic __inline uint32_t Chip_Clock_GetADCClockDiv(void)
N{
N	return (LPC_SYSCON->ADCCLKDIV & 0xFF);
X	return (((LPC_SYSCON_T *) 0x40000000UL)->ADCCLKDIV & 0xFF);
N}
N
N/**
N * Clock sources for FLEXCOMM clock source select
N */
Ntypedef enum {
N	SYSCON_FLEXCOMMCLKSELSRC_FRO12MHZ = 0,		/*!< FRO 12-MHz */
N	SYSCON_FLEXCOMMCLKSELSRC_FROHF,             /*!< HF-FRO 48-MHz or 96-MHz */
N	SYSCON_FLEXCOMMCLKSELSRC_PLL,               /*!< PLL output */
N	SYSCON_FLEXCOMMCLKSELSRC_MCLK,              /*!< MCLK output */
N	SYSCON_FLEXCOMMCLKSELSRC_FRG,               /*!< FRG output */
N	SYSCON_FLEXCOMMCLKSELSRC_NONE = 7           /*!< NONE output */
N} CHIP_SYSCON_FLEXCOMMCLKSELSRC_T;
N
N/**
N * @brief	Set the FLEXCOMM clock source
N * @param	idx	: Index of the flexcomm (0 to 7)
N * @param	src	: FLEXCOMM clock source (See #CHIP_SYSCON_FLEXCOMMCLKSELSRC_T)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_Clock_SetFLEXCOMMClockSource(uint32_t idx, CHIP_SYSCON_FLEXCOMMCLKSELSRC_T src)
Xstatic __inline void Chip_Clock_SetFLEXCOMMClockSource(uint32_t idx, CHIP_SYSCON_FLEXCOMMCLKSELSRC_T src)
N{
N	LPC_SYSCON->FXCOMCLKSEL[idx] = (uint32_t) src;
X	((LPC_SYSCON_T *) 0x40000000UL)->FXCOMCLKSEL[idx] = (uint32_t) src;
N}
N
N/**
N * @brief   Returns the FLEXCOMM clock source
N * @param	idx	: Index of the flexcomm (0 to 7)
N * @return	Returns which clock is used for the FLEXCOMM clock source
N */
N__STATIC_INLINE CHIP_SYSCON_FLEXCOMMCLKSELSRC_T Chip_Clock_GetFLEXCOMMClockSource(uint32_t idx)
Xstatic __inline CHIP_SYSCON_FLEXCOMMCLKSELSRC_T Chip_Clock_GetFLEXCOMMClockSource(uint32_t idx)
N{
N	return (CHIP_SYSCON_FLEXCOMMCLKSELSRC_T) (LPC_SYSCON->FXCOMCLKSEL[idx] & 0x07);
X	return (CHIP_SYSCON_FLEXCOMMCLKSELSRC_T) (((LPC_SYSCON_T *) 0x40000000UL)->FXCOMCLKSEL[idx] & 0x07);
N}
N
N/**
N * @brief	Return FlexCOMM clock rate
N * @param	id	: FlexCOMM ID (Valid range: 0 to 7)
N * @return	FlexCOMM clock rate
N */
Nuint32_t Chip_Clock_GetFLEXCOMMClockRate(uint32_t id);
N
N/**
N * Clock sources for ADC clock source select
N */
Ntypedef enum {
N	SYSCON_ADCCLKSELSRC_MAINCLK = 0,        /*!< Main clock */
N	SYSCON_ADCCLKSELSRC_SYSPLLOUT,          /*!< PLL output */
N	SYSCON_ADCCLKSELSRC_FROHF               /*!< High frequency FRO 48MHz or 96MHz */
N} CHIP_SYSCON_ADCCLKSELSRC_T;
N
N/**
N * @brief	Set the ADC clock source
N * @param	src	: ADC clock source
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_Clock_SetADCClockSource(CHIP_SYSCON_ADCCLKSELSRC_T src)
Xstatic __inline void Chip_Clock_SetADCClockSource(CHIP_SYSCON_ADCCLKSELSRC_T src)
N{
N	LPC_SYSCON->ADCCLKSEL = (uint32_t) src;
X	((LPC_SYSCON_T *) 0x40000000UL)->ADCCLKSEL = (uint32_t) src;
N}
N
N/**
N * @brief   Returns the ADC clock source
N * @return	Returns which clock is used for the ADC clock source
N */
N__STATIC_INLINE CHIP_SYSCON_ADCCLKSELSRC_T Chip_Clock_GetADCClockSource(void)
Xstatic __inline CHIP_SYSCON_ADCCLKSELSRC_T Chip_Clock_GetADCClockSource(void)
N{
N	return (CHIP_SYSCON_ADCCLKSELSRC_T) (LPC_SYSCON->ADCCLKSEL & 0x07);
X	return (CHIP_SYSCON_ADCCLKSELSRC_T) (((LPC_SYSCON_T *) 0x40000000UL)->ADCCLKSEL & 0x07);
N}
N
N/**
N * @brief	Return ADC clock rate
N * @return	ADC clock rate
N */
Nuint32_t Chip_Clock_GetADCClockRate(void);
N
N/**
N * @brief	Enable the RTC 32KHz output
N * @return	Nothing
N * @note	This clock can be used for the main clock directly, but
N *			do not use this clock with the system PLL.
N */
N__STATIC_INLINE void Chip_Clock_EnableRTCOsc(void)
Xstatic __inline void Chip_Clock_EnableRTCOsc(void)
N{
N	LPC_SYSCON->RTCOSCCTRL  = 1;
X	((LPC_SYSCON_T *) 0x40000000UL)->RTCOSCCTRL  = 1;
N}
N
N/**
N * @brief	Disable the RTC 32KHz output
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_Clock_DisableRTCOsc(void)
Xstatic __inline void Chip_Clock_DisableRTCOsc(void)
N{
N	LPC_SYSCON->RTCOSCCTRL  = 0;
X	((LPC_SYSCON_T *) 0x40000000UL)->RTCOSCCTRL  = 0;
N}
N
N__STATIC_INLINE bool Chip_Clock_GetRTCOsc(void)
Xstatic __inline _Bool Chip_Clock_GetRTCOsc(void)
N{
N	return (LPC_SYSCON->RTCOSCCTRL) ? true : false;
X	return (((LPC_SYSCON_T *) 0x40000000UL)->RTCOSCCTRL) ? 1 : 0;
N}
N
N/**
N * Clock source selections for the asynchronous APB clock
N */
Ntypedef enum {
N	SYSCON_ASYNC_MAINCLK = 0,       /*!< Main System clock */
N	SYSCON_ASYNC_FRO12MHZ,			/*!< 12MHz FRO */
N} CHIP_ASYNC_SYSCON_SRC_T;
N
N/**
N * @brief	Set asynchronous APB clock source
N * @param	src	: Clock source for asynchronous APB clock
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_Clock_SetAsyncSysconClockSource(CHIP_ASYNC_SYSCON_SRC_T src)
Xstatic __inline void Chip_Clock_SetAsyncSysconClockSource(CHIP_ASYNC_SYSCON_SRC_T src)
N{
N	LPC_ASYNC_SYSCON->ASYNCAPBCLKSELA = (uint32_t) src;
X	((LPC_ASYNC_SYSCON_T *) 0x40040000UL)->ASYNCAPBCLKSELA = (uint32_t) src;
N}
N
N/**
N * @brief	Get asynchronous APB clock source
N * @return	Clock source for asynchronous APB clock
N */
N__STATIC_INLINE CHIP_ASYNC_SYSCON_SRC_T Chip_Clock_GetAsyncSysconClockSource(void)
Xstatic __inline CHIP_ASYNC_SYSCON_SRC_T Chip_Clock_GetAsyncSysconClockSource(void)
N{
N	return (CHIP_ASYNC_SYSCON_SRC_T) (LPC_ASYNC_SYSCON->ASYNCAPBCLKSELA & 0x3);
X	return (CHIP_ASYNC_SYSCON_SRC_T) (((LPC_ASYNC_SYSCON_T *) 0x40040000UL)->ASYNCAPBCLKSELA & 0x3);
N}
N
N/**
N * @brief	Return asynchronous APB clock rate
N * @return	Asynchronous APB clock rate
N * @note	Includes adjustments by Async clock divider (ASYNCCLKDIV).
N */
Nuint32_t Chip_Clock_GetAsyncSyscon_ClockRate(void);
N
N/**
N * Clock sources for main system clock. This is a mix of both main clock A
N * and B selections.
N */
Ntypedef enum {
N	SYSCON_MAINCLKSRC_FRO12MHZ = 0,         /*!< 12-MHz FRO */
N	SYSCON_MAINCLKSRC_CLKIN,				/*!< Crystal (main) oscillator in */
N	SYSCON_MAINCLKSRC_WDTOSC,				/*!< Watchdog oscillator rate */
N	SYSCON_MAINCLKSRC_FROHF,                /*!< 48MHz or 96-MHz HF-FRO */
N	SYSCON_MAINCLKSRC_PLLOUT = 6,			/*!< System PLL output */
N	SYSCON_MAINCLKSRC_RTC					/*!< RTC oscillator 32KHz output */
N} CHIP_SYSCON_MAINCLKSRC_T;
N
N/**
N * @brief	Set main system clock source
N * @param	src	: Clock source for main system (See #CHIP_SYSCON_MAINCLKSRC_T)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_Clock_SetMainClockSource(CHIP_SYSCON_MAINCLKSRC_T src)
Xstatic __inline void Chip_Clock_SetMainClockSource(CHIP_SYSCON_MAINCLKSRC_T src)
N{
N	uint32_t clkSrc = (uint32_t) src;
N
N	if (clkSrc >= 4) {
N		/* Main B source only, not using main A */
N		Chip_Clock_SetMain_B_ClockSource((CHIP_SYSCON_MAIN_B_CLKSRC_T) (clkSrc - 4));
N	}
N	else {
N		/* Select main A clock source and set main B source to use main A */
N		Chip_Clock_SetMain_A_ClockSource((CHIP_SYSCON_MAIN_A_CLKSRC_T) clkSrc);
N		Chip_Clock_SetMain_B_ClockSource(SYSCON_MAIN_B_CLKSRC_MAINCLKSELA);
N	}
N}
N
N/**
N * @brief	Get main system clock source
N * @return	Clock source for main system
N * @note
N */
NCHIP_SYSCON_MAINCLKSRC_T Chip_Clock_GetMainClockSource(void);
N
N/**
N * @brief	Return main clock rate
N * @return	main clock rate
N */
Nuint32_t Chip_Clock_GetMainClockRate(void);
N
N/**
N * @brief	Return system clock rate
N * @return	system clock rate
N * @note	This is the main clock rate divided by AHBCLKDIV.
N */
Nuint32_t Chip_Clock_GetSystemClockRate(void);
N
N/**
N * @brief	Fractional Divider clock sources
N */
Ntypedef enum {
N	SYSCON_FRGCLKSRC_MAINCLK,     /*!< Main Clock */
N	SYSCON_FRGCLKSRC_PLL,         /*!< Output clock from PLL */
N	SYSCON_FRGCLKSRC_FRO12MHZ,    /*!< FRO 12-MHz */
N	SYSCON_FRGCLKSRC_FROHF,       /*!< FRO High Frequency (48 or 96) MHz */
N	SYSCON_FRGCLKSRC_NONE = 7     /*!< No clock input */
N}CHIP_SYSCON_FRGCLKSRC_T;
N
N/**
N * @brief	Get the input clock frequency of FRG
N * @return	Frequency in Hz on success (0 on failure)
N */
Nuint32_t Chip_Clock_GetFRGInClockRate(void);
N
N/**
N * @brief	Set clock source used by FRG
N * @return	Clock source used by FRG
N * @note
N */
N__STATIC_INLINE void Chip_Clock_SetFRGClockSource(CHIP_SYSCON_FRGCLKSRC_T src)
Xstatic __inline void Chip_Clock_SetFRGClockSource(CHIP_SYSCON_FRGCLKSRC_T src)
N{
N	LPC_SYSCON->FRGCLKSEL = (uint32_t) src;
X	((LPC_SYSCON_T *) 0x40000000UL)->FRGCLKSEL = (uint32_t) src;
N}
N
N/**
N * @brief	Get clock source used by FRG
N * @return	Clock source used by FRG
N * @note
N */
N__STATIC_INLINE CHIP_SYSCON_FRGCLKSRC_T Chip_Clock_GetFRGClockSource(void)
Xstatic __inline CHIP_SYSCON_FRGCLKSRC_T Chip_Clock_GetFRGClockSource(void)
N{
N	return (CHIP_SYSCON_FRGCLKSRC_T)(LPC_SYSCON->FRGCLKSEL & 0x07);
X	return (CHIP_SYSCON_FRGCLKSRC_T)(((LPC_SYSCON_T *) 0x40000000UL)->FRGCLKSEL & 0x07);
N}
N
N/**
N * @brief	Get Fraction Rate Generator (FRG) clock rate
N * @return	UART base clock rate
N */
Nuint32_t Chip_Clock_GetFRGClockRate(void);
N
N/**
N * @brief	Set FRG rate to given rate
N * @return	Actual FRG clock rate
N * @note	If FRG is used for UART base clock, @a rate
N * is recommended to be 16 times desired baud rate;
N * <b>This API must only be called after setting the source using
N * Chip_Clock_SetFRGClockSource()</b>
N */
Nuint32_t Chip_Clock_SetFRGClockRate(uint32_t rate);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CLOCK_5411X_H_ */
L 180 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "pmu_5411x.h"
L 1 "..\..\..\chip_5411x\inc\pmu_5411x.h" 1
N/*
N * @brief LPC5411X Power Management declarations and functions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __PMU_5411X_H_
N#define __PMU_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup PMU_5411X CHIP: LPC5411X Power Management declarations and functions
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/**
N * @brief PMU register block structure
N * @note Most of the PMU support is handled by the PMU library.
N */
Ntypedef struct {
N	__I  uint32_t RESERVED0[17];
X	volatile const  uint32_t RESERVED0[17];
N	__IO uint32_t BODCTRL;
X	volatile uint32_t BODCTRL;
N} LPC_PMU_T;
N
N/**
N * Brown-out detector reset level
N */
Ntypedef enum {
N	PMU_BODRSTLVL_0,	/*!< Brown-out reset at ~1.5v */
N	PMU_BODRSTLVL_1_50V = PMU_BODRSTLVL_0,
N	PMU_BODRSTLVL_1,	/*!< Brown-out reset at ~1.85v */
N	PMU_BODRSTLVL_1_85V = PMU_BODRSTLVL_1,
N	PMU_BODRSTLVL_2,	/*!< Brown-out reset at ~2.0v */
N	PMU_BODRSTLVL_2_00V = PMU_BODRSTLVL_2,
N	PMU_BODRSTLVL_3,	/*!< Brown-out reset at ~2.3v */
N	PMU_BODRSTLVL_2_30V = PMU_BODRSTLVL_3
N} CHIP_PMU_BODRSTLVL_T;
N
N/**
N * Brown-out detector interrupt level
N */
Ntypedef enum CHIP_PMU_BODRINTVAL {
N	PMU_BODINTVAL_LVL0,	/*!< Brown-out interrupt at ~2.05v */
N	PMU_BODINTVAL_2_05v = PMU_BODINTVAL_LVL0,
N	PMU_BODINTVAL_LVL1,	/*!< Brown-out interrupt at ~2.45v */
N	PMU_BODINTVAL_2_45v = PMU_BODINTVAL_LVL1,
N	PMU_BODINTVAL_LVL2,	/*!< Brown-out interrupt at ~2.75v */
N	PMU_BODINTVAL_2_75v = PMU_BODINTVAL_LVL2,
N	PMU_BODINTVAL_LVL3,	/*!< Brown-out interrupt at ~3.05v */
N	PMU_BODINTVAL_3_05v = PMU_BODINTVAL_LVL3
N} CHIP_PMU_BODRINTVAL_T;
N
N/**
N * brown-out detection reset status (in BODCTRL register)
N */
N#define PMU_BOD_RST     (1 << 6)
N/**
N * brown-out detection interrupt status (in BODCTRL register)
N */
N#define PMU_BOD_INT     (1 << 7)
N
N/**
N * @brief	Set brown-out detection interrupt and reset levels
N * @param	rstlvl	: Brown-out detector reset level
N * @param	intlvl	: Brown-out interrupt level
N * @return	Nothing
N * @note	Brown-out detection reset will be disabled upon exiting this function.
N * Use Chip_PMU_EnableBODReset() to re-enable.
N */
N__STATIC_INLINE void Chip_PMU_SetBODLevels(CHIP_PMU_BODRSTLVL_T rstlvl,
Xstatic __inline void Chip_PMU_SetBODLevels(CHIP_PMU_BODRSTLVL_T rstlvl,
N										 CHIP_PMU_BODRINTVAL_T intlvl)
N{
N	LPC_PMU->BODCTRL = ((uint32_t)(rstlvl & 0x03) | ((uint32_t) (intlvl & 0x03) << 3));
X	((LPC_PMU_T *) 0x40020000UL)->BODCTRL = ((uint32_t)(rstlvl & 0x03) | ((uint32_t) (intlvl & 0x03) << 3));
N}
N
N/**
N * @brief	Enable brown-out detection reset
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_PMU_EnableBODReset(void)
Xstatic __inline void Chip_PMU_EnableBODReset(void)
N{
N	LPC_PMU->BODCTRL |= (1 << 2);
X	((LPC_PMU_T *) 0x40020000UL)->BODCTRL |= (1 << 2);
N}
N
N/**
N * @brief	Disable brown-out detection reset
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_PMU_DisableBODReset(void)
Xstatic __inline void Chip_PMU_DisableBODReset(void)
N{
N	LPC_PMU->BODCTRL &= ~(1 << 2);
X	((LPC_PMU_T *) 0x40020000UL)->BODCTRL &= ~(1 << 2);
N}
N
N/**
N * @brief	Enable brown-out detection interrupt
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_PMU_EnableBODInt(void)
Xstatic __inline void Chip_PMU_EnableBODInt(void)
N{
N	LPC_PMU->BODCTRL |= (1 << 5);
X	((LPC_PMU_T *) 0x40020000UL)->BODCTRL |= (1 << 5);
N}
N
N/**
N * @brief	Disable brown-out detection interrupt
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_PMU_DisableBODInt(void)
Xstatic __inline void Chip_PMU_DisableBODInt(void)
N{
N	LPC_PMU->BODCTRL &= ~(1 << 5);
X	((LPC_PMU_T *) 0x40020000UL)->BODCTRL &= ~(1 << 5);
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __PMU_5411X_H_ */
L 181 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "iocon_5411x.h"
L 1 "..\..\..\chip_5411x\inc\iocon_5411x.h" 1
N/*
N * @brief LPC5411X IOCON register block and driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __IOCON_5411X_H_
N#define __IOCON_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup IOCON_5411X CHIP: LPC5411X IOCON register block and driver
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/**
N * @brief LPC5411X IO Configuration Unit register block structure
N */
Ntypedef struct {			/*!< LPC5411X IOCON Structure */
N	__IO uint32_t  PIO[2][32];
X	volatile uint32_t  PIO[2][32];
N} LPC_IOCON_T;
N
N/**
N * @brief Array of IOCON pin definitions passed to Chip_IOCON_SetPinMuxing() must be in this format
N */
Ntypedef struct {
N	uint32_t port : 8;			/* Pin port */
N	uint32_t pin : 8;			/* Pin number */
N	uint32_t modefunc : 16;		/* Function and mode */
N} PINMUX_GRP_T;
N
N/**
N * IOCON function and mode selection definitions
N * See the User Manual for specific modes and functions supported by the
N * various LPC15XX pins.
N */
N#define IOCON_FUNC0             0x0				/*!< Selects pin function 0 */
N#define IOCON_FUNC1             0x1				/*!< Selects pin function 1 */
N#define IOCON_FUNC2             0x2				/*!< Selects pin function 2 */
N#define IOCON_FUNC3             0x3				/*!< Selects pin function 3 */
N#define IOCON_FUNC4             0x4				/*!< Selects pin function 4 */
N#define IOCON_FUNC5             0x5				/*!< Selects pin function 5 */
N#define IOCON_FUNC6             0x6				/*!< Selects pin function 6 */
N#define IOCON_FUNC7             0x7				/*!< Selects pin function 7 */
N#define IOCON_MODE_INACT        (0x0 << 3)		/*!< No addition pin function */
N#define IOCON_MODE_PULLDOWN     (0x1 << 3)		/*!< Selects pull-down function */
N#define IOCON_MODE_PULLUP       (0x2 << 3)		/*!< Selects pull-up function */
N#define IOCON_MODE_REPEATER     (0x3 << 3)		/*!< Selects pin repeater function */
N#define IOCON_HYS_EN            (0x1 << 5)		/*!< Enables hysteresis */
N#define IOCON_GPIO_MODE         (0x1 << 5)		/*!< GPIO Mode */
N#define IOCON_I2C_SLEW          (0x1 << 5)		/*!< I2C Slew Rate Control */
N#define IOCON_INV_EN            (0x1 << 6)		/*!< Enables invert function on input */
N#define IOCON_ANALOG_EN         (0x0 << 7)		/*!< Enables analog function by setting 0 to bit 7 */
N#define IOCON_DIGITAL_EN        (0x1 << 7)		/*!< Enables digital function by setting 1 to bit 7(default) */
N#define IOCON_STDI2C_EN         (0x1 << 8)		/*!< I2C standard mode/fast-mode */
N#define IOCON_FASTI2C_EN        (0x3 << 8)		/*!< I2C Fast-mode Plus and high-speed slave */
N#define IOCON_INPFILT_OFF       (0x1 << 8)		/*!< Input filter Off for GPIO pins */
N#define IOCON_INPFILT_ON        (0x0 << 8)		/*!< Input filter On for GPIO pins */
N#define IOCON_OPENDRAIN_EN      (0x1 << 10)		/*!< Enables open-drain function */
N#define IOCON_S_MODE_0CLK       (0x0 << 11)		/*!< Bypass input filter */
N#define IOCON_S_MODE_1CLK       (0x1 << 11)		/*!< Input pulses shorter than 1 filter clock are rejected */
N#define IOCON_S_MODE_2CLK       (0x2 << 11)		/*!< Input pulses shorter than 2 filter clock2 are rejected */
N#define IOCON_S_MODE_3CLK       (0x3 << 11)		/*!< Input pulses shorter than 3 filter clock2 are rejected */
N#define IOCON_S_MODE(clks)      ((clks) << 11)	/*!< Select clocks for digital input filter mode */
N#define IOCON_CLKDIV(div)       ((div) << 13)	/*!< Select peripheral clock divider for input filter sampling clock, 2^n, n=0-6 */
N
N/**
N * @brief	Sets I/O Control pin mux
N * @param	pIOCON		: The base of IOCON peripheral on the chip
N * @param	port		: GPIO port to mux
N * @param	pin			: GPIO pin to mux
N * @param	modefunc	: OR'ed values or type IOCON_*
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_IOCON_PinMuxSet(LPC_IOCON_T *pIOCON, uint8_t port, uint8_t pin, uint32_t modefunc)
Xstatic __inline void Chip_IOCON_PinMuxSet(LPC_IOCON_T *pIOCON, uint8_t port, uint8_t pin, uint32_t modefunc)
N{
N	pIOCON->PIO[port][pin] = modefunc;
N}
N
N/**
N * @brief	I/O Control pin mux
N * @param	pIOCON	: The base of IOCON peripheral on the chip
N * @param	port	: GPIO port to mux
N * @param	pin		: GPIO pin to mux
N * @param	mode	: OR'ed values or type IOCON_*
N * @param	func	: Pin function, value of type IOCON_FUNC?
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_IOCON_PinMux(LPC_IOCON_T *pIOCON, uint8_t port, uint8_t pin, uint16_t mode, uint8_t func)
Xstatic __inline void Chip_IOCON_PinMux(LPC_IOCON_T *pIOCON, uint8_t port, uint8_t pin, uint16_t mode, uint8_t func)
N{
N	Chip_IOCON_PinMuxSet(pIOCON, port, pin, (uint32_t) (mode | func));
N}
N
N/**
N * @brief	Set all I/O Control pin muxing
N * @param	pIOCON	    : The base of IOCON peripheral on the chip
N * @param	pinArray    : Pointer to array of pin mux selections
N * @param	arrayLength : Number of entries in pinArray
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_IOCON_SetPinMuxing(LPC_IOCON_T *pIOCON, const PINMUX_GRP_T *pinArray, uint32_t arrayLength)
Xstatic __inline void Chip_IOCON_SetPinMuxing(LPC_IOCON_T *pIOCON, const PINMUX_GRP_T *pinArray, uint32_t arrayLength)
N{
N	uint32_t ix;
N
N	for (ix = 0; ix < arrayLength; ix++ ) {
N		Chip_IOCON_PinMuxSet(pIOCON, pinArray[ix].port, pinArray[ix].pin, pinArray[ix].modefunc);
N	}
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __IOCON_5411X_H_ */
L 182 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "pinint_5411x.h"
L 1 "..\..\..\chip_5411x\inc\pinint_5411x.h" 1
N/*
N * @brief LPC5411X Pin Interrupt and Pattern Match Registers and driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __PININT_5411X_H_
N#define __PININT_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup PININT_5411X CHIP: LPC5411X Pin Interrupt and Pattern Match driver
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/**
N * @brief LPC5411X Pin Interrupt and Pattern Match register block structure
N */
Ntypedef struct {			/*!< PIN_INT Structure */
N	__IO uint32_t ISEL;		/*!< Pin Interrupt Mode register */
X	volatile uint32_t ISEL;		 
N	__IO uint32_t IENR;		/*!< Pin Interrupt Enable (Rising) register */
X	volatile uint32_t IENR;		 
N	__O  uint32_t SIENR;	/*!< Set Pin Interrupt Enable (Rising) register */
X	volatile  uint32_t SIENR;	 
N	__O  uint32_t CIENR;	/*!< Clear Pin Interrupt Enable (Rising) register */
X	volatile  uint32_t CIENR;	 
N	__IO uint32_t IENF;		/*!< Pin Interrupt Enable Falling Edge / Active Level register */
X	volatile uint32_t IENF;		 
N	__O  uint32_t SIENF;	/*!< Set Pin Interrupt Enable Falling Edge / Active Level register */
X	volatile  uint32_t SIENF;	 
N	__O  uint32_t CIENF;	/*!< Clear Pin Interrupt Enable Falling Edge / Active Level address */
X	volatile  uint32_t CIENF;	 
N	__IO uint32_t RISE;		/*!< Pin Interrupt Rising Edge register */
X	volatile uint32_t RISE;		 
N	__IO uint32_t FALL;		/*!< Pin Interrupt Falling Edge register */
X	volatile uint32_t FALL;		 
N	__IO uint32_t IST;		/*!< Pin Interrupt Status register */
X	volatile uint32_t IST;		 
N	__IO uint32_t PMCTRL;	/*!< GPIO pattern match interrupt control register          */
X	volatile uint32_t PMCTRL;	 
N	__IO uint32_t PMSRC;	/*!< GPIO pattern match interrupt bit-slice source register */
X	volatile uint32_t PMSRC;	 
N	__IO uint32_t PMCFG;	/*!< GPIO pattern match interrupt bit slice configuration register */
X	volatile uint32_t PMCFG;	 
N} LPC_PIN_INT_T;
N
N/**
N * LPC5411X Pin Interrupt and Pattern match engine register
N * bit fields and macros
N */
N
N/* PININT Interrupt Mode Mask */
N#define PININT_ISEL_PMODE_MASK   ((uint32_t) 0x00FF)
N
N/* PININT Pattern Match Control Register Mask */
N#define PININT_PMCTRL_MASK       ((uint32_t) 0xFF000003)
N
N/* PININT interrupt control register */
N#define PININT_PMCTRL_PMATCH_SEL (1 << 0)
N#define PININT_PMCTRL_RXEV_ENA   (1 << 1)
N
N/* PININT Bit slice source register bits */
N#define PININT_SRC_BITSOURCE_START  8
N#define PININT_SRC_BITSOURCE_MASK   7
N
N/* PININT Bit slice configuration register bits */
N#define PININT_SRC_BITCFG_START  8
N#define PININT_SRC_BITCFG_MASK   7
N
N/**
N * LPC5411X Pin Interrupt channel values
N */
N#define PININTCH0         (1 << 0)
N#define PININTCH1         (1 << 1)
N#define PININTCH2         (1 << 2)
N#define PININTCH3         (1 << 3)
N#define PININTCH4         (1 << 4)
N#define PININTCH5         (1 << 5)
N#define PININTCH6         (1 << 6)
N#define PININTCH7         (1 << 7)
N#define PININTCH(ch)      (1 << (ch))
N
N/**
N * LPC5411X Pin Interrupt select enum values
N */
Ntypedef enum Chip_PININT_SELECT {
N	PININTSELECT0 = 0,
N	PININTSELECT1 = 1,
N	PININTSELECT2 = 2,
N	PININTSELECT3 = 3,
N	PININTSELECT4 = 4,
N	PININTSELECT5 = 5,
N	PININTSELECT6 = 6,
N	PININTSELECT7 = 7
N} Chip_PININT_SELECT_T;
N
N/**
N * LPC5411X Pin Matching Interrupt bit slice enum values
N */
Ntypedef enum Chip_PININT_BITSLICE {
N	PININTBITSLICE0 = 0,	/*!< PININT Bit slice 0 */
N	PININTBITSLICE1 = 1,	/*!< PININT Bit slice 1 */
N	PININTBITSLICE2 = 2,	/*!< PININT Bit slice 2 */
N	PININTBITSLICE3 = 3,	/*!< PININT Bit slice 3 */
N	PININTBITSLICE4 = 4,	/*!< PININT Bit slice 4 */
N	PININTBITSLICE5 = 5,	/*!< PININT Bit slice 5 */
N	PININTBITSLICE6 = 6,	/*!< PININT Bit slice 6 */
N	PININTBITSLICE7 = 7		/*!< PININT Bit slice 7 */
N} Chip_PININT_BITSLICE_T;
N
N/**
N * LPC5411X Pin Matching Interrupt bit slice configuration enum values
N */
Ntypedef enum Chip_PININT_BITSLICE_CFG {
N	PININT_PATTERNCONST1           = 0x0,	/*!< Contributes to product term match */
N	PININT_PATTERNRISING           = 0x1,	/*!< Rising edge */
N	PININT_PATTERNFALLING          = 0x2,	/*!< Falling edge */
N	PININT_PATTERNRISINGORFALLING  = 0x3,	/*!< Rising or Falling edge */
N	PININT_PATTERNHIGH             = 0x4,	/*!< High level */
N	PININT_PATTERNLOW              = 0x5,	/*!< Low level */
N	PININT_PATTERNCONST0           = 0x6,	/*!< Never contributes for match */
N	PININT_PATTERNEVENT            = 0x7	/*!< Match occurs on event */
N} Chip_PININT_BITSLICE_CFG_T;
N
N/**
N * @brief	Initialize Pin interrupt block
N * @param	pPININT	: The base address of Pin interrupt block
N * @return	Nothing
N * @note	This function should be used after the Chip_GPIO_Init() function.
N */
N__STATIC_INLINE void Chip_PININT_Init(LPC_PIN_INT_T *pPININT)
Xstatic __inline void Chip_PININT_Init(LPC_PIN_INT_T *pPININT)
N{
N	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_PINT);
N	Chip_SYSCON_PeriphReset(RESET_PINT);
N}
N
N/**
N * @brief	De-Initialize Pin interrupt block
N * @param	pPININT	: The base address of Pin interrupt block
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_PININT_DeInit(LPC_PIN_INT_T *pPININT)
Xstatic __inline void Chip_PININT_DeInit(LPC_PIN_INT_T *pPININT)
N{
N	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_PINT);
N}
N
N/**
N * @brief	Configure the pins as edge sensitive in Pin interrupt block
N * @param	pPININT	: The base address of Pin interrupt block
N * @param	pins	: Pins (ORed value of PININTCH*)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_PININT_SetPinModeEdge(LPC_PIN_INT_T *pPININT, uint32_t pins)
Xstatic __inline void Chip_PININT_SetPinModeEdge(LPC_PIN_INT_T *pPININT, uint32_t pins)
N{
N	pPININT->ISEL = (pPININT->ISEL & PININT_ISEL_PMODE_MASK) & ~pins;
X	pPININT->ISEL = (pPININT->ISEL & ((uint32_t) 0x00FF)) & ~pins;
N}
N
N/**
N * @brief	Configure the pins as level sensitive in Pin interrupt block
N * @param	pPININT	: The base address of Pin interrupt block
N * @param	pins	: Pins (ORed value of PININTCH*)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_PININT_SetPinModeLevel(LPC_PIN_INT_T *pPININT, uint32_t pins)
Xstatic __inline void Chip_PININT_SetPinModeLevel(LPC_PIN_INT_T *pPININT, uint32_t pins)
N{
N	pPININT->ISEL = (pPININT->ISEL & PININT_ISEL_PMODE_MASK) | pins;
X	pPININT->ISEL = (pPININT->ISEL & ((uint32_t) 0x00FF)) | pins;
N}
N
N/**
N * @brief	Return current PININT edge or level sensitive interrupt selection state
N * @param	pPININT	: The base address of Pin interrupt block
N * @return	A bifield containing the edge/level sensitive selection for each
N * interrupt. Bit 0 = PININT0, 1 = PININT1, etc.
N * For each bit, a 0 means the edge sensitive interrupt is selected, while a 1
N * means the level sensitive interrupt is selected.
N */
N__STATIC_INLINE uint32_t Chip_PININT_GetPinMode(LPC_PIN_INT_T *pPININT)
Xstatic __inline uint32_t Chip_PININT_GetPinMode(LPC_PIN_INT_T *pPININT)
N{
N	return pPININT->ISEL & PININT_ISEL_PMODE_MASK;
X	return pPININT->ISEL & ((uint32_t) 0x00FF);
N}
N
N/**
N * @brief	Return current PININT rising edge or level interrupt enable state
N * @param	pPININT	: The base address of Pin interrupt block
N * @return	A bifield containing the rising edge/level enable for each
N * interrupt. Bit 0 = PININT0, 1 = PININT1, etc.
N * For each bit, a 0 means the rising edge/level interrupt is disabled, while a 1
N * means it's enabled.
N */
N__STATIC_INLINE uint32_t Chip_PININT_GetHighEnabled(LPC_PIN_INT_T *pPININT)
Xstatic __inline uint32_t Chip_PININT_GetHighEnabled(LPC_PIN_INT_T *pPININT)
N{
N	return pPININT->IENR;
N}
N
N/**
N * @brief	Enable rising edge/level PININT interrupts for pins
N * @param	pPININT	: The base address of Pin interrupt block
N * @param	pins	: Pins to enable (ORed value of PININTCH*)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_PININT_EnableIntHigh(LPC_PIN_INT_T *pPININT, uint32_t pins)
Xstatic __inline void Chip_PININT_EnableIntHigh(LPC_PIN_INT_T *pPININT, uint32_t pins)
N{
N	pPININT->SIENR = pins;
N}
N
N/**
N * @brief	Disable rising edge/level PININT interrupts for pins
N * @param	pPININT	: The base address of Pin interrupt block
N * @param	pins	: Pins to disable (ORed value of PININTCH*)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_PININT_DisableIntHigh(LPC_PIN_INT_T *pPININT, uint32_t pins)
Xstatic __inline void Chip_PININT_DisableIntHigh(LPC_PIN_INT_T *pPININT, uint32_t pins)
N{
N	pPININT->CIENR = pins;
N}
N
N/**
N * @brief	Return current PININT falling edge or level interrupt active level enable state
N * @param	pPININT	: The base address of Pin interrupt block
N * @return	A bifield containing the falling edge/level interrupt active level enable for each
N * interrupt. Bit 0 = PININT0, 1 = PININT1, etc.
N * For each bit, a 0 means the falling edge is disabled/level interrupt active low is enabled, while a 1
N * means the falling edge is enabled/level interrupt active high is enabled.
N */
N__STATIC_INLINE uint32_t Chip_PININT_GetLowEnabled(LPC_PIN_INT_T *pPININT)
Xstatic __inline uint32_t Chip_PININT_GetLowEnabled(LPC_PIN_INT_T *pPININT)
N{
N	return pPININT->IENF;
N}
N
N/**
N * @brief	Enable falling edge/level active level PININT interrupts for pins
N * @param	pPININT	: The base address of Pin interrupt block
N * @param	pins	: Pins to enable (ORed value of PININTCH*)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_PININT_EnableIntLow(LPC_PIN_INT_T *pPININT, uint32_t pins)
Xstatic __inline void Chip_PININT_EnableIntLow(LPC_PIN_INT_T *pPININT, uint32_t pins)
N{
N	pPININT->SIENF = pins;
N}
N
N/**
N * @brief	Disable low edge/level active level PININT interrupts for pins
N * @param	pPININT	: The base address of Pin interrupt block
N * @param	pins	: Pins to disable (ORed value of PININTCH*)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_PININT_DisableIntLow(LPC_PIN_INT_T *pPININT, uint32_t pins)
Xstatic __inline void Chip_PININT_DisableIntLow(LPC_PIN_INT_T *pPININT, uint32_t pins)
N{
N	pPININT->CIENF = pins;
N}
N
N/**
N * @brief	Return pin states that have a detected latched rising edge (RISE) state
N * @param	pPININT	: The base address of Pin interrupt block
N * @return	PININT states (bit n = high) with a latched rise state detected
N */
N__STATIC_INLINE uint32_t Chip_PININT_GetRiseStates(LPC_PIN_INT_T *pPININT)
Xstatic __inline uint32_t Chip_PININT_GetRiseStates(LPC_PIN_INT_T *pPININT)
N{
N	return pPININT->RISE;
N}
N
N/**
N * @brief	Clears pin states that had a latched rising edge (RISE) state
N * @param	pPININT	: The base address of Pin interrupt block
N * @param	pins	: Pins with latched states to clear
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_PININT_ClearRiseStates(LPC_PIN_INT_T *pPININT, uint32_t pins)
Xstatic __inline void Chip_PININT_ClearRiseStates(LPC_PIN_INT_T *pPININT, uint32_t pins)
N{
N	pPININT->RISE = pins;
N}
N
N/**
N * @brief	Return pin states that have a detected latched falling edge (FALL) state
N * @param	pPININT	: The base address of Pin interrupt block
N * @return	PININT states (bit n = high) with a latched rise state detected
N */
N__STATIC_INLINE uint32_t Chip_PININT_GetFallStates(LPC_PIN_INT_T *pPININT)
Xstatic __inline uint32_t Chip_PININT_GetFallStates(LPC_PIN_INT_T *pPININT)
N{
N	return pPININT->FALL;
N}
N
N/**
N * @brief	Clears pin states that had a latched falling edge (FALL) state
N * @param	pPININT	: The base address of Pin interrupt block
N * @param	pins	: Pins with latched states to clear
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_PININT_ClearFallStates(LPC_PIN_INT_T *pPININT, uint32_t pins)
Xstatic __inline void Chip_PININT_ClearFallStates(LPC_PIN_INT_T *pPININT, uint32_t pins)
N{
N	pPININT->FALL = pins;
N}
N
N/**
N * @brief	Get interrupt status from Pin interrupt block
N * @param	pPININT	: The base address of Pin interrupt block
N * @return	Interrupt status (bit n for PININTn = high means interrupt ie pending)
N */
N__STATIC_INLINE uint32_t Chip_PININT_GetIntStatus(LPC_PIN_INT_T *pPININT)
Xstatic __inline uint32_t Chip_PININT_GetIntStatus(LPC_PIN_INT_T *pPININT)
N{
N	return pPININT->IST;
N}
N
N/**
N * @brief	Clear interrupt status in Pin interrupt block
N * @param	pPININT	: The base address of Pin interrupt block
N * @param	pins	: Pin interrupts to clear (ORed value of PININTCH*)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_PININT_ClearIntStatus(LPC_PIN_INT_T *pPININT, uint32_t pins)
Xstatic __inline void Chip_PININT_ClearIntStatus(LPC_PIN_INT_T *pPININT, uint32_t pins)
N{
N	pPININT->IST = pins;
N}
N
N/**
N * @brief	Set source for pattern match in Pin interrupt block
N * @param	pPININT	: The base address of Pin interrupt block
N * @param	channelNum : PININT channel number (From 0 to 7)
N * @param	sliceNum	: PININT slice number
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_PININT_SetPatternMatchSrc(LPC_PIN_INT_T *pPININT,
Xstatic __inline void Chip_PININT_SetPatternMatchSrc(LPC_PIN_INT_T *pPININT,
N									Chip_PININT_SELECT_T channelNum,
N									Chip_PININT_BITSLICE_T sliceNum)
N{
N	uint32_t idx = PININT_SRC_BITSOURCE_START + (sliceNum * 3);
X	uint32_t idx = 8 + (sliceNum * 3);
N
N	/* Source source for pattern matching */
N	pPININT->PMSRC = (pPININT->PMSRC & ~(PININT_SRC_BITSOURCE_MASK << idx)) |
X	pPININT->PMSRC = (pPININT->PMSRC & ~(7 << idx)) |
N			(channelNum << idx);
N}
N
N/**
N * @brief	Configure the pattern matcch in Pin interrupt block
N * @param	pPININT	: The base address of Pin interrupt block
N * @param	sliceNum : PININT slice number
N * @param	slice_cfg	: PININT slice configuration value (enum Chip_PININT_BITSLICE_CFG_T)
N * @param	end_point	: If true, current slice is final component
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_PININT_SetPatternMatchConfig(LPC_PIN_INT_T *pPININT,
Xstatic __inline void Chip_PININT_SetPatternMatchConfig(LPC_PIN_INT_T *pPININT,
N		Chip_PININT_BITSLICE_T sliceNum,
N		Chip_PININT_BITSLICE_CFG_T slice_cfg, bool end_point)
X		Chip_PININT_BITSLICE_CFG_T slice_cfg, _Bool end_point)
N{
N	uint32_t pmcfg, idx = PININT_SRC_BITCFG_START + (sliceNum * 3);
X	uint32_t pmcfg, idx = 8 + (sliceNum * 3);
N
N	/* Configure bit slice configuration */
N	pmcfg = pPININT->PMCFG;
N	pmcfg = (pmcfg & ~(PININT_SRC_BITCFG_MASK << idx)) | (slice_cfg << idx);
X	pmcfg = (pmcfg & ~(7 << idx)) | (slice_cfg << idx);
N
N	/* If end point is true, enable the bits */
N	if (sliceNum != PININTBITSLICE7) {
N		if (end_point) {
N			pmcfg |= (0x1 << sliceNum);
N		}
N		else {
N			pmcfg &= ~(0x1 << sliceNum);
N		}
N	}
N
N	pPININT->PMCFG = pmcfg;
N}
N
N/**
N * @brief	Enable pattern match interrupts in Pin interrupt block
N * @param	pPININT	: The base address of Pin interrupt block
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_PININT_EnablePatternMatch(LPC_PIN_INT_T *pPININT)
Xstatic __inline void Chip_PININT_EnablePatternMatch(LPC_PIN_INT_T *pPININT)
N{
N	pPININT->PMCTRL = (pPININT->PMCTRL & PININT_PMCTRL_MASK) | PININT_PMCTRL_PMATCH_SEL;
X	pPININT->PMCTRL = (pPININT->PMCTRL & ((uint32_t) 0xFF000003)) | (1 << 0);
N}
N
N/**
N * @brief	Disable pattern match interrupts in Pin interrupt block
N * @param	pPININT	: The base address of Pin interrupt block
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_PININT_DisablePatternMatch(LPC_PIN_INT_T *pPININT)
Xstatic __inline void Chip_PININT_DisablePatternMatch(LPC_PIN_INT_T *pPININT)
N{
N	pPININT->PMCTRL = (pPININT->PMCTRL & PININT_PMCTRL_MASK) & ~PININT_PMCTRL_PMATCH_SEL;
X	pPININT->PMCTRL = (pPININT->PMCTRL & ((uint32_t) 0xFF000003)) & ~(1 << 0);
N}
N
N/**
N * @brief	Enable RXEV output in Pin interrupt block
N * @param	pPININT	: The base address of Pin interrupt block
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_PININT_EnablePatternMatchRxEv(LPC_PIN_INT_T *pPININT)
Xstatic __inline void Chip_PININT_EnablePatternMatchRxEv(LPC_PIN_INT_T *pPININT)
N{
N	pPININT->PMCTRL = (pPININT->PMCTRL & PININT_PMCTRL_MASK) | PININT_PMCTRL_RXEV_ENA;
X	pPININT->PMCTRL = (pPININT->PMCTRL & ((uint32_t) 0xFF000003)) | (1 << 1);
N}
N
N/**
N * @brief	Disable RXEV output in Pin interrupt block
N * @param	pPININT	: The base address of Pin interrupt block
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_PININT_DisablePatternMatchRxEv(LPC_PIN_INT_T *pPININT)
Xstatic __inline void Chip_PININT_DisablePatternMatchRxEv(LPC_PIN_INT_T *pPININT)
N{
N	pPININT->PMCTRL = (pPININT->PMCTRL & PININT_PMCTRL_MASK) & ~PININT_PMCTRL_RXEV_ENA;
X	pPININT->PMCTRL = (pPININT->PMCTRL & ((uint32_t) 0xFF000003)) & ~(1 << 1);
N}
N
N/**
N * @brief	Return pattern match state
N * @param	pPININT	: The base address of Pin interrupt block
N * @return	8 bit pattern match state, where a 1 in any bit indicates that
N *					the corresponding product term has matched by the current state
N *					of its inputs.
N */
N__STATIC_INLINE uint32_t Chip_PININT_GetPatternMatchState(LPC_PIN_INT_T *pPININT)
Xstatic __inline uint32_t Chip_PININT_GetPatternMatchState(LPC_PIN_INT_T *pPININT)
N{
N	return pPININT->PMCTRL >> 24;
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __PININT_5411X_H_ */
L 183 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "inmux_5411x.h"
L 1 "..\..\..\chip_5411x\inc\inmux_5411x.h" 1
N/*
N * @brief LPC5411X Input Mux Registers and Driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __INMUX_5411X_H_
N#define __INMUX_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup INMUX_5411X CHIP: LPC5411X Input Mux Registers and Driver
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/**
N * @brief LPC5411X Input Mux Register Block Structure
N */
Ntypedef struct {						/*!< INMUX Structure */
N	__I  uint32_t RESERVED1[48];
X	volatile const  uint32_t RESERVED1[48];
N	__IO uint32_t PINTSEL[8];			/*!< Pin interrupt select registers */
X	volatile uint32_t PINTSEL[8];			 
N	__IO uint32_t DMA_ITRIG_INMUX[22];	/*!< Input mux register for DMA trigger inputs */
X	volatile uint32_t DMA_ITRIG_INMUX[22];	 
N	__I  uint32_t RESERVED2[10];
X	volatile const  uint32_t RESERVED2[10];
N	__IO uint32_t DMA_OTRIG_INMUX[4];	/*!< Input mux register for DMA trigger inputs */
X	volatile uint32_t DMA_OTRIG_INMUX[4];	 
N	__I  uint32_t RESERVED3[4];
X	volatile const  uint32_t RESERVED3[4];
N	__IO uint32_t FREQMEAS_REF;			/*!< Clock selection for frequency measurement ref clock */
X	volatile uint32_t FREQMEAS_REF;			 
N	__IO uint32_t FREQMEAS_TARGET;		/*!< Clock selection for frequency measurement target clock */
X	volatile uint32_t FREQMEAS_TARGET;		 
N} LPC_INMUX_T;
N
N/**
N * @brief	GPIO Pin Interrupt Pin Select (sets PINTSEL register)
N * @param	pintSel	: GPIO PINTSEL interrupt, should be: 0 to 7
N * @param	portNum	: GPIO port number interrupt, should be: 0 to 1
N * @param	pinNum	: GPIO pin number Interrupt, should be: 0 to 31
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_INMUX_PinIntSel(uint8_t pintSel, uint8_t portNum, uint8_t pinNum)
Xstatic __inline void Chip_INMUX_PinIntSel(uint8_t pintSel, uint8_t portNum, uint8_t pinNum)
N{
N	LPC_INMUX->PINTSEL[pintSel] = (portNum * 32) + pinNum;
X	((LPC_INMUX_T *) 0x40005000UL)->PINTSEL[pintSel] = (portNum * 32) + pinNum;
N}
N
N/* DMA triggers that can mapped to DMA channels */
Ntypedef enum {
N	DMATRIG_ADC0_SEQA_IRQ = 0,			/*!< ADC0 sequencer A interrupt as trigger */
N	DMATRIG_ADC0_SEQB_IRQ,				/*!< ADC0 sequencer B interrupt as trigger */
N	DMATRIG_SCT0_DMA0,				/*!< SCT 0, DMA 0 as trigger */
N	DMATRIG_SCT0_DMA1,				/*!< SCT 1, DMA 1 as trigger */
N	DMATRIG_TIMER0_MATCH0,				/*!< Timer 0, match 0 trigger */
N	DMATRIG_TIMER0_MATCH1,				/*!< Timer 0, match 1 trigger */
N	DMATRIG_TIMER1_MATCH0,				/*!< Timer 1, match 0 trigger */
N	DMATRIG_TIMER2_MATCH0,				/*!< Timer 2, match 0 trigger */
N	DMATRIG_TIMER2_MATCH1,				/*!< Timer 2, match 1 trigger */
N	DMATRIG_TIMER3_MATCH0,				/*!< Timer 3, match 0 trigger */
N	DMATRIG_TIMER4_MATCH0,				/*!< Timer 4, match 0 trigger */
N	DMATRIG_TIMER4_MATCH1,				/*!< Timer 4, match 1 trigger */
N	DMATRIG_PININT0,				/*!< Pin interrupt 0 trigger */
N	DMATRIG_PININT1,				/*!< Pin interrupt 1 trigger */
N	DMATRIG_PININT2,				/*!< Pin interrupt 2 trigger */
N	DMATRIG_PININT3,				/*!< Pin interrupt 3 trigger */
N	DMATRIG_OUTMUX0,				/*!< DMA trigger tied to this source, Select with Chip_INMUX_SetDMAOutMux */
N	DMATRIG_OUTMUX1,				/*!< DMA trigger tied to this source, Select with Chip_INMUX_SetDMAOutMux */
N	DMATRIG_OUTMUX2,				/*!< DMA trigger tied to this source, Select with Chip_INMUX_SetDMAOutMux */
N	DMATRIG_OUTMUX3					/*!< DMA trigger tied to this source, Select with Chip_INMUX_SetDMAOutMux */
N} DMA_TRIGSRC_T;
N
N/**
N * @brief	Select a trigger source for a DMA channel
N * @param	ch		: DMA channel number
N * @param	trig	: Trigger source for the DMA channel
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_INMUX_SetDMATrigger(uint8_t ch, DMA_TRIGSRC_T trig)
Xstatic __inline void Chip_INMUX_SetDMATrigger(uint8_t ch, DMA_TRIGSRC_T trig)
N{
N	LPC_INMUX->DMA_ITRIG_INMUX[ch] = (uint32_t) trig;
X	((LPC_INMUX_T *) 0x40005000UL)->DMA_ITRIG_INMUX[ch] = (uint32_t) trig;
N}
N
N/**
N * @brief	Selects a DMA trigger source for the DMATRIG_OUTMUXn IDs
N * @param	index	: Select 0 to 3 to sets the source for DMATRIG_OUTMUX0 to DMATRIG_OUTMUX3
N * @param	dmaCh	: DMA channel to select for DMATRIG_OUTMUXn source
N * @return	Nothing
N * @note	This function sets the DMA trigger (out) source used with the DMATRIG_OUTMUXn
N *			trigger source.
N */
N__STATIC_INLINE void Chip_INMUX_SetDMAOutMux(uint8_t index, uint8_t dmaCh)
Xstatic __inline void Chip_INMUX_SetDMAOutMux(uint8_t index, uint8_t dmaCh)
N{
N	LPC_INMUX->DMA_OTRIG_INMUX[index] = (uint32_t) dmaCh;
X	((LPC_INMUX_T *) 0x40005000UL)->DMA_OTRIG_INMUX[index] = (uint32_t) dmaCh;
N}
N
N/* Freqeuency measure reference and target clock sources */
Ntypedef enum {
N	FREQMSR_CLKIN = 0,				/*!< CLKIN pin */
N	FREQMSR_FRO12MHZ,				/*!< FRO 12-MHz */
N	FREQMSR_WDOSC,					/*!< Watchdog oscillator */
N	FREQMSR_32KHZOSC,				/*!< 32KHz (RTC) oscillator rate */
N	FREQ_MEAS_MAIN_CLK,				/*!< main system clock */
N	FREQMSR_PIO0_4,					/*!< External pin PIO0_4 as input rate */
N	FREQMSR_PIO0_20,				/*!< External pin PIO0_20 as input rate */
N	FREQMSR_PIO0_24,				/*!< External pin PIO0_24 as input rate */
N	FREQMSR_PIO1_4					/*!< External pin PIO1_4 as input rate */
N} FREQMSR_SRC_T;
N
N/**
N * @brief	Selects a reference clock used with the frequency measure function
N * @param	ref	: Frequency measure function reference clock
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_INMUX_SetFreqMeasRefClock(FREQMSR_SRC_T ref)
Xstatic __inline void Chip_INMUX_SetFreqMeasRefClock(FREQMSR_SRC_T ref)
N{
N	LPC_INMUX->FREQMEAS_REF = (uint32_t) ref;
X	((LPC_INMUX_T *) 0x40005000UL)->FREQMEAS_REF = (uint32_t) ref;
N}
N
N/**
N * @brief	Selects a target clock used with the frequency measure function
N * @param	targ	: Frequency measure function reference clock
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_INMUX_SetFreqMeasTargClock(FREQMSR_SRC_T targ)
Xstatic __inline void Chip_INMUX_SetFreqMeasTargClock(FREQMSR_SRC_T targ)
N{
N	LPC_INMUX->FREQMEAS_TARGET = (uint32_t) targ;
X	((LPC_INMUX_T *) 0x40005000UL)->FREQMEAS_TARGET = (uint32_t) targ;
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __INMUX_5411X_H_ */
L 184 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "crc_5411x.h"
L 1 "..\..\..\chip_5411x\inc\crc_5411x.h" 1
N/*
N * @brief LPC5411X Cyclic Redundancy Check (CRC) Engine driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __CRC_5411X_H_
N#define __CRC_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup CRC_5411X CHIP: LPC5411X Cyclic Redundancy Check Engine driver
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/**
N * @brief CRC register block structure
N */
Ntypedef struct {					/*!< CRC Structure */
N	__IO    uint32_t    MODE;		/*!< CRC Mode Register */
X	volatile    uint32_t    MODE;		 
N	__IO    uint32_t    SEED;		/*!< CRC SEED Register */
X	volatile    uint32_t    SEED;		 
N	union {
N		__I     uint32_t    SUM;	/*!< CRC Checksum Register. */
X		volatile const     uint32_t    SUM;	 
N		__O     uint32_t    WRDATA32;	/*!< CRC Data Register: write size 32-bit*/
X		volatile     uint32_t    WRDATA32;	 
N		__O     uint16_t    WRDATA16;	/*!< CRC Data Register: write size 16-bit*/
X		volatile     uint16_t    WRDATA16;	 
N		__O     uint8_t     WRDATA8;	/*!< CRC Data Register: write size 8-bit*/
X		volatile     uint8_t     WRDATA8;	 
N	};
N
N} LPC_CRC_T;
N
N/*
N * @brief CRC MODE register description
N */
N#define CRC_MODE_POLY_BITMASK   ((0x03))	/** CRC polynomial Bit mask */
N#define CRC_MODE_POLY_CCITT     (0x00)		/** Select CRC-CCITT polynomial */
N#define CRC_MODE_POLY_CRC16     (0x01)		/** Select CRC-16 polynomial */
N#define CRC_MODE_POLY_CRC32     (0x02)		/** Select CRC-32 polynomial */
N#define CRC_MODE_WRDATA_BITMASK (0x03 << 2)	/** CRC WR_Data Config Bit mask */
N#define CRC_MODE_WRDATA_BIT_RVS (1 << 2)	/** Select Bit order reverse for WR_DATA (per byte) */
N#define CRC_MODE_WRDATA_CMPL    (1 << 3)	/** Select One's complement for WR_DATA */
N#define CRC_MODE_SUM_BITMASK    (0x03 << 4)	/** CRC Sum Config Bit mask */
N#define CRC_MODE_SUM_BIT_RVS    (1 << 4)	/** Select Bit order reverse for CRC_SUM */
N#define CRC_MODE_SUM_CMPL       (1 << 5)	/** Select One's complement for CRC_SUM */
N
N#define MODE_CFG_CCITT          (0x00)	/** Pre-defined mode word for default CCITT setup */
N#define MODE_CFG_CRC16          (0x15)	/** Pre-defined mode word for default CRC16 setup */
N#define MODE_CFG_CRC32          (0x36)	/** Pre-defined mode word for default CRC32 setup */
N
N#define CRC_SEED_CCITT          (0x0000FFFF)/** Initial seed value for CCITT mode */
N#define CRC_SEED_CRC16          (0x00000000)/** Initial seed value for CRC16 mode */
N#define CRC_SEED_CRC32          (0xFFFFFFFF)/** Initial seed value for CRC32 mode */
N
N/**
N * @brief CRC polynomial
N */
Ntypedef enum IP_CRC_001_POLY {
N	CRC_POLY_CCITT = CRC_MODE_POLY_CCITT,	/**< CRC-CCIT polynomial */
X	CRC_POLY_CCITT = (0x00),	 
N	CRC_POLY_CRC16 = CRC_MODE_POLY_CRC16,	/**< CRC-16 polynomial */
X	CRC_POLY_CRC16 = (0x01),	 
N	CRC_POLY_CRC32 = CRC_MODE_POLY_CRC32,	/**< CRC-32 polynomial */
X	CRC_POLY_CRC32 = (0x02),	 
N	CRC_POLY_LAST,
N} CRC_POLY_T;
N
N/**
N * @brief	Initializes the CRC Engine
N * @param   pCRC	: Pointer to the crc register block
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_CRC_Init(LPC_CRC_T *pCRC)
Xstatic __inline void Chip_CRC_Init(LPC_CRC_T *pCRC)
N{
N	switch ((uint32_t) pCRC) {
N		case LPC_CRC_BASE:
X		case 0x40095000UL:
N			Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_CRC);
N			Chip_SYSCON_PeriphReset(RESET_CRC);
N			break;
N		default:
N			/* BUG: Application called this API with wrong base address */
N			break;
N	}
N}
N
N/**
N * @brief	Deinitializes the CRC Engine
N * @param   pCRC	: Pointer to the crc register block
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_CRC_Deinit(LPC_CRC_T *pCRC)
Xstatic __inline void Chip_CRC_Deinit(LPC_CRC_T *pCRC)
N{
N	switch ((uint32_t) pCRC) {
N		case LPC_CRC_BASE:
X		case 0x40095000UL:
N			Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_CRC);
N			break;
N		default:
N			/* BUG: Application called this API with wrong base address */
N			break;
N	}
N}
N
N/**
N * @brief	Set the polynomial used for the CRC calculation
N * @param   pCRC	: Pointer to the crc register block
N * @param	poly	: The enumerated polynomial to be used
N * @param	flags	: An Or'ed value of flags that setup the mode
N * @return	Nothing
N * @note	Flags for setting up the mode word include CRC_MODE_WRDATA_BIT_RVS,
N * CRC_MODE_WRDATA_CMPL, CRC_MODE_SUM_BIT_RVS, and CRC_MODE_SUM_CMPL.
N */
N__STATIC_INLINE void Chip_CRC_SetPoly(LPC_CRC_T *pCRC, CRC_POLY_T poly, uint32_t flags)
Xstatic __inline void Chip_CRC_SetPoly(LPC_CRC_T *pCRC, CRC_POLY_T poly, uint32_t flags)
N{
N	pCRC->MODE = (uint32_t) poly | flags;
N}
N
N/**
N * @brief	Sets up the CRC engine for CRC16 mode
N * @param   pCRC	: Pointer to the crc register block
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_CRC_UseCRC16(LPC_CRC_T *pCRC)
Xstatic __inline void Chip_CRC_UseCRC16(LPC_CRC_T *pCRC)
N{
N	pCRC->MODE = MODE_CFG_CRC16;
X	pCRC->MODE = (0x15);
N	pCRC->SEED = CRC_SEED_CRC16;
X	pCRC->SEED = (0x00000000);
N}
N
N/**
N * @brief	Sets up the CRC engine for CRC32 mode
N * @param   pCRC	: Pointer to the crc register block
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_CRC_UseCRC32(LPC_CRC_T *pCRC)
Xstatic __inline void Chip_CRC_UseCRC32(LPC_CRC_T *pCRC)
N{
N	pCRC->MODE = MODE_CFG_CRC32;
X	pCRC->MODE = (0x36);
N	pCRC->SEED = CRC_SEED_CRC32;
X	pCRC->SEED = (0xFFFFFFFF);
N}
N
N/**
N * @brief	Sets up the CRC engine for CCITT mode
N * @param   pCRC	: Pointer to the crc register block
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_CRC_UseCCITT(LPC_CRC_T *pCRC)
Xstatic __inline void Chip_CRC_UseCCITT(LPC_CRC_T *pCRC)
N{
N	pCRC->MODE = MODE_CFG_CCITT;
X	pCRC->MODE = (0x00);
N	pCRC->SEED = CRC_SEED_CCITT;
X	pCRC->SEED = (0x0000FFFF);
N}
N
N/**
N * @brief	Engage the CRC engine with defaults based on the polynomial to be used
N * @param   pCRC	: Pointer to the crc register block
N * @param	poly	: The enumerated polynomial to be used
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_CRC_UseDefaultConfig(LPC_CRC_T *pCRC, CRC_POLY_T poly)
Xstatic __inline void Chip_CRC_UseDefaultConfig(LPC_CRC_T *pCRC, CRC_POLY_T poly)
N{
N	switch (poly) {
N	case CRC_POLY_CRC16:
N		Chip_CRC_UseCRC16(pCRC);
N		break;
N
N	case CRC_POLY_CRC32:
N		Chip_CRC_UseCRC32(pCRC);
N		break;
N
N	case CRC_POLY_CCITT:
N	default:
N		Chip_CRC_UseCCITT(pCRC);
N		break;
N	}
N}
N
N/**
N * @brief	Set the CRC Mode bits
N * @param   pCRC	: Pointer to the crc register block
N * @param	mode	: Mode value
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_CRC_SetMode(LPC_CRC_T *pCRC, uint32_t mode)
Xstatic __inline void Chip_CRC_SetMode(LPC_CRC_T *pCRC, uint32_t mode)
N{
N	pCRC->MODE = mode;
N}
N
N/**
N * @brief	Get the CRC Mode bits
N * @param   pCRC	: Pointer to the crc register block
N * @return	The current value of the CRC Mode bits
N */
N__STATIC_INLINE uint32_t Chip_CRC_GetMode(LPC_CRC_T *pCRC)
Xstatic __inline uint32_t Chip_CRC_GetMode(LPC_CRC_T *pCRC)
N{
N	return pCRC->MODE;
N}
N
N/**
N * @brief	Set the seed bits used by the CRC_SUM register
N * @param   pCRC	: Pointer to the crc register block
N * @param	seed	: Seed value
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_CRC_SetSeed(LPC_CRC_T *pCRC, uint32_t seed)
Xstatic __inline void Chip_CRC_SetSeed(LPC_CRC_T *pCRC, uint32_t seed)
N{
N	pCRC->SEED = seed;
N}
N
N/**
N * @brief	Get the CRC seed value
N * @param   pCRC	: Pointer to the crc register block
N * @return	Seed value
N */
N__STATIC_INLINE uint32_t Chip_CRC_GetSeed(LPC_CRC_T *pCRC)
Xstatic __inline uint32_t Chip_CRC_GetSeed(LPC_CRC_T *pCRC)
N{
N	return pCRC->SEED;
N}
N
N/**
N * @brief	Convenience function for writing 8-bit data to the CRC engine
N * @param   pCRC	: Pointer to the crc register block
N * @param	data	: 8-bit data to write
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_CRC_Write8(LPC_CRC_T *pCRC, uint8_t data)
Xstatic __inline void Chip_CRC_Write8(LPC_CRC_T *pCRC, uint8_t data)
N{
N	pCRC->WRDATA8 = data;
N}
N
N/**
N * @brief	Convenience function for writing 16-bit data to the CRC engine
N * @param   pCRC	: Pointer to the crc register block
N * @param	data	: 16-bit data to write
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_CRC_Write16(LPC_CRC_T *pCRC, uint16_t data)
Xstatic __inline void Chip_CRC_Write16(LPC_CRC_T *pCRC, uint16_t data)
N{
N	pCRC->WRDATA16 = data;
N}
N
N/**
N * @brief	Convenience function for writing 32-bit data to the CRC engine
N * @param   pCRC	: Pointer to the crc register block
N * @param	data	: 32-bit data to write
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_CRC_Write32(LPC_CRC_T *pCRC, uint32_t data)
Xstatic __inline void Chip_CRC_Write32(LPC_CRC_T *pCRC, uint32_t data)
N{
N	pCRC->WRDATA32 = data;
N}
N
N/**
N * @brief	Gets the CRC Sum based on the Mode and Seed as previously configured
N * @param   pCRC	: Pointer to the crc register block
N * @return	CRC Checksum value
N */
N__STATIC_INLINE uint32_t Chip_CRC_Sum(LPC_CRC_T *pCRC)
Xstatic __inline uint32_t Chip_CRC_Sum(LPC_CRC_T *pCRC)
N{
N	return pCRC->SUM;
N}
N
N/**
N * @brief	Convenience function for computing a standard CCITT checksum from an 8-bit data block
N * @param   pCRC	: Pointer to the crc register block
N * @param	data	: Pointer to the block of 8-bit data
N * @param   bytes	: The number of bytes pointed to by data
N * @return	Check sum value
N */
N__STATIC_INLINE uint32_t Chip_CRC_CRC8(LPC_CRC_T *pCRC, const uint8_t *data, uint32_t bytes)
Xstatic __inline uint32_t Chip_CRC_CRC8(LPC_CRC_T *pCRC, const uint8_t *data, uint32_t bytes)
N{
N	Chip_CRC_UseCCITT(pCRC);
N	while (bytes > 0) {
N		Chip_CRC_Write8(pCRC, *data);
N		data++;
N		bytes--;
N	}
N
N	return Chip_CRC_Sum(pCRC);
N}
N
N/**
N * @brief	Convenience function for computing a standard CRC16 checksum from 16-bit data block
N * @param   pCRC	: Pointer to the crc register block
N * @param	data	: Pointer to the block of 16-bit data
N * @param   hwords	: The number of 16 byte entries pointed to by data
N * @return	Check sum value
N */
N__STATIC_INLINE uint32_t Chip_CRC_CRC16(LPC_CRC_T *pCRC, const uint16_t *data, uint32_t hwords)
Xstatic __inline uint32_t Chip_CRC_CRC16(LPC_CRC_T *pCRC, const uint16_t *data, uint32_t hwords)
N{
N	Chip_CRC_UseCRC16(pCRC);
N	while (hwords > 0) {
N		Chip_CRC_Write16(pCRC, *data);
N		data++;
N		hwords--;
N	}
N
N	return Chip_CRC_Sum(pCRC);
N}
N
N/**
N * @brief	Convenience function for computing a standard CRC32 checksum from 32-bit data block
N * @param   pCRC	: Pointer to the crc register block
N * @param	data	: Pointer to the block of 32-bit data
N * @param   words	: The number of 32-bit entries pointed to by data
N * @return	Check sum value
N */
N__STATIC_INLINE uint32_t Chip_CRC_CRC32(LPC_CRC_T *pCRC, const uint32_t *data, uint32_t words)
Xstatic __inline uint32_t Chip_CRC_CRC32(LPC_CRC_T *pCRC, const uint32_t *data, uint32_t words)
N{
N	Chip_CRC_UseCRC32(pCRC);
N	while (words > 0) {
N		Chip_CRC_Write32(pCRC, *data);
N		data++;
N		words--;
N	}
N
N	return Chip_CRC_Sum(pCRC);
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CRC_5411X_H_ */
L 185 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "gpio_5411x.h"
L 1 "..\..\..\chip_5411x\inc\gpio_5411x.h" 1
N/*
N * @brief LPC5411X GPIO driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __GPIO_5411X_H_
N#define __GPIO_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup GPIO_5411X CHIP: LPC5411X GPIO driver
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/**
N * @brief  GPIO port register block structure
N */
Ntypedef struct {				/*!< GPIO_PORT Structure */
N	__IO uint8_t B[128][32];	/*!< Offset 0x0000: Byte pin registers ports 0 to n; pins PIOn_0 to PIOn_31 */
X	volatile uint8_t B[128][32];	 
N	__IO uint32_t W[32][32];	/*!< Offset 0x1000: Word pin registers port 0 to n */
X	volatile uint32_t W[32][32];	 
N	__IO uint32_t DIR[32];		/*!< Offset 0x2000: Direction registers port n */
X	volatile uint32_t DIR[32];		 
N	__IO uint32_t MASK[32];		/*!< Offset 0x2080: Mask register port n */
X	volatile uint32_t MASK[32];		 
N	__IO uint32_t PIN[32];		/*!< Offset 0x2100: Portpin register port n */
X	volatile uint32_t PIN[32];		 
N	__IO uint32_t MPIN[32];		/*!< Offset 0x2180: Masked port register port n */
X	volatile uint32_t MPIN[32];		 
N	__IO uint32_t SET[32];		/*!< Offset 0x2200: Write: Set register for port n Read: output bits for port n */
X	volatile uint32_t SET[32];		 
N	__O  uint32_t CLR[32];		/*!< Offset 0x2280: Clear port n */
X	volatile  uint32_t CLR[32];		 
N	__O  uint32_t NOT[32];		/*!< Offset 0x2300: Toggle port n */
X	volatile  uint32_t NOT[32];		 
N} LPC_GPIO_T;
N
N/**
N * @brief	Initialize GPIO block
N * @param	pGPIO	: The base of GPIO peripheral on the chip (not used)
N * @return	Nothing
N * @note	@a pGPIO parameter is ignored and all available GPIOs
N * will be turned on by default.
N */
N__STATIC_INLINE void Chip_GPIO_Init(LPC_GPIO_T *pGPIO)
Xstatic __inline void Chip_GPIO_Init(LPC_GPIO_T *pGPIO)
N{
N	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_GPIO0);
N	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_GPIO1);
N	Chip_SYSCON_PeriphReset(RESET_GPIO0);
N	Chip_SYSCON_PeriphReset(RESET_GPIO1);
N}
N
N/**
N * @brief	De-Initialize GPIO block
N * @param	pGPIO	: The base of GPIO peripheral on the chip (not used)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_GPIO_DeInit(LPC_GPIO_T *pGPIO)
Xstatic __inline void Chip_GPIO_DeInit(LPC_GPIO_T *pGPIO)
N{
N	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_GPIO0);
N	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_GPIO1);
N}
N
N/**
N * @brief	Set a GPIO port/pin state
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: GPIO port to set
N * @param	pin		: GPIO pin to set
N * @param	setting	: true for high, false for low
N * @return	Nothing
N * @note	It is recommended to use the Chip_GPIO_SetPinState() function instead.
N */
N__STATIC_INLINE void Chip_GPIO_WritePortBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t pin, bool setting)
Xstatic __inline void Chip_GPIO_WritePortBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t pin, _Bool setting)
N{
N	pGPIO->B[port][pin] = setting;
N}
N
N/**
N * @brief	Set a GPIO pin state via the GPIO byte register
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: GPIO port to set
N * @param	pin		: GPIO pin to set
N * @param	setting	: true for high, false for low
N * @return	Nothing
N * @note	This function replaces Chip_GPIO_WritePortBit()
N */
N__STATIC_INLINE void Chip_GPIO_SetPinState(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin, bool setting)
Xstatic __inline void Chip_GPIO_SetPinState(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin, _Bool setting)
N{
N	pGPIO->B[port][pin] = setting;
N}
N
N/**
N * @brief	Read a GPIO pin state via the GPIO byte register
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: GPIO port to read
N * @param	pin		: GPIO pin to read
N * @return	true if the GPIO pin is high, false if low
N * @note	It is recommended to use the Chip_GPIO_GetPinState() function instead.
N */
N__STATIC_INLINE bool Chip_GPIO_ReadPortBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t pin)
Xstatic __inline _Bool Chip_GPIO_ReadPortBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t pin)
N{
N	return (bool) pGPIO->B[port][pin];
X	return (_Bool) pGPIO->B[port][pin];
N}
N
N/**
N * @brief	Get a GPIO pin state via the GPIO byte register
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: GPIO port to read
N * @param	pin		: GPIO pin to get state for
N * @return	true if the GPIO is high, false if low
N * @note	This function replaces Chip_GPIO_ReadPortBit()
N */
N__STATIC_INLINE bool Chip_GPIO_GetPinState(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
Xstatic __inline _Bool Chip_GPIO_GetPinState(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
N{
N	return (bool) pGPIO->B[port][pin];
X	return (_Bool) pGPIO->B[port][pin];
N}
N
N/**
N * @brief	Set GPIO direction for a single GPIO pin
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: GPIO port to set
N * @param	pin		: GPIO pin to set
N * @param	setting	: true for output, false for input
N * @return	Nothing
N * @note	It is recommended to use the Chip_GPIO_SetPinDIROutput(),
N * Chip_GPIO_SetPinDIRInput() or Chip_GPIO_SetPinDIR() functions instead
N * of this function.
N */
N__STATIC_INLINE void Chip_GPIO_WriteDirBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t pin, bool setting)
Xstatic __inline void Chip_GPIO_WriteDirBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t pin, _Bool setting)
N{
N	if (setting) {
N		pGPIO->DIR[port] |= 1UL << pin;
N	}
N	else {
N		pGPIO->DIR[port] &= ~(1UL << pin);
N	}
N}
N
N/**
N * @brief	Set GPIO direction for a single GPIO pin to an output
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: GPIO port to set
N * @param	pin		: GPIO pin to set direction on as output
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_GPIO_SetPinDIROutput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
Xstatic __inline void Chip_GPIO_SetPinDIROutput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
N{
N	pGPIO->DIR[port] |= 1UL << pin;
N}
N
N/**
N * @brief	Set GPIO direction for a single GPIO pin to an input
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: GPIO port to set
N * @param	pin		: GPIO pin to set direction on as input
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_GPIO_SetPinDIRInput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
Xstatic __inline void Chip_GPIO_SetPinDIRInput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
N{
N	pGPIO->DIR[port] &= ~(1UL << pin);
N}
N
N/**
N * @brief	Set GPIO direction for a single GPIO pin
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: GPIO port to set
N * @param	pin		: GPIO pin to set direction for
N * @param	output	: true for output, false for input
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_GPIO_SetPinDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin, bool output)
Xstatic __inline void Chip_GPIO_SetPinDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin, _Bool output)
N{
N	if (output) {
N		Chip_GPIO_SetPinDIROutput(pGPIO, port, pin);
N	}
N	else {
N		Chip_GPIO_SetPinDIRInput(pGPIO, port, pin);
N	}
N}
N
N/**
N * @brief	Read a GPIO direction (out or in)
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: GPIO port to read
N * @param	bit		: GPIO bit direction to read
N * @return	true if the GPIO is an output, false if input
N * @note	It is recommended to use the Chip_GPIO_GetPinDIR() function instead.
N */
N__STATIC_INLINE bool Chip_GPIO_ReadDirBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t bit)
Xstatic __inline _Bool Chip_GPIO_ReadDirBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t bit)
N{
N	return (bool) (((pGPIO->DIR[port]) >> bit) & 1);
X	return (_Bool) (((pGPIO->DIR[port]) >> bit) & 1);
N}
N
N/**
N * @brief	Get GPIO direction for a single GPIO pin
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: GPIO port to read (supports port 0 only)
N * @param	pin		: GPIO pin to get direction for
N * @return	true if the GPIO is an output, false if input
N */
N__STATIC_INLINE bool Chip_GPIO_GetPinDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
Xstatic __inline _Bool Chip_GPIO_GetPinDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
N{
N	return Chip_GPIO_ReadDirBit(pGPIO, port, pin);
N}
N
N/**
N * @brief	Set Direction for a GPIO port
N * @param	pGPIO		: The base of GPIO peripheral on the chip
N * @param	portNum		: port Number
N * @param	bitValue	: GPIO bit to set
N * @param	out			: Direction value, 0 = input, !0 = output
N * @return	None
N * @note	Bits set to '0' are not altered. It is recommended to use the
N * Chip_GPIO_SetPortDIR() function instead.
N */
N__STATIC_INLINE void Chip_GPIO_SetDir(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue, uint8_t out)
Xstatic __inline void Chip_GPIO_SetDir(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue, uint8_t out)
N{
N	if (out) {
N		pGPIO->DIR[portNum] |= bitValue;
N	}
N	else {
N		pGPIO->DIR[portNum] &= ~bitValue;
N	}
N}
N
N/**
N * @brief	Set GPIO direction for a all selected GPIO pins to an output
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number
N * @param	pinMask	: GPIO pin mask to set direction on as output (bits 0..b for pins 0..n)
N * @return	Nothing
N * @note	Sets multiple GPIO pins to the output direction, each bit's position that is
N * high sets the corresponding pin number for that bit to an output.
N */
N__STATIC_INLINE void Chip_GPIO_SetPortDIROutput(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pinMask)
Xstatic __inline void Chip_GPIO_SetPortDIROutput(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pinMask)
N{
N	pGPIO->DIR[port] |= pinMask;
N}
N
N/**
N * @brief	Set GPIO direction for a all selected GPIO pins to an input
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number
N * @param	pinMask	: GPIO pin mask to set direction on as input (bits 0..b for pins 0..n)
N * @return	Nothing
N * @note	Sets multiple GPIO pins to the input direction, each bit's position that is
N * high sets the corresponding pin number for that bit to an input.
N */
N__STATIC_INLINE void Chip_GPIO_SetPortDIRInput(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pinMask)
Xstatic __inline void Chip_GPIO_SetPortDIRInput(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pinMask)
N{
N	pGPIO->DIR[port] &= ~pinMask;
N}
N
N/**
N * @brief	Set GPIO direction for a all selected GPIO pins to an input or output
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number
N * @param	pinMask	: GPIO pin mask to set direction on (bits 0..b for pins 0..n)
N * @param	outSet	: Direction value, false = set as inputs, true = set as outputs
N * @return	Nothing
N * @note	Sets multiple GPIO pins to the input direction, each bit's position that is
N * high sets the corresponding pin number for that bit to an input.
N */
N__STATIC_INLINE void Chip_GPIO_SetPortDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pinMask, bool outSet)
Xstatic __inline void Chip_GPIO_SetPortDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pinMask, _Bool outSet)
N{
N	if (outSet) {
N		Chip_GPIO_SetPortDIROutput(pGPIO, port, pinMask);
N	}
N	else {
N		Chip_GPIO_SetPortDIRInput(pGPIO, port, pinMask);
N	}
N}
N
N/**
N * @brief	Get GPIO direction for a all GPIO pins
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number
N * @return	a bitfield containing the input and output states for each pin
N * @note	For pins 0..n, a high state in a bit corresponds to an output state for the
N * same pin, while a low  state corresponds to an input state.
N */
N__STATIC_INLINE uint32_t Chip_GPIO_GetPortDIR(LPC_GPIO_T *pGPIO, uint8_t port)
Xstatic __inline uint32_t Chip_GPIO_GetPortDIR(LPC_GPIO_T *pGPIO, uint8_t port)
N{
N	return pGPIO->DIR[port];
N}
N
N/**
N * @brief	Set GPIO port mask value for GPIO masked read and write
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	mask	: Mask value for read and write
N * @return	Nothing
N * @note	Controls which bits corresponding to PIO0_n are active in the P0MPORT
N * register (bit 0 = PIO0_0, bit 1 = PIO0_1, ..., bit 17 = PIO0_17).
N */
N__STATIC_INLINE void Chip_GPIO_SetPortMask(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t mask)
Xstatic __inline void Chip_GPIO_SetPortMask(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t mask)
N{
N	pGPIO->MASK[port] = mask;
N}
N
N/**
N * @brief	Get GPIO port mask value used for GPIO masked read and write
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @return	Returns value set with the Chip_GPIO_SetPortMask() function.
N */
N__STATIC_INLINE uint32_t Chip_GPIO_GetPortMask(LPC_GPIO_T *pGPIO, uint8_t port)
Xstatic __inline uint32_t Chip_GPIO_GetPortMask(LPC_GPIO_T *pGPIO, uint8_t port)
N{
N	return pGPIO->MASK[port];
N}
N
N/**
N * @brief	Set all GPIO raw pin states (regardless of masking)
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	value	: Value to set all GPIO pin states (0..n) to
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_GPIO_SetPortValue(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t value)
Xstatic __inline void Chip_GPIO_SetPortValue(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t value)
N{
N	pGPIO->PIN[port] = value;
N}
N
N/**
N * @brief	Get all GPIO raw pin states (regardless of masking)
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @return	Current (raw) state of all GPIO pins
N */
N__STATIC_INLINE uint32_t Chip_GPIO_GetPortValue(LPC_GPIO_T *pGPIO, uint8_t port)
Xstatic __inline uint32_t Chip_GPIO_GetPortValue(LPC_GPIO_T *pGPIO, uint8_t port)
N{
N	return pGPIO->PIN[port];
N}
N
N/**
N * @brief	Set all GPIO pin states, but mask via the MASKP0 register
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	value	: Value to set all GPIO pin states (0..n) to
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_GPIO_SetMaskedPortValue(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t value)
Xstatic __inline void Chip_GPIO_SetMaskedPortValue(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t value)
N{
N	pGPIO->MPIN[port] = value;
N}
N
N/**
N * @brief	Get all GPIO pin statesm but mask via the MASKP0 register
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @return	Current (masked) state of all GPIO pins
N */
N__STATIC_INLINE uint32_t Chip_GPIO_GetMaskedPortValue(LPC_GPIO_T *pGPIO, uint8_t port)
Xstatic __inline uint32_t Chip_GPIO_GetMaskedPortValue(LPC_GPIO_T *pGPIO, uint8_t port)
N{
N	return pGPIO->MPIN[port];
N}
N
N/**
N * @brief	Set a GPIO port/bit to the high state
N * @param	pGPIO		: The base of GPIO peripheral on the chip
N * @param	portNum		: port number (supports port 0 only)
N * @param	bitValue	: bit(s) in the port to set high
N * @return	None
N * @note	Any bit set as a '0' will not have it's state changed. This only
N * applies to ports configured as an output. It is recommended to use the
N * Chip_GPIO_SetPortOutHigh() function instead.
N */
N__STATIC_INLINE void Chip_GPIO_SetValue(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue)
Xstatic __inline void Chip_GPIO_SetValue(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue)
N{
N	pGPIO->SET[portNum] = bitValue;
N}
N
N/**
N * @brief	Set selected GPIO output pins to the high state
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	pins	: pins (0..n) to set high
N * @return	None
N * @note	Any bit set as a '0' will not have it's state changed. This only
N * applies to ports configured as an output.
N */
N__STATIC_INLINE void Chip_GPIO_SetPortOutHigh(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pins)
Xstatic __inline void Chip_GPIO_SetPortOutHigh(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pins)
N{
N	pGPIO->SET[port] = pins;
N}
N
N/**
N * @brief	Set an individual GPIO output pin to the high state
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	pin		: pin number (0..n) to set high
N * @return	None
N * @note	Any bit set as a '0' will not have it's state changed. This only
N * applies to ports configured as an output.
N */
N__STATIC_INLINE void Chip_GPIO_SetPinOutHigh(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
Xstatic __inline void Chip_GPIO_SetPinOutHigh(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
N{
N	pGPIO->SET[port] = (1 << pin);
N}
N
N/**
N * @brief	Set a GPIO port/bit to the low state
N * @param	pGPIO		: The base of GPIO peripheral on the chip
N * @param	portNum		: port number (support port 0 only)
N * @param	bitValue	: bit(s) in the port to set low
N * @return	None
N * @note	Any bit set as a '0' will not have it's state changed. This only
N * applies to ports configured as an output. It is recommended to use the
N * Chip_GPIO_SetPortOutLow() function instead.
N */
N__STATIC_INLINE void Chip_GPIO_ClearValue(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue)
Xstatic __inline void Chip_GPIO_ClearValue(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue)
N{
N	pGPIO->CLR[portNum] = bitValue;
N}
N
N/**
N * @brief	Set selected GPIO output pins to the low state
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	pins	: pins (0..n) to set low
N * @return	None
N * @note	Any bit set as a '0' will not have it's state changed. This only
N * applies to ports configured as an output.
N */
N__STATIC_INLINE void Chip_GPIO_SetPortOutLow(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pins)
Xstatic __inline void Chip_GPIO_SetPortOutLow(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pins)
N{
N	pGPIO->CLR[port] = pins;
N}
N
N/**
N * @brief	Set an individual GPIO output pin to the low state
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	pin		: pin number (0..n) to set low
N * @return	None
N * @note	Any bit set as a '0' will not have it's state changed. This only
N * applies to ports configured as an output.
N */
N__STATIC_INLINE void Chip_GPIO_SetPinOutLow(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
Xstatic __inline void Chip_GPIO_SetPinOutLow(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
N{
N	pGPIO->CLR[port] = (1 << pin);
N}
N
N/**
N * @brief	Toggle selected GPIO output pins to the opposite state
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	pins	: pins (0..n) to toggle
N * @return	None
N * @note	Any bit set as a '0' will not have it's state changed. This only
N * applies to ports configured as an output.
N */
N__STATIC_INLINE void Chip_GPIO_SetPortToggle(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pins)
Xstatic __inline void Chip_GPIO_SetPortToggle(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pins)
N{
N	pGPIO->NOT[port] = pins;
N}
N
N/**
N * @brief	Toggle an individual GPIO output pin to the opposite state
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	port	: port Number (supports port 0 only)
N * @param	pin		: pin number (0..n) to toggle
N * @return	None
N * @note	Any bit set as a '0' will not have it's state changed. This only
N * applies to ports configured as an output.
N */
N__STATIC_INLINE void Chip_GPIO_SetPinToggle(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
Xstatic __inline void Chip_GPIO_SetPinToggle(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
N{
N	pGPIO->NOT[port] = (1 << pin);
N}
N
N/**
N * @brief	Read current bit states for the selected port
N * @param	pGPIO	: The base of GPIO peripheral on the chip
N * @param	portNum	: port number to read (supports port 0 only)
N * @return	Current value of GPIO port
N * @note	The current states of the bits for the port are read, regardless of
N * whether the GPIO port bits are input or output. It is recommended to use the
N * Chip_GPIO_GetPortValue() function instead.
N */
N__STATIC_INLINE uint32_t Chip_GPIO_ReadValue(LPC_GPIO_T *pGPIO, uint8_t portNum)
Xstatic __inline uint32_t Chip_GPIO_ReadValue(LPC_GPIO_T *pGPIO, uint8_t portNum)
N{
N	return pGPIO->PIN[portNum];
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __GPIO_5411X_H_ */
L 186 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "mrt_5411x.h"
L 1 "..\..\..\chip_5411x\inc\mrt_5411x.h" 1
N/*
N * @brief LPC5411X Multi-Rate Timer (MRT) registers and driver functions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __MRT_5411X_H_
N#define __MRT_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup MRT_5411X CHIP: LPC5411X Multi-Rate Timer driver
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/**
N * @brief LPC5411X MRT chip configuration
N */
N#define MRT_CHANNELS_NUM      (4)
N#define MRT_NO_IDLE_CHANNEL   (0x40)
N
N/**
N * @brief MRT register block structure
N */
Ntypedef struct {
N	__IO uint32_t INTVAL;	/*!< Timer interval register */
X	volatile uint32_t INTVAL;	 
N	__O  uint32_t TIMER;	/*!< Timer register */
X	volatile  uint32_t TIMER;	 
N	__IO uint32_t CTRL;		/*!< Timer control register */
X	volatile uint32_t CTRL;		 
N	__IO uint32_t STAT;		/*!< Timer status register */
X	volatile uint32_t STAT;		 
N} LPC_MRT_CH_T;
N
N/**
N * @brief MRT register block structure
N */
Ntypedef struct {
N	LPC_MRT_CH_T CHANNEL[MRT_CHANNELS_NUM];
X	LPC_MRT_CH_T CHANNEL[(4)];
N	uint32_t unused[44];
N	__IO uint32_t MODCFG;
X	volatile uint32_t MODCFG;
N	__O  uint32_t IDLE_CH;
X	volatile  uint32_t IDLE_CH;
N	__IO uint32_t IRQ_FLAG;
X	volatile uint32_t IRQ_FLAG;
N} LPC_MRT_T;
N
N/**
N * @brief MRT Interrupt Modes enum
N */
Ntypedef enum MRT_MODE {
N	MRT_MODE_REPEAT =  (0 << 1),	/*!< MRT Repeat interrupt mode */
N	MRT_MODE_ONESHOT = (1 << 1)		/*!< MRT One-shot interrupt mode */
N} MRT_MODE_T;
N
N/**
N * @brief MRT register bit fields & masks
N */
N/* MRT Time interval register bit fields */
N#define MRT_INTVAL_IVALUE        (0xFFFFFF)		/* Maximum interval load value and mask */
N#define MRT_INTVAL_LOAD          (0x80000000UL)	/* Force immediate load of timer interval register bit */
N
N/* MRT Control register bit fields & masks */
N#define MRT_CTRL_INTEN_MASK      (0x01)
N#define MRT_CTRL_MODE_MASK       (0x06)
N
N/* MRT Status register bit fields & masks */
N#define MRT_STAT_INTFLAG         (0x01)
N#define MRT_STAT_RUNNING         (0x02)
N
N/* Pointer to individual MR register blocks */
N#define LPC_MRT_CH0         ((LPC_MRT_CH_T *) &LPC_MRT->CHANNEL[0])
N#define LPC_MRT_CH1         ((LPC_MRT_CH_T *) &LPC_MRT->CHANNEL[1])
N#define LPC_MRT_CH2         ((LPC_MRT_CH_T *) &LPC_MRT->CHANNEL[2])
N#define LPC_MRT_CH3         ((LPC_MRT_CH_T *) &LPC_MRT->CHANNEL[3])
N#define LPC_MRT_CH(ch)      ((LPC_MRT_CH_T *) &LPC_MRT->CHANNEL[(ch)])
N
N/* Global interrupt flag register interrupt mask/clear values */
N#define MRT0_INTFLAG        (1)
N#define MRT1_INTFLAG        (2)
N#define MRT2_INTFLAG        (4)
N#define MRT3_INTFLAG        (8)
N#define MRTn_INTFLAG(ch)    (1 << (ch))
N
N/**
N * @brief	Initializes the MRT
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_MRT_Init(void)
Xstatic __inline void Chip_MRT_Init(void)
N{
N	/* Enable the clock to the register interface */
N	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_MRT);
N
N	/* Reset MRT */
N	Chip_SYSCON_PeriphReset(RESET_MRT);
N}
N
N/**
N * @brief	De-initializes the MRT Channel
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_MRT_DeInit(void)
Xstatic __inline void Chip_MRT_DeInit(void)
N{
N	/* Disable the clock to the MRT */
N	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_MRT);
N}
N
N/**
N * @brief	Returns a pointer to the register block for a MRT channel
N * @param	ch	: MRT channel tog et register block for (0..3)
N * @return	Pointer to the MRT register block for the channel
N */
N__STATIC_INLINE LPC_MRT_CH_T *Chip_MRT_GetRegPtr(uint8_t ch)
Xstatic __inline LPC_MRT_CH_T *Chip_MRT_GetRegPtr(uint8_t ch)
N{
N	return LPC_MRT_CH(ch);
X	return ((LPC_MRT_CH_T *) &((LPC_MRT_T *) 0x4000D000UL)->CHANNEL[(ch)]);
N}
N
N/**
N * @brief	Returns the timer time interval value
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	Timer time interval value (IVALUE)
N */
N__STATIC_INLINE uint32_t Chip_MRT_GetInterval(LPC_MRT_CH_T *pMRT)
Xstatic __inline uint32_t Chip_MRT_GetInterval(LPC_MRT_CH_T *pMRT)
N{
N	return pMRT->INTVAL;
N}
N
N/**
N * @brief	Sets the timer time interval value
N * @param	pMRT	 : Pointer to selected MRT Channel
N * @param   interval : The interval timeout (31-bits)
N * @return	Nothing
N * @note	Setting bit 31 in timer time interval register causes the time interval value
N * to load immediately, otherwise the time interval value will be loaded in
N * next timer cycle.<br>
N * Example: Chip_MRT_SetInterval(pMRT, 0x500 | MRT_INTVAL_LOAD); // Will load timer interval immediately<br>
N * Example: Chip_MRT_SetInterval(pMRT, 0x500); // Will load timer interval after internal expires
N */
N__STATIC_INLINE void Chip_MRT_SetInterval(LPC_MRT_CH_T *pMRT, uint32_t interval)
Xstatic __inline void Chip_MRT_SetInterval(LPC_MRT_CH_T *pMRT, uint32_t interval)
N{
N	pMRT->INTVAL = interval;
N}
N
N/**
N * @brief	Returns the current timer value
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	The current timer value
N */
N__STATIC_INLINE uint32_t Chip_MRT_GetTimer(LPC_MRT_CH_T *pMRT)
Xstatic __inline uint32_t Chip_MRT_GetTimer(LPC_MRT_CH_T *pMRT)
N{
N	return pMRT->TIMER;
N}
N
N/**
N * @brief	Returns true if the timer is enabled
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	True if enabled, Flase if not enabled
N */
N__STATIC_INLINE bool Chip_MRT_GetEnabled(LPC_MRT_CH_T *pMRT)
Xstatic __inline _Bool Chip_MRT_GetEnabled(LPC_MRT_CH_T *pMRT)
N{
N	return (bool) ((pMRT->CTRL & MRT_CTRL_INTEN_MASK) != 0);
X	return (_Bool) ((pMRT->CTRL & (0x01)) != 0);
N}
N
N/**
N * @brief	Enables the timer
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_MRT_SetEnabled(LPC_MRT_CH_T *pMRT)
Xstatic __inline void Chip_MRT_SetEnabled(LPC_MRT_CH_T *pMRT)
N{
N	pMRT->CTRL |= MRT_CTRL_INTEN_MASK;
X	pMRT->CTRL |= (0x01);
N}
N
N/**
N * @brief	Disables the timer
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_MRT_SetDisabled(LPC_MRT_CH_T *pMRT)
Xstatic __inline void Chip_MRT_SetDisabled(LPC_MRT_CH_T *pMRT)
N{
N	pMRT->CTRL &= ~MRT_CTRL_INTEN_MASK;
X	pMRT->CTRL &= ~(0x01);
N}
N
N/**
N * @brief	Returns the timer mode (repeat or one-shot)
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	The current timer mode
N */
N__STATIC_INLINE MRT_MODE_T Chip_MRT_GetMode(LPC_MRT_CH_T *pMRT)
Xstatic __inline MRT_MODE_T Chip_MRT_GetMode(LPC_MRT_CH_T *pMRT)
N{
N	return (MRT_MODE_T) (pMRT->CTRL & MRT_CTRL_MODE_MASK);
X	return (MRT_MODE_T) (pMRT->CTRL & (0x06));
N}
N
N/**
N * @brief	Sets the timer mode (repeat or one-shot)
N * @param	pMRT	: Pointer to selected MRT Channel
N * @param   mode    : Timer mode
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_MRT_SetMode(LPC_MRT_CH_T *pMRT, MRT_MODE_T mode)
Xstatic __inline void Chip_MRT_SetMode(LPC_MRT_CH_T *pMRT, MRT_MODE_T mode)
N{
N	uint32_t reg;
N
N	reg = pMRT->CTRL & ~MRT_CTRL_MODE_MASK;
X	reg = pMRT->CTRL & ~(0x06);
N	pMRT->CTRL = reg | (uint32_t) mode;
N}
N
N/**
N * @brief	Check if the timer is configured in repeat mode
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	True if in repeat mode, False if in one-shot mode
N */
N__STATIC_INLINE bool Chip_MRT_IsRepeatMode(LPC_MRT_CH_T *pMRT)
Xstatic __inline _Bool Chip_MRT_IsRepeatMode(LPC_MRT_CH_T *pMRT)
N{
N	return ((pMRT->CTRL & MRT_CTRL_MODE_MASK) != 0) ? false : true;
X	return ((pMRT->CTRL & (0x06)) != 0) ? 0 : 1;
N}
N
N/**
N * @brief	Check if the timer is configured in one-shot mode
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	True if in one-shot mode, False if in repeat mode
N */
N__STATIC_INLINE bool Chip_MRT_IsOneShotMode(LPC_MRT_CH_T *pMRT)
Xstatic __inline _Bool Chip_MRT_IsOneShotMode(LPC_MRT_CH_T *pMRT)
N{
N	return ((pMRT->CTRL & MRT_CTRL_MODE_MASK) != 0) ? true : false;
X	return ((pMRT->CTRL & (0x06)) != 0) ? 1 : 0;
N}
N
N/**
N * @brief	Check if the timer has an interrupt pending
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	True if interrupt is pending, False if no interrupt is pending
N */
N__STATIC_INLINE bool Chip_MRT_IntPending(LPC_MRT_CH_T *pMRT)
Xstatic __inline _Bool Chip_MRT_IntPending(LPC_MRT_CH_T *pMRT)
N{
N	return (bool) ((pMRT->STAT & MRT_STAT_INTFLAG) != 0);
X	return (_Bool) ((pMRT->STAT & (0x01)) != 0);
N}
N
N/**
N * @brief	Clears the pending interrupt (if any)
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_MRT_IntClear(LPC_MRT_CH_T *pMRT)
Xstatic __inline void Chip_MRT_IntClear(LPC_MRT_CH_T *pMRT)
N{
N	pMRT->STAT |= MRT_STAT_INTFLAG;
X	pMRT->STAT |= (0x01);
N}
N
N/**
N * @brief	Check if the timer is running
N * @param	pMRT	: Pointer to selected MRT Channel
N * @return	True if running, False if stopped
N */
N__STATIC_INLINE bool Chip_MRT_Running(LPC_MRT_CH_T *pMRT)
Xstatic __inline _Bool Chip_MRT_Running(LPC_MRT_CH_T *pMRT)
N{
N	return (bool) ((pMRT->STAT & MRT_STAT_RUNNING) != 0);
X	return (_Bool) ((pMRT->STAT & (0x02)) != 0);
N}
N
N/**
N * @brief	Returns the IDLE channel value
N * @return	IDLE channel value (unshifted in bits 7..4)
N */
N__STATIC_INLINE uint8_t Chip_MRT_GetIdleChannel(void)
Xstatic __inline uint8_t Chip_MRT_GetIdleChannel(void)
N{
N	return (uint8_t) (LPC_MRT->IDLE_CH);
X	return (uint8_t) (((LPC_MRT_T *) 0x4000D000UL)->IDLE_CH);
N}
N
N/**
N * @brief	Returns the IDLE channel value
N * @return	IDLE channel value (shifted in bits 3..0)
N */
N__STATIC_INLINE uint8_t Chip_MRT_GetIdleChannelShifted(void)
Xstatic __inline uint8_t Chip_MRT_GetIdleChannelShifted(void)
N{
N	return (uint8_t) (Chip_MRT_GetIdleChannel() >> 4);
N}
N
N/**
N * @brief	Returns the interrupt pending status for all MRT channels
N * @return	IRQ pending channel bitfield(bit 0 = MRT0, bit 1 = MRT1, etc.)
N */
N__STATIC_INLINE uint32_t Chip_MRT_GetIntPending(void)
Xstatic __inline uint32_t Chip_MRT_GetIntPending(void)
N{
N	return LPC_MRT->IRQ_FLAG;
X	return ((LPC_MRT_T *) 0x4000D000UL)->IRQ_FLAG;
N}
N
N/**
N * @brief	Returns the interrupt pending status for a singel MRT channel
N * @param	ch	: Channel to check pending interrupt status for
N * @return	IRQ pending channel number
N */
N__STATIC_INLINE bool Chip_MRT_GetIntPendingByChannel(uint8_t ch)
Xstatic __inline _Bool Chip_MRT_GetIntPendingByChannel(uint8_t ch)
N{
N	return (bool) (((LPC_MRT->IRQ_FLAG >> ch) & 1) != 0);
X	return (_Bool) (((((LPC_MRT_T *) 0x4000D000UL)->IRQ_FLAG >> ch) & 1) != 0);
N}
N
N/**
N * @brief	Clears the interrupt pending status for one or more MRT channels
N * @param	mask	: Channels to clear (bit 0 = MRT0, bit 1 = MRT1, etc.)
N * @return	Nothing
N * @note	Use this function to clear multiple interrupt pending states in
N * a single call via the IRQ_FLAG register. Performs the same function for
N * all MRT channels in a single call as the Chip_MRT_IntClear() does for a
N * single channel.
N */
N__STATIC_INLINE void Chip_MRT_ClearIntPending(uint32_t mask)
Xstatic __inline void Chip_MRT_ClearIntPending(uint32_t mask)
N{
N	LPC_MRT->IRQ_FLAG = mask;
X	((LPC_MRT_T *) 0x4000D000UL)->IRQ_FLAG = mask;
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MRT_5411X_H_ */
L 187 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "wwdt_5411x.h"
L 1 "..\..\..\chip_5411x\inc\wwdt_5411x.h" 1
N/*
N * @brief LPC5411X WWDT chip driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __WWDT_5411X_H_
N#define __WWDT_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup LPC_WWDT CHIP: LPC5411X Windowed Watchdog driver
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/**
N * @brief Windowed Watchdog register block structure
N */
Ntypedef struct {				/*!< WWDT Structure         */
N	__IO uint32_t  MOD;			/*!< Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer. */
X	volatile uint32_t  MOD;			 
N	__IO uint32_t  TC;			/*!< Watchdog timer constant register. This register determines the time-out value. */
X	volatile uint32_t  TC;			 
N	__O  uint32_t  FEED;		/*!< Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC. */
X	volatile  uint32_t  FEED;		 
N	__I  uint32_t  TV;			/*!< Watchdog timer value register. This register reads out the current value of the Watchdog timer. */
X	volatile const  uint32_t  TV;			 
N	__I  uint32_t  RESERVED0;
X	volatile const  uint32_t  RESERVED0;
N	__IO uint32_t  WARNINT;		/*!< Watchdog warning interrupt register. This register contains the Watchdog warning interrupt compare value. */
X	volatile uint32_t  WARNINT;		 
N	__IO uint32_t  WINDOW;		/*!< Watchdog timer window register. This register contains the Watchdog window value. */
X	volatile uint32_t  WINDOW;		 
N} LPC_WWDT_T;
N
N/**
N * @brief Watchdog Mode register definitions
N */
N/** Watchdog Mode Bitmask */
N#define WWDT_WDMOD_BITMASK          ((uint32_t) 0x3F)
N/** WWDT enable bit */
N#define WWDT_WDMOD_WDEN             ((uint32_t) (1 << 0))
N/** WWDT reset enable bit */
N#define WWDT_WDMOD_WDRESET          ((uint32_t) (1 << 1))
N/** WWDT time-out flag bit */
N#define WWDT_WDMOD_WDTOF            ((uint32_t) (1 << 2))
N/** WWDT warning interrupt flag bit */
N#define WWDT_WDMOD_WDINT            ((uint32_t) (1 << 3))
N/** WWDT Protect flag bit */
N#define WWDT_WDMOD_WDPROTECT        ((uint32_t) (1 << 4))
N/** WWDT lock bit */
N#define WWDT_WDMOD_LOCK             ((uint32_t) (1 << 5))
N
N/**
N * @brief	Initialize the Watchdog timer
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @return	None
N */
N__STATIC_INLINE void Chip_WWDT_Init(LPC_WWDT_T *pWWDT)
Xstatic __inline void Chip_WWDT_Init(LPC_WWDT_T *pWWDT)
N{
N	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_WWDT);
N	Chip_SYSCON_PeriphReset(RESET_WWDT);
N
N	/* Disable watchdog */
N	pWWDT->MOD       = 0;
N	pWWDT->TC        = 0xFF;
N	pWWDT->WARNINT   = 0x3FF;
N	pWWDT->WINDOW    = 0xFFFFFF;
N}
N
N/**
N * @brief	Shutdown the Watchdog timer
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @return	None
N */
N__STATIC_INLINE void Chip_WWDT_DeInit(LPC_WWDT_T *pWWDT)
Xstatic __inline void Chip_WWDT_DeInit(LPC_WWDT_T *pWWDT)
N{
N	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_WWDT);
N}
N
N/**
N * @brief	Set WDT timeout constant value used for feed
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @param	timeout	: WDT timeout in ticks, between WWDT_TICKS_MIN and WWDT_TICKS_MAX
N * @return	none
N */
N__STATIC_INLINE void Chip_WWDT_SetTimeOut(LPC_WWDT_T *pWWDT, uint32_t timeout)
Xstatic __inline void Chip_WWDT_SetTimeOut(LPC_WWDT_T *pWWDT, uint32_t timeout)
N{
N	pWWDT->TC = timeout;
N}
N
N/**
N * @brief	Feed watchdog timer
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @return	None
N * @note	If this function isn't called, a watchdog timer warning will occur.
N * After the warning, a timeout will occur if a feed has happened.
N * Note that if WWDT registers are modified in an interrupt then it is a good
N * idea to prevent those interrupts when writing the feed sequence.
N */
N__STATIC_INLINE void Chip_WWDT_Feed(LPC_WWDT_T *pWWDT)
Xstatic __inline void Chip_WWDT_Feed(LPC_WWDT_T *pWWDT)
N{
N	pWWDT->FEED = 0xAA;
N	pWWDT->FEED = 0x55;
N}
N
N/**
N * @brief	Set WWDT warning interrupt
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @param	timeout	: WDT warning in ticks, between 0 and 1023
N * @return	None
N * @note	This is the number of ticks after the watchdog interrupt that the
N * warning interrupt will be generated.
N */
N__STATIC_INLINE void Chip_WWDT_SetWarning(LPC_WWDT_T *pWWDT, uint32_t timeout)
Xstatic __inline void Chip_WWDT_SetWarning(LPC_WWDT_T *pWWDT, uint32_t timeout)
N{
N	pWWDT->WARNINT = timeout;
N}
N
N/**
N * @brief	Get WWDT warning interrupt
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @return	WWDT warning interrupt
N */
N__STATIC_INLINE uint32_t Chip_WWDT_GetWarning(LPC_WWDT_T *pWWDT)
Xstatic __inline uint32_t Chip_WWDT_GetWarning(LPC_WWDT_T *pWWDT)
N{
N	return pWWDT->WARNINT;
N}
N
N/**
N * @brief	Set WWDT window time
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @param	timeout	: WDT timeout in ticks, between WWDT_TICKS_MIN and WWDT_TICKS_MAX
N * @return	None
N * @note	The watchdog timer must be fed between the timeout from the Chip_WWDT_SetTimeOut()
N * function and this function, with this function defining the last tick before the
N * watchdog window interrupt occurs.
N */
N__STATIC_INLINE void Chip_WWDT_SetWindow(LPC_WWDT_T *pWWDT, uint32_t timeout)
Xstatic __inline void Chip_WWDT_SetWindow(LPC_WWDT_T *pWWDT, uint32_t timeout)
N{
N	pWWDT->WINDOW = timeout;
N}
N
N/**
N * @brief	Get WWDT window time
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @return	WWDT window time
N */
N__STATIC_INLINE uint32_t Chip_WWDT_GetWindow(LPC_WWDT_T *pWWDT)
Xstatic __inline uint32_t Chip_WWDT_GetWindow(LPC_WWDT_T *pWWDT)
N{
N	return pWWDT->WINDOW;
N}
N
N/**
N * @brief	Enable watchdog timer options
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @param	options	: An or'ed set of options of values
N *						WWDT_WDMOD_WDEN, WWDT_WDMOD_WDRESET, and WWDT_WDMOD_WDPROTECT
N * @return	None
N * @note	You can enable more than one option at once (ie, WWDT_WDMOD_WDRESET |
N * WWDT_WDMOD_WDPROTECT), but use the WWDT_WDMOD_WDEN after all other options
N * are set (or unset) with no other options. If WWDT_WDMOD_LOCK is used, it cannot
N * be unset.
N */
N__STATIC_INLINE void Chip_WWDT_SetOption(LPC_WWDT_T *pWWDT, uint32_t options)
Xstatic __inline void Chip_WWDT_SetOption(LPC_WWDT_T *pWWDT, uint32_t options)
N{
N	pWWDT->MOD = (pWWDT->MOD & WWDT_WDMOD_BITMASK) | options;
X	pWWDT->MOD = (pWWDT->MOD & ((uint32_t) 0x3F)) | options;
N}
N
N/**
N * @brief	Disable/clear watchdog timer options
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @param	options	: An or'ed set of options of values
N *						WWDT_WDMOD_WDEN, WWDT_WDMOD_WDRESET, and WWDT_WDMOD_WDPROTECT
N * @return	None
N * @note	You can disable more than one option at once (ie, WWDT_WDMOD_WDRESET |
N * WWDT_WDMOD_WDTOF).
N */
N__STATIC_INLINE void Chip_WWDT_UnsetOption(LPC_WWDT_T *pWWDT, uint32_t options)
Xstatic __inline void Chip_WWDT_UnsetOption(LPC_WWDT_T *pWWDT, uint32_t options)
N{
N	pWWDT->MOD &= (~options) & WWDT_WDMOD_BITMASK;
X	pWWDT->MOD &= (~options) & ((uint32_t) 0x3F);
N}
N
N/**
N * @brief	Enable WWDT activity
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @return	None
N */
N__STATIC_INLINE void Chip_WWDT_Start(LPC_WWDT_T *pWWDT)
Xstatic __inline void Chip_WWDT_Start(LPC_WWDT_T *pWWDT)
N{
N	Chip_WWDT_SetOption(pWWDT, WWDT_WDMOD_WDEN);
X	Chip_WWDT_SetOption(pWWDT, ((uint32_t) (1 << 0)));
N	Chip_WWDT_Feed(pWWDT);
N}
N
N/**
N * @brief	Read WWDT status flag
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @return	Watchdog status, an Or'ed value of WWDT_WDMOD_*
N */
N__STATIC_INLINE uint32_t Chip_WWDT_GetStatus(LPC_WWDT_T *pWWDT)
Xstatic __inline uint32_t Chip_WWDT_GetStatus(LPC_WWDT_T *pWWDT)
N{
N	return pWWDT->MOD;
N}
N
N/**
N * @brief	Clear WWDT interrupt status flags
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @param	status	: Or'ed value of status flag(s) that you want to clear, should be:
N *              - WWDT_WDMOD_WDTOF: Clear watchdog timeout flag
N *              - WWDT_WDMOD_WDINT: Clear watchdog warning flag
N * @return	None
N */
N__STATIC_INLINE void Chip_WWDT_ClearStatusFlag(LPC_WWDT_T *pWWDT, uint32_t status)
Xstatic __inline void Chip_WWDT_ClearStatusFlag(LPC_WWDT_T *pWWDT, uint32_t status)
N{
N	if (status & WWDT_WDMOD_WDTOF) {
X	if (status & ((uint32_t) (1 << 2))) {
N		pWWDT->MOD &= (~WWDT_WDMOD_WDTOF) & WWDT_WDMOD_BITMASK;
X		pWWDT->MOD &= (~((uint32_t) (1 << 2))) & ((uint32_t) 0x3F);
N	}
N	/* Interrupt flag is cleared by writing a 1 */
N	if (status & WWDT_WDMOD_WDINT) {
X	if (status & ((uint32_t) (1 << 3))) {
N		pWWDT->MOD = (pWWDT->MOD & WWDT_WDMOD_BITMASK) | WWDT_WDMOD_WDINT;
X		pWWDT->MOD = (pWWDT->MOD & ((uint32_t) 0x3F)) | ((uint32_t) (1 << 3));
N	}
N}
N
N/**
N * @brief	Get the current value of WDT
N * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
N * @return	current value of WDT
N */
N__STATIC_INLINE uint32_t Chip_WWDT_GetCurrentCount(LPC_WWDT_T *pWWDT)
Xstatic __inline uint32_t Chip_WWDT_GetCurrentCount(LPC_WWDT_T *pWWDT)
N{
N	return pWWDT->TV;
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __WWDT_5411X_H_ */
L 188 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "sct_5411x.h"
L 1 "..\..\..\chip_5411x\inc\sct_5411x.h" 1
N/*
N * @brief LPC5411X State Configurable Timer (SCT) Chip driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licenser disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __SCT_5411X_H_
N#define __SCT_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup SCT_5411X CHIP: LPC5411X State Configurable Timer driver
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/*                         match/cap registers,     events,           states,         inputs,         outputs
N *
N * @brief SCT Module configuration
N */
N#define CONFIG_SCT_nEV   (13)			/*!< Number of events */
N#define CONFIG_SCT_nRG   (13)			/*!< Number of match/compare registers */
N#define CONFIG_SCT_nOU   (8)			/*!< Number of outputs */
N#define CONFIG_SCT_nIN   (8)			/*!< Number of outputs */
N
N/**
N * @brief State Configurable Timer register block structure
N */
Ntypedef struct {
N	__IO uint32_t CONFIG;		/*!< Configuration Register */
X	volatile uint32_t CONFIG;		 
N
N	union {
N		__IO uint32_t CTRL_U;		/*!< Control Register */
X		volatile uint32_t CTRL_U;		 
N
N		struct {
N			__IO uint16_t CTRL_L;		/*!< Low control register */
X			volatile uint16_t CTRL_L;		 
N			__IO uint16_t CTRL_H;		/*!< High control register */
X			volatile uint16_t CTRL_H;		 
N		};
N
N	};
N
N	__IO uint16_t LIMIT_L;		/*!< limit register for counter L */
X	volatile uint16_t LIMIT_L;		 
N	__IO uint16_t LIMIT_H;		/*!< limit register for counter H */
X	volatile uint16_t LIMIT_H;		 
N	__IO uint16_t HALT_L;		/*!< halt register for counter L */
X	volatile uint16_t HALT_L;		 
N	__IO uint16_t HALT_H;		/*!< halt register for counter H */
X	volatile uint16_t HALT_H;		 
N	__IO uint16_t STOP_L;		/*!< stop register for counter L */
X	volatile uint16_t STOP_L;		 
N	__IO uint16_t STOP_H;		/*!< stop register for counter H */
X	volatile uint16_t STOP_H;		 
N	__IO uint16_t START_L;		/*!< start register for counter L */
X	volatile uint16_t START_L;		 
N	__IO uint16_t START_H;		/*!< start register for counter H */
X	volatile uint16_t START_H;		 
N	uint32_t RESERVED1[10];		/*!< 0x03C reserved */
N
N	union {
N		__IO uint32_t COUNT_U;		/*!< counter register */
X		volatile uint32_t COUNT_U;		 
N
N		struct {
N			__IO uint16_t COUNT_L;		/*!< counter register for counter L */
X			volatile uint16_t COUNT_L;		 
N			__IO uint16_t COUNT_H;		/*!< counter register for counter H */
X			volatile uint16_t COUNT_H;		 
N		};
N
N	};
N
N	__IO uint16_t STATE_L;		/*!< state register for counter L */
X	volatile uint16_t STATE_L;		 
N	__IO uint16_t STATE_H;		/*!< state register for counter H */
X	volatile uint16_t STATE_H;		 
N	__I uint32_t INPUT;		/*!< input register */
X	volatile const uint32_t INPUT;		 
N	__IO uint16_t REGMODE_L;	/*!< match - capture registers mode register L */
X	volatile uint16_t REGMODE_L;	 
N	__IO uint16_t REGMODE_H;	/*!< match - capture registers mode register H */
X	volatile uint16_t REGMODE_H;	 
N	__IO uint32_t OUTPUT;		/*!< output register */
X	volatile uint32_t OUTPUT;		 
N	__IO uint32_t OUTPUTDIRCTRL;	/*!< output counter direction Control Register */
X	volatile uint32_t OUTPUTDIRCTRL;	 
N	__IO uint32_t RES;		/*!< conflict resolution register */
X	volatile uint32_t RES;		 
N	__IO uint32_t DMA0REQUEST;		/*!< DMA0 Request Register */
X	volatile uint32_t DMA0REQUEST;		 
N	__IO uint32_t DMA1REQUEST;		/*!< DMA1 Request Register */
X	volatile uint32_t DMA1REQUEST;		 
N	uint32_t RESERVED2[35];
N	__IO uint32_t EVEN;		/*!< event enable register */
X	volatile uint32_t EVEN;		 
N	__IO uint32_t EVFLAG;		/*!< event flag register */
X	volatile uint32_t EVFLAG;		 
N	__IO uint32_t CONEN;	/*!< conflict enable register */
X	volatile uint32_t CONEN;	 
N	__IO uint32_t CONFLAG;		/*!< conflict flag register */
X	volatile uint32_t CONFLAG;		 
N
N	union {
N
N		__IO union {	/*!< ... Match / Capture value */
X		volatile union {	 
N			uint32_t U;		/*!<       SCTMATCH[i].U  Unified 32-bit register */
N
N			struct {
N				uint16_t L;		/*!<       SCTMATCH[i].L  Access to L value */
N				uint16_t H;		/*!<       SCTMATCH[i].H  Access to H value */
N			};
N
N		} MATCH[CONFIG_SCT_nRG];
X		} MATCH[(13)];
N
N		__I union {
X		volatile const union {
N			uint32_t U;		/*!<       SCTCAP[i].U  Unified 32-bit register */
N
N			struct {
N				uint16_t L;		/*!<       SCTCAP[i].L  Access to L value */
N				uint16_t H;		/*!<       SCTCAP[i].H  Access to H value */
N			};
N
N		} CAP[CONFIG_SCT_nRG];
X		} CAP[(13)];
N
N	};
N
N	uint32_t RESERVED3[48 + (16 - CONFIG_SCT_nRG)];
X	uint32_t RESERVED3[48 + (16 - (13))];
N
N	union {
N
N		__IO union {	/* 0x200-... Match Reload / Capture Control value */
X		volatile union {	 
N			uint32_t U;		/*       SCTMATCHREL[i].U  Unified 32-bit register */
N
N			struct {
N				uint16_t L;		/*       SCTMATCHREL[i].L  Access to L value */
N				uint16_t H;		/*       SCTMATCHREL[i].H  Access to H value */
N			};
N
N		} MATCHREL[CONFIG_SCT_nRG];
X		} MATCHREL[(13)];
N
N		__IO union {
X		volatile union {
N			uint32_t U;		/*       SCTCAPCTRL[i].U  Unified 32-bit register */
N
N			struct {
N				uint16_t L;		/*       SCTCAPCTRL[i].L  Access to H value */
N				uint16_t H;		/*       SCTCAPCTRL[i].H  Access to H value */
N			};
N
N		} CAPCTRL[CONFIG_SCT_nRG];
X		} CAPCTRL[(13)];
N
N	};
N
N	uint32_t RESERVED6[48 + (16 - CONFIG_SCT_nRG)];
X	uint32_t RESERVED6[48 + (16 - (13))];
N
N	__IO struct {		/* 0x300-0x3FC  SCTEVENT[i].STATE / SCTEVENT[i].CTRL*/
X	volatile struct {		 
N		uint32_t STATE;		/* Event State Register */
N		uint32_t CTRL;		/* Event Control Register */
N	} EVENT[CONFIG_SCT_nEV];
X	} EVENT[(13)];
N
N	uint32_t RESERVED9[128 - 2 * CONFIG_SCT_nEV];		/*!< ...-0x4FC reserved */
X	uint32_t RESERVED9[128 - 2 * (13)];		 
N
N	__IO struct {		/*!< 0x500-0x57C  SCTOUT[i].SET / SCTOUT[i].CLR */
X	volatile struct {		 
N		uint32_t SET;		/*!< Output n Set Register */
N		uint32_t CLR;		/*!< Output n Clear Register */
N	} OUT[CONFIG_SCT_nOU];
X	} OUT[(8)];
N
N	uint32_t RESERVED10[191 - 2 * CONFIG_SCT_nOU];		/*!< ...-0x7F8 reserved */
X	uint32_t RESERVED10[191 - 2 * (8)];		 
N	__I uint32_t MODULECONTENT;		/*!< 0x7FC Module Content */
X	volatile const uint32_t MODULECONTENT;		 
N} LPC_SCT_T;
N
N/**
N * @brief Macro defines for SCT configuration register
N */
N#define SCT_CONFIG_16BIT_COUNTER        0x00000000	/*!< Operate as 2 16-bit counters */
N#define SCT_CONFIG_32BIT_COUNTER        0x00000001	/*!< Operate as 1 32-bit counter */
N
N#define SCT_CONFIG_CLKMODE_BUSCLK       (0x0 << 1)	/*!< Bus clock */
N#define SCT_CONFIG_CLKMODE_SCTCLK       (0x1 << 1)	/*!< SCT clock */
N#define SCT_CONFIG_CLKMODE_INCLK        (0x2 << 1)	/*!< Input clock selected in CLKSEL field */
N#define SCT_CONFIG_CLKMODE_INEDGECLK    (0x3 << 1)	/*!< Input clock edge selected in CLKSEL field */
N
N#define SCT_CONFIG_CLKMODE_SYSCLK               (0x0 << 1)	/*!< System clock */
N#define SCT_CONFIG_CLKMODE_PRESCALED_SYSCLK     (0x1 << 1)	/*!< Prescaled system clock */
N#define SCT_CONFIG_CLKMODE_SCT_INPUT            (0x2 << 1)	/*!< Input clock/edge selected in CKSEL field */
N#define SCT_CONFIG_CLKMODE_PRESCALED_SCT_INPUT  (0x3 << 1)	/*!< Prescaled input clock/edge selected in CKSEL field */
N
N#define SCT_CONFIG_CKSEL_RISING_IN_0    (0x0UL << 3)
N#define SCT_CONFIG_CKSEL_FALLING_IN_0   (0x1UL << 3)
N#define SCT_CONFIG_CKSEL_RISING_IN_1    (0x2UL << 3)
N#define SCT_CONFIG_CKSEL_FALLING_IN_1   (0x3UL << 3)
N#define SCT_CONFIG_CKSEL_RISING_IN_2    (0x4UL << 3)
N#define SCT_CONFIG_CKSEL_FALLING_IN_2   (0x5UL << 3)
N#define SCT_CONFIG_CKSEL_RISING_IN_3    (0x6UL << 3)
N#define SCT_CONFIG_CKSEL_FALLING_IN_3   (0x7UL << 3)
N#define SCT_CONFIG_CKSEL_RISING_IN_4    (0x8UL << 3)
N#define SCT_CONFIG_CKSEL_FALLING_IN_4   (0x9UL << 3)
N#define SCT_CONFIG_CKSEL_RISING_IN_5    (0xAUL << 3)
N#define SCT_CONFIG_CKSEL_FALLING_IN_5   (0xBUL << 3)
N#define SCT_CONFIG_CKSEL_RISING_IN_6    (0xCUL << 3)
N#define SCT_CONFIG_CKSEL_FALLING_IN_6   (0xDUL << 3)
N#define SCT_CONFIG_CKSEL_RISING_IN_7    (0xEUL << 3)
N#define SCT_CONFIG_CKSEL_FALLING_IN_7   (0xFUL << 3)
N#define SCT_CONFIG_NORELOADL_U          (0x1 << 7)	/*!< Operate as 1 32-bit counter */
N#define SCT_CONFIG_NORELOADH            (0x1 << 8)	/*!< Operate as 1 32-bit counter */
N#define SCT_CONFIG_AUTOLIMIT_U          (0x1UL << 17)
N#define SCT_CONFIG_AUTOLIMIT_L          (0x1UL << 17)
N#define SCT_CONFIG_AUTOLIMIT_H          (0x1UL << 18)
N
N/**
N * @brief Macro defines for SCT control register
N */
N#define COUNTUP_TO_LIMIT_THEN_CLEAR_TO_ZERO     0			/*!< Direction for low or unified counter */
N#define COUNTUP_TO LIMIT_THEN_COUNTDOWN_TO_ZERO 1
N
N#define SCT_CTRL_STOP_L                 (1 << 1)				/*!< Stop low counter */
N#define SCT_CTRL_HALT_L                 (1 << 2)				/*!< Halt low counter */
N#define SCT_CTRL_CLRCTR_L               (1 << 3)				/*!< Clear low or unified counter */
N#define SCT_CTRL_BIDIR_L(x)             (((x) & 0x01) << 4)		/*!< Bidirectional bit */
N#define SCT_CTRL_PRE_L(x)               (((x) & 0xFF) << 5)		/*!< Prescale clock for low or unified counter */
N
N#define COUNTUP_TO_LIMIT_THEN_CLEAR_TO_ZERO     0			/*!< Direction for high counter */
N#define COUNTUP_TO LIMIT_THEN_COUNTDOWN_TO_ZERO 1
N#define SCT_CTRL_STOP_H                 (1 << 17)				/*!< Stop high counter */
N#define SCT_CTRL_HALT_H                 (1 << 18)				/*!< Halt high counter */
N#define SCT_CTRL_CLRCTR_H               (1 << 19)				/*!< Clear high counter */
N#define SCT_CTRL_BIDIR_H(x)             (((x) & 0x01) << 20)
N#define SCT_CTRL_PRE_H(x)               (((x) & 0xFF) << 21)	/*!< Prescale clock for high counter */
N
N#define SCT_EV_CTRL_MATCHSEL(reg)               (reg << 0)
N#define SCT_EV_CTRL_HEVENT_L                    (0UL << 4)
N#define SCT_EV_CTRL_HEVENT_H                    (1UL << 4)
N#define SCT_EV_CTRL_OUTSEL_INPUT                (0UL << 5)
N#define SCT_EV_CTRL_OUTSEL_OUTPUT               (0UL << 5)
N#define SCT_EV_CTRL_IOSEL(signal)               (signal << 6)
N
N#define SCT_EV_CTRL_IOCOND_LOW                  (0UL << 10)
N#define SCT_EV_CTRL_IOCOND_RISE                 (0x1UL << 10)
N#define SCT_EV_CTRL_IOCOND_FALL                 (0x2UL << 10)
N#define SCT_EV_CTRL_IOCOND_HIGH                 (0x3UL << 10)
N#define SCT_EV_CTRL_COMBMODE_OR                 (0x0UL << 12)
N#define SCT_EV_CTRL_COMBMODE_MATCH              (0x1UL << 12)
N#define SCT_EV_CTRL_COMBMODE_IO                 (0x2UL << 12)
N#define SCT_EV_CTRL_COMBMODE_AND                (0x3UL << 12)
N#define SCT_EV_CTRL_STATELD                     (0x1UL << 14)
N#define SCT_EV_CTRL_STATEV(x)                   (x << 15)
N#define SCT_EV_CTRL_MATCHMEM                    (0x1UL << 20)
N#define SCT_EV_CTRL_DIRECTION_INDEPENDENT       (0x0UL << 21)
N#define SCT_EV_CTRL_DIRECTION_UP                (0x1UL << 21)
N#define SCT_EV_CTRL_DIRECTION_DOWN              (0x2UL << 21)
N
N/**
N * @brief Macro defines for SCT Conflict resolution register
N */
N#define SCT_RES_NOCHANGE                (0)
N#define SCT_RES_SET_OUTPUT              (1)
N#define SCT_RES_CLEAR_OUTPUT            (2)
N#define SCT_RES_TOGGLE_OUTPUT           (3)
N
N/**
N * SCT Match register values enum
N */
Ntypedef enum CHIP_SCT_MATCH_REG {
N	SCT_MATCH_0 = 0,	/*!< SCT Match register 0 */
N	SCT_MATCH_1,
N	SCT_MATCH_2,
N	SCT_MATCH_3,
N	SCT_MATCH_4,
N	SCT_MATCH_5,
N	SCT_MATCH_6,
N	SCT_MATCH_7,
N	SCT_MATCH_8,
N	SCT_MATCH_9,
N	SCT_MATCH_10,
N	SCT_MATCH_11,
N	SCT_MATCH_12,
N	SCT_MATCH_13,
N	SCT_MATCH_14,
N	SCT_MATCH_15
N} CHIP_SCT_MATCH_REG_T;
N
N/**
N * SCT Event values enum
N */
Ntypedef enum CHIP_SCT_EVENT {
N	SCT_EVT_0 = (1 << 0),		/*!< Event 0 */
N	SCT_EVT_1 = (1 << 1),		/*!< Event 1 */
N	SCT_EVT_2 = (1 << 2),		/*!< Event 2 */
N	SCT_EVT_3 = (1 << 3),		/*!< Event 3 */
N	SCT_EVT_4 = (1 << 4),		/*!< Event 4 */
N	SCT_EVT_5 = (1 << 5),		/*!< Event 5 */
N	SCT_EVT_6 = (1 << 6),		/*!< Event 6 */
N	SCT_EVT_7 = (1 << 7),		/*!< Event 7 */
N	SCT_EVT_8 = (1 << 8),		/*!< Event 8 */
N	SCT_EVT_9 = (1 << 9),		/*!< Event 9 */
N	SCT_EVT_10 = (1 << 10),		/*!< Event 10 */
N	SCT_EVT_11 = (1 << 11),		/*!< Event 11 */
N	SCT_EVT_12 = (1 << 12),		/*!< Event 12 */
N	SCT_EVT_13 = (1 << 13),		/*!< Event 13 */
N	SCT_EVT_14 = (1 << 14),		/*!< Event 14 */
N	SCT_EVT_15 = (1 << 15)		/*!< Event 15 */
N} CHIP_SCT_EVENT_T;
N
N/**
N * @brief	Set event control register
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	event_number
N * @param	value	: The 32-bit event control setting
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SCT_EventControl(LPC_SCT_T *pSCT, uint32_t event_number,
Xstatic __inline void Chip_SCT_EventControl(LPC_SCT_T *pSCT, uint32_t event_number,
N										 uint32_t value) {
N	pSCT->EVENT[event_number].CTRL = value;
N}
N
N/**
N * @brief	Set event state mask register
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	event_number
N * @param	event_state_mask      : The 32-bit event state mask setting
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SCT_EventStateMask(LPC_SCT_T *pSCT, uint32_t event_number,
Xstatic __inline void Chip_SCT_EventStateMask(LPC_SCT_T *pSCT, uint32_t event_number,
N										   uint32_t event_state_mask) {
N	pSCT->EVENT[event_number].STATE = event_state_mask;
N}
N
N/**
N * @brief	Set configuration register
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	cfg      : The 32-bit configuration setting
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SCT_Config(LPC_SCT_T *pSCT, uint32_t cfg) {
Xstatic __inline void Chip_SCT_Config(LPC_SCT_T *pSCT, uint32_t cfg) {
N	pSCT->CONFIG = cfg;
N}
N
N/**
N * @brief	Configures the Limit register
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	value	: The 32-bit Limit register value
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SCT_Limit(LPC_SCT_T *pSCT, uint32_t value) {
Xstatic __inline void Chip_SCT_Limit(LPC_SCT_T *pSCT, uint32_t value) {
N	pSCT->LIMIT_L = value;
N}
N
N/**
N * @brief	Set or Clear the Control register
N * @param	pSCT			: Pointer to SCT register block
N * @param	value			: SCT Control register value
N * @param	ena             : ENABLE - To set the fields specified by value
N *                          : DISABLE - To clear the field specified by value
N * @return	Nothing
N * Set or clear the control register bits as specified by the \a value
N * parameter. If \a ena is set to ENABLE, the mentioned register fields
N * will be set. If \a ena is set to DISABLE, the mentioned register
N * fields will be cleared
N */
Nvoid Chip_SCT_SetClrControl(LPC_SCT_T *pSCT, uint32_t value, FunctionalState ena);
N
N/**
N * @brief	Set the conflict resolution
N * @param	pSCT			: Pointer to SCT register block
N * @param	outnum			: Output number
N * @param	value           : Output value
N *                          - SCT_RES_NOCHANGE		:No change
N *					        - SCT_RES_SET_OUTPUT	:Set output
N *					        - SCT_RES_CLEAR_OUTPUT	:Clear output
N *					        - SCT_RES_TOGGLE_OUTPUT :Toggle output
N *                          : SCT_RES_NOCHANGE
N *                          : DISABLE - To clear the field specified by value
N * @return	Nothing
N * Set conflict resolution for the output \a outnum
N */
Nvoid Chip_SCT_SetConflictResolution(LPC_SCT_T *pSCT, uint8_t outnum, uint8_t value);
N
N/**
N * @brief	Set unified count value in State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	count	: The 32-bit count value
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SCT_SetCount(LPC_SCT_T *pSCT, uint32_t count) {
Xstatic __inline void Chip_SCT_SetCount(LPC_SCT_T *pSCT, uint32_t count) {
N	pSCT->COUNT_U = count;
N}
N
N/**
N * @brief	Set lower count value in State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	count	: The 16-bit count value
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SCT_SetCountL(LPC_SCT_T *pSCT, uint16_t count) {
Xstatic __inline void Chip_SCT_SetCountL(LPC_SCT_T *pSCT, uint16_t count) {
N	pSCT->COUNT_L = count;
N}
N
N/**
N * @brief	Set higher count value in State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	count	: The 16-bit count value
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SCT_SetCountH(LPC_SCT_T *pSCT, uint16_t count) {
Xstatic __inline void Chip_SCT_SetCountH(LPC_SCT_T *pSCT, uint16_t count) {
N	pSCT->COUNT_H = count;
N}
N
N/**
N * @brief	Set unified match count value in State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	n		: Match register value
N * @param	value	: The 32-bit match count value
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SCT_SetMatchCount(LPC_SCT_T *pSCT, CHIP_SCT_MATCH_REG_T n, uint32_t value) {
Xstatic __inline void Chip_SCT_SetMatchCount(LPC_SCT_T *pSCT, CHIP_SCT_MATCH_REG_T n, uint32_t value) {
N	pSCT->MATCH[n].U = value;
N}
N
N/**
N * @brief	Set unified match reload count value in State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	n		: Match register value
N * @param	value	: The 32-bit match count reload value
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SCT_SetMatchReload(LPC_SCT_T *pSCT, CHIP_SCT_MATCH_REG_T n, uint32_t value) {
Xstatic __inline void Chip_SCT_SetMatchReload(LPC_SCT_T *pSCT, CHIP_SCT_MATCH_REG_T n, uint32_t value) {
N	pSCT->MATCHREL[n].U = value;
N}
N
N/**
N * @brief	Enable the interrupt for the specified event in State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	evt		: Event value
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SCT_EnableEventInt(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt) {
Xstatic __inline void Chip_SCT_EnableEventInt(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt) {
N	pSCT->EVEN |= evt;
N}
N
N/**
N * @brief	Disable the interrupt for the specified event in State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	evt		: Event value
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SCT_DisableEventInt(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt) {
Xstatic __inline void Chip_SCT_DisableEventInt(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt) {
N	pSCT->EVEN &= ~(evt);
N}
N
N/**
N * @brief	Clear the specified event flag in State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	evt		: Event value
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SCT_ClearEventFlag(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt) {
Xstatic __inline void Chip_SCT_ClearEventFlag(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt) {
N	pSCT->EVFLAG |= evt;
N}
N
N/**
N * @brief	Set control register in State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	value	: Value (ORed value of SCT_CTRL_* bits)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SCT_SetControl(LPC_SCT_T *pSCT, uint32_t value) {
Xstatic __inline void Chip_SCT_SetControl(LPC_SCT_T *pSCT, uint32_t value) {
N	pSCT->CTRL_U |= value;
N}
N
N/**
N * @brief	Clear control register in State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	value	: Value (ORed value of SCT_CTRL_* bits)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SCT_ClearControl(LPC_SCT_T *pSCT, uint32_t value) {
Xstatic __inline void Chip_SCT_ClearControl(LPC_SCT_T *pSCT, uint32_t value) {
N	pSCT->CTRL_U &= ~(value);
N}
N
N/**
N * @brief	Initializes the State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @return	Nothing
N */
Nvoid Chip_SCT_Init(LPC_SCT_T *pSCT);
N
N/**
N * @brief	Deinitializes the State Configurable Timer
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @return	Nothing
N */
Nvoid Chip_SCT_DeInit(LPC_SCT_T *pSCT);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
S
N#endif
N
N#endif /* __SCT_5411X_H_ */
L 189 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "sct_pwm_5411x.h"
L 1 "..\..\..\chip_5411x\inc\sct_pwm_5411x.h" 1
N/*
N * @brief LPC5411x State Configurable Timer (SCT/PWM) Chip driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licenser disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __SCT_PWM_5411X_H_
N#define __SCT_PWM_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup SCT_PWM_5411X CHIP: LPC5411X State Configurable Timer PWM driver
N *
N * For more information on how to use the driver please visit the FAQ page at
N * <a href="http://www.lpcware.com/content/faq/how-use-sct-standard-pwm-using-lpcopen">
N * www.lpcware.com</a>
N *
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/**
N * @brief	Get number of ticks per PWM cycle
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @return	Number ot ticks that will be counted per cycle
N * @note	Return value of this function will be vaild only
N *          after calling Chip_SCTPWM_SetRate()
N */
N__STATIC_INLINE uint32_t Chip_SCTPWM_GetTicksPerCycle(LPC_SCT_T *pSCT)
Xstatic __inline uint32_t Chip_SCTPWM_GetTicksPerCycle(LPC_SCT_T *pSCT)
N{
N	return pSCT->MATCHREL[0].U;
N}
N
N/**
N * @brief	Converts a percentage to ticks
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	percent	: Percentage to convert (0 - 100)
N * @return	Number ot ticks corresponding to given percentage
N * @note	Do not use this function when using very low
N *          pwm rate (like 100Hz or less), on a chip that has
N *          very high frequency as the calculation might
N *          cause integer overflow
N */
N__STATIC_INLINE uint32_t Chip_SCTPWM_PercentageToTicks(LPC_SCT_T *pSCT, uint8_t percent)
Xstatic __inline uint32_t Chip_SCTPWM_PercentageToTicks(LPC_SCT_T *pSCT, uint8_t percent)
N{
N	return (Chip_SCTPWM_GetTicksPerCycle(pSCT) * percent) / 100;
N}
N
N/**
N * @brief	Get number of ticks on per PWM cycle
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	index	: Index of the PWM 1 to N (see notes)
N * @return	Number ot ticks for which the output will be ON per cycle
N * @note	@a index will be 1 to N where N is the "Number of
N *          match registers available in the SCT - 1" or
N *          "Number of OUTPUT pins available in the SCT" whichever
N *          is minimum.
N */
N__STATIC_INLINE uint32_t Chip_SCTPWM_GetDutyCycle(LPC_SCT_T *pSCT, uint8_t index)
Xstatic __inline uint32_t Chip_SCTPWM_GetDutyCycle(LPC_SCT_T *pSCT, uint8_t index)
N{
N	return pSCT->MATCHREL[index].U;
N}
N
N/**
N * @brief	Get number of ticks on per PWM cycle
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	index	: Index of the PWM 1 to N (see notes)
N * @param	ticks	: Number of ticks the output should say ON
N * @return	None
N * @note	@a index will be 1 to N where N is the "Number of
N *          match registers available in the SCT - 1" or
N *          "Number of OUTPUT pins available in the SCT" whichever
N *          is minimum. The new duty cycle will be effective only
N *          after completion of current PWM cycle.
N */
N__STATIC_INLINE void Chip_SCTPWM_SetDutyCycle(LPC_SCT_T *pSCT, uint8_t index, uint32_t ticks)
Xstatic __inline void Chip_SCTPWM_SetDutyCycle(LPC_SCT_T *pSCT, uint8_t index, uint32_t ticks)
N{
N	Chip_SCT_SetMatchReload(pSCT, (CHIP_SCT_MATCH_REG_T) index, ticks);
N}
N
N/**
N * @brief	Initialize the SCT/PWM clock and reset
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @return	None
N */
N__STATIC_INLINE void Chip_SCTPWM_Init(LPC_SCT_T *pSCT)
Xstatic __inline void Chip_SCTPWM_Init(LPC_SCT_T *pSCT)
N{
N	Chip_SCT_Init(pSCT);
N}
N
N/**
N * @brief	Start the SCT PWM
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @return	None
N * @note	This function must be called after all the
N *          configuration is completed. Do not call Chip_SCTPWM_SetRate()
N *          or Chip_SCTPWM_SetOutPin() after the SCT/PWM is started. Use
N *          Chip_SCTPWM_Stop() to stop the SCT/PWM before reconfiguring,
N *          Chip_SCTPWM_SetDutyCycle() can be called when the SCT/PWM is
N *          running to change the DutyCycle.
N */
N__STATIC_INLINE void Chip_SCTPWM_Start(LPC_SCT_T *pSCT)
Xstatic __inline void Chip_SCTPWM_Start(LPC_SCT_T *pSCT)
N{
N	Chip_SCT_ClearControl(pSCT, SCT_CTRL_HALT_L | SCT_CTRL_HALT_H);
X	Chip_SCT_ClearControl(pSCT, (1 << 2) | (1 << 18));
N}
N
N/**
N * @brief	Stop the SCT PWM
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @return	None
N */
N__STATIC_INLINE void Chip_SCTPWM_Stop(LPC_SCT_T *pSCT)
Xstatic __inline void Chip_SCTPWM_Stop(LPC_SCT_T *pSCT)
N{
N	/* Stop SCT */
N	Chip_SCT_SetControl(pSCT, SCT_CTRL_HALT_L | SCT_CTRL_HALT_H);
X	Chip_SCT_SetControl(pSCT, (1 << 2) | (1 << 18));
N
N	/* Clear the counter */
N	Chip_SCT_SetControl(pSCT, SCT_CTRL_CLRCTR_L | SCT_CTRL_CLRCTR_H);
X	Chip_SCT_SetControl(pSCT, (1 << 3) | (1 << 19));
N}
N
N/**
N * @brief	Sets the frequency of the generated PWM wave
N * @param	pSCT	: The base of SCT peripheral on the chip
N * @param	freq	: Frequency in Hz
N * @return	None
N */
Nvoid Chip_SCTPWM_SetRate(LPC_SCT_T *pSCT, uint32_t freq);
N
N/**
N * @brief	Setup the OUTPUT pin and associate it with an index
N * @param	pSCT	: The base of the SCT peripheral on the chip
N * @param	index	: Index of PWM 1 to N (see notes)
N * @param	pin		: COUT pin to be associated with the index
N * @return	None
N * @note	@a index will be 1 to N where N is the "Number of
N *          match registers available in the SCT - 1" or
N *          "Number of OUTPUT pins available in the SCT" whichever
N *          is minimum.
N */
Nvoid Chip_SCTPWM_SetOutPin(LPC_SCT_T *pSCT, uint8_t index, uint8_t pin);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
S
N#endif
N
N#endif /* __SCT_PWM_5411X_H_ */
L 190 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "rtc_5411x.h"
L 1 "..\..\..\chip_5411x\inc\rtc_5411x.h" 1
N/*
N * @brief LPC5411X RTC chip driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __RTC_5411X_H_
N#define __RTC_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup RTC_5411X CHIP: LPC5411X Real Time clock
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/**
N * @brief LPC5411X Real Time clock register block structure
N */
Ntypedef struct {			/*!< RTC */
N	__IO uint32_t CTRL;		/*!< RTC control register */
X	volatile uint32_t CTRL;		 
N	__IO uint32_t MATCH;	/*!< PRTC match (alarm) register */
X	volatile uint32_t MATCH;	 
N	__IO uint32_t COUNT;	/*!< RTC counter register */
X	volatile uint32_t COUNT;	 
N	__IO uint32_t WAKE;		/*!< RTC high-resolution/wake-up timer control register */
X	volatile uint32_t WAKE;		 
N} LPC_RTC_T;
N
N/* CTRL register defniitions */
N#define RTC_CTRL_SWRESET        (1 << 0)	/*!< Apply reset to RTC */
N#define RTC_CTRL_ALARM1HZ       (1 << 2)	/*!< RTC 1 Hz timer alarm flag status (match) bit */
N#define RTC_CTRL_WAKE1KHZ       (1 << 3)	/*!< RTC 1 kHz timer wake-up flag status (timeout) bit */
N#define RTC_CTRL_ALARMDPD_EN    (1 << 4)	/*!< RTC 1 Hz timer alarm for Deep power-down enable bit */
N#define RTC_CTRL_WAKEDPD_EN     (1 << 5)	/*!< RTC 1 kHz timer wake-up for Deep power-down enable bit */
N#define RTC_CTRL_RTC1KHZ_EN     (1 << 6)	/*!< RTC 1 kHz clock enable bit */
N#define RTC_CTRL_RTC_EN         (1 << 7)	/*!< RTC enable bit */
N#define RTC_CTRL_RTC_OSC_PD     (1 << 8)	/*!< RTC power-down bit */
N#define RTC_CTRL_RTC_OSC_BYPASS (1 << 9)	/*!< RTC power-down bit */
N#define RTC_CTRL_MASK           ((uint32_t) 0x0000003FD)	/*!< RTC Control register Mask for reserved bits */
N
N
N/**
N * @brief	Initialize the RTC peripheral
N * @param	pRTC	: RTC peripheral selected
N * @return	None
N */
N__STATIC_INLINE void Chip_RTC_Init(LPC_RTC_T *pRTC)
Xstatic __inline void Chip_RTC_Init(LPC_RTC_T *pRTC)
N{
N	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_RTC);
N}
N
N/**
N * @brief	De-initialize the RTC peripheral
N * @param	pRTC	: RTC peripheral selected
N * @return	None
N */
N__STATIC_INLINE void Chip_RTC_DeInit(LPC_RTC_T *pRTC)
Xstatic __inline void Chip_RTC_DeInit(LPC_RTC_T *pRTC)
N{
N	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_RTC);
N}
N
N/**
N * @brief	Enable RTC options
N * @param	pRTC	: The base address of RTC block
N * @param	flags	: And OR'ed value of RTC_CTRL_* definitions to enable
N * @return	Nothing
N * @note	You can enable multiple RTC options at once using this function
N *			by OR'ing them together. It is recommended to only use the
N *			RTC_CTRL_ALARMDPD_EN, RTC_CTRL_WAKEDPD_EN, RTC_CTRL_RTC1KHZ_EN, and
N *			RTC_CTRL_RTC_EN flags with this function.
N */
N__STATIC_INLINE void Chip_RTC_EnableOptions(LPC_RTC_T *pRTC, uint32_t flags)
Xstatic __inline void Chip_RTC_EnableOptions(LPC_RTC_T *pRTC, uint32_t flags)
N{
N	pRTC->CTRL = (pRTC->CTRL & RTC_CTRL_MASK) | flags;
X	pRTC->CTRL = (pRTC->CTRL & ((uint32_t) 0x0000003FD)) | flags;
N}
N
N/**
N * @brief	Disable RTC options
N * @param	pRTC	: The base address of RTC block
N * @param	flags	: And OR'ed value of RTC_CTRL_* definitions to disable
N * @return	Nothing
N * @note	You can enable multiple RTC options at once using this function
N *			by OR'ing them together. It is recommended to only use the
N *			RTC_CTRL_ALARMDPD_EN, RTC_CTRL_WAKEDPD_EN, RTC_CTRL_RTC1KHZ_EN, and
N *			RTC_CTRL_RTC_EN flags with this function.
N */
N__STATIC_INLINE void Chip_RTC_DisableOptions(LPC_RTC_T *pRTC, uint32_t flags)
Xstatic __inline void Chip_RTC_DisableOptions(LPC_RTC_T *pRTC, uint32_t flags)
N{
N	pRTC->CTRL = (pRTC->CTRL & RTC_CTRL_MASK) & ~flags;
X	pRTC->CTRL = (pRTC->CTRL & ((uint32_t) 0x0000003FD)) & ~flags;
N}
N
N/**
N * @brief	Reset RTC
N * @param	pRTC	: The base address of RTC block
N * @return	Nothing
N * @note	The RTC state will be returned to it's default.
N */
N__STATIC_INLINE void Chip_RTC_Reset(LPC_RTC_T *pRTC)
Xstatic __inline void Chip_RTC_Reset(LPC_RTC_T *pRTC)
N{
N	Chip_RTC_EnableOptions(pRTC, RTC_CTRL_SWRESET);
X	Chip_RTC_EnableOptions(pRTC, (1 << 0));
N	Chip_RTC_DisableOptions(pRTC, RTC_CTRL_SWRESET);
X	Chip_RTC_DisableOptions(pRTC, (1 << 0));
N}
N
N/**
N * @brief	Enables the RTC
N * @param	pRTC	: The base address of RTC block
N * @return	Nothing
N * @note	You can also use Chip_RTC_EnableOptions() with the
N *			RTC_CTRL_RTC_EN flag to enable the RTC.
N */
N__STATIC_INLINE void Chip_RTC_Enable(LPC_RTC_T *pRTC)
Xstatic __inline void Chip_RTC_Enable(LPC_RTC_T *pRTC)
N{
N	Chip_RTC_EnableOptions(pRTC, RTC_CTRL_RTC_EN);
X	Chip_RTC_EnableOptions(pRTC, (1 << 7));
N}
N
N/**
N * @brief	Disables the RTC
N * @param	pRTC	: The base address of RTC block
N * @return	Nothing
N * @note	You can also use Chip_RTC_DisableOptions() with the
N *			RTC_CTRL_RTC_EN flag to enable the RTC.
N */
N__STATIC_INLINE void Chip_RTC_Disable(LPC_RTC_T *pRTC)
Xstatic __inline void Chip_RTC_Disable(LPC_RTC_T *pRTC)
N{
N	Chip_RTC_DisableOptions(pRTC, RTC_CTRL_RTC_EN);
X	Chip_RTC_DisableOptions(pRTC, (1 << 7));
N}
N
N/**
N * @brief	Power up the RTC
N * @param	pRTC	: The base address of RTC block
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_RTC_PowerUp(LPC_RTC_T *pRTC)
Xstatic __inline void Chip_RTC_PowerUp(LPC_RTC_T *pRTC)
N{
N	Chip_RTC_DisableOptions(pRTC, RTC_CTRL_RTC_OSC_PD);
X	Chip_RTC_DisableOptions(pRTC, (1 << 8));
N}
N
N/**
N * @brief	Disables the RTC
N * @param	pRTC	: The base address of RTC block
N * @return	Nothing
N * @note	You can also use Chip_RTC_DisableOptions() with the
N *			RTC_CTRL_RTC_EN flag to enable the RTC.
N */
N__STATIC_INLINE void Chip_RTC_PowerDown(LPC_RTC_T *pRTC)
Xstatic __inline void Chip_RTC_PowerDown(LPC_RTC_T *pRTC)
N{
N	Chip_RTC_EnableOptions(pRTC, RTC_CTRL_RTC_OSC_PD);
X	Chip_RTC_EnableOptions(pRTC, (1 << 8));
N}
N
N
N/**
N * @brief	Enables the RTC 1KHz high resolution timer
N * @param	pRTC	: The base address of RTC block
N * @return	Nothing
N * @note	You can also use Chip_RTC_EnableOptions() with the
N *			RTC_CTRL_RTC1KHZ_EN flag to enable the high resolution
N *			timer.
N */
N__STATIC_INLINE void Chip_RTC_Enable1KHZ(LPC_RTC_T *pRTC)
Xstatic __inline void Chip_RTC_Enable1KHZ(LPC_RTC_T *pRTC)
N{
N	Chip_RTC_EnableOptions(pRTC, RTC_CTRL_RTC1KHZ_EN);
X	Chip_RTC_EnableOptions(pRTC, (1 << 6));
N}
N
N/**
N * @brief	Disables the RTC 1KHz high resolution timer
N * @param	pRTC	: The base address of RTC block
N * @return	Nothing
N * @note	You can also use Chip_RTC_DisableOptions() with the
N *			RTC_CTRL_RTC1KHZ_EN flag to disable the high resolution
N *			timer.
N */
N__STATIC_INLINE void Chip_RTC_Disable1KHZ(LPC_RTC_T *pRTC)
Xstatic __inline void Chip_RTC_Disable1KHZ(LPC_RTC_T *pRTC)
N{
N	Chip_RTC_DisableOptions(pRTC, RTC_CTRL_RTC1KHZ_EN);
X	Chip_RTC_DisableOptions(pRTC, (1 << 6));
N}
N
N/**
N * @brief	Enables selected RTC wakeup events
N * @param	pRTC	: The base address of RTC block
N * @param	ints	: Wakeup events to enable
N * @return	Nothing
N * @note	Select either one or both (OR'ed) RTC_CTRL_ALARMDPD_EN
N *			and RTC_CTRL_WAKEDPD_EN values to enabled. You can also
N *			use Chip_RTC_EnableOptions() with the flags to enable
N *			the events.
N */
N__STATIC_INLINE void Chip_RTC_EnableWakeup(LPC_RTC_T *pRTC, uint32_t ints)
Xstatic __inline void Chip_RTC_EnableWakeup(LPC_RTC_T *pRTC, uint32_t ints)
N{
N	Chip_RTC_EnableOptions(pRTC, ints);
N}
N
N/**
N * @brief	Disables selected RTC wakeup events
N * @param	pRTC	: The base address of RTC block
N * @param	ints	: Wakeup events to disable
N * @return	Nothing
N * @note	Select either one or both (OR'ed) RTC_CTRL_ALARMDPD_EN
N *			and RTC_CTRL_WAKEDPD_EN values to disabled. You can also
N *			use Chip_RTC_DisableOptions() with the flags to disable
N *			the events.
N */
N__STATIC_INLINE void Chip_RTC_DisableWakeup(LPC_RTC_T *pRTC, uint32_t ints)
Xstatic __inline void Chip_RTC_DisableWakeup(LPC_RTC_T *pRTC, uint32_t ints)
N{
N	Chip_RTC_DisableOptions(pRTC, ints);
N}
N
N/**
N * @brief	Clears latched RTC statuses
N * @param	pRTC	: The base address of RTC block
N * @param	stsMask	: OR'ed status bits to clear
N * @return	Nothing
N * @note	Use and OR'ed stsMask value of RTC_CTRL_ALARM1HZ,
N *			and RTC_CTRL_WAKE1KHZ to clear specific RTC states.
N */
N__STATIC_INLINE void Chip_RTC_ClearStatus(LPC_RTC_T *pRTC, uint32_t stsMask)
Xstatic __inline void Chip_RTC_ClearStatus(LPC_RTC_T *pRTC, uint32_t stsMask)
N{
N	pRTC->CTRL = (pRTC->CTRL & RTC_CTRL_MASK) | stsMask;
X	pRTC->CTRL = (pRTC->CTRL & ((uint32_t) 0x0000003FD)) | stsMask;
N}
N
N/**
N * @brief	Return RTC control/status register
N * @param	pRTC	: The base address of RTC block
N * @return	The current RTC control/status register
N * @note	Mask the return value with a RTC_CTRL_* definitions to determine
N *			which bits are set. For example, mask the return value with
N *			RTC_CTRL_ALARM1HZ to determine if the alarm interrupt is pending.
N */
N__STATIC_INLINE uint32_t Chip_RTC_GetStatus(LPC_RTC_T *pRTC)
Xstatic __inline uint32_t Chip_RTC_GetStatus(LPC_RTC_T *pRTC)
N{
N	return pRTC->CTRL;
N}
N
N/**
N * @brief	Set RTC match value for alarm status/interrupt
N * @param	pRTC	: The base address of RTC block
N * @param	count	: Alarm event time
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_RTC_SetAlarm(LPC_RTC_T *pRTC, uint32_t count)
Xstatic __inline void Chip_RTC_SetAlarm(LPC_RTC_T *pRTC, uint32_t count)
N{
N	pRTC->MATCH = count;
N}
N
N/**
N * @brief	Return the RTC match value used for alarm status/interrupt
N * @param	pRTC	: The base address of RTC block
N * @return	Alarm event time
N */
N__STATIC_INLINE uint32_t Chip_RTC_GetAlarm(LPC_RTC_T *pRTC)
Xstatic __inline uint32_t Chip_RTC_GetAlarm(LPC_RTC_T *pRTC)
N{
N	return pRTC->MATCH;
N}
N
N/**
N * @brief	Set RTC match count for 1 second timer count
N * @param	pRTC	: The base address of RTC block
N * @param	count	: Initial count to set
N * @return	Nothing
N * @note	Only write to this register when the RTC_CTRL_RTC_EN bit in
N *			the CTRL Register is 0. The counter increments one second
N *			after the RTC_CTRL_RTC_EN bit is set.
N */
N__STATIC_INLINE void Chip_RTC_SetCount(LPC_RTC_T *pRTC, uint32_t count)
Xstatic __inline void Chip_RTC_SetCount(LPC_RTC_T *pRTC, uint32_t count)
N{
N	pRTC->COUNT = count;
N}
N
N/**
N * @brief	Get current RTC 1 second timer count
N * @param	pRTC	: The base address of RTC block
N * @return	current RTC 1 second timer count
N */
N__STATIC_INLINE uint32_t Chip_RTC_GetCount(LPC_RTC_T *pRTC)
Xstatic __inline uint32_t Chip_RTC_GetCount(LPC_RTC_T *pRTC)
N{
N	return pRTC->COUNT;
N}
N
N/**
N * @brief	Set RTC wake count countdown value (in mS ticks)
N * @param	pRTC	: The base address of RTC block
N * @param	count	: wakeup time in milliSeconds
N * @return	Nothing
N * @note	A write pre-loads a start count value into the wake-up
N *			timer and initializes a count-down sequence.
N */
N__STATIC_INLINE void Chip_RTC_SetWake(LPC_RTC_T *pRTC, uint16_t count)
Xstatic __inline void Chip_RTC_SetWake(LPC_RTC_T *pRTC, uint16_t count)
N{
N	pRTC->WAKE = count;
N}
N
N/**
N * @brief	Get RTC wake count countdown value
N * @param	pRTC	: The base address of RTC block
N * @return	current RTC wake count countdown value (in mS)
N */
N__STATIC_INLINE uint16_t Chip_RTC_GetWake(LPC_RTC_T *pRTC)
Xstatic __inline uint16_t Chip_RTC_GetWake(LPC_RTC_T *pRTC)
N{
N	return pRTC->WAKE;
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __RTC_5411X_H_ */
L 191 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "timer_5411x.h"
L 1 "..\..\..\chip_5411x\inc\timer_5411x.h" 1
N/*
N * @brief LPC5411X 32-bit Timer/PWM driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __TIMER_5411X_H_
N#define __TIMER_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup TIMER_5411X CHIP: LPC5411X 32-bit Timer driver
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/**
N * @brief 32-bit Standard timer register block structure
N */
Ntypedef struct {					/*!< TIMERn Structure       */
N	__IO uint32_t IR;				/*!< Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending. */
X	volatile uint32_t IR;				 
N	__IO uint32_t TCR;				/*!< Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR. */
X	volatile uint32_t TCR;				 
N	__IO uint32_t TC;				/*!< Timer Counter. The 32 bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR. */
X	volatile uint32_t TC;				 
N	__IO uint32_t PR;				/*!< Prescale Register. The Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC. */
X	volatile uint32_t PR;				 
N	__IO uint32_t PC;				/*!< Prescale Counter. The 32 bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface. */
X	volatile uint32_t PC;				 
N	__IO uint32_t MCR;				/*!< Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs. */
X	volatile uint32_t MCR;				 
N	__IO uint32_t MR[4];			/*!< Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC. */
X	volatile uint32_t MR[4];			 
N	__IO uint32_t CCR;				/*!< Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place. */
X	volatile uint32_t CCR;				 
N	__IO uint32_t CR[4];			/*!< Capture Register. CR is loaded with the value of TC when there is an event on the CAPn.0 input. */
X	volatile uint32_t CR[4];			 
N	__IO uint32_t EMR;				/*!< External Match Register. The EMR controls the external match pins MATn.0-3 (MAT0.0-3 and MAT1.0-3 respectively). */
X	volatile uint32_t EMR;				 
N	__I  uint32_t RESERVED0[12];
X	volatile const  uint32_t RESERVED0[12];
N	__IO uint32_t CTCR;				/*!< Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting. */
X	volatile uint32_t CTCR;				 
N	__IO uint32_t PWMC;
X	volatile uint32_t PWMC;
N} LPC_TIMER_T;
N
N/** Macro to clear interrupt pending */
N#define TIMER_IR_CLR(n)         _BIT(n)
N
N/** Macro for getting a timer match interrupt bit */
N#define TIMER_MATCH_INT(n)      (_BIT((n) & 0x0F))
N/** Macro for getting a capture event interrupt bit */
N#define TIMER_CAP_INT(n)        (_BIT((((n) & 0x0F) + 4)))
N
N/** Timer/counter enable bit */
N#define TIMER_ENABLE            ((uint32_t) (1 << 0))
N/** Timer/counter reset bit */
N#define TIMER_RESET             ((uint32_t) (1 << 1))
N/** Timer Control register Mask */
N#define TIMER_CTRL_MASK         ((uint32_t) 0x03)
N
N/** Bit location for interrupt on MRx match, n = 0 to 3 */
N#define TIMER_INT_ON_MATCH(n)   (_BIT(((n) * 3)))
N/** Bit location for reset on MRx match, n = 0 to 3 */
N#define TIMER_RESET_ON_MATCH(n) (_BIT((((n) * 3) + 1)))
N/** Bit location for stop on MRx match, n = 0 to 3 */
N#define TIMER_STOP_ON_MATCH(n)  (_BIT((((n) * 3) + 2)))
N/** Match Control register Mask */
N#define TIMER_MCR_MASK          ((uint32_t) 0x0FFF)
N
N/** Bit location for CAP.n on CRx rising edge, n = 0 to 3 */
N#define TIMER_CAP_RISING(n)     (_BIT(((n) * 3)))
N/** Bit location for CAP.n on CRx falling edge, n = 0 to 3 */
N#define TIMER_CAP_FALLING(n)    (_BIT((((n) * 3) + 1)))
N/** Bit location for CAP.n on CRx interrupt enable, n = 0 to 3 */
N#define TIMER_INT_ON_CAP(n)     (_BIT((((n) * 3) + 2)))
N/** Capture Control register Mask */
N#define TIMER_CCR_MASK          ((uint32_t) 0x0FFF)
N/** External Match register Mask */
N#define TIMER_EMR_MASK          ((uint32_t) 0x0FFF)
N/** Counter Control register Mask */
N#define TIMER_CTCR_MASK          ((uint32_t) 0x0F)
N
N/**
N * @brief	Initialize a timer
N * @param	pTMR	: Pointer to timer IP register address
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_TIMER_Init(LPC_TIMER_T *pTMR)
Xstatic __inline void Chip_TIMER_Init(LPC_TIMER_T *pTMR)
N{
N	switch((uint32_t) pTMR) {
N		case LPC_TIMER4_BASE:
X		case 0x40049000UL:
N			Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_TIMER4);
N			Chip_SYSCON_PeriphReset(RESET_TIMER4);
N		case LPC_TIMER3_BASE:
X		case 0x40048000UL:
N			Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_TIMER3);
N			Chip_SYSCON_PeriphReset(RESET_TIMER3);
N		case LPC_TIMER2_BASE:
X		case 0x40028000UL:
N			Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_TIMER2);
N			Chip_SYSCON_PeriphReset(RESET_TIMER2);
N		case LPC_TIMER1_BASE:
X		case 0x40009000UL:
N			Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_TIMER1);
N			Chip_SYSCON_PeriphReset(RESET_TIMER1);
N		case LPC_TIMER0_BASE:
X		case 0x40008000UL:
N			Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_TIMER0);
N			Chip_SYSCON_PeriphReset(RESET_TIMER0);
N		default:
N			/* BUG: Application has provided wrong timer base address */
N			return;
N	}
N}
N
N/**
N * @brief	Shutdown a timer
N * @param	pTMR	: Pointer to timer IP register address
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_TIMER_DeInit(LPC_TIMER_T *pTMR)
Xstatic __inline void Chip_TIMER_DeInit(LPC_TIMER_T *pTMR)
N{
N	switch((uint32_t) pTMR) {
N		case LPC_TIMER4_BASE:
X		case 0x40049000UL:
N			Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_TIMER4);
N		case LPC_TIMER3_BASE:
X		case 0x40048000UL:
N			Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_TIMER3);
N		case LPC_TIMER2_BASE:
X		case 0x40028000UL:
N			Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_TIMER2);
N		case LPC_TIMER1_BASE:
X		case 0x40009000UL:
N			Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_TIMER1);
N		case LPC_TIMER0_BASE:
X		case 0x40008000UL:
N			Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_TIMER0);
N		default:
N			/* BUG: Application has provided wrong timer base address */
N			return;
N	}
N}
N
N/**
N * @brief	Determine if a match interrupt is pending
N * @param	pTMR		: Pointer to timer IP register address
N * @param	matchnum	: Match interrupt number to check
N * @return	false if the interrupt is not pending, otherwise true
N * @note	Determine if the match interrupt for the passed timer and match
N * counter is pending.
N */
N__STATIC_INLINE bool Chip_TIMER_MatchPending(LPC_TIMER_T *pTMR, int8_t matchnum)
Xstatic __inline _Bool Chip_TIMER_MatchPending(LPC_TIMER_T *pTMR, int8_t matchnum)
N{
N	return (bool) ((pTMR->IR & TIMER_MATCH_INT(matchnum)) != 0);
X	return (_Bool) ((pTMR->IR & ((1 << ((matchnum) & 0x0F)))) != 0);
N}
N
N/**
N * @brief	Determine if a capture interrupt is pending
N * @param	pTMR	: Pointer to timer IP register address
N * @param	capnum	: Capture interrupt number to check
N * @return	false if the interrupt is not pending, otherwise true
N * @note	Determine if the capture interrupt for the passed capture pin is
N * pending.
N */
N__STATIC_INLINE bool Chip_TIMER_CapturePending(LPC_TIMER_T *pTMR, int8_t capnum)
Xstatic __inline _Bool Chip_TIMER_CapturePending(LPC_TIMER_T *pTMR, int8_t capnum)
N{
N	return (bool) ((pTMR->IR & TIMER_CAP_INT(capnum)) != 0);
X	return (_Bool) ((pTMR->IR & ((1 << ((((capnum) & 0x0F) + 4))))) != 0);
N}
N
N/**
N * @brief	Clears a (pending) match interrupt
N * @param	pTMR		: Pointer to timer IP register address
N * @param	matchnum	: Match interrupt number to clear
N * @return	Nothing
N * @note	Clears a pending timer match interrupt.
N */
N__STATIC_INLINE void Chip_TIMER_ClearMatch(LPC_TIMER_T *pTMR, int8_t matchnum)
Xstatic __inline void Chip_TIMER_ClearMatch(LPC_TIMER_T *pTMR, int8_t matchnum)
N{
N	pTMR->IR = TIMER_IR_CLR(matchnum);
X	pTMR->IR = (1 << (matchnum));
N}
N
N/**
N * @brief	Clears a (pending) capture interrupt
N * @param	pTMR	: Pointer to timer IP register address
N * @param	capnum	: Capture interrupt number to clear
N * @return	Nothing
N * @note	Clears a pending timer capture interrupt.
N */
N__STATIC_INLINE void Chip_TIMER_ClearCapture(LPC_TIMER_T *pTMR, int8_t capnum)
Xstatic __inline void Chip_TIMER_ClearCapture(LPC_TIMER_T *pTMR, int8_t capnum)
N{
N	pTMR->IR = (0x10 << capnum);
N}
N
N/**
N * @brief	Enables the timer (starts count)
N * @param	pTMR	: Pointer to timer IP register address
N * @return	Nothing
N * @note	Enables the timer to start counting.
N */
N__STATIC_INLINE void Chip_TIMER_Enable(LPC_TIMER_T *pTMR)
Xstatic __inline void Chip_TIMER_Enable(LPC_TIMER_T *pTMR)
N{
N	pTMR->TCR = (pTMR->TCR & TIMER_CTRL_MASK) | TIMER_ENABLE;
X	pTMR->TCR = (pTMR->TCR & ((uint32_t) 0x03)) | ((uint32_t) (1 << 0));
N}
N
N/**
N * @brief	Disables the timer (stops count)
N * @param	pTMR	: Pointer to timer IP register address
N * @return	Nothing
N * @note	Disables the timer to stop counting.
N */
N__STATIC_INLINE void Chip_TIMER_Disable(LPC_TIMER_T *pTMR)
Xstatic __inline void Chip_TIMER_Disable(LPC_TIMER_T *pTMR)
N{
N	pTMR->TCR = (pTMR->TCR & TIMER_CTRL_MASK) & ~TIMER_ENABLE;
X	pTMR->TCR = (pTMR->TCR & ((uint32_t) 0x03)) & ~((uint32_t) (1 << 0));
N}
N
N/**
N * @brief	Returns the current timer count
N * @param	pTMR	: Pointer to timer IP register address
N * @return	Current timer terminal count value
N * @note	Returns the current timer terminal count.
N */
N__STATIC_INLINE uint32_t Chip_TIMER_ReadCount(LPC_TIMER_T *pTMR)
Xstatic __inline uint32_t Chip_TIMER_ReadCount(LPC_TIMER_T *pTMR)
N{
N	return pTMR->TC;
N}
N
N/**
N * @brief	Returns the current prescale count
N * @param	pTMR	: Pointer to timer IP register address
N * @return	Current timer prescale count value
N * @note	Returns the current prescale count.
N */
N__STATIC_INLINE uint32_t Chip_TIMER_ReadPrescale(LPC_TIMER_T *pTMR)
Xstatic __inline uint32_t Chip_TIMER_ReadPrescale(LPC_TIMER_T *pTMR)
N{
N	return pTMR->PC;
N}
N
N/**
N * @brief	Sets the prescaler value
N * @param	pTMR		: Pointer to timer IP register address
N * @param	prescale	: Prescale value to set the prescale register to
N * @return	Nothing
N * @note	Sets the prescale count value.
N */
N__STATIC_INLINE void Chip_TIMER_PrescaleSet(LPC_TIMER_T *pTMR, uint32_t prescale)
Xstatic __inline void Chip_TIMER_PrescaleSet(LPC_TIMER_T *pTMR, uint32_t prescale)
N{
N	pTMR->PR = prescale;
N}
N
N/**
N * @brief	Sets a timer match value
N * @param	pTMR		: Pointer to timer IP register address
N * @param	matchnum	: Match timer to set match count for
N * @param	matchval	: Match value for the selected match count
N * @return	Nothing
N * @note	Sets one of the timer match values.
N */
N__STATIC_INLINE void Chip_TIMER_SetMatch(LPC_TIMER_T *pTMR, int8_t matchnum, uint32_t matchval)
Xstatic __inline void Chip_TIMER_SetMatch(LPC_TIMER_T *pTMR, int8_t matchnum, uint32_t matchval)
N{
N	pTMR->MR[matchnum] = matchval;
N}
N
N/**
N * @brief	Reads a capture register
N * @param	pTMR	: Pointer to timer IP register address
N * @param	capnum	: Capture register to read
N * @return	The selected capture register value
N * @note	Returns the selected capture register value.
N */
N__STATIC_INLINE uint32_t Chip_TIMER_ReadCapture(LPC_TIMER_T *pTMR, int8_t capnum)
Xstatic __inline uint32_t Chip_TIMER_ReadCapture(LPC_TIMER_T *pTMR, int8_t capnum)
N{
N	return pTMR->CR[capnum];
N}
N
N/**
N * @brief	Resets the timer terminal and prescale counts to 0
N * @param	pTMR	: Pointer to timer IP register address
N * @return	Nothing
N */
Nvoid Chip_TIMER_Reset(LPC_TIMER_T *pTMR);
N
N/**
N * @brief	Enables a match interrupt that fires when the terminal count
N *			matches the match counter value.
N * @param	pTMR		: Pointer to timer IP register address
N * @param	matchnum	: Match timer, 0 to 3
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_TIMER_MatchEnableInt(LPC_TIMER_T *pTMR, int8_t matchnum)
Xstatic __inline void Chip_TIMER_MatchEnableInt(LPC_TIMER_T *pTMR, int8_t matchnum)
N{
N	pTMR->MCR = (pTMR->MCR & TIMER_MCR_MASK) | TIMER_INT_ON_MATCH(matchnum);
X	pTMR->MCR = (pTMR->MCR & ((uint32_t) 0x0FFF)) | ((1 << (((matchnum) * 3))));
N}
N
N/**
N * @brief	Disables a match interrupt for a match counter.
N * @param	pTMR		: Pointer to timer IP register address
N * @param	matchnum	: Match timer, 0 to 3
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_TIMER_MatchDisableInt(LPC_TIMER_T *pTMR, int8_t matchnum)
Xstatic __inline void Chip_TIMER_MatchDisableInt(LPC_TIMER_T *pTMR, int8_t matchnum)
N{
N	pTMR->MCR = (pTMR->MCR & TIMER_MCR_MASK) & ~TIMER_INT_ON_MATCH(matchnum);
X	pTMR->MCR = (pTMR->MCR & ((uint32_t) 0x0FFF)) & ~((1 << (((matchnum) * 3))));
N}
N
N/**
N * @brief	For the specific match counter, enables reset of the terminal count register when a match occurs
N * @param	pTMR		: Pointer to timer IP register address
N * @param	matchnum	: Match timer, 0 to 3
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_TIMER_ResetOnMatchEnable(LPC_TIMER_T *pTMR, int8_t matchnum)
Xstatic __inline void Chip_TIMER_ResetOnMatchEnable(LPC_TIMER_T *pTMR, int8_t matchnum)
N{
N	pTMR->MCR = (pTMR->MCR & TIMER_MCR_MASK) | TIMER_RESET_ON_MATCH(matchnum);
X	pTMR->MCR = (pTMR->MCR & ((uint32_t) 0x0FFF)) | ((1 << ((((matchnum) * 3) + 1))));
N}
N
N/**
N * @brief	For the specific match counter, disables reset of the terminal count register when a match occurs
N * @param	pTMR		: Pointer to timer IP register address
N * @param	matchnum	: Match timer, 0 to 3
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_TIMER_ResetOnMatchDisable(LPC_TIMER_T *pTMR, int8_t matchnum)
Xstatic __inline void Chip_TIMER_ResetOnMatchDisable(LPC_TIMER_T *pTMR, int8_t matchnum)
N{
N	pTMR->MCR = (pTMR->MCR & TIMER_MCR_MASK) & ~TIMER_RESET_ON_MATCH(matchnum);
X	pTMR->MCR = (pTMR->MCR & ((uint32_t) 0x0FFF)) & ~((1 << ((((matchnum) * 3) + 1))));
N}
N
N/**
N * @brief	Enable a match timer to stop the terminal count when a
N *			match count equals the terminal count.
N * @param	pTMR		: Pointer to timer IP register address
N * @param	matchnum	: Match timer, 0 to 3
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_TIMER_StopOnMatchEnable(LPC_TIMER_T *pTMR, int8_t matchnum)
Xstatic __inline void Chip_TIMER_StopOnMatchEnable(LPC_TIMER_T *pTMR, int8_t matchnum)
N{
N	pTMR->MCR = (pTMR->MCR & TIMER_MCR_MASK) | TIMER_STOP_ON_MATCH(matchnum);
X	pTMR->MCR = (pTMR->MCR & ((uint32_t) 0x0FFF)) | ((1 << ((((matchnum) * 3) + 2))));
N}
N
N/**
N * @brief	Disable stop on match for a match timer. Disables a match timer
N *			to stop the terminal count when a match count equals the terminal count.
N * @param	pTMR		: Pointer to timer IP register address
N * @param	matchnum	: Match timer, 0 to 3
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_TIMER_StopOnMatchDisable(LPC_TIMER_T *pTMR, int8_t matchnum)
Xstatic __inline void Chip_TIMER_StopOnMatchDisable(LPC_TIMER_T *pTMR, int8_t matchnum)
N{
N	pTMR->MCR = (pTMR->MCR & TIMER_MCR_MASK) & ~TIMER_STOP_ON_MATCH(matchnum);
X	pTMR->MCR = (pTMR->MCR & ((uint32_t) 0x0FFF)) & ~((1 << ((((matchnum) * 3) + 2))));
N}
N
N/**
N * @brief	Enables capture on on rising edge of selected CAP signal for the
N *			selected capture register, enables the selected CAPn.capnum signal to load
N *			the capture register with the terminal coount on a rising edge.
N * @param	pTMR	: Pointer to timer IP register address
N * @param	capnum	: Capture signal/register to use
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_TIMER_CaptureRisingEdgeEnable(LPC_TIMER_T *pTMR, int8_t capnum)
Xstatic __inline void Chip_TIMER_CaptureRisingEdgeEnable(LPC_TIMER_T *pTMR, int8_t capnum)
N{
N	pTMR->CCR = (pTMR->CCR & TIMER_CCR_MASK) | TIMER_CAP_RISING(capnum);
X	pTMR->CCR = (pTMR->CCR & ((uint32_t) 0x0FFF)) | ((1 << (((capnum) * 3))));
N}
N
N/**
N * @brief	Disables capture on on rising edge of selected CAP signal. For the
N *			selected capture register, disables the selected CAPn.capnum signal to load
N *			the capture register with the terminal coount on a rising edge.
N * @param	pTMR	: Pointer to timer IP register address
N * @param	capnum	: Capture signal/register to use
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_TIMER_CaptureRisingEdgeDisable(LPC_TIMER_T *pTMR, int8_t capnum)
Xstatic __inline void Chip_TIMER_CaptureRisingEdgeDisable(LPC_TIMER_T *pTMR, int8_t capnum)
N{
N	pTMR->CCR = (pTMR->CCR & TIMER_CCR_MASK) & ~TIMER_CAP_RISING(capnum);
X	pTMR->CCR = (pTMR->CCR & ((uint32_t) 0x0FFF)) & ~((1 << (((capnum) * 3))));
N}
N
N/**
N * @brief	Enables capture on on falling edge of selected CAP signal. For the
N *			selected capture register, enables the selected CAPn.capnum signal to load
N *			the capture register with the terminal coount on a falling edge.
N * @param	pTMR	: Pointer to timer IP register address
N * @param	capnum	: Capture signal/register to use
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_TIMER_CaptureFallingEdgeEnable(LPC_TIMER_T *pTMR, int8_t capnum)
Xstatic __inline void Chip_TIMER_CaptureFallingEdgeEnable(LPC_TIMER_T *pTMR, int8_t capnum)
N{
N	pTMR->CCR = (pTMR->CCR & TIMER_CCR_MASK) | TIMER_CAP_FALLING(capnum);
X	pTMR->CCR = (pTMR->CCR & ((uint32_t) 0x0FFF)) | ((1 << ((((capnum) * 3) + 1))));
N}
N
N/**
N * @brief	Disables capture on on falling edge of selected CAP signal. For the
N *			selected capture register, disables the selected CAPn.capnum signal to load
N *			the capture register with the terminal coount on a falling edge.
N * @param	pTMR	: Pointer to timer IP register address
N * @param	capnum	: Capture signal/register to use
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_TIMER_CaptureFallingEdgeDisable(LPC_TIMER_T *pTMR, int8_t capnum)
Xstatic __inline void Chip_TIMER_CaptureFallingEdgeDisable(LPC_TIMER_T *pTMR, int8_t capnum)
N{
N	pTMR->CCR = (pTMR->CCR & TIMER_CCR_MASK) & ~TIMER_CAP_FALLING(capnum);
X	pTMR->CCR = (pTMR->CCR & ((uint32_t) 0x0FFF)) & ~((1 << ((((capnum) * 3) + 1))));
N}
N
N/**
N * @brief	Enables interrupt on capture of selected CAP signal. For the
N *			selected capture register, an interrupt will be generated when the enabled
N *			rising or falling edge on CAPn.capnum is detected.
N * @param	pTMR	: Pointer to timer IP register address
N * @param	capnum	: Capture signal/register to use
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_TIMER_CaptureEnableInt(LPC_TIMER_T *pTMR, int8_t capnum)
Xstatic __inline void Chip_TIMER_CaptureEnableInt(LPC_TIMER_T *pTMR, int8_t capnum)
N{
N	pTMR->CCR = (pTMR->CCR & TIMER_CCR_MASK) | TIMER_INT_ON_CAP(capnum);
X	pTMR->CCR = (pTMR->CCR & ((uint32_t) 0x0FFF)) | ((1 << ((((capnum) * 3) + 2))));
N}
N
N/**
N * @brief	Disables interrupt on capture of selected CAP signal
N * @param	pTMR	: Pointer to timer IP register address
N * @param	capnum	: Capture signal/register to use
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_TIMER_CaptureDisableInt(LPC_TIMER_T *pTMR, int8_t capnum)
Xstatic __inline void Chip_TIMER_CaptureDisableInt(LPC_TIMER_T *pTMR, int8_t capnum)
N{
N	pTMR->CCR = (pTMR->CCR & TIMER_CCR_MASK) & ~TIMER_INT_ON_CAP(capnum);
X	pTMR->CCR = (pTMR->CCR & ((uint32_t) 0x0FFF)) & ~((1 << ((((capnum) * 3) + 2))));
N}
N
N/**
N * @brief Standard timer initial match pin state and change state
N */
Ntypedef enum IP_TIMER_PIN_MATCH_STATE {
N	TIMER_EXTMATCH_DO_NOTHING = 0,	/*!< Timer match state does nothing on match pin */
N	TIMER_EXTMATCH_CLEAR      = 1,	/*!< Timer match state sets match pin low */
N	TIMER_EXTMATCH_SET        = 2,	/*!< Timer match state sets match pin high */
N	TIMER_EXTMATCH_TOGGLE     = 3		/*!< Timer match state toggles match pin */
N} TIMER_PIN_MATCH_STATE_T;
N
N/**
N * @brief	Sets external match control (MATn.matchnum) pin control. For the pin
N *          selected with matchnum, sets the function of the pin that occurs on
N *          a terminal count match for the match count.
N * @param	pTMR			: Pointer to timer IP register address
N * @param	initial_state	: Initial state of the pin, high(1) or low(0)
N * @param	matchState		: Selects the match state for the pin
N * @param	matchnum		: MATn.matchnum signal to use
N * @return	Nothing
N * @note	For the pin selected with matchnum, sets the function of the pin that occurs on
N * a terminal count match for the match count.
N */
Nvoid Chip_TIMER_ExtMatchControlSet(LPC_TIMER_T *pTMR, int8_t initial_state,
N								   TIMER_PIN_MATCH_STATE_T matchState, int8_t matchnum);
N
N/**
N * @brief Standard timer clock and edge for count source
N */
Ntypedef enum IP_TIMER_CAP_SRC_STATE {
N	TIMER_CAPSRC_RISING_PCLK  = 0,	/*!< Timer ticks on PCLK rising edge */
N	TIMER_CAPSRC_RISING_CAPN  = 1,	/*!< Timer ticks on CAPn.x rising edge */
N	TIMER_CAPSRC_FALLING_CAPN = 2,	/*!< Timer ticks on CAPn.x falling edge */
N	TIMER_CAPSRC_BOTH_CAPN    = 3		/*!< Timer ticks on CAPn.x both edges */
N} TIMER_CAP_SRC_STATE_T;
N
N/**
N * @brief	Sets timer count source and edge with the selected passed from CapSrc.
N *          If CapSrc selected a CAPn pin, select the specific CAPn pin with the capnum value.
N * @param	pTMR	: Pointer to timer IP register address
N * @param	capSrc	: timer clock source and edge
N * @param	capnum	: CAPn.capnum pin to use (0 - 2)
N * @return	Nothing
N * @note	If CapSrc selected a CAPn pin, select the specific CAPn pin with the capnum value.
N */
N__STATIC_INLINE void Chip_TIMER_TIMER_SetCountClockSrc(LPC_TIMER_T *pTMR,
Xstatic __inline void Chip_TIMER_TIMER_SetCountClockSrc(LPC_TIMER_T *pTMR,
N													 TIMER_CAP_SRC_STATE_T capSrc,
N													 int8_t capnum)
N{
N	pTMR->CTCR = (pTMR->CTCR & ~TIMER_CTCR_MASK) | ((uint32_t) capSrc | ((uint32_t) capnum) << 2);
X	pTMR->CTCR = (pTMR->CTCR & ~((uint32_t) 0x0F)) | ((uint32_t) capSrc | ((uint32_t) capnum) << 2);
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __TIMER_5411X_H_ */
L 192 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "utick_5411x.h"
L 1 "..\..\..\chip_5411x\inc\utick_5411x.h" 1
N/*
N * @brief LPC5411X Micro Tick chip driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __UTICK_5411X_H_
N#define __UTICK_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup UTICK_5411X CHIP: LPC5411X Micro Tick driver
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/**
N * @brief Micro Tick register block structure
N */
Ntypedef struct {
N	__IO uint32_t CTRL;				/*!< UTick Control register */
X	volatile uint32_t CTRL;				 
N	__IO uint32_t STATUS;			/*!< UTick Status register */
X	volatile uint32_t STATUS;			 
N} LPC_UTICK_T;
N
N/**
N * @brief UTick register definitions
N */
N/** UTick repeat delay bit */
N#define UTICK_CTRL_REPEAT           ((uint32_t) 1UL << 31)
N/** UTick Delay Value Mask */
N#define UTICK_CTRL_DELAY_MASK       ((uint32_t) 0x7FFFFFFF)
N/** UTick Interrupt Status bit */
N#define UTICK_STATUS_INTR           ((uint32_t) 1 << 0)
N/** UTick Active Status bit */
N#define UTICK_STATUS_ACTIVE         ((uint32_t) 1 << 1)
N/** UTick Status Register Mask */
N#define UTICK_STATUS_MASK           ((uint32_t) 0x03)
N
N/**
N * @brief	Initialize the UTICK peripheral
N * @param	pUTICK	: UTICK peripheral selected
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_UTICK_Init(LPC_UTICK_T *pUTICK)
Xstatic __inline void Chip_UTICK_Init(LPC_UTICK_T *pUTICK)
N{
N	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_UTICK);
N	Chip_SYSCON_PeriphReset(RESET_UTICK);
N}
N
N/**
N * @brief	De-initialize the UTICK peripheral
N * @param	pUTICK	: UTICK peripheral selected
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_UTICK_DeInit(LPC_UTICK_T *pUTICK)
Xstatic __inline void Chip_UTICK_DeInit(LPC_UTICK_T *pUTICK)
N{
N	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_UTICK);
N}
N
N/**
N * @brief	Setup UTICK
N * @param	pUTICK		: The base address of UTICK block
N * @param	tick_value	: Tick value, should not exceed UTICK_CTRL_DELAY_MASK
N * @param	repeat		: If true then delay repeats continuously else it is one time
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_UTICK_SetTick(LPC_UTICK_T *pUTICK, uint32_t tick_value, bool repeat)
Xstatic __inline void Chip_UTICK_SetTick(LPC_UTICK_T *pUTICK, uint32_t tick_value, _Bool repeat)
N{
N	if (repeat) {
N		tick_value |= UTICK_CTRL_REPEAT;
X		tick_value |= ((uint32_t) 1UL << 31);
N	}
N
N	pUTICK->CTRL = tick_value;
N}
N
N/**
N * @brief	Setup UTICK for the passed delay (in mS)
N * @param	pUTICK	: The base address of UTICK block
N * @param	delayMs	: Delay value in mS (Maximum is 1000mS)
N * @param	repeat	: If true then delay repeats continuously else it is one time
N * @return	Nothing
N * @note	The WDT oscillator runs at about 500KHz, so delays in uS won't be
N * too accurate.
N */
N__STATIC_INLINE void Chip_UTICK_SetDelayMs(LPC_UTICK_T *pUTICK, uint32_t delayMs, bool repeat)
Xstatic __inline void Chip_UTICK_SetDelayMs(LPC_UTICK_T *pUTICK, uint32_t delayMs, _Bool repeat)
N{
N	uint32_t tick_value = (delayMs * Chip_Clock_GetWDTOSCRate()) / 1000;
N
N	if (repeat) {
N		tick_value |= UTICK_CTRL_REPEAT;
X		tick_value |= ((uint32_t) 1UL << 31);
N	}
N	else {
N		tick_value &= ~UTICK_CTRL_REPEAT;
X		tick_value &= ~((uint32_t) 1UL << 31);
N	}
N
N	pUTICK->CTRL = tick_value;
N}
N
N/**
N * @brief	Read UTICK Value
N * @param	pUTICK	: The base address of UTICK block
N * @return	Current tick value
N */
N__STATIC_INLINE uint32_t Chip_UTICK_GetTick(LPC_UTICK_T *pUTICK)
Xstatic __inline uint32_t Chip_UTICK_GetTick(LPC_UTICK_T *pUTICK)
N{
N	return pUTICK->CTRL & UTICK_CTRL_DELAY_MASK;
X	return pUTICK->CTRL & ((uint32_t) 0x7FFFFFFF);
N}
N
N/**
N * @brief	Halt UTICK timer
N * @param	pUTICK	: The base address of UTICK block
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_UTICK_Halt(LPC_UTICK_T *pUTICK)
Xstatic __inline void Chip_UTICK_Halt(LPC_UTICK_T *pUTICK)
N{
N	pUTICK->CTRL = 0;
N}
N
N/**
N * @brief	Returns the status of UTICK
N * @param	pUTICK	: The base address of UTICK block
N * @return Micro tick timer status register value
N */
N__STATIC_INLINE uint32_t Chip_UTICK_GetStatus(LPC_UTICK_T *pUTICK)
Xstatic __inline uint32_t Chip_UTICK_GetStatus(LPC_UTICK_T *pUTICK)
N{
N	return pUTICK->STATUS;
N}
N
N/**
N * @brief	Clears UTICK Interrupt flag
N * @param	pUTICK	: The base address of UTICK block
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_UTICK_ClearInterrupt(LPC_UTICK_T *pUTICK)
Xstatic __inline void Chip_UTICK_ClearInterrupt(LPC_UTICK_T *pUTICK)
N{
N	pUTICK->STATUS = UTICK_STATUS_INTR;
X	pUTICK->STATUS = ((uint32_t) 1 << 0);
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __UTICK_5411X_H_ */
L 193 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "gpiogroup_5411x.h"
L 1 "..\..\..\chip_5411x\inc\gpiogroup_5411x.h" 1
N/*
N * @brief LPC5411x GPIO group driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __GPIOGROUP_5411X_H_
N#define __GPIOGROUP_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup GPIOGP_5411X CHIP: LPC5411X GPIO group driver
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/**
N * @brief GPIO grouped interrupt register block structure
N */
Ntypedef struct {					/*!< GPIO_GROUP_INTn Structure */
N	__IO uint32_t  CTRL;			/*!< GPIO grouped interrupt control register */
X	volatile uint32_t  CTRL;			 
N	__I  uint32_t  RESERVED0[7];
X	volatile const  uint32_t  RESERVED0[7];
N	__IO uint32_t  PORT_POL[8];		/*!< GPIO grouped interrupt port polarity register */
X	volatile uint32_t  PORT_POL[8];		 
N	__IO uint32_t  PORT_ENA[8];		/*!< GPIO grouped interrupt port m enable register */
X	volatile uint32_t  PORT_ENA[8];		 
N	uint32_t       RESERVED1[4072];
N} LPC_GPIOGROUPINT_T;
N
N/**
N * LPC5411x GPIO group bit definitions
N */
N#define GPIOGR_INT       (1 << 0)	/*!< GPIO interrupt pending/clear bit */
N#define GPIOGR_COMB      (1 << 1)	/*!< GPIO interrupt OR(0)/AND(1) mode bit */
N#define GPIOGR_TRIG      (1 << 2)	/*!< GPIO interrupt edge(0)/level(1) mode bit */
N
N/**
N * @brief	Initialize GPIO group interrupt block
N * @param	pGPIOGPINT	: The base of GPIO group peripheral on the chip
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_GPIOGP_Init(LPC_GPIOGROUPINT_T *pGPIOGPINT)
Xstatic __inline void Chip_GPIOGP_Init(LPC_GPIOGROUPINT_T *pGPIOGPINT)
N{
N	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_GINT);
N	Chip_SYSCON_PeriphReset(RESET_GINT);
N}
N
N/**
N * @brief	De-Initialize GPIO group interrupt block
N * @param	pGPIOGPINT	: The base of GPIO group peripheral on the chip
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_GPIOGP_DeInit(LPC_GPIOGROUPINT_T *pGPIOGPINT)
Xstatic __inline void Chip_GPIOGP_DeInit(LPC_GPIOGROUPINT_T *pGPIOGPINT)
N{
N	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_GINT);
N}
N
N/**
N * @brief	Clear interrupt pending status for the selected group
N * @param	pGPIOGPINT	: Pointer to GPIO group register block
N * @param	group		: GPIO group number
N * @return	None
N */
N__STATIC_INLINE void Chip_GPIOGP_ClearIntStatus(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
Xstatic __inline void Chip_GPIOGP_ClearIntStatus(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
N{
N	pGPIOGPINT[group].CTRL |= GPIOGR_INT;
X	pGPIOGPINT[group].CTRL |= (1 << 0);
N}
N
N/**
N * @brief	Returns current GPIO group inetrrupt pending status
N * @param	pGPIOGPINT	: Pointer to GPIO group register block
N * @param	group		: GPIO group number
N * @return	true if the group interrupt is pending, otherwise false.
N */
N__STATIC_INLINE bool Chip_GPIOGP_GetIntStatus(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
Xstatic __inline _Bool Chip_GPIOGP_GetIntStatus(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
N{
N	return (bool) ((pGPIOGPINT[group].CTRL & GPIOGR_INT) != 0);
X	return (_Bool) ((pGPIOGPINT[group].CTRL & (1 << 0)) != 0);
N}
N
N/**
N * @brief	Selected GPIO group functionality for trigger on any pin in group (OR mode)
N * @param	pGPIOGPINT	: Pointer to GPIO group register block
N * @param	group		: GPIO group number
N * @return	None
N */
N__STATIC_INLINE void Chip_GPIOGP_SelectOrMode(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
Xstatic __inline void Chip_GPIOGP_SelectOrMode(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
N{
N	pGPIOGPINT[group].CTRL &= ~(GPIOGR_COMB | GPIOGR_INT);
X	pGPIOGPINT[group].CTRL &= ~((1 << 1) | (1 << 0));
N}
N
N/**
N * @brief	Selected GPIO group functionality for trigger on all matching pins in group (AND mode)
N * @param	pGPIOGPINT	: Pointer to GPIO group register block
N * @param	group		: GPIO group number
N * @return	None
N */
N__STATIC_INLINE void Chip_GPIOGP_SelectAndMode(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
Xstatic __inline void Chip_GPIOGP_SelectAndMode(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
N{
N	pGPIOGPINT[group].CTRL = (pGPIOGPINT[group].CTRL & ~GPIOGR_INT) | GPIOGR_COMB;
X	pGPIOGPINT[group].CTRL = (pGPIOGPINT[group].CTRL & ~(1 << 0)) | (1 << 1);
N}
N
N/**
N * @brief	Selected GPIO group functionality edge trigger mode
N * @param	pGPIOGPINT	: Pointer to GPIO group register block
N * @param	group		: GPIO group number
N * @return	None
N */
N__STATIC_INLINE void Chip_GPIOGP_SelectEdgeMode(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
Xstatic __inline void Chip_GPIOGP_SelectEdgeMode(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
N{
N	pGPIOGPINT[group].CTRL &= ~(GPIOGR_TRIG | GPIOGR_INT);
X	pGPIOGPINT[group].CTRL &= ~((1 << 2) | (1 << 0));
N}
N
N/**
N * @brief	Selected GPIO group functionality level trigger mode
N * @param	pGPIOGPINT	: Pointer to GPIO group register block
N * @param	group		: GPIO group number
N * @return	None
N */
N__STATIC_INLINE void Chip_GPIOGP_SelectLevelMode(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
Xstatic __inline void Chip_GPIOGP_SelectLevelMode(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
N{
N	pGPIOGPINT[group].CTRL = (pGPIOGPINT[group].CTRL & ~GPIOGR_INT) | GPIOGR_TRIG;
X	pGPIOGPINT[group].CTRL = (pGPIOGPINT[group].CTRL & ~(1 << 0)) | (1 << 2);
N}
N
N/**
N * @brief	Set selected pins for the group and port to low level trigger
N * @param	pGPIOGPINT	: Pointer to GPIO group register block
N * @param	group		: GPIO group number
N * @param	port		: GPIO port number
N * @param	pinMask		: Or'ed value of pins to select for low level (bit 0 = pin 0, 1 = pin1, etc.)
N * @return	None
N */
N__STATIC_INLINE void Chip_GPIOGP_SelectLowLevel(LPC_GPIOGROUPINT_T *pGPIOGPINT,
Xstatic __inline void Chip_GPIOGP_SelectLowLevel(LPC_GPIOGROUPINT_T *pGPIOGPINT,
N											  uint8_t group,
N											  uint8_t port,
N											  uint32_t pinMask)
N{
N	pGPIOGPINT[group].PORT_POL[port] &= ~pinMask;
N}
N
N/**
N * @brief	Set selected pins for the group and port to high level trigger
N * @param	pGPIOGPINT	: Pointer to GPIO group register block
N * @param	group		: GPIO group number
N * @param	port		: GPIO port number
N * @param	pinMask		: Or'ed value of pins to select for high level (bit 0 = pin 0, 1 = pin1, etc.)
N * @return	None
N */
N__STATIC_INLINE void Chip_GPIOGP_SelectHighLevel(LPC_GPIOGROUPINT_T *pGPIOGPINT,
Xstatic __inline void Chip_GPIOGP_SelectHighLevel(LPC_GPIOGROUPINT_T *pGPIOGPINT,
N											   uint8_t group,
N											   uint8_t port,
N											   uint32_t pinMask)
N{
N	pGPIOGPINT[group].PORT_POL[port] |= pinMask;
N}
N
N/**
N * @brief	Disabled selected pins for the group interrupt
N * @param	pGPIOGPINT	: Pointer to GPIO group register block
N * @param	group		: GPIO group number
N * @param	port		: GPIO port number
N * @param	pinMask		: Or'ed value of pins to disable interrupt for (bit 0 = pin 0, 1 = pin1, etc.)
N * @return	None
N * @note	Disabled pins do not contribute to the group interrupt.
N */
N__STATIC_INLINE void Chip_GPIOGP_DisableGroupPins(LPC_GPIOGROUPINT_T *pGPIOGPINT,
Xstatic __inline void Chip_GPIOGP_DisableGroupPins(LPC_GPIOGROUPINT_T *pGPIOGPINT,
N												uint8_t group,
N												uint8_t port,
N												uint32_t pinMask)
N{
N	pGPIOGPINT[group].PORT_ENA[port] &= ~pinMask;
N}
N
N/**
N * @brief	Enable selected pins for the group interrupt
N * @param	pGPIOGPINT	: Pointer to GPIO group register block
N * @param	group		: GPIO group number
N * @param	port		: GPIO port number
N * @param	pinMask		: Or'ed value of pins to enable interrupt for (bit 0 = pin 0, 1 = pin1, etc.)
N * @return	None
N * @note	Enabled pins contribute to the group interrupt.
N */
N__STATIC_INLINE void Chip_GPIOGP_EnableGroupPins(LPC_GPIOGROUPINT_T *pGPIOGPINT,
Xstatic __inline void Chip_GPIOGP_EnableGroupPins(LPC_GPIOGROUPINT_T *pGPIOGPINT,
N											   uint8_t group,
N											   uint8_t port,
N											   uint32_t pinMask)
N{
N	pGPIOGPINT[group].PORT_ENA[port] |= pinMask;
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __GPIOGROUP_5411X_H_ */
L 194 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "mailbox_5411x.h"
L 1 "..\..\..\chip_5411x\inc\mailbox_5411x.h" 1
N/*
N * @brief LPC5411X Mailbox M4/M0+ driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __MAILBOX_5411X_H_
N#define __MAILBOX_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup MAILBOX_5411X CHIP: LPC5411X Mailbox M4/M0+ driver
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/* Mailbox indexes */
Ntypedef enum {
N	MAILBOX_CM0PLUS = 0,
N	MAILBOX_CM4
N} MBOX_IDX_T;
N#define MAILBOX_AVAIL       (MAILBOX_CM4 + 1)	/* Number of available mailboxes */
N
N/** Individual mailbox IRQ structure */
Ntypedef struct {
N	__IO    uint32_t        IRQ;		/*!< Mailbox data */
X	volatile    uint32_t        IRQ;		 
N	__O     uint32_t        IRQSET;		/*!< Mailbox data set bits only */
X	volatile     uint32_t        IRQSET;		 
N	__O     uint32_t        IRQCLR;		/*!< Mailbox dataclearset bits only */
X	volatile     uint32_t        IRQCLR;		 
N	__I     uint32_t        RESERVED;
X	volatile const     uint32_t        RESERVED;
N} LPC_MBOXIRQ_T;
N
N/** Mailbox register structure */
Ntypedef struct {						/*!< Mailbox register structure */
N	LPC_MBOXIRQ_T           BOX[MAILBOX_AVAIL];	/*!< Mailbox, offset 0 = M0+, offset 1 = M4 */
X	LPC_MBOXIRQ_T           BOX[(MAILBOX_CM4 + 1)];	 
N	LPC_MBOXIRQ_T           RESERVED1[15 - MAILBOX_AVAIL];
X	LPC_MBOXIRQ_T           RESERVED1[15 - (MAILBOX_CM4 + 1)];
N	__I     uint32_t        RESERVED2[2];
X	volatile const     uint32_t        RESERVED2[2];
N	__IO    uint32_t        MUTEX;		/*!< Mutex */
X	volatile    uint32_t        MUTEX;		 
N} LPC_MBOX_T;
N
N/**
N * @brief	Initialize mailbox
N * @param	pMBOX	: Pointer to the mailbox register structure
N * @return	Nothing
N * @note	Even if both cores use the amilbox, only 1 core should initialize it.
N */
N__STATIC_INLINE void Chip_MBOX_Init(LPC_MBOX_T *pMBOX)
Xstatic __inline void Chip_MBOX_Init(LPC_MBOX_T *pMBOX)
N{
N	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_MAILBOX);
N}
N
N/**
N * @brief	Shutdown mailbox
N * @param	pMBOX	: Pointer to the mailbox register structure
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_MBOX_DeInit(LPC_MBOX_T *pMBOX)
Xstatic __inline void Chip_MBOX_DeInit(LPC_MBOX_T *pMBOX)
N{
N	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_MAILBOX);
N}
N
N/**
N * @brief	Set data value in the mailbox based on the CPU ID
N * @param	pMBOX		: Pointer to the mailbox register structure
N * @param	cpu_id		: MAILBOX_CM0PLUS is M0+ or MAILBOX_CM4 is M4
N * @param	mboxData	: data to send in the mailbox
N * @return	Nothing
N * @note	Sets a data value to send via the MBOX to the other core.
N */
N__STATIC_INLINE void Chip_MBOX_SetValue(LPC_MBOX_T *pMBOX, uint32_t cpu_id, uint32_t mboxData)
Xstatic __inline void Chip_MBOX_SetValue(LPC_MBOX_T *pMBOX, uint32_t cpu_id, uint32_t mboxData)
N{
N	pMBOX->BOX[cpu_id].IRQ = mboxData;
N}
N
N/**
N * @brief	Set data bits in the mailbox based on the CPU ID
N * @param	pMBOX		: Pointer to the mailbox register structure
N * @param	cpu_id		: MAILBOX_CM0PLUS is M0+ or MAILBOX_CM4 is M4
N * @param	mboxSetBits	: data bits to set in the mailbox
N * @return	Nothing
N * @note	Sets data bits to send via the MBOX to the other core, A value of 0 will
N * do nothing.  Only sets bits selected with a 1 in it's bit position.
N */
N__STATIC_INLINE void Chip_MBOX_SetValueBits(LPC_MBOX_T *pMBOX, uint32_t cpu_id, uint32_t mboxSetBits)
Xstatic __inline void Chip_MBOX_SetValueBits(LPC_MBOX_T *pMBOX, uint32_t cpu_id, uint32_t mboxSetBits)
N{
N	pMBOX->BOX[cpu_id].IRQSET = mboxSetBits;
N}
N
N/**
N * @brief	Clear data bits in the mailbox based on the CPU ID
N * @param	pMBOX		: Pointer to the mailbox register structure
N * @param	cpu_id		: MAILBOX_CM0PLUS is M0+ or MAILBOX_CM4 is M4
N * @param	mboxClrBits	: data bits to clear in the mailbox
N * @return	Nothing
N * @note	Clear data bits to send via the MBOX to the other core. A value of 0 will
N * do nothing. Only clears bits selected with a 1 in it's bit position.
N */
N__STATIC_INLINE void Chip_MBOX_ClearValueBits(LPC_MBOX_T *pMBOX, uint32_t cpu_id, uint32_t mboxClrBits)
Xstatic __inline void Chip_MBOX_ClearValueBits(LPC_MBOX_T *pMBOX, uint32_t cpu_id, uint32_t mboxClrBits)
N{
N	pMBOX->BOX[cpu_id].IRQCLR = mboxClrBits;
N}
N
N/**
N * @brief	Get data in the mailbox based on the cpu_id
N * @param	pMBOX	: Pointer to the mailbox register structure
N * @param	cpu_id	: MAILBOX_CM0PLUS is M0+ or MAILBOX_CM4 is M4
N * @return	Current mailbox data
N */
N__STATIC_INLINE uint32_t Chip_MBOX_GetValue(LPC_MBOX_T *pMBOX, uint32_t cpu_id)
Xstatic __inline uint32_t Chip_MBOX_GetValue(LPC_MBOX_T *pMBOX, uint32_t cpu_id)
N{
N	return pMBOX->BOX[cpu_id].IRQ;
N}
N
N/**
N * @brief	Get MUTEX state and lock mutex
N * @param	pMBOX	: Pointer to the mailbox register structure
N * @return	See note
N * @note	Returns '1' if the mutex was taken or '0' if another resources has the
N * mutex locked. Once a mutex is taken, it can be returned with the Chip_MBOX_SetMutex()
N * function.
N */
N__STATIC_INLINE uint32_t Chip_MBOX_GetMutex(LPC_MBOX_T *pMBOX)
Xstatic __inline uint32_t Chip_MBOX_GetMutex(LPC_MBOX_T *pMBOX)
N{
N	return pMBOX->MUTEX;
N}
N
N/**
N * @brief	Set MUTEX state
N * @param	pMBOX	: Pointer to the mailbox register structure
N * @return	Nothing
N * @note	Sets mutex state to '1' and allows other resources to get the mutex
N */
N__STATIC_INLINE void Chip_MBOX_SetMutex(LPC_MBOX_T *pMBOX)
Xstatic __inline void Chip_MBOX_SetMutex(LPC_MBOX_T *pMBOX)
N{
N	pMBOX->MUTEX = 1;
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MAILBOX_5411X_H_ */
L 195 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "fpu_init.h"
L 1 "..\..\..\chip_5411x\inc\fpu_init.h" 1
N/*
N * @brief FPU init code
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __FPU_INIT_H_
N#define __FPU_INIT_H_
N
N/**
N * @defgroup CHIP_FPU_CMX CHIP: FPU initialization
N * @ingroup CHIP_Common
N * Cortex FPU initialization
N * @{
N */
N
N/**
N * @brief	Early initialization of the FPU
N * @return	Nothing
N */
Nvoid fpuInit(void);
N
N/**
N * @}
N */
N
N#endif /* __FPU_INIT_H_ */
L 196 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "power_lib_5411x.h"
L 1 "..\..\..\chip_5411x\inc\power_lib_5411x.h" 1
N/*
N * @brief LPC5411x Power library functions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2016
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __POWER_LIB_5411X_H_
N#define __POWER_LIB_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup POWER_LIBRARY_5411X CHIP: LPC5411X Power LIBRARY functions
N * The power library provides functions to control system power usage and
N * place the device into low power modes.<br>
N *
N * <b>Clock shutdown in sleep and power down modes</b><br>
N * When using the Chip_POWER_EnterPowerMode() function, system clocks are
N * shutdown based on the selected sleep or power down mode and the device
N * version being used. The following list details which clocks are shut down
N * in which modes for which device versions. You can keep a clock enabled
N * for a sleep or power down mode by enabling it in the 'peripheral_ctrl'
N * field in the Chip_POWER_EnterPowerMode() function.<br>
N *
N * Mode: Sleep<br>
N * No clocks are disabled for any chip version.<br>
N *
N * Mode: Deep sleep<br>
N * SYSCON_PDRUNCFG_PD_IRC_OSC<br>
N * SYSCON_PDRUNCFG_PD_IRC<br>
N * SYSCON_PDRUNCFG_PD_FLASH (v17.1 and later only)<br>
N * SYSCON_PDRUNCFG_PD_BOD_INTR<br>
N * SYSCON_PDRUNCFG_PD_ADC0<br>
N * SYSCON_PDRUNCFG_PD_ROM<br>
N * SYSCON_PDRUNCFG_PD_VDDA_ENA<br>
N * SYSCON_PDRUNCFG_PD_SYS_PLL<br>
N * SYSCON_PDRUNCFG_PD_VREFP<br>
N *
N * Mode: Power down<br>
N * SYSCON_PDRUNCFG_PD_IRC_OSC<br>
N * SYSCON_PDRUNCFG_PD_IRC<br>
N * SYSCON_PDRUNCFG_PD_FLASH (v17.1 and later only)<br>
N * SYSCON_PDRUNCFG_PD_BOD_RST<br>
N * SYSCON_PDRUNCFG_PD_BOD_INTR<br>
N * SYSCON_PDRUNCFG_PD_ADC0<br>
N * SYSCON_PDRUNCFG_PD_SRAM0B<br>
N * SYSCON_PDRUNCFG_PD_SRAM1<br>
N * SYSCON_PDRUNCFG_PD_SRAM2<br>
N * SYSCON_PDRUNCFG_PD_ROM<br>
N * SYSCON_PDRUNCFG_PD_VDDA_ENA<br>
N * SYSCON_PDRUNCFG_PD_WDT_OSC<br>
N * SYSCON_PDRUNCFG_PD_SYS_PLL<br>
N * SYSCON_PDRUNCFG_PD_VREFP<br>
N * SYSCON_PDRUNCFG_PD_32K_OSC<br>
N *
N * Mode: Deep power down<br>
N * All clocks are disabled for all chip versions.<br>
N *
N * If you are using a peripheral was a wakeup source for a power down mode,
N * it needs to be kept active with the call to Chip_POWER_EnterPowerMode(). For
N * example, if you are using the RTC to wake the system up from power down mode,
N * the 32KHz RTC oscillator needs to remain active, so the power down call would
N * look like this:<br>
N * Chip_POWER_EnterPowerMode(POWER_POWER_DOWN, SYSCON_PDRUNCFG_PD_32K_OSC);<br>
N * If your application uses internal RAM beyond the first 8K, you will also need
N * to prevent power down of the IRAM like this:<br>
N * Chip_POWER_EnterPowerMode(POWER_POWER_DOWN, (SYSCON_PDRUNCFG_PD_32K_OSC | SYSCON_PDRUNCFG_PD_SRAM0A));<br>
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N// Saved in case they need to be re-installed publicly later
N
N/* 'mode' input values to power_mode_configure ROM function */
Ntypedef enum {
N	POWER_SLEEP = 0,
N	POWER_DEEP_SLEEP,
N	POWER_DEEP_POWER_DOWN
N} POWER_MODE_T;
N
N/**
N * @brief	Sets the High Frequency FRO rate to (48MHz or 96MHz)
N * @param	freq	: Frequency selection for FRO
N * @return	none
N */
N
Nvoid Chip_POWER_SetFROHFRate(uint32_t freq);
N
N/**
N * @brief	Sets up the System PLL given the PLL input frequency and feedback multiplier
N * @param	multiply_by	: PLL multiplier, minimum of 1, maximum of 16
N * @param	input_freq	: Input frequency into the PLL
N * @return	LPC_OK on success, or an error code (see error.h)
N */
Nuint32_t Chip_POWER_SetPLL(uint32_t multiply_by, uint32_t input_freq);
N
N/**
N * @brief	Set optimal system voltage based on passed system frequency
N * @param	desired_freq	: System (CPU) frequency
N * @return	LPC_OK on success, or an error code (see error.h)
N * @note	This function will adjust the system voltages to the lowest
N * levels that will support the passed CPU frequency.
N */
Nuint32_t Chip_POWER_SetVoltage(uint32_t desired_freq);
N
N/**
N * @brief	Set low-power voltage levels for LP mode
N * @param   frequency : This is the frequency at which CPU is running.
N * @note    Low power mode is only possible at 12MHz and 48MHz FRO
N * @return	Nothing
N */
Nvoid Chip_POWER_SetLowPowerVoltage(uint32_t freq);
N
N/**
N * @brief	Enters the selected power state
N * @param	mode			: Power mode
N * @param	peripheral_ctrl	: Peripherals that will remain powered up in the power state
N * @return	Nothing
N * @note	The 'peripheral_ctrl' field is a bitmask of bits from the
N * PDRUNCFG register (SYSCON_PDRUNCFG_PD_*) that describe which
N * peripherals can wake up the chip from the power state. These
N * peripherals are not powered down during the power state.<br>
N */
Nvoid Chip_POWER_EnterPowerMode(POWER_MODE_T mode, uint32_t peripheral_ctrl);
N
N/* ROM versions */
N#define LPC5411X_ROMVER_0   (0x1100)
N#define LPC5411X_ROMVER_1   (0x1101)
N#define LPC5411X_ROMVER_2   (0x1102)
N
N/**
N * @brief	Return ROM version
N * @return	ROM version
N * @note	Will return one of the following version numbers:<br>
N * (0x1100) for v17.0 ROMs.<br>
N * (0x1101) for v17.1 ROMs.<br>
N * (0x1102) for v17.2 ROMs.<br>
N */
Nuint32_t Chip_POWER_GetROMVersion(void);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __POWER_LIB_5411X_H_ */
L 197 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "flexcomm_5411x.h"
L 1 "..\..\..\chip_5411x\inc\flexcomm_5411x.h" 1
N/*
N * @brief LPC5411X FLEXCOMM driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licenser disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __FLEXCOMM_5411X_H_
N#define __FLEXCOMM_5411X_H_
N
N#include "cmsis.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup FLEXCOMM_5411X CHIP: LPC5411X flexcomm API
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
Ntypedef void LPC_FLEXCOMM_T;
N
N/** @brief	FLEXCOMM Peripheral functions */
Ntypedef enum {
N	FLEXCOMM_PERIPH_NONE,      /*!< No peripheral */
N	FLEXCOMM_PERIPH_USART,     /*!< USART peripheral */
N	FLEXCOMM_PERIPH_SPI,       /*!< SPI Peripheral */
N	FLEXCOMM_PERIPH_I2C,       /*!< I2C Peripheral */
N	FLEXCOMM_PERIPH_I2S_TX,    /*!< I2S TX Peripheral */
N	FLEXCOMM_PERIPH_I2S_RX,    /*!< I2S RX Peripheral */
N} FLEXCOMM_PERIPH_T;
N
N/** @brief	FlexCOMM PSEL register bits */
N#define FLEXCOMM_LOCK         (1 << 3)       /*!< Lock Bit */
N#define FLEXCOMM_ID_USART     (1 << 4)       /*!< USART Support bit */
N#define FLEXCOMM_ID_SPI       (1 << 5)       /*!< SPI Support bit */
N#define FLEXCOMM_ID_I2C       (1 << 6)       /*!< I2C Support bit */
N#define FLEXCOMM_ID_I2S       (1 << 7)       /*!< I2S Support bit */
N
N/**	@brief Flexcomm error and offset values */
N#define ERR_FLEXCOMM_FUNCNOTSUPPORTED     -1       /*!< Selected flexcomm does not support the function desired */
N#define ERR_FLEXCOMM_NOTFREE              -2       /*!< FlexCOMM is not free (used as a different peripheral) */
N#define ERR_FLEXCOMM_INVALIDBASE          -3       /*!< Invalid flexcomm base address */
N#define FLEXCOMM_PSEL_OFFSET              0xFF8   /*!< Offset of the flexcomm PSEL register */
N
N/**
N * @brief	Get currently enabled FLEXCOMM function
N * @param	pFCOMM	: Base address of the flexcomm peripheral
N * @return	Enabled flexcomm peripheral (See #FLEXCOMM_PERIPH_T)
N */
N__STATIC_INLINE FLEXCOMM_PERIPH_T Chip_FLEXCOMM_GetFunc(LPC_FLEXCOMM_T *pFCOMM)
Xstatic __inline FLEXCOMM_PERIPH_T Chip_FLEXCOMM_GetFunc(LPC_FLEXCOMM_T *pFCOMM)
N{
N	return (FLEXCOMM_PERIPH_T)(((volatile uint32_t *) pFCOMM)[FLEXCOMM_PSEL_OFFSET / 4] & 7);
X	return (FLEXCOMM_PERIPH_T)(((volatile uint32_t *) pFCOMM)[0xFF8 / 4] & 7);
N}
N
N/**
N * @brief	Checks if given FLEXCOMM is locked to a function
N * @param	pFCOMM	: Base address of the flexcomm peripheral
N * @return	1 - FLEXCOMM is locked to a function; 0 - FLEXCOMM is not locked
N */
N__STATIC_INLINE int Chip_FLEXCOMM_IsLocked(LPC_FLEXCOMM_T *pFCOMM)
Xstatic __inline int Chip_FLEXCOMM_IsLocked(LPC_FLEXCOMM_T *pFCOMM)
N{
N	return (((volatile uint32_t *) pFCOMM)[FLEXCOMM_PSEL_OFFSET / 4] & FLEXCOMM_LOCK) != 0;
X	return (((volatile uint32_t *) pFCOMM)[0xFF8 / 4] & (1 << 3)) != 0;
N}
N
N/**
N * @brief	Lock FLEXCOMM to a function
N * @param	pFCOMM	: Base address of the flexcomm peripheral
N * @return	Nothing
N * @note	Once the FLEXCOMM is locked, it can only be unlocked by a reset
N */
N__STATIC_INLINE void Chip_FLEXCOMM_Lock(LPC_FLEXCOMM_T *pFCOMM)
Xstatic __inline void Chip_FLEXCOMM_Lock(LPC_FLEXCOMM_T *pFCOMM)
N{
N	volatile uint32_t *psel = &((volatile uint32_t *)pFCOMM)[FLEXCOMM_PSEL_OFFSET / 4];
X	volatile uint32_t *psel = &((volatile uint32_t *)pFCOMM)[0xFF8 / 4];
N	if (!(*psel & FLEXCOMM_LOCK))
X	if (!(*psel & (1 << 3)))
N		*psel = (*psel & 0xF) | FLEXCOMM_LOCK;
X		*psel = (*psel & 0xF) | (1 << 3);
N}
N
N/**
N * @brief	Set FLEXCOMM to a peripheral function
N * @param	pFCOMM	: Base address of the flexcomm peripheral
N * @param	periph	: Selected peripheral (See #FLEXCOMM_PERIPH_T)
N * @param	lock	: 1 - Flexcomm will be locked as given peripheral, 0 - Do not lock
N * @sa		Chip_FLEXCOMM_Init()
N * @return	0 on success, #ERR_FLEXCOMM_FUNCNOTSUPPORTED when the given FlexComm does not
N * support peripheral provided by @a periph, #ERR_FLEXCOMM_NOTFREE when the flexcomm is
N * being used already as a peripheral.
N * @note	Once the FLEXCOMM is locked, it can only be unlocked by a reset
N */
Nint Chip_FLEXCOMM_SetPeriph(LPC_FLEXCOMM_T *pFCOMM, FLEXCOMM_PERIPH_T periph, int lock);
N
N/**
N * @brief	Get index of the FLEXCOMM corresponding to the given base address
N * @param	pFCOMM	: Base address of the flexcomm peripheral
N * @return	Index of FLEXCOMM, #ERR_FLEXCOMM_INVALIDBASE - when base address is invalid
N */
Nint Chip_FLEXCOMM_GetIndex(LPC_FLEXCOMM_T *pFCOMM);
N
N/**
N * @brief	Initialize FlexCOMM and associate it with a given peripheral
N * @param	pFCOMM	: Base address of the flexcomm peripheral
N * @param	periph	: Peripheral to set the FlexCOMM to
N * @return	0 on success, #ERR_FLEXCOMM_FUNCNOTSUPPORTED when the given FlexComm does not
N * support peripheral provided by @a periph, #ERR_FLEXCOMM_NOTFREE when the flexcomm is
N * being used already as a peripheral.
N */
Nint Chip_FLEXCOMM_Init(LPC_FLEXCOMM_T *pFCOMM, FLEXCOMM_PERIPH_T periph);
N
N/**
N * @brief	Uninitialize the FlexCOMM
N * @param	pFCOMM	: Base address of the flexcomm peripheral
N * @return	Nothing
N */
Nvoid Chip_FLEXCOMM_DeInit(LPC_FLEXCOMM_T *pFCOMM);
N
N /**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __FLEXCOMM_5411X_H_ */
L 198 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "usbd_5411x.h"
L 1 "..\..\..\chip_5411x\inc\usbd_5411x.h" 1
N/*
N * @brief LPC5411x USB device register block
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __USBD_5411X_H_
N#define __USBD_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup USBD_5411X CHIP: LPC5411x USB Device driver
N * @ingroup CHIP_5411X_Drivers
N * @{
N */
N
N/**
N * @brief USB device register block structure
N */
Ntypedef struct {				/*!< (@ 0x40080000) USB Structure */
N	__IO uint32_t DEVCMDSTAT;	/*!< (@ 0x40080000) USB Device Command/Status register */
X	volatile uint32_t DEVCMDSTAT;	 
N	__IO uint32_t INFO;			/*!< (@ 0x40080004) USB Info register */
X	volatile uint32_t INFO;			 
N	__IO uint32_t EPLISTSTART;	/*!< (@ 0x40080008) USB EP Command/Status List start address */
X	volatile uint32_t EPLISTSTART;	 
N	__IO uint32_t DATABUFSTART;	/*!< (@ 0x4008000C) USB Data buffer start address */
X	volatile uint32_t DATABUFSTART;	 
N	__IO uint32_t LPM;			/*!< (@ 0x40080010) Link Power Management register */
X	volatile uint32_t LPM;			 
N	__IO uint32_t EPSKIP;		/*!< (@ 0x40080014) USB Endpoint skip */
X	volatile uint32_t EPSKIP;		 
N	__IO uint32_t EPINUSE;		/*!< (@ 0x40080018) USB Endpoint Buffer in use */
X	volatile uint32_t EPINUSE;		 
N	__IO uint32_t EPBUFCFG;		/*!< (@ 0x4008001C) USB Endpoint Buffer Configuration register */
X	volatile uint32_t EPBUFCFG;		 
N	__IO uint32_t INTSTAT;		/*!< (@ 0x40080020) USB interrupt status register */
X	volatile uint32_t INTSTAT;		 
N	__IO uint32_t INTEN;		/*!< (@ 0x40080024) USB interrupt enable register */
X	volatile uint32_t INTEN;		 
N	__IO uint32_t INTSETSTAT;	/*!< (@ 0x40080028) USB set interrupt status register */
X	volatile uint32_t INTSETSTAT;	 
N	__I  uint32_t RESERVED0[2];
X	volatile const  uint32_t RESERVED0[2];
N	__I  uint32_t EPTOGGLE;		/*!< (@ 0x40080034) USB Endpoint toggle register */
X	volatile const  uint32_t EPTOGGLE;		 
N} LPC_USB_T;
N
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __USBD_5411X_H_ */
L 199 "..\..\..\chip_5411x\inc\chip.h" 2
N
N#include "adc_5411x.h"
L 1 "..\..\..\chip_5411x\inc\adc_5411x.h" 1
N/*
N * @brief LPC5411X ADC driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __ADC_5411X_H_
N#define __ADC_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup ADC_5411X CHIP:  LPC5411X A/D conversion driver
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/** Sequence index enumerations, used in various parts of the code for
N    register indexing and sequencer selection */
Ntypedef enum {
N	ADC_SEQA_IDX = 0,
N	ADC_SEQB_IDX
N} ADC_SEQ_IDX_T;
N
N/**
N * @brief ADC register block structure
N */
Ntypedef struct {								/*!< ADCn Structure */
N	__IO uint32_t CTRL;			// (0x00)
X	volatile uint32_t CTRL;			
N	__IO uint32_t INSEL;		// (0x04)
X	volatile uint32_t INSEL;		
N	union {
N		__IO uint32_t SEQ_CTRL[2];	// (0x08~0x0C)
X		volatile uint32_t SEQ_CTRL[2];	
N		struct {
N			__IO uint32_t SEQA_CTRL;
X			volatile uint32_t SEQA_CTRL;
N			__IO uint32_t SEQB_CTRL;
X			volatile uint32_t SEQB_CTRL;
N		};
N
N	};
N
N	union {
N		__IO uint32_t SEQ_GDAT[2];	// (0x10~0x14)
X		volatile uint32_t SEQ_GDAT[2];	
N		struct {
N			__IO uint32_t SEQA_GDAT;
X			volatile uint32_t SEQA_GDAT;
N			__IO uint32_t SEQB_GDAT;
X			volatile uint32_t SEQB_GDAT;
N		};
N
N	};
N
N	__IO uint32_t RESERVED0[2];	// (0x18-0x1C)
X	volatile uint32_t RESERVED0[2];	
N	__IO uint32_t DAT[12];		// (0x20-0x4C)
X	volatile uint32_t DAT[12];		
N	__IO uint32_t THR_LOW[2];	// (0x50~0x54)
X	volatile uint32_t THR_LOW[2];	
N	__IO uint32_t THR_HIGH[2];	// (0x58~0x5C)
X	volatile uint32_t THR_HIGH[2];	
N	__IO uint32_t CHAN_THRSEL;	// (0x60)
X	volatile uint32_t CHAN_THRSEL;	
N	__IO uint32_t INTEN;		// (0x64)
X	volatile uint32_t INTEN;		
N	__IO uint32_t FLAGS;		// (0x68)
X	volatile uint32_t FLAGS;		
N	__IO uint32_t STARTUP;		// (0x6C)
X	volatile uint32_t STARTUP;		
N	__IO uint32_t CALIBR;		// (0x70)
X	volatile uint32_t CALIBR;		
N} LPC_ADC_T;
N
N/** Maximum sample rate in Hz (12-bit conversions) */
N#define ADC_MAX_SAMPLE_RATE 80000000
N#define ADC_MAX_CHANNEL_NUM 12
N
N/**
N * @brief ADC register support bitfields and mask
N */
N/** ADC Control register bit fields */
N#define ADC_CR_CLKDIV_MASK      (0xFF << 0)				/*!< Mask for Clock divider value */
N#define ADC_CR_CLKDIV_BITPOS    (0)						/*!< Bit position for Clock divider value */
N#define ADC_CR_ASYNC_MODE               (1 << 8)				/*!< Asynchronous mode enable bit */
N#define ADC_CR_RESOL(n)         ((n) << 9)			/*!< 2-bits, 6(0x0),8(0x1),10(0x2),12(0x3)-bit mode enable bit */
N#define ADC_CR_LPWRMODEBIT      (1 << 10)				/*!< Low power mode enable bit */
N#define ADC_CR_BYPASS           (1 << 11)				/*!< Bypass mode */
N#define ADC_CR_TSAMP(n)         ((n) << 12)			/*!< 3-bits, 2.5(0x0),3.5(0x1),4.5(0x2),5.5(0x3),6.5(0x4),7.5(0x5),8.5(0x6),9.5(0x7) ADC clocks sampling time */
N#define ADC_CR_CALMODEBIT       (1 << 30)				/*!< Self calibration cycle enable bit */
N#define ADC_CR_BITACC(n)        ((((n) & 0x1) << 9))	/*!< 12-bit or 10-bit ADC accuracy */
N#define ADC_CR_CLKDIV(n)        ((((n) & 0xFF) << 0))	/*!< The APB clock (PCLK) is divided by (this value plus one) to produce the clock for the A/D */
N#define ADC_SAMPLE_RATE_CONFIG_MASK (ADC_CR_CLKDIV(0xFF) | ADC_CR_BITACC(0x01))
N
N/**
N * @brief ADC sampling time bits 12, 13 and 14
N */
Ntypedef enum _ADC_TSAMP_T {
N	ADC_TSAMP_2CLK5 = 0,
N	ADC_TSAMP_3CLK5,
N	ADC_TSAMP_4CLK5,
N	ADC_TSAMP_5CLK5,
N	ADC_TSAMP_6CLK5,
N	ADC_TSAMP_7CLK5,
N	ADC_TSAMP_8CLK5,
N	ADC_TSAMP_9CLK5,
N} ADC_TSAMP_T;
N
N/** SEQ_CTRL register bit fields */
N#define ADC_SEQ_CTRL_CHANNEL_EN(n)       (1 << n)
N#define ADC_SEQ_CTRL_TRIGGER(n)          ((n & 0x3f)<<12)
N#define ADC_SEQ_CTRL_HWTRIG_POLPOS       (1 << 18)		/*!< HW trigger polarity - positive edge */
N#define ADC_SEQ_CTRL_HWTRIG_SYNCBYPASS   (1 << 19)		/*!< HW trigger bypass synchronisation */
N#define ADC_SEQ_CTRL_START               (1 << 26)		/*!< Start conversion enable bit */
N#define ADC_SEQ_CTRL_BURST               (1 << 27)		/*!< Repeated conversion enable bit */
N#define ADC_SEQ_CTRL_SINGLESTEP          (1 << 28)		/*!< Single step enable bit */
N#define ADC_SEQ_CTRL_LOWPRIO             (1 << 29)		/*!< High priority enable bit (regardless of name) */
N#define ADC_SEQ_CTRL_MODE_EOS            (1 << 30)		/*!< Mode End of sequence enable bit */
N#define ADC_SEQ_CTRL_SEQ_ENA             (1UL << 31)	/*!< Sequence enable bit */
N
N/** ADC global data register bit fields */
N#define ADC_SEQ_GDAT_RESULT_MASK         (0xFFF << 4)	/*!< Result value mask */
N#define ADC_SEQ_GDAT_RESULT_BITPOS       (4)			/*!< Result start bit position */
N#define ADC_SEQ_GDAT_THCMPRANGE_MASK     (0x3 << 16)	/*!< Comparion range mask */
N#define ADC_SEQ_GDAT_THCMPRANGE_BITPOS   (16)			/*!< Comparison range bit position */
N#define ADC_SEQ_GDAT_THCMPCROSS_MASK     (0x3 << 18)	/*!< Comparion cross mask */
N#define ADC_SEQ_GDAT_THCMPCROSS_BITPOS   (18)			/*!< Comparison cross bit position */
N#define ADC_SEQ_GDAT_CHAN_MASK           (0xF << 26)	/*!< Channel number mask */
N#define ADC_SEQ_GDAT_CHAN_BITPOS         (26)			/*!< Channel number bit position */
N#define ADC_SEQ_GDAT_OVERRUN             (1 << 30)		/*!< Overrun bit */
N#define ADC_SEQ_GDAT_DATAVALID           (1UL << 31)	/*!< Data valid bit */
N
N/** ADC Data register bit fields */
N#define ADC_DR_RESULT_BITPOS       (4)			/*!< Result start bit position */
N#define ADC_DR_RESULT(n)           ((((n) >> 4) & 0xFFF))	/*!< Macro for getting the ADC data value */
N#define ADC_DR_THCMPRANGE_MASK     (0x3 << 16)			/*!< Comparion range mask */
N#define ADC_DR_THCMPRANGE_BITPOS   (16)					/*!< Comparison range bit position */
N#define ADC_DR_THCMPRANGE(n)       (((n) >> ADC_DR_THCMPRANGE_BITPOS) & 0x3)
N#define ADC_DR_THCMPCROSS_MASK     (0x3 << 18)			/*!< Comparion cross mask */
N#define ADC_DR_THCMPCROSS_BITPOS   (18)					/*!< Comparison cross bit position */
N#define ADC_DR_THCMPCROSS(n)       (((n) >> ADC_DR_THCMPCROSS_BITPOS) & 0x3)
N#define ADC_DR_CHAN_MASK           (0xF << 26)			/*!< Channel number mask */
N#define ADC_DR_CHAN_BITPOS         (26)					/*!< Channel number bit position */
N#define ADC_DR_CHANNEL(n)          (((n) >> ADC_DR_CHAN_BITPOS) & 0xF)	/*!< Channel number bit position */
N#define ADC_DR_OVERRUN             (1 << 30)			/*!< Overrun bit */
N#define ADC_DR_DATAVALID           (1UL << 31)			/*!< Data valid bit */
N#define ADC_DR_DONE(n)             (((n) >> 31))
N
N/** ADC low/high Threshold register bit fields */
N#define ADC_THR_VAL_MASK            (0xFFF << 4)		/*!< Threshold value bit mask */
N#define ADC_THR_VAL_POS             (4)					/*!< Threshold value bit position */
N
N/** ADC Threshold select register bit fields */
N#define ADC_THRSEL_CHAN_SEL_THR1(n) (1 << (n))			/*!< Select THR1 register for channel n */
N
N/** ADC Interrupt Enable register bit fields */
N#define ADC_INTEN_SEQA_ENABLE       (1 << 0)			/*!< Sequence A Interrupt enable bit */
N#define ADC_INTEN_SEQB_ENABLE       (1 << 1)			/*!< Sequence B Interrupt enable bit */
N#define ADC_INTEN_SEQN_ENABLE(seq)  (1 << (seq))		/*!< Sequence A/B Interrupt enable bit */
N#define ADC_INTEN_OVRRUN_ENABLE     (1 << 2)			/*!< Overrun Interrupt enable bit */
N#define ADC_INTEN_CMP_DISBALE       (0)					/*!< Disable comparison interrupt value */
N#define ADC_INTEN_CMP_OUTSIDETH     (1)					/*!< Outside threshold interrupt value */
N#define ADC_INTEN_CMP_CROSSTH       (2)					/*!< Crossing threshold interrupt value */
N#define ADC_INTEN_CMP_MASK          (3)					/*!< Comparison interrupt value mask */
N#define ADC_INTEN_CMP_ENABLE(isel, ch) (((isel) & ADC_INTEN_CMP_MASK) << ((2 * (ch)) + 3))	/*!< Interrupt selection for channel */
N
N/** ADC Flags register bit fields */
N#define ADC_FLAGS_THCMP_MASK(ch)    (1 << (ch))		/*!< Threshold comparison status for channel */
N#define ADC_FLAGS_OVRRUN_MASK(ch)   (1 << (12 + (ch)))	/*!< Overrun status for channel */
N#define ADC_FLAGS_SEQA_OVRRUN_MASK  (1 << 24)			/*!< Seq A Overrun status */
N#define ADC_FLAGS_SEQB_OVRRUN_MASK  (1 << 25)			/*!< Seq B Overrun status */
N#define ADC_FLAGS_SEQN_OVRRUN_MASK(seq) (1 << (24 + (seq)))	/*!< Seq A/B Overrun status */
N#define ADC_FLAGS_SEQA_INT_MASK     (1 << 28)			/*!< Seq A Interrupt status */
N#define ADC_FLAGS_SEQB_INT_MASK     (1 << 29)			/*!< Seq B Interrupt status */
N#define ADC_FLAGS_SEQN_INT_MASK(seq) (1 << (28 + (seq)))/*!< Seq A/B Interrupt status */
N#define ADC_FLAGS_THCMP_INT_MASK    (1 << 30)			/*!< Threshold comparison Interrupt status */
N#define ADC_FLAGS_OVRRUN_INT_MASK   (1UL << 31)			/*!< Overrun Interrupt status */
N
N/** ADC Startup register bit fields */
N#define ADC_STARTUP_ENABLE       (0x1 << 0)
N#define ADC_STARTUP_INIT         (0x1 << 1)
N
N/* ADC Calibration register definition */
N#define ADC_CALIB						(0x1<<0)
N#define ADC_CALREQD						(0x1<<1)
N
N/**
N * @brief	Initialize the ADC peripheral
N * @param	pADC	: The base of ADC peripheral on the chip
N * @param	flags	: ADC flags for init (ADC_CR_MODE10BIT and/or ADC_CR_LPWRMODEBIT)
N * @return	Nothing
N * @note	To select low-power ADC mode, enable the ADC_CR_LPWRMODEBIT flag.
N * To select 10-bit conversion mode, enable the ADC_CR_MODE10BIT flag.<br>
N * Example: Chip_ADC_Init(LPC_ADC, (ADC_CR_MODE10BIT | ADC_CR_LPWRMODEBIT));
N */
Nvoid Chip_ADC_Init(LPC_ADC_T *pADC, uint32_t flags);
N
N/**
N * @brief	Shutdown ADC
N * @param	pADC	: The base of ADC peripheral on the chip
N * @return	Nothing
N * @note	Disables the ADC clocks and ADC power
N */
Nvoid Chip_ADC_DeInit(LPC_ADC_T *pADC);
N
N/**
N * @brief	Set ADC divider
N * @param	pADC	: The base of ADC peripheral on the chip
N * @param	div		: ADC divider value to set minus 1
N * @return	Nothing
N * @note	The value is used as a divider to generate the ADC
N * clock rate from the ADC input clock. The ADC input clock is based
N * on the system clock. Valid values for this function are from 0 to 255
N * with 0=divide by 1, 1=divide by 2, 2=divide by 3, etc.<br>
N * Do not decrement this value by 1.<br>
N * To set the ADC clock rate to 1MHz, use the following function:<br>
N * Chip_ADC_SetDivider(LPC_ADC, (Chip_Clock_GetSystemClockRate() / 1000000) - 1);
N */
N__STATIC_INLINE void Chip_ADC_SetDivider(LPC_ADC_T *pADC, uint8_t div)
Xstatic __inline void Chip_ADC_SetDivider(LPC_ADC_T *pADC, uint8_t div)
N{
N	uint32_t temp;
N
N	temp = pADC->CTRL & ~(ADC_CR_CLKDIV_MASK);
X	temp = pADC->CTRL & ~((0xFF << 0));
N	pADC->CTRL = temp | (uint32_t) div;
N}
N
N/**
N * @brief	Set ADC clock rate
N * @param	pADC	: The base of ADC peripheral on the chip
N * @param	rate	: rate in Hz to set ADC clock to (maximum ADC_MAX_SAMPLE_RATE)
N * @return	Nothing
N */
Nvoid Chip_ADC_SetClockRate(LPC_ADC_T *pADC, uint32_t rate);
N
N/**
N * @brief	Get ADC divider
N * @param	pADC	: The base of ADC peripheral on the chip
N * @return	the current ADC divider
N * @note	This function returns the divider that is used to generate the
N * ADC frequency. The returned value must be incremented by 1. The
N * frequency can be determined with the following function:<br>
N * adc_freq = Chip_Clock_GetSystemClockRate() / (Chip_ADC_GetDivider(LPC_ADC) + 1);
N */
N__STATIC_INLINE uint8_t Chip_ADC_GetDivider(LPC_ADC_T *pADC)
Xstatic __inline uint8_t Chip_ADC_GetDivider(LPC_ADC_T *pADC)
N{
N	return pADC->CTRL & ADC_CR_CLKDIV_MASK;
X	return pADC->CTRL & (0xFF << 0);
N}
N
N/**
N * @brief	Perform ADC calibration
N * @param	pADC	: The base of ADC peripheral on the chip
N * @return	LPC_OK on success, ERR_TIME_OUT or ERR_ADC_NO_POWER on failure
N * @note	Calibration is not done as part of Chip_ADC_Init(), but
N * is required after the call to Chip_ADC_Init() or after returning
N * from a power-down state.
N */
Nuint32_t Chip_ADC_Calibration(LPC_ADC_T *pADC);
N
N/**
N * @brief	Selects Temperature sensor as the input for Channel 0
N * @param	pADC		: The base of ADC peripheral on the chip
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_ADC_SelectTempSensorInput(LPC_ADC_T *pADC)
Xstatic __inline void Chip_ADC_SelectTempSensorInput(LPC_ADC_T *pADC)
N{
N	/* Select Temperature sensor as the input for Channel 0 */
N	pADC->INSEL = 0x03;
N}
N
N
N/**
N * @brief	Helper function for safely setting ADC sequencer register bits
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param	seqIndex	: Sequencer to set bits for
N * @param	bits		: Or'ed bits of a sequencer register to set
N * @return	Nothing
N * @note	This function will safely set the ADC sequencer register bits
N * while maintaining bits 20..25 as 0, regardless of the read state of those bits.
N */
N__STATIC_INLINE void Chip_ADC_SetSequencerBits(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex, uint32_t bits)
Xstatic __inline void Chip_ADC_SetSequencerBits(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex, uint32_t bits)
N{
N	/* Read sequencer register and mask off bits 20..25 */
N	pADC->SEQ_CTRL[seqIndex] = (pADC->SEQ_CTRL[seqIndex] & ~(0x3F << 20)) | bits;
N}
N
N/**
N * @brief	Helper function for safely clearing ADC sequencer register bits
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param	seqIndex	: Sequencer to clear bits for
N * @param	bits		: Or'ed bits of a sequencer register to clear
N * @return	Nothing
N * @note	This function will safely clear the ADC sequencer register bits
N * while maintaining bits 20..25 as 0, regardless of the read state of those bits.
N */
N__STATIC_INLINE void Chip_ADC_ClearSequencerBits(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex, uint32_t bits)
Xstatic __inline void Chip_ADC_ClearSequencerBits(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex, uint32_t bits)
N{
N	/* Read sequencer register and mask off bits 20..25 */
N	pADC->SEQ_CTRL[seqIndex] = pADC->SEQ_CTRL[seqIndex] & ~((0x3F << 20) | bits);
N}
N
N/**
N * @brief	Sets up ADC conversion sequencer A or B
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param	seqIndex	: Sequencer to setup
N * @param	options		: OR'ed Sequencer options to setup (see notes)
N * @return	Nothing
N * @note	Sets up sequencer options for a conversion sequence. This function
N * should be used to setup the selected channels for the sequence, the sequencer
N * trigger, the trigger polarity, synchronization bypass, priority, and mode. All
N * options are passed to the functions as a OR'ed list of values. This function will
N * disable/clear the sequencer start/burst/single step/enable if they are enabled.<br>
N * Select the channels by OR'ing in one or more ADC_SEQ_CTRL_CHANSEL(ch) values.<br>
N * Select the hardware trigger by OR'ing in one ADC_SEQ_CTRL_HWTRIG_* value.<br>
N * Select a positive edge hardware trigger by OR'ing in ADC_SEQ_CTRL_HWTRIG_POLPOS.<br>
N * Select trigger bypass synchronisation by OR'ing in ADC_SEQ_CTRL_HWTRIG_SYNCBYPASS.<br>
N * Select ADC single step on trigger/start by OR'ing in ADC_SEQ_CTRL_SINGLESTEP.<br>
N * Select higher priority conversion on the other sequencer by OR'ing in ADC_SEQ_CTRL_LOWPRIO.<br>
N * Select end of seqeuence instead of end of conversion interrupt by OR'ing in ADC_SEQ_CTRL_MODE_EOS.<br>
N * Example for setting up sequencer A (channels 0-2, trigger on high edge of PIO0_2, interrupt on end of sequence):<br>
N * Chip_ADC_SetupSequencer(LPC_ADC, ADC_SEQA_IDX, (
N *     ADC_SEQ_CTRL_CHANSEL(0) | ADC_SEQ_CTRL_CHANSEL(1) | ADC_SEQ_CTRL_CHANSEL(2) |
N *     ADC_SEQ_CTRL_HWTRIG_PIO0_2 | ADC_SEQ_CTRL_HWTRIG_POLPOS | ADC_SEQ_CTRL_MODE_EOS));
N */
N__STATIC_INLINE void Chip_ADC_SetupSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex, uint32_t options)
Xstatic __inline void Chip_ADC_SetupSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex, uint32_t options)
N{
N	pADC->SEQ_CTRL[seqIndex] = options;
N}
N
N/**
N * @brief	Get sequenceX control register value
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param	seqIndex	: Sequencer to setup
N * @return	Sequencer control register value
N */
N__STATIC_INLINE uint32_t Chip_ADC_GetSequencerCtrl(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
Xstatic __inline uint32_t Chip_ADC_GetSequencerCtrl(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
N{
N	return pADC->SEQ_CTRL[seqIndex];
N}
N
N/**
N * @brief	Enables a sequencer
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param	seqIndex	: Sequencer to enable
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_ADC_EnableSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
Xstatic __inline void Chip_ADC_EnableSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
N{
N	Chip_ADC_SetSequencerBits(pADC, seqIndex, ADC_SEQ_CTRL_SEQ_ENA);
X	Chip_ADC_SetSequencerBits(pADC, seqIndex, (1UL << 31));
N}
N
N/**
N * @brief	Disables a sequencer
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param	seqIndex	: Sequencer to disable
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_ADC_DisableSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
Xstatic __inline void Chip_ADC_DisableSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
N{
N	Chip_ADC_ClearSequencerBits(pADC, seqIndex, ADC_SEQ_CTRL_SEQ_ENA);
X	Chip_ADC_ClearSequencerBits(pADC, seqIndex, (1UL << 31));
N}
N
N/**
N * @brief	Forces a sequencer trigger event (software trigger of ADC)
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param	seqIndex	: Sequencer to start
N * @return	Nothing
N * @note	This function sets the START bit for the sequencer to force a
N * single conversion sequence or a single step conversion. START and BURST bits can not
N * be set at the same time, thus, BURST bit will be cleared.
N */
N__STATIC_INLINE void Chip_ADC_StartSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
Xstatic __inline void Chip_ADC_StartSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
N{
N	Chip_ADC_ClearSequencerBits(pADC, seqIndex, ADC_SEQ_CTRL_BURST);
X	Chip_ADC_ClearSequencerBits(pADC, seqIndex, (1 << 27));
N	Chip_ADC_SetSequencerBits(pADC, seqIndex, ADC_SEQ_CTRL_START);
X	Chip_ADC_SetSequencerBits(pADC, seqIndex, (1 << 26));
N}
N
N/**
N * @brief	Starts sequencer burst mode
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param	seqIndex	: Sequencer to start burst on
N * @return	Nothing
N * @note	This function sets the BURST bit for the sequencer to force
N * continuous conversion. Use Chip_ADC_StopBurstSequencer() to stop the
N * ADC burst sequence. START and BURST bits can not be set at the same time, thus,
N * START bit will be cleared.
N */
N__STATIC_INLINE void Chip_ADC_StartBurstSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
Xstatic __inline void Chip_ADC_StartBurstSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
N{
N	/* START and BURST bits can not be set at the same time. */
N	Chip_ADC_ClearSequencerBits(pADC, seqIndex, ADC_SEQ_CTRL_START);
X	Chip_ADC_ClearSequencerBits(pADC, seqIndex, (1 << 26));
N	Chip_ADC_SetSequencerBits(pADC, seqIndex, ADC_SEQ_CTRL_BURST);
X	Chip_ADC_SetSequencerBits(pADC, seqIndex, (1 << 27));
N}
N
N/**
N * @brief	Stops sequencer burst mode
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param	seqIndex	: Sequencer to stop burst on
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_ADC_StopBurstSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
Xstatic __inline void Chip_ADC_StopBurstSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
N{
N	Chip_ADC_ClearSequencerBits(pADC, seqIndex, ADC_SEQ_CTRL_BURST);
X	Chip_ADC_ClearSequencerBits(pADC, seqIndex, (1 << 27));
N}
N
N/** ADC sequence global data register threshold comparison range enumerations */
Ntypedef enum {
N	ADC_DR_THCMPRANGE_INRANGE,
N	ADC_DR_THCMPRANGE_RESERVED,
N	ADC_DR_THCMPRANGE_BELOW,
N	ADC_DR_THCMPRANGE_ABOVE
N} ADC_DR_THCMPRANGE_T;
N
N/** ADC sequence global data register threshold comparison cross enumerations */
Ntypedef enum {
N	ADC_DR_THCMPCROSS_NOCROSS,
N	ADC_DR_THCMPCROSS_RESERVED,
N	ADC_DR_THCMPCROSS_DOWNWARD,
N	ADC_DR_THCMPCROSS_UPWARD
N} ADC_DR_THCMPCROSS_T;
N
N/**
N * @brief	Read a ADC sequence global data register
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param	seqIndex	: Sequencer to read
N * @return	Current raw value of the ADC sequence A or B global data register
N * @note	This function returns the raw value of the data register and clears
N * the overrun and datavalid status for the register. Once this register is read,
N * the following functions can be used to parse the raw value:<br>
N * uint32_t adcDataRawValue = Chip_ADC_GetGlobalDataReg(LPC_ADC, ADC_SEQA_IDX); // Get raw value
N * uint32_t adcDataValue = ADC_DR_RESULT(adcDataRawValue); // Aligned and masked ADC data value
N * ADC_DR_THCMPRANGE_T adcRange = (ADC_DR_THCMPRANGE_T) ADC_DR_THCMPRANGE(adcDataRawValue); // Sample range compared to threshold low/high
N * ADC_DR_THCMPCROSS_T adcRange = (ADC_DR_THCMPCROSS_T) ADC_DR_THCMPCROSS(adcDataRawValue); // Sample cross compared to threshold low
N * uint32_t channel = ADC_DR_CHANNEL(adcDataRawValue); // ADC channel for this sample/data
N * bool adcDataOverrun = (bool) ((adcDataRawValue & ADC_DR_OVERRUN) != 0); // Data overrun flag
N * bool adcDataValid = (bool) ((adcDataRawValue & ADC_SEQ_GDAT_DATAVALID) != 0); // Data valid flag
N */
N__STATIC_INLINE uint32_t Chip_ADC_GetGlobalDataReg(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
Xstatic __inline uint32_t Chip_ADC_GetGlobalDataReg(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
N{
N	return pADC->SEQ_GDAT[seqIndex];
N}
N
N/**
N * @brief	Read a ADC data register
N * @param	pADC	: The base of ADC peripheral on the chip
N * @param	index	: Data register to read, 0-11
N * @return	Current raw value of the ADC data register
N * @note	This function returns the raw value of the data register and clears
N * the overrun and datavalid status for the register. Once this register is read,
N * the following functions can be used to parse the raw value:<br>
N * uint32_t adcDataRawValue = Chip_ADC_GetDataReg(LPC_ADC, ADC_MAX_CHANNEL_NUM); // Get raw value
N * uint32_t adcDataValue = ADC_DR_RESULT(adcDataRawValue); // Aligned and masked ADC data value
N * ADC_DR_THCMPRANGE_T adcRange = (ADC_DR_THCMPRANGE_T) ADC_DR_THCMPRANGE(adcDataRawValue); // Sample range compared to threshold low/high
N * ADC_DR_THCMPCROSS_T adcRange = (ADC_DR_THCMPCROSS_T) ADC_DR_THCMPCROSS(adcDataRawValue); // Sample cross compared to threshold low
N * uint32_t channel = ADC_DR_CHANNEL(adcDataRawValue); // ADC channel for this sample/data
N * bool adcDataOverrun = (bool) ((adcDataRawValue & ADC_DR_OVERRUN) != 0); // Data overrun flag
N * bool adcDataValid = (bool) ((adcDataRawValue & ADC_SEQ_GDAT_DATAVALID) != 0); // Data valid flag
N */
N__STATIC_INLINE uint32_t Chip_ADC_GetDataReg(LPC_ADC_T *pADC, uint8_t index)
Xstatic __inline uint32_t Chip_ADC_GetDataReg(LPC_ADC_T *pADC, uint8_t index)
N{
N	return pADC->DAT[index];
N}
N
N/**
N * @brief	Set Threshold low value in ADC
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param   thrnum      : Threshold register value (1 for threshold register 1, 0 for threshold register 0)
N * @param   value       : Threshold low data value (should be 12-bit value)
N * @return	None
N */
N__STATIC_INLINE void Chip_ADC_SetThrLowValue(LPC_ADC_T *pADC, uint8_t thrnum, uint16_t value)
Xstatic __inline void Chip_ADC_SetThrLowValue(LPC_ADC_T *pADC, uint8_t thrnum, uint16_t value)
N{
N	pADC->THR_LOW[thrnum] = (((uint32_t) value) << ADC_THR_VAL_POS);
X	pADC->THR_LOW[thrnum] = (((uint32_t) value) << (4));
N}
N
N/**
N * @brief	Set Threshold high value in ADC
N * @param	pADC	: The base of ADC peripheral on the chip
N * @param   thrnum	: Threshold register value (1 for threshold register 1, 0 for threshold register 0)
N * @param   value	: Threshold high data value (should be 12-bit value)
N * @return	None
N */
N__STATIC_INLINE void Chip_ADC_SetThrHighValue(LPC_ADC_T *pADC, uint8_t thrnum, uint16_t value)
Xstatic __inline void Chip_ADC_SetThrHighValue(LPC_ADC_T *pADC, uint8_t thrnum, uint16_t value)
N{
N	pADC->THR_HIGH[thrnum] = (((uint32_t) value) << ADC_THR_VAL_POS);
X	pADC->THR_HIGH[thrnum] = (((uint32_t) value) << (4));
N}
N
N/**
N * @brief	Select threshold 0 values for comparison for selected channels
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param   channels	: An OR'ed value of one or more ADC_THRSEL_CHAN_SEL_THR1(ch) values
N * @return	None
N * @note	Select multiple channels to use the threshold 0 comparison.<br>
N * Example:<br>
N * Chip_ADC_SelectTH0Channels(LPC_ADC, (ADC_THRSEL_CHAN_SEL_THR1(1) | ADC_THRSEL_CHAN_SEL_THR1(2))); // Selects channels 1 and 2 for threshold 0
N */
N__STATIC_INLINE void Chip_ADC_SelectTH0Channels(LPC_ADC_T *pADC, uint32_t channels)
Xstatic __inline void Chip_ADC_SelectTH0Channels(LPC_ADC_T *pADC, uint32_t channels)
N{
N	/* Read and write values may not be the same, write 0 to undefined bits */
N	pADC->CHAN_THRSEL = pADC->CHAN_THRSEL & (0x00000FFF & ~channels);
N}
N
N/**
N * @brief	Select threshold 1 value for comparison for selected channels
N * @param	pADC		: The base of ADC peripheral on the chip
N * @param   channels	: An OR'ed value of one or more ADC_THRSEL_CHAN_SEL_THR1(ch) values
N * @return	None
N * @note	Select multiple channels to use the 1 threshold comparison.<br>
N * Example:<br>
N * Chip_ADC_SelectTH1Channels(LPC_ADC, (ADC_THRSEL_CHAN_SEL_THR1(4) | ADC_THRSEL_CHAN_SEL_THR1(5))); // Selects channels 4 and 5 for 1 threshold
N */
N__STATIC_INLINE void Chip_ADC_SelectTH1Channels(LPC_ADC_T *pADC, uint32_t channels)
Xstatic __inline void Chip_ADC_SelectTH1Channels(LPC_ADC_T *pADC, uint32_t channels)
N{
N	/* Read and write values may not be the same, write 0 to undefined bits */
N	pADC->CHAN_THRSEL = (pADC->CHAN_THRSEL | channels) & 0x00000FFF;
N}
N
N/**
N * @brief	Enable interrupts in ADC (sequencers A/B and overrun)
N * @param	pADC	: The base of ADC peripheral on the chip
N * @param	intMask	: Interrupt values to be enabled (see notes)
N * @return	None
N * @note	Select one or more OR'ed values of ADC_INTEN_SEQA_ENABLE,
N * ADC_INTEN_SEQB_ENABLE, and ADC_INTEN_OVRRUN_ENABLE to enable the
N * specific ADC interrupts.
N */
N__STATIC_INLINE void Chip_ADC_EnableInt(LPC_ADC_T *pADC, uint32_t intMask)
Xstatic __inline void Chip_ADC_EnableInt(LPC_ADC_T *pADC, uint32_t intMask)
N{
N	/* Read and write values may not be the same, write 0 to undefined bits */
N	pADC->INTEN = (pADC->INTEN | intMask) & 0x07FFFFFF;
N}
N
N/**
N * @brief	Disable interrupts in ADC (sequencers A/B and overrun)
N * @param	pADC	: The base of ADC peripheral on the chip
N * @param	intMask	: Interrupt values to be disabled (see notes)
N * @return	None
N * @note	Select one or more OR'ed values of ADC_INTEN_SEQA_ENABLE,
N * ADC_INTEN_SEQB_ENABLE, and ADC_INTEN_OVRRUN_ENABLE to disable the
N * specific ADC interrupts.
N */
N__STATIC_INLINE void Chip_ADC_DisableInt(LPC_ADC_T *pADC, uint32_t intMask)
Xstatic __inline void Chip_ADC_DisableInt(LPC_ADC_T *pADC, uint32_t intMask)
N{
N	/* Read and write values may not be the same, write 0 to undefined bits */
N	pADC->INTEN = pADC->INTEN & (0x07FFFFFF & ~intMask);
N}
N
N/** Threshold interrupt event options */
Ntypedef enum {
N	ADC_INTEN_THCMP_DISABLE,
N	ADC_INTEN_THCMP_OUTSIDE,
N	ADC_INTEN_THCMP_CROSSING,
N} ADC_INTEN_THCMP_T;
N
N/**
N * @brief	Enable a threshold event interrupt in ADC
N * @param	pADC	: The base of ADC peripheral on the chip
N * @param	ch		: ADC channel to set threshold inetrrupt for, 1-8
N * @param	thInt	: Selected threshold interrupt type
N * @return	None
N */
N__STATIC_INLINE void Chip_ADC_SetThresholdInt(LPC_ADC_T *pADC, uint8_t ch, ADC_INTEN_THCMP_T thInt)
Xstatic __inline void Chip_ADC_SetThresholdInt(LPC_ADC_T *pADC, uint8_t ch, ADC_INTEN_THCMP_T thInt)
N{
N	int shiftIndex = 3 + (ch * 2);
N
N	/* Clear current bits first */
N	Chip_ADC_DisableInt(pADC, (ADC_INTEN_CMP_MASK << shiftIndex));
X	Chip_ADC_DisableInt(pADC, ((3) << shiftIndex));
N
N	/* Set new threshold interrupt type */
N	Chip_ADC_EnableInt(pADC, ((uint32_t) thInt << shiftIndex));
N}
N
N/**
N * @brief	Get flags register in ADC
N * @param	pADC	: The base of ADC peripheral on the chip
N * @return  Flags register value (ORed ADC_FLAG* values)
N * @note	Mask the return value of this function with the ADC_FLAGS_*
N * definitions to determine the overall ADC interrupt events.<br>
N * Example:<br>
N * if (Chip_ADC_GetFlags(LPC_ADC) & ADC_FLAGS_THCMP_MASK(3) // Check of threshold comp status for ADC channel 3
N */
N__STATIC_INLINE uint32_t Chip_ADC_GetFlags(LPC_ADC_T *pADC)
Xstatic __inline uint32_t Chip_ADC_GetFlags(LPC_ADC_T *pADC)
N{
N	return pADC->FLAGS;
N}
N
N/**
N * @brief	Clear flags register in ADC
N * @param	pADC	: The base of ADC peripheral on the chip
N * @param	flags	: An Or'ed values of ADC_FLAGS_* values to clear
N * @return  Flags register value (ORed ADC_FLAG* values)
N */
N__STATIC_INLINE void Chip_ADC_ClearFlags(LPC_ADC_T *pADC, uint32_t flags)
Xstatic __inline void Chip_ADC_ClearFlags(LPC_ADC_T *pADC, uint32_t flags)
N{
N	pADC->FLAGS = flags;
N}
N
N/**
N * @brief	Set Threshold selection bits
N * @param	pADC	: The base of ADC peripheral on the chip
N * @param	mask	: Threshold selection mask
N * @return  Nothing
N */
N__STATIC_INLINE void Chip_ADC_SetTHRSELBits(LPC_ADC_T *pADC, uint32_t mask)
Xstatic __inline void Chip_ADC_SetTHRSELBits(LPC_ADC_T *pADC, uint32_t mask)
N{
N}
N
N/**
N * @brief	Clear Threshold selection bits
N * @param	pADC	: The base of ADC peripheral on the chip
N * @param	mask	: Threshold selection mask
N * @return  Nothing
N */
N__STATIC_INLINE void Chip_ADC_ClearTHRSELBits(LPC_ADC_T *pADC, uint32_t mask)
Xstatic __inline void Chip_ADC_ClearTHRSELBits(LPC_ADC_T *pADC, uint32_t mask)
N{
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __ADC_5411X_H_ */
L 201 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "dma_5411x.h"
L 1 "..\..\..\chip_5411x\inc\dma_5411x.h" 1
N/*
N * @brief LPC5411X DMA driver declarations and functions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2015
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __DMA_5411X_H
N#define __DMA_5411X_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup DMALEG_5411X CHIP: LPC5411X DMA Engine driver (legacy)
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N/**
N * @brief DMA Controller shared registers structure
N */
Ntypedef struct {					/*!< DMA shared registers structure */
N	__IO uint32_t  ENABLESET;		/*!< DMA Channel Enable read and Set for all DMA channels */
X	volatile uint32_t  ENABLESET;		 
N	__I  uint32_t  RESERVED0;
X	volatile const  uint32_t  RESERVED0;
N	__O  uint32_t  ENABLECLR;		/*!< DMA Channel Enable Clear for all DMA channels */
X	volatile  uint32_t  ENABLECLR;		 
N	__I  uint32_t  RESERVED1;
X	volatile const  uint32_t  RESERVED1;
N	__I  uint32_t  ACTIVE;			/*!< DMA Channel Active status for all DMA channels */
X	volatile const  uint32_t  ACTIVE;			 
N	__I  uint32_t  RESERVED2;
X	volatile const  uint32_t  RESERVED2;
N	__I  uint32_t  BUSY;			/*!< DMA Channel Busy status for all DMA channels */
X	volatile const  uint32_t  BUSY;			 
N	__I  uint32_t  RESERVED3;
X	volatile const  uint32_t  RESERVED3;
N	__IO uint32_t  ERRINT;			/*!< DMA Error Interrupt status for all DMA channels */
X	volatile uint32_t  ERRINT;			 
N	__I  uint32_t  RESERVED4;
X	volatile const  uint32_t  RESERVED4;
N	__IO uint32_t  INTENSET;		/*!< DMA Interrupt Enable read and Set for all DMA channels */
X	volatile uint32_t  INTENSET;		 
N	__I  uint32_t  RESERVED5;
X	volatile const  uint32_t  RESERVED5;
N	__O  uint32_t  INTENCLR;		/*!< DMA Interrupt Enable Clear for all DMA channels */
X	volatile  uint32_t  INTENCLR;		 
N	__I  uint32_t  RESERVED6;
X	volatile const  uint32_t  RESERVED6;
N	__IO uint32_t  INTA;			/*!< DMA Interrupt A status for all DMA channels */
X	volatile uint32_t  INTA;			 
N	__I  uint32_t  RESERVED7;
X	volatile const  uint32_t  RESERVED7;
N	__IO uint32_t  INTB;			/*!< DMA Interrupt B status for all DMA channels */
X	volatile uint32_t  INTB;			 
N	__I  uint32_t  RESERVED8;
X	volatile const  uint32_t  RESERVED8;
N	__O  uint32_t  SETVALID;		/*!< DMA Set ValidPending control bits for all DMA channels */
X	volatile  uint32_t  SETVALID;		 
N	__I  uint32_t  RESERVED9;
X	volatile const  uint32_t  RESERVED9;
N	__O  uint32_t  SETTRIG;			/*!< DMA Set Trigger control bits for all DMA channels */
X	volatile  uint32_t  SETTRIG;			 
N	__I  uint32_t  RESERVED10;
X	volatile const  uint32_t  RESERVED10;
N	__O  uint32_t  ABORT;			/*!< DMA Channel Abort control for all DMA channels */
X	volatile  uint32_t  ABORT;			 
N} LPC_DMA_COMMON_T;
N
N/**
N * @brief DMA Controller shared registers structure
N */
Ntypedef struct {					/*!< DMA channel register structure */
N	__IO uint32_t  CFG;				/*!< DMA Configuration register */
X	volatile uint32_t  CFG;				 
N	__IO uint32_t  CTLSTAT;			/*!< DMA Control and status register */
X	volatile uint32_t  CTLSTAT;			 
N	__IO uint32_t  XFERCFG;			/*!< DMA Transfer configuration register */
X	volatile uint32_t  XFERCFG;			 
N	__I  uint32_t  RESERVED;
X	volatile const  uint32_t  RESERVED;
N} LPC_DMA_CHANNEL_T;
N
N/* On LPC540XX, Max DMA channel is 20 */
N#define MAX_DMA_CHANNEL         (20)
N
N/**
N * @brief DMA Controller register block structure
N */
Ntypedef struct {					/*!< DMA Structure */
N	volatile  uint32_t  CTRL;			/*!< DMA control register */
N	volatile  uint32_t  INTSTAT;			/*!< DMA Interrupt status register */
N	volatile  uint32_t  SRAMBASE;		/*!< DMA SRAM address of the channel configuration table */
N	volatile  uint32_t  RESERVED2[5];
N	LPC_DMA_COMMON_T DMACOMMON[1];	/*!< DMA shared channel (common) registers */
N	volatile  uint32_t  RESERVED0[225];
N	LPC_DMA_CHANNEL_T DMACH[MAX_DMA_CHANNEL];	/*!< DMA channel registers */
X	LPC_DMA_CHANNEL_T DMACH[(20)];	 
N} LPC_DMA_T;
N
N/* DMA channel mapping - each channel is mapped to an individual peripheral
N   and direction or a DMA imput mux trigger */
Ntypedef enum {
N	DMA_CH0,                             /* DMA Request for channel 0 */
N	DMA_CH1,                             /* DMA Request for channel 1 */
N	DMA_CH2,                             /* DMA Request for channel 2 */
N	DMA_CH3,                             /* DMA Request for channel 3 */
N	DMA_CH4,                             /* DMA Request for channel 4 */
N	DMA_CH5,                             /* DMA Request for channel 5 */
N	DMA_CH6,                             /* DMA Request for channel 6 */
N	DMA_CH7,                             /* DMA Request for channel 7 */
N	DMA_CH8,                             /* DMA Request for channel 8 */
N	DMA_CH9,                             /* DMA Request for channel 9 */
N	DMA_CH10,                            /* DMA Request for channel 10 */
N	DMA_CH11,                            /* DMA Request for channel 11 */
N	DMA_CH12,                            /* DMA Request for channel 12 */
N	DMA_CH13,                            /* DMA Request for channel 13 */
N	DMA_CH14,                            /* DMA Request for channel 14 */
N	DMA_CH15,                            /* DMA Request for channel 15 */
N	DMA_CH16,                            /* DMA Request for channel 16 */
N	DMA_CH17,                            /* DMA Request for channel 17 */
N	DMA_CH18,                            /* DMA Request for channel 18 */
N	DMA_CH19,                            /* DMA Request for channel 19 */
N
N	/* Alias DMAREQ defines */
N	DMAREQ_FLEXCOMM0_RX = DMA_CH0,       /* DMA Request for flexcomm 0 RX */
N	DMAREQ_FLEXCOMM0_TX,                 /* DMA Request for flexcomm 0 TX */
N	DMAREQ_FLEXCOMM1_RX,                 /* DMA Request for flexcomm 1 RX */
N	DMAREQ_FLEXCOMM1_TX,                 /* DMA Request for flexcomm 1 TX */
N	DMAREQ_FLEXCOMM2_RX,                 /* DMA Request for flexcomm 2 RX */
N	DMAREQ_FLEXCOMM2_TX,                 /* DMA Request for flexcomm 2 TX */
N	DMAREQ_FLEXCOMM3_RX,                 /* DMA Request for flexcomm 3 RX */
N	DMAREQ_FLEXCOMM3_TX,                 /* DMA Request for flexcomm 3 TX */
N	DMAREQ_FLEXCOMM4_RX,                 /* DMA Request for flexcomm 4 RX */
N	DMAREQ_FLEXCOMM4_TX,                 /* DMA Request for flexcomm 4 TX */
N	DMAREQ_FLEXCOMM5_RX,                 /* DMA Request for flexcomm 5 RX */
N	DMAREQ_FLEXCOMM5_TX,                 /* DMA Request for flexcomm 5 TX */
N	DMAREQ_FLEXCOMM6_RX,                 /* DMA Request for flexcomm 6 RX */
N	DMAREQ_FLEXCOMM6_TX,                 /* DMA Request for flexcomm 6 TX */
N	DMAREQ_FLEXCOMM7_RX,                 /* DMA Request for flexcomm 7 RX */
N	DMAREQ_FLEXCOMM7_TX,                 /* DMA Request for flexcomm 7 TX */
N	DMAREQ_DMIC0,                        /* DMA Request for Digital MIC-0 */
N	DMAREQ_DMIC1,                        /* DMA Request for Digital MIC-1 */
N	DMAREQ_SPIFI,                        /* DMA Request for SPIFI controller */
N} DMA_CHID_T;
N
N/* DMA interrupt status bits (common) */
N#define DMA_INTSTAT_ACTIVEINT       0x2		/*!< Summarizes whether any enabled interrupts are pending */
N#define DMA_INTSTAT_ACTIVEERRINT    0x4		/*!< Summarizes whether any error interrupts are pending */
N
N/* Support macro for DMA_CHDESC_T */
N#define DMA_ADDR(addr)      ((uint32_t) (addr))
N
N/* Support definitions for setting the configuration of a DMA channel. You
N   will need to get more information on these options from the User manual. */
N#define DMA_CFG_PERIPHREQEN     (1 << 0)	/*!< Enables Peripheral DMA requests */
N#define DMA_CFG_HWTRIGEN        (1 << 1)	/*!< Use hardware triggering via imput mux */
N#define DMA_CFG_TRIGPOL_LOW     (0 << 4)	/*!< Hardware trigger is active low or falling edge */
N#define DMA_CFG_TRIGPOL_HIGH    (1 << 4)	/*!< Hardware trigger is active high or rising edge */
N#define DMA_CFG_TRIGTYPE_EDGE   (0 << 5)	/*!< Hardware trigger is edge triggered */
N#define DMA_CFG_TRIGTYPE_LEVEL  (1 << 5)	/*!< Hardware trigger is level triggered */
N#define DMA_CFG_TRIGBURST_SNGL  (0 << 6)	/*!< Single transfer. Hardware trigger causes a single transfer */
N#define DMA_CFG_TRIGBURST_BURST (1 << 6)	/*!< Burst transfer (see UM) */
N#define DMA_CFG_BURSTPOWER_1    (0 << 8)	/*!< Set DMA burst size to 1 transfer */
N#define DMA_CFG_BURSTPOWER_2    (1 << 8)	/*!< Set DMA burst size to 2 transfers */
N#define DMA_CFG_BURSTPOWER_4    (2 << 8)	/*!< Set DMA burst size to 4 transfers */
N#define DMA_CFG_BURSTPOWER_8    (3 << 8)	/*!< Set DMA burst size to 8 transfers */
N#define DMA_CFG_BURSTPOWER_16   (4 << 8)	/*!< Set DMA burst size to 16 transfers */
N#define DMA_CFG_BURSTPOWER_32   (5 << 8)	/*!< Set DMA burst size to 32 transfers */
N#define DMA_CFG_BURSTPOWER_64   (6 << 8)	/*!< Set DMA burst size to 64 transfers */
N#define DMA_CFG_BURSTPOWER_128  (7 << 8)	/*!< Set DMA burst size to 128 transfers */
N#define DMA_CFG_BURSTPOWER_256  (8 << 8)	/*!< Set DMA burst size to 256 transfers */
N#define DMA_CFG_BURSTPOWER_512  (9 << 8)	/*!< Set DMA burst size to 512 transfers */
N#define DMA_CFG_BURSTPOWER_1024 (10 << 8)	/*!< Set DMA burst size to 1024 transfers */
N#define DMA_CFG_BURSTPOWER(n)   ((n) << 8)	/*!< Set DMA burst size to 2^n transfers, max n=10 */
N#define DMA_CFG_SRCBURSTWRAP    (1 << 14)	/*!< Source burst wrapping is enabled for this DMA channel */
N#define DMA_CFG_DSTBURSTWRAP    (1 << 15)	/*!< Destination burst wrapping is enabled for this DMA channel */
N#define DMA_CFG_CHPRIORITY(p)   ((p) << 16)	/*!< Sets DMA channel priority, min 0 (highest), max 3 (lowest) */
N
N/* DMA channel control and status register definitions */
N#define DMA_CTLSTAT_VALIDPENDING    (1 << 0)	/*!< Valid pending flag for this channel */
N#define DMA_CTLSTAT_TRIG            (1 << 2)	/*!< Trigger flag. Indicates that the trigger for this channel is currently set */
N
N/* DMA channel transfer configuration registers definitions */
N#define DMA_XFERCFG_CFGVALID        (1 << 0)	/*!< Configuration Valid flag */
N#define DMA_XFERCFG_RELOAD          (1 << 1)	/*!< Indicates whether the channels control structure will be reloaded when the current descriptor is exhausted */
N#define DMA_XFERCFG_SWTRIG          (1 << 2)	/*!< Software Trigger */
N#define DMA_XFERCFG_CLRTRIG         (1 << 3)	/*!< Clear Trigger */
N#define DMA_XFERCFG_SETINTA         (1 << 4)	/*!< Set Interrupt flag A for this channel to fire when descriptor is complete */
N#define DMA_XFERCFG_SETINTB         (1 << 5)	/*!< Set Interrupt flag B for this channel to fire when descriptor is complete */
N#define DMA_XFERCFG_WIDTH_8         (0 << 8)	/*!< 8-bit transfers are performed */
N#define DMA_XFERCFG_WIDTH_16        (1 << 8)	/*!< 16-bit transfers are performed */
N#define DMA_XFERCFG_WIDTH_32        (2 << 8)	/*!< 32-bit transfers are performed */
N#define DMA_XFERCFG_SRCINC_0        (0 << 12)	/*!< DMA source address is not incremented after a transfer */
N#define DMA_XFERCFG_SRCINC_1        (1 << 12)	/*!< DMA source address is incremented by 1 (width) after a transfer */
N#define DMA_XFERCFG_SRCINC_2        (2 << 12)	/*!< DMA source address is incremented by 2 (width) after a transfer */
N#define DMA_XFERCFG_SRCINC_4        (3 << 12)	/*!< DMA source address is incremented by 4 (width) after a transfer */
N#define DMA_XFERCFG_DSTINC_0        (0 << 14)	/*!< DMA destination address is not incremented after a transfer */
N#define DMA_XFERCFG_DSTINC_1        (1 << 14)	/*!< DMA destination address is incremented by 1 (width) after a transfer */
N#define DMA_XFERCFG_DSTINC_2        (2 << 14)	/*!< DMA destination address is incremented by 2 (width) after a transfer */
N#define DMA_XFERCFG_DSTINC_4        (3 << 14)	/*!< DMA destination address is incremented by 4 (width) after a transfer */
N#define DMA_XFERCFG_XFERCOUNT(n)    ((n - 1) << 16)	/*!< DMA transfer count in 'transfers', between (0)1 and (1023)1024 */
N
N/** @defgroup DMALEG_COMMON_5411X CHIP: LPC5411X DMA Controller driver common functions (legacy)
N * @{
N */
N
N/**
N * @brief	Initialize DMA controller
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_DMA_Init(LPC_DMA_T *pDMA)
Xstatic __inline void Chip_DMA_Init(LPC_DMA_T *pDMA)
N{
N	(void) pDMA;
N	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_DMA);
N}
N
N/**
N * @brief	De-Initialize DMA controller
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_DMA_DeInit(LPC_DMA_T *pDMA)
Xstatic __inline void Chip_DMA_DeInit(LPC_DMA_T *pDMA)
N{
N	(void) pDMA;
N	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_DMA);
N}
N
N/**
N * @brief	Enable DMA controller
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_DMA_Enable(LPC_DMA_T *pDMA)
Xstatic __inline void Chip_DMA_Enable(LPC_DMA_T *pDMA)
N{
N	pDMA->CTRL = 1;
N}
N
N/**
N * @brief	Disable DMA controller
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_DMA_Disable(LPC_DMA_T *pDMA)
Xstatic __inline void Chip_DMA_Disable(LPC_DMA_T *pDMA)
N{
N	pDMA->CTRL = 0;
N}
N
N/**
N * @brief	Get pending interrupt or error interrupts
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	An Or'ed value of DMA_INTSTAT_* types
N * @note	If any DMA channels have an active interrupt or error interrupt
N *			pending, this functional will a common status that applies to all
N *			channels.
N */
N__STATIC_INLINE uint32_t Chip_DMA_GetIntStatus(LPC_DMA_T *pDMA)
Xstatic __inline uint32_t Chip_DMA_GetIntStatus(LPC_DMA_T *pDMA)
N{
N	return pDMA->INTSTAT;
N}
N
N/**
N * @brief	Set DMA controller SRAM base address
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	base	: The base address where the DMA descriptors will be stored
N * @return	Nothing
N * @note	A 256 byte block of memory aligned on a 256 byte boundary must be
N *			provided for this function. It sets the base address used for
N *			DMA descriptor table (16 descriptors total that use 16 bytes each).<br>
N *
N *			A pre-defined table with correct alignment can be used for this
N *			function by calling Chip_DMA_SetSRAMBase(LPC_DMA, DMA_ADDR(Chip_DMA_Table));
N */
N__STATIC_INLINE void Chip_DMA_SetSRAMBase(LPC_DMA_T *pDMA, uint32_t base)
Xstatic __inline void Chip_DMA_SetSRAMBase(LPC_DMA_T *pDMA, uint32_t base)
N{
N	pDMA->SRAMBASE = base;
N}
N
N/**
N * @brief	Returns DMA controller SRAM base address
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	The base address where the DMA descriptors are stored
N */
N__STATIC_INLINE uint32_t Chip_DMA_GetSRAMBase(LPC_DMA_T *pDMA)
Xstatic __inline uint32_t Chip_DMA_GetSRAMBase(LPC_DMA_T *pDMA)
N{
N	return pDMA->SRAMBASE;
N}
N
N/**
N * @}
N */
N
N/** @defgroup DMALEG_COMMONCHAN_5411X CHIP: LPC5411X DMA Controller driver common channel functions (legacy)
N * @{
N */
N
N/**
N * @brief	Enables a single DMA channel
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_DMA_EnableChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_EnableChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	pDMA->DMACOMMON[0].ENABLESET = (1 << ch);
N}
N
N/**
N * @brief	Disables a single DMA channel
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_DMA_DisableChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_DisableChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	pDMA->DMACOMMON[0].ENABLECLR = (1 << ch);
N}
N
N/**
N * @brief	Returns all enabled DMA channels
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	An Or'ed value of all enabled DMA channels (0 - 15)
N * @note	A high values in bits 0 .. 15 in the return values indicates
N *			that the channel for that bit (bit 0 = channel 0, bit 1 -
N *			channel 1, etc.) is enabled. A low state is disabled.
N */
N__STATIC_INLINE uint32_t Chip_DMA_GetEnabledChannels(LPC_DMA_T *pDMA)
Xstatic __inline uint32_t Chip_DMA_GetEnabledChannels(LPC_DMA_T *pDMA)
N{
N	return pDMA->DMACOMMON[0].ENABLESET;
N}
N
N/**
N * @brief	Returns all active DMA channels
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	An Or'ed value of all active DMA channels (0 - 15)
N * @note	A high values in bits 0 .. 15 in the return values indicates
N *			that the channel for that bit (bit 0 = channel 0, bit 1 -
N *			channel 1, etc.) is active. A low state is inactive. A active
N *			channel indicates that a DMA operation has been started but
N *			not yet fully completed.
N */
N__STATIC_INLINE uint32_t Chip_DMA_GetActiveChannels(LPC_DMA_T *pDMA)
Xstatic __inline uint32_t Chip_DMA_GetActiveChannels(LPC_DMA_T *pDMA)
N{
N	return pDMA->DMACOMMON[0].ACTIVE;
N}
N
N/**
N * @brief	Returns all busy DMA channels
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	An Or'ed value of all busy DMA channels (0 - 15)
N * @note	A high values in bits 0 .. 15 in the return values indicates
N *			that the channel for that bit (bit 0 = channel 0, bit 1 -
N *			channel 1, etc.) is busy. A low state is not busy. A DMA
N *			channel is considered busy when there is any operation
N *			related to that channel in the DMA controllers internal
N *			pipeline.
N */
N__STATIC_INLINE uint32_t Chip_DMA_GetBusyChannels(LPC_DMA_T *pDMA)
Xstatic __inline uint32_t Chip_DMA_GetBusyChannels(LPC_DMA_T *pDMA)
N{
N	return pDMA->DMACOMMON[0].BUSY;
N}
N
N/**
N * @brief	Returns pending error interrupt status for all DMA channels
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	An Or'ed value of all channels (0 - 15) error interrupt status
N * @note	A high values in bits 0 .. 15 in the return values indicates
N *			that the channel for that bit (bit 0 = channel 0, bit 1 -
N *			channel 1, etc.) has a pending error interrupt. A low state
N *			indicates no error interrupt.
N */
N__STATIC_INLINE uint32_t Chip_DMA_GetErrorIntChannels(LPC_DMA_T *pDMA)
Xstatic __inline uint32_t Chip_DMA_GetErrorIntChannels(LPC_DMA_T *pDMA)
N{
N	return pDMA->DMACOMMON[0].ERRINT;
N}
N
N/**
N * @brief	Clears a pending error interrupt status for a single DMA channel
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_DMA_ClearErrorIntChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_ClearErrorIntChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	pDMA->DMACOMMON[0].ERRINT = (1 << ch);
N}
N
N/**
N * @brief	Enables a single DMA channel's interrupt used in common DMA interrupt
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_DMA_EnableIntChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_EnableIntChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	pDMA->DMACOMMON[0].INTENSET = (1 << ch);
N}
N
N/**
N * @brief	Disables a single DMA channel's interrupt used in common DMA interrupt
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_DMA_DisableIntChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_DisableIntChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	pDMA->DMACOMMON[0].INTENCLR = (1 << ch);
N}
N
N/**
N * @brief	Returns all enabled interrupt channels
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	Nothing
N * @note	A high values in bits 0 .. 15 in the return values indicates
N *			that the channel for that bit (bit 0 = channel 0, bit 1 -
N *			channel 1, etc.) has an enabled interrupt for the channel.
N *			A low state indicates that the DMA channel will not contribute
N *			to the common DMA interrupt status.
N */
N__STATIC_INLINE uint32_t Chip_DMA_GetEnableIntChannels(LPC_DMA_T *pDMA)
Xstatic __inline uint32_t Chip_DMA_GetEnableIntChannels(LPC_DMA_T *pDMA)
N{
N	return pDMA->DMACOMMON[0].INTENSET;
N}
N
N/**
N * @brief	Returns active A interrupt status for all channels
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	Nothing
N * @note	A high values in bits 0 .. 15 in the return values indicates
N *			that the channel for that bit (bit 0 = channel 0, bit 1 -
N *			channel 1, etc.) has an active A interrupt for the channel.
N *			A low state indicates that the A interrupt is not active.
N */
N__STATIC_INLINE uint32_t Chip_DMA_GetActiveIntAChannels(LPC_DMA_T *pDMA)
Xstatic __inline uint32_t Chip_DMA_GetActiveIntAChannels(LPC_DMA_T *pDMA)
N{
N	return pDMA->DMACOMMON[0].INTA;
N}
N
N/**
N * @brief	Clears active A interrupt status for a single channel
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_DMA_ClearActiveIntAChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_ClearActiveIntAChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	pDMA->DMACOMMON[0].INTA = (1 << ch);
N}
N
N/**
N * @brief	Returns active B interrupt status for all channels
N * @param	pDMA	: The base of DMA controller on the chip
N * @return	Nothing
N * @note	A high values in bits 0 .. 15 in the return values indicates
N *			that the channel for that bit (bit 0 = channel 0, bit 1 -
N *			channel 1, etc.) has an active B interrupt for the channel.
N *			A low state indicates that the B interrupt is not active.
N */
N__STATIC_INLINE uint32_t Chip_DMA_GetActiveIntBChannels(LPC_DMA_T *pDMA)
Xstatic __inline uint32_t Chip_DMA_GetActiveIntBChannels(LPC_DMA_T *pDMA)
N{
N	return pDMA->DMACOMMON[0].INTB;
N}
N
N/**
N * @brief	Clears active B interrupt status for a single channel
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_DMA_ClearActiveIntBChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_ClearActiveIntBChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	pDMA->DMACOMMON[0].INTB = (1 << ch);
N}
N
N/**
N * @brief	Sets the VALIDPENDING control bit for a single channel
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N * @note	See the User Manual for more information for what this bit does.
N *
N */
N__STATIC_INLINE void Chip_DMA_SetValidChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_SetValidChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	pDMA->DMACOMMON[0].SETVALID = (1 << ch);
N}
N
N/**
N * @brief	Sets the TRIG bit for a single channel
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N * @note	See the User Manual for more information for what this bit does.
N */
N__STATIC_INLINE void Chip_DMA_SetTrigChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_SetTrigChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	pDMA->DMACOMMON[0].SETTRIG = (1 << ch);
N}
N
N/**
N * @brief	Aborts a DMA operation for a single channel
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N * @note	To abort a channel, the channel should first be disabled. Then wait
N *			until the channel is no longer busy by checking the corresponding
N *			bit in BUSY. Finally, abort the channel operation. This prevents the
N *			channel from restarting an incomplete operation when it is enabled
N *			again.
N */
N__STATIC_INLINE void Chip_DMA_AbortChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_AbortChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	pDMA->DMACOMMON[0].ABORT = (1 << ch);
N}
N
N/**
N * @}
N */
N
N/** @defgroup DMALEG_CHANNEL_5411X CHIP: LPC5411X DMA Controller driver channel specific functions (legacy)
N * @{
N */
N
N/* DMA channel source/address/next descriptor */
Ntypedef struct {
N	uint32_t  xfercfg;	/*!< Transfer configuration (only used in linked lists and ping-pong configs) */
N	uint32_t  source;		/*!< DMA transfer source end address */
N	uint32_t  dest;			/*!< DMA transfer desintation end address */
N	uint32_t  next;			/*!< Link to next DMA descriptor, must be 16 byte aligned */
N} DMA_CHDESC_T;
N
N/* DMA SRAM table - this can be optionally used with the Chip_DMA_SetSRAMBase()
N   function if a DMA SRAM table is needed. */
Nextern DMA_CHDESC_T Chip_DMA_Table[MAX_DMA_CHANNEL];
Xextern DMA_CHDESC_T Chip_DMA_Table[(20)];
N
N/**
N * @brief	Setup a DMA channel configuration
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @param	cfg		: An Or'ed value of DMA_CFG_* values that define the channel's configuration
N * @return	Nothing
N * @note	This function sets up all configurable options for the DMA channel.
N *			These options are usually set once for a channel and then unchanged.<br>
N *
N *			The following example show how to configure the channel for peripheral
N *			DMA requests, burst transfer size of 1 (in 'transfers', not bytes),
N *			continuous reading of the same source address, incrementing destination
N *			address, and highest channel priority.<br>
N *			Example: Chip_DMA_SetupChannelConfig(pDMA, SSP0_RX_DMA,
N *				(DMA_CFG_PERIPHREQEN | DMA_CFG_TRIGBURST_BURST | DMA_CFG_BURSTPOWER_1 |
N *				DMA_CFG_SRCBURSTWRAP | DMA_CFG_CHPRIORITY(0)));<br>
N *
N *			The following example show how to configure the channel for an external
N *			trigger from the imput mux with low edge polarity, a burst transfer size of 8,
N *			incrementing source and destination addresses, and lowest channel
N *			priority.<br>
N *			Example: Chip_DMA_SetupChannelConfig(pDMA, DMA_CH14,
N *				(DMA_CFG_HWTRIGEN | DMA_CFG_TRIGPOL_LOW | DMA_CFG_TRIGTYPE_EDGE |
N *				DMA_CFG_TRIGBURST_BURST | DMA_CFG_BURSTPOWER_8 |
N *				DMA_CFG_CHPRIORITY(3)));<br>
N *
N *			For non-peripheral DMA triggering (DMA_CFG_HWTRIGEN definition), use the
N *			DMA input mux functions to configure the DMA trigger source for a DMA channel.
N */
N__STATIC_INLINE void Chip_DMA_SetupChannelConfig(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t cfg)
Xstatic __inline void Chip_DMA_SetupChannelConfig(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t cfg)
N{
N	pDMA->DMACH[ch].CFG = cfg;
N}
N
N/**
N * @brief	Returns channel specific status flags
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	AN Or'ed value of DMA_CTLSTAT_VALIDPENDING and DMA_CTLSTAT_TRIG
N */
N__STATIC_INLINE uint32_t Chip_DMA_GetChannelStatus(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline uint32_t Chip_DMA_GetChannelStatus(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	return pDMA->DMACH[ch].XFERCFG;
N}
N
N/**
N * @brief	Setup a DMA channel transfer configuration
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @param	cfg		: An Or'ed value of DMA_XFERCFG_* values that define the channel's transfer configuration
N * @return	Nothing
N * @note	This function sets up the transfer configuration for the DMA channel.<br>
N *
N *			The following example show how to configure the channel's transfer for
N *			multiple transfer descriptors (ie, ping-pong), interrupt 'A' trigger on
N *			transfer descriptor completion, 128 byte size transfers, and source and
N *			destination address increment.<br>
N *			Example: Chip_DMA_SetupChannelTransfer(pDMA, SSP0_RX_DMA,
N *				(DMA_XFERCFG_CFGVALID | DMA_XFERCFG_RELOAD | DMA_XFERCFG_SETINTA |
N *				DMA_XFERCFG_WIDTH_8 | DMA_XFERCFG_SRCINC_1 | DMA_XFERCFG_DSTINC_1 |
N *				DMA_XFERCFG_XFERCOUNT(128)));<br>
N */
N__STATIC_INLINE void Chip_DMA_SetupChannelTransfer(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t cfg)
Xstatic __inline void Chip_DMA_SetupChannelTransfer(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t cfg)
N{
N	pDMA->DMACH[ch].XFERCFG = cfg;
N}
N
N/**
N * @brief	Set DMA transfer register interrupt bits (safe)
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @param	mask	: Bits to set
N * @return	Nothing
N * @note	This function safely sets bits in the DMA channel specific XFERCFG
N *			register.
N */
N__STATIC_INLINE void Chip_DMA_SetTranBits(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t mask)
Xstatic __inline void Chip_DMA_SetTranBits(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t mask)
N{
N	pDMA->DMACH[ch].XFERCFG = (pDMA->DMACH[ch].XFERCFG | mask) & ~0xFC000CC0;
N}
N
N/**
N * @brief	Clear DMA transfer register interrupt bits (safe)
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @param	mask	: Bits to clear
N * @return	Nothing
N * @note	This function safely clears bits in the DMA channel specific XFERCFG
N *			register.
N */
N__STATIC_INLINE void Chip_DMA_ClearTranBits(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t mask)
Xstatic __inline void Chip_DMA_ClearTranBits(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t mask)
N{
N	pDMA->DMACH[ch].XFERCFG = pDMA->DMACH[ch].XFERCFG & ~(0xFC000CC0 | mask);
N}
N
N/**
N * @brief	Update the transfer size in an existing DMA channel transfer configuration
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @param	trans	: Number of transfers to update the transfer configuration to (1 - 1023)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_DMA_SetupChannelTransferSize(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t trans)
Xstatic __inline void Chip_DMA_SetupChannelTransferSize(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t trans)
N{
N	Chip_DMA_ClearTranBits(pDMA, ch, (0x3FF << 16));
N	Chip_DMA_SetTranBits(pDMA, ch, DMA_XFERCFG_XFERCOUNT(trans));
X	Chip_DMA_SetTranBits(pDMA, ch, ((trans - 1) << 16));
N}
N
N/**
N * @brief	Sets a DMA channel configuration as valid
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_DMA_SetChannelValid(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_SetChannelValid(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	Chip_DMA_SetTranBits(pDMA, ch, DMA_XFERCFG_CFGVALID);
X	Chip_DMA_SetTranBits(pDMA, ch, (1 << 0));
N}
N
N/**
N * @brief	Sets a DMA channel configuration as invalid
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_DMA_SetChannelInValid(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_SetChannelInValid(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	Chip_DMA_ClearTranBits(pDMA, ch, DMA_XFERCFG_CFGVALID);
X	Chip_DMA_ClearTranBits(pDMA, ch, (1 << 0));
N}
N
N/**
N * @brief	Performs a software trigger of the DMA channel
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_DMA_SWTriggerChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
Xstatic __inline void Chip_DMA_SWTriggerChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
N{
N	Chip_DMA_SetTranBits(pDMA, ch, DMA_XFERCFG_SWTRIG);
X	Chip_DMA_SetTranBits(pDMA, ch, (1 << 2));
N}
N
N/**
N * @brief	Sets up a DMA channel with the passed DMA transfer descriptor
N * @param	pDMA	: The base of DMA controller on the chip
N * @param	ch		: DMA channel ID
N * @param	desc	: Pointer to DMA transfer descriptor
N * @return	false if the DMA channel was active, otherwise true
N * @note	This function will set the DMA descriptor in the SRAM table to the
N *			the passed descriptor. This function is only meant to be used when
N *			the DMA channel is not active and can be used to setup the
N *			initial transfer for a linked list or ping-pong buffer or just a
N *			single transfer without a next descriptor.<br>
N *
N *			If using this function to write the initial transfer descriptor in
N *			a linked list or ping-pong buffer configuration, it should contain a
N *			non-NULL 'next' field pointer.
N */
N__STATIC_INLINE bool Chip_DMA_SetupTranChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch, DMA_CHDESC_T *desc)
Xstatic __inline _Bool Chip_DMA_SetupTranChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch, DMA_CHDESC_T *desc)
N{
N	DMA_CHDESC_T *pDesc = (DMA_CHDESC_T *) pDMA->SRAMBASE;
N
N	if ((Chip_DMA_GetActiveChannels(pDMA) & (1 << ch)) == 0) {
N		/* Channel is not active, so update the descriptor */
N		pDesc[ch] = *desc;
N
N		return true;
X		return 1;
N	}
N
N	return false;
X	return 0;
N}
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __DMA_5411X_H */
L 202 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "dma_service_5411x.h"
L 1 "..\..\..\chip_5411x\inc\dma_service_5411x.h" 1
N/*
N * @brief LPC5411X DMA service driver declarations and functions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2015
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __DMA_SERVICE_5411X_H
N#define __DMA_SERVICE_5411X_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup DMA_SERVICE_5411X CHIP: LPC5411X DMA Service driver
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
Ntypedef void (* DMA_CALLBACK_T)(int32_t);
N
Ntypedef struct {
N	uint32_t			channel;
N	volatile uint32_t*	register_location;
N	uint32_t			width;
N	uint32_t			src_increment;
N	uint32_t			dst_increment;
N	bool				write;
X	_Bool				write;
N} DMA_PERIPHERAL_CONTEXT_T;
N
Ntypedef struct {
N	DMA_CHDESC_T  descr[2];
N} DMA_DUAL_DESCRIPTOR_T;														// Note: Must be 16 byte aligned
N
N/**
N * @brief	Initialize DMA service
N * @param	base	: The base address where the DMA descriptors will be stored
N * @return	Nothing
N */
Nvoid Chip_DMASERVICE_Init(DMA_CHDESC_T * base);
N
N/**
N * @brief	DMA service interrupt handler
N * @param	None
N * @return	Nothing
N * @Note	Must be called from DMA_IRQHandler
N */
Nvoid Chip_DMASERVICE_Isr(void);
N
N/**
N * @brief	Register callback function
N * @param	pContext	: Pointer to peripheral channel context
N * @param	pCallback	: Pointer to callback function
N * @return	Nothing
N */
Nvoid Chip_DMASERVICE_RegisterCb(const DMA_PERIPHERAL_CONTEXT_T * pContext, DMA_CALLBACK_T pCallback);
N
N/**
N * @brief	Use Single buffer mechanism
N * @param	pContext	: Pointer to peripheral channel context
N * @param	pMem		: Pointer to data memory
N * @param	length		: Transfer length in bytes
N * @return	Nothing
N */
Nvoid Chip_DMASERVICE_SingleBuffer(const DMA_PERIPHERAL_CONTEXT_T * pContext, uint32_t  pMem, uint32_t length);
N
N/**
N * @brief	Use double buffer mechanism
N * @param	pContext	: Pointer to peripheral channel context
N * @param	pMem		: Pointer to data memory
N * @param	length		: Transfer length in bytes
N * @param	pD			: Pointer to dma dual descriptor
N * @return	Nothing
N */
Nvoid Chip_DMASERVICE_DoubleBuffer(const DMA_PERIPHERAL_CONTEXT_T * pContext, uint32_t  pMem, uint32_t length, DMA_DUAL_DESCRIPTOR_T * pD);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __DMA_SERVICE_5411X_H */
L 203 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "dmic_5411x.h"
L 1 "..\..\..\chip_5411x\inc\dmic_5411x.h" 1
N/*
N * @brief LPC5411X DMIC driver declarations and functions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2015
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.	 This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __DMIC_5411X_H
N#define __DMIC_5411X_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup DMIC_5411X CHIP: LPC5411X DMIC driver
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
Ntypedef struct {
N	__IO uint32_t OSR;						// 0x00
X	volatile uint32_t OSR;						
N	__IO uint32_t DIVHFCLK;					// 0x04
X	volatile uint32_t DIVHFCLK;					
N	__IO uint32_t PREAC2FSCOEF;				// 0x08
X	volatile uint32_t PREAC2FSCOEF;				
N	__IO uint32_t PREAC4FSCOEF;				// 0x0c
X	volatile uint32_t PREAC4FSCOEF;				
N	__IO uint32_t GAINSHFT;					// 0x10
X	volatile uint32_t GAINSHFT;					
N	__IO uint32_t TDM96EN;					// 0x14
X	volatile uint32_t TDM96EN;					
N	__IO uint32_t TDM19EN;					// 0x18
X	volatile uint32_t TDM19EN;					
N	__IO uint32_t reserved[25];
X	volatile uint32_t reserved[25];
N	__IO uint32_t FIFO_CTRL;				// 0x80
X	volatile uint32_t FIFO_CTRL;				
N	__IO uint32_t FIFO_STATUS;				// 0x84
X	volatile uint32_t FIFO_STATUS;				
N	__IO uint32_t FIFO_DATA;				// 0x88
X	volatile uint32_t FIFO_DATA;				
N	__IO uint32_t PHY_CTRL;					// 0x8C
X	volatile uint32_t PHY_CTRL;					
N	__IO uint32_t DC_CTRL;					// 0x90
X	volatile uint32_t DC_CTRL;					
N	__IO uint32_t reserved1[27];
X	volatile uint32_t reserved1[27];
N} LPC_DMIC_Channel_Type;
N
N
Ntypedef struct {
N	__IO LPC_DMIC_Channel_Type CHANNEL[15];	// 0x000 - 0xefc  with 0x100 per channel
X	volatile LPC_DMIC_Channel_Type CHANNEL[15];	
N	// common
N	__IO uint32_t CHANEN;						// 0xf00
X	volatile uint32_t CHANEN;						
N	__IO uint32_t reserved0[2];					// 0xf04 - 0xf08
X	volatile uint32_t reserved0[2];					
N	__IO uint32_t IOCFG;						// 0xf0C
X	volatile uint32_t IOCFG;						
N	__IO uint32_t USE2FS;						// 0xf10
X	volatile uint32_t USE2FS;						
N	__IO uint32_t reserved[27];					// 0xf14 - 0xf7c
X	volatile uint32_t reserved[27];					
N	// HWVAD
N	__IO uint32_t HWVADGAIN;					// 0xf80
X	volatile uint32_t HWVADGAIN;					
N	__IO uint32_t HWVADHPFS;					// 0xf84
X	volatile uint32_t HWVADHPFS;					
N	__IO uint32_t HWVADST10;					// 0xf88
X	volatile uint32_t HWVADST10;					
N	__IO uint32_t HWVADRSTT;					// 0xf8c
X	volatile uint32_t HWVADRSTT;					
N	__IO uint32_t HWVADTHGN;					// 0xf90
X	volatile uint32_t HWVADTHGN;					
N	__IO uint32_t HWVADTHGS;					// 0xf94
X	volatile uint32_t HWVADTHGS;					
N	__IO uint32_t HWVADLOWZ;					// 0xf98
X	volatile uint32_t HWVADLOWZ;					
N	__IO uint32_t reserved1[24];				// 0xf9c - 0xff8
X	volatile uint32_t reserved1[24];				
N	__O uint32_t ID;							// 0xffc
X	volatile uint32_t ID;							
N} LPC_DMIC_T;
N
N/**
N * @brief	DMIC statistics structure
N * @note
N * Maintains current DMIC statistics.
N */
Ntypedef struct {
N	uint32_t		fifo_ints;				/*!< count: FIFO interrupts */
N	uint32_t		fifo_overrun;			/*!< count: FIFO over-run errors */
N	uint32_t		fifo_underrun;			/*!< count: FIFO under-run errors */
N} DMIC_STATISTICS_T;
N
N
N// INFREQ SEL selection
N//
N//	OSR		Infreq SEL
N// -------------------------
N//	16	 ->	  0
N//	32	 ->	  1
N//	64	 ->	  2
N//	128	 ->	  3
N//	256	 ->	  4
N//	512	 ->	  5
N
N// FIFO CTRL bits
N#define DMIC_FIFO_ENABLE_P			0
N#define DMIC_FIFO_RESETN_P			1
N#define DMIC_FIFO_INTREN_P			2
N#define DMIC_FIFO_DMAEN_P			3
N
N#define DMIC_FIFO_TLVL_P			16
N
N#define DMIC_FIFO_ENABLE			(1<<DMIC_FIFO_ENABLE_P)
N#define DMIC_FIFO_RESETN			(1<<DMIC_FIFO_RESETN_P)
N#define DMIC_FIFO_INTREN			(1<<DMIC_FIFO_INTREN_P)
N#define DMIC_FIFO_DMAEN				(1<<DMIC_FIFO_DMAEN_P )
N
N// FIFO STATUS bits
N#define DMIC_FIFO_INT_P				0
N#define DMIC_FIFO_OVERRUN_P			1
N#define DMIC_FIFO_UNDERRUN_P		2
N
N#define DMIC_FIFO_INT				(1<<DMIC_FIFO_INT_P		)
N#define DMIC_FIFO_OVERRUN			(1<<DMIC_FIFO_OVERRUN_P )
N#define DMIC_FIFO_UNDERRUN			(1<<DMIC_FIFO_UNDERRUN_P)
N
N// PHY CTRL bits
N#define DMIC_PHY_FALL_P				0
N#define DMIC_PHY_HALF_P				1
N
N#define DMIC_PHY_FALL				(1<<DMIC_PHY_FALL_P)
N#define DMIC_PHY_HALF				(1<<DMIC_PHY_HALF_P)
N
N// DC Block ctrl
N
N#define DMIC_DCPOLE_P				0
N#define DMIC_DCGAIN_REDUCE_P		4
N#define DMIC_SATURATE_AT16BIT_P		8
N
N/* note that the polling mode can be achieved without the driver, it is in
Nany way not recommended due to its overhead, this link should normally use dma or irq */
Ntypedef enum {
N	DMIC_OP_POLL,
N	DMIC_OP_INTR,
N	DMIC_OP_DMA,
N} OP_MODE_T;
N
Ntypedef enum {
N	DMIC_LEFT			= 0,
N	DMIC_RIGHT			= 1,
N} STEREO_SIDE_T;
N
Ntypedef enum {
N	DMIC_PDM_DIV1		= 0,
N	DMIC_PDM_DIV2		= 1,
N	DMIC_PDM_DIV3		= 2,
N	DMIC_PDM_DIV4		= 3,
N	DMIC_PDM_DIV6		= 4,
N	DMIC_PDM_DIV8		= 5,
N	DMIC_PDM_DIV12		= 6,
N	DMIC_PDM_DIV16		= 7,
N	DMIC_PDM_DIV24		= 8,
N	DMIC_PDM_DIV32		= 9,
N	DMIC_PDM_DIV48		= 10,
N	DMIC_PDM_DIV64		= 11,
N	DMIC_PDM_DIV96		= 12,
N	DMIC_PDM_DIV128		= 13,
N} PDM_DIV_T;
N
Ntypedef enum {
N	DMIC_COMP0_0		= 0,
N	DMIC_COMP0_16		= 1,
N	DMIC_COMP0_15		= 2,
N	DMIC_COMP0_13		= 3,
N} COMPENSATION_T;
N
Ntypedef enum {
N	DMIC_DC_NOREMOVE	= 0,
N	DMIC_DC_CUT155		= 1,
N	DMIC_DC_CUT78		= 2,
N	DMIC_DC_CUT39		= 3,
N} DC_REMOVAL_T;
N
Ntypedef enum {
N	pdm_dual			= 0,		/*!< Two separate pairs of PDM wires */
N	pdm_stereo			= 4,		/*!< Stereo Mic */
N	pdm_bypass			= 3,		/*!< Clk Bypas clocks both channels */
N	pdm_bypass_clk0		= 1,		/*!< Clk Bypas clocks only channel0 */
N	pdm_bypass_clk1		= 2,		/*!< Clk Bypas clocks only channel1 */
N} DMIC_IO_T;
N
Ntypedef struct {
N	STEREO_SIDE_T		side;
N	PDM_DIV_T			divhfclk;
N	uint32_t			osr;
N	int32_t				gainshft;
N	COMPENSATION_T		preac2coef;
N	COMPENSATION_T		preac4coef;
N} DMIC_CHANNEL_CONFIG_T;
N
N/**
N * @brief	Initialize DMIC interface
N * @param	clock	: DMIC clock assignment
N * @param	reset	: DMIC reset assignment
N * @return	Nothing
N */
Nvoid Chip_DMIC_Init(const CHIP_SYSCON_CLOCK_T clock, const CHIP_SYSCON_PERIPH_RESET_T reset);
N
N/**
N * @brief	Configure DMIC io
N * @param	pDMIC	: The base address of DMIC interface
N * @param	cfg		: DMIC io configuration
N * @return	Nothing
N */
Nvoid Chip_DMIC_CfgIO(LPC_DMIC_T * pDMIC, DMIC_IO_T cfg);
N
N/**
N * @brief	Set DMIC operating mode
N * @param	pDMIC	: The base address of DMIC interface
N * @param	mode	: DMIC mode
N * @return	Nothing
N */
Nvoid Chip_DMIC_SetOpMode(LPC_DMIC_T * pDMIC, OP_MODE_T mode);
N
N/**
N * @brief	Configure DMIC channel
N * @param	pDMIC		: The base address of DMIC interface
N * @param	channel		: DMIC channel
N * @param	channel_cfg	: Channel configuration
N * @return	Nothing
N */
Nvoid Chip_DMIC_CfgChannel(LPC_DMIC_T * pDMIC, uint32_t channel, DMIC_CHANNEL_CONFIG_T * channel_cfg);
N
N/**
N * @brief	Configure DMIC channel DC removal setting
N * @param	pDMIC				: The base address of DMIC interface
N * @param	channel				: DMIC channel
N * @param	dc_cut_level		: DC cut level
N * @param	post_dc_gain_reduce : Post DC cut gain adjustment
N * @param	saturate16bit		: Saturation setting
N * @return	Nothing
N */
Nvoid Chip_DMIC_CfgChannelDc(LPC_DMIC_T * pDMIC, uint32_t channel, DC_REMOVAL_T dc_cut_level, uint32_t post_dc_gain_reduce, bool saturate16bit);
Xvoid Chip_DMIC_CfgChannelDc(LPC_DMIC_T * pDMIC, uint32_t channel, DC_REMOVAL_T dc_cut_level, uint32_t post_dc_gain_reduce, _Bool saturate16bit);
N
N/**
N * @brief	Configure Clock scaling
N * @param	pDMIC		: The base address of DMIC interface
N * @param	use2fs		: clock scaling
N * @return	Nothing
N */
Nvoid Chip_DMIC_Use2fs(LPC_DMIC_T * pDMIC, bool use2fs);
Xvoid Chip_DMIC_Use2fs(LPC_DMIC_T * pDMIC, _Bool use2fs);
N
N/**
N * @brief	Configure Clock scaling
N * @param	pDMIC		: The base address of DMIC interface
N * @param	channelmask	: Channel selection
N * @return	Nothing
N */
Nvoid Chip_DMIC_EnableChannnel(LPC_DMIC_T * pDMIC, uint32_t channelmask);
N
N/**
N * @brief	Configure fifo settings for DMIC channel
N * @param	pDMIC		: The base address of DMIC interface
N * @param	channel		: DMIC channel
N * @param	trig_level	: FIFO trigger level
N * @param	enable		: FIFO level
N * @param	resetn		: FIFO reset
N * @return	Nothing
N */
Nvoid Chip_DMIC_FifoChannel(LPC_DMIC_T * pDMIC, uint32_t channel, uint32_t trig_level, uint32_t enable, uint32_t resetn);
N
N/**
N * @brief	Get FIFO status
N * @param	pDMIC		: The base address of DMIC interface
N * @param	channel		: DMIC channel
N * @return	FIFO status
N */
N__STATIC_INLINE uint32_t Chip_DMIC_FifoGetStatus(LPC_DMIC_T * pDMIC, uint32_t channel)
Xstatic __inline uint32_t Chip_DMIC_FifoGetStatus(LPC_DMIC_T * pDMIC, uint32_t channel)
N{
N	return pDMIC->CHANNEL[channel].FIFO_STATUS;
N}
N
N/**
N * @brief	Clear FIFO status
N * @param	pDMIC		: The base address of DMIC interface
N * @param	channel		: DMIC channel
N * @param	mask		: Bits to be cleared
N * @return	FIFO status
N */
N__STATIC_INLINE void Chip_DMIC_FifoClearStatus(LPC_DMIC_T * pDMIC, uint32_t channel, uint32_t mask)
Xstatic __inline void Chip_DMIC_FifoClearStatus(LPC_DMIC_T * pDMIC, uint32_t channel, uint32_t mask)
N{
N	pDMIC->CHANNEL[channel].FIFO_STATUS = mask;
N}
N
N/**
N * @brief	Get FIFO data
N * @param	pDMIC		: The base address of DMIC interface
N * @param	channel		: DMIC channel
N * @return	FIFO data
N */
N__STATIC_INLINE uint32_t Chip_DMIC_FifoGetData(LPC_DMIC_T * pDMIC, uint32_t channel)
Xstatic __inline uint32_t Chip_DMIC_FifoGetData(LPC_DMIC_T * pDMIC, uint32_t channel)
N{
N	return pDMIC->CHANNEL[channel].FIFO_DATA;
N}
N
Nextern DMA_PERIPHERAL_CONTEXT_T dmic_ch0_dma_context;
Nextern DMA_PERIPHERAL_CONTEXT_T dmic_ch1_dma_context;
Nextern DMA_PERIPHERAL_CONTEXT_T dmic_ch0_dma_interleaved_context;
Nextern DMA_PERIPHERAL_CONTEXT_T dmic_ch1_dma_interleaved_context;
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __DMIC_5411X_H */
L 204 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "uart_5411x.h"
L 1 "..\..\..\chip_5411x\inc\uart_5411x.h" 1
N/*
N * @brief LPC5411X UART driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2015
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __UART_5411X_H_
N#define __UART_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "ring_buffer.h"
L 1 "..\..\..\chip_5411x\inc\ring_buffer.h" 1
N/*
N * @brief Common ring buffer support functions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2012
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __RING_BUFFER_H_
N#define __RING_BUFFER_H_
N
N#include "lpc_types.h"
N#include "cmsis.h"
N
N/** @defgroup Ring_Buffer CHIP: Simple ring buffer implementation
N * @ingroup CHIP_Common
N * @{
N */
N
N/**
N * @brief Ring buffer structure
N */
Ntypedef struct {
N	void *data;
N	int count;
N	int itemSz;
N	uint32_t head;
N	uint32_t tail;
N	void *(*copy)(void *dst, const void *src, uint32_t len);
N} RINGBUFF_T;
N
N/**
N * @def		RB_VHEAD(rb)
N * volatile typecasted head index
N */
N#define RB_VHEAD(rb)              (*(volatile uint32_t *) &(rb)->head)
N
N/**
N * @def		RB_VTAIL(rb)
N * volatile typecasted tail index
N */
N#define RB_VTAIL(rb)              (*(volatile uint32_t *) &(rb)->tail)
N
N/**
N * @brief	Initialize ring buffer
N * @param	RingBuff	: Pointer to ring buffer to initialize
N * @param	buffer		: Pointer to buffer to associate with RingBuff
N * @param	itemSize	: Size of each buffer item size
N * @param	count		: Size of ring buffer
N * @param	cpyFunc		: Call-back function that copies data (if NULL library @a memcpy will be used)
N * @note	Memory pointed by @a buffer must have correct alignment of
N *          @a itemSize, and @a count must be a power of 2 and must at
N *          least be 2 or greater. @a len of the @a cpyFunc is in bytes.
N * @return	Nothing
N */
Nint RingBuffer_Init(RINGBUFF_T *RingBuff,
N					void *buffer,
N					int itemSize,
N					int count,
N					void *(*cpyFunc)(void *dst, const void *src, uint32_t len));
N
N/**
N * @brief	Resets the ring buffer to empty
N * @param	RingBuff	: Pointer to ring buffer
N * @return	Nothing
N */
N__STATIC_INLINE void RingBuffer_Flush(RINGBUFF_T *RingBuff)
Xstatic __inline void RingBuffer_Flush(RINGBUFF_T *RingBuff)
N{
N	RingBuff->head = RingBuff->tail = 0;
N}
N
N/**
N * @brief	Return size the ring buffer
N * @param	RingBuff	: Pointer to ring buffer
N * @return	Size of the ring buffer in bytes
N */
N__STATIC_INLINE int RingBuffer_GetSize(RINGBUFF_T *RingBuff)
Xstatic __inline int RingBuffer_GetSize(RINGBUFF_T *RingBuff)
N{
N	return RingBuff->count;
N}
N
N/**
N * @brief	Return number of items in the ring buffer
N * @param	RingBuff	: Pointer to ring buffer
N * @return	Number of items in the ring buffer
N */
N__STATIC_INLINE int RingBuffer_GetCount(RINGBUFF_T *RingBuff)
Xstatic __inline int RingBuffer_GetCount(RINGBUFF_T *RingBuff)
N{
N	return RB_VHEAD(RingBuff) - RB_VTAIL(RingBuff);
X	return (*(volatile uint32_t *) &(RingBuff)->head) - (*(volatile uint32_t *) &(RingBuff)->tail);
N}
N
N/**
N * @brief	Return number of free items in the ring buffer
N * @param	RingBuff	: Pointer to ring buffer
N * @return	Number of free items in the ring buffer
N */
N__STATIC_INLINE int RingBuffer_GetFree(RINGBUFF_T *RingBuff)
Xstatic __inline int RingBuffer_GetFree(RINGBUFF_T *RingBuff)
N{
N	return RingBuff->count - RingBuffer_GetCount(RingBuff);
N}
N
N/**
N * @brief	Return number of items in the ring buffer
N * @param	RingBuff	: Pointer to ring buffer
N * @return	1 if the ring buffer is full, otherwise 0
N */
N__STATIC_INLINE int RingBuffer_IsFull(RINGBUFF_T *RingBuff)
Xstatic __inline int RingBuffer_IsFull(RINGBUFF_T *RingBuff)
N{
N	return RingBuffer_GetCount(RingBuff) >= RingBuff->count;
N}
N
N/**
N * @brief	Return empty status of ring buffer
N * @param	RingBuff	: Pointer to ring buffer
N * @return	1 if the ring buffer is empty, otherwise 0
N */
N__STATIC_INLINE int RingBuffer_IsEmpty(RINGBUFF_T *RingBuff)
Xstatic __inline int RingBuffer_IsEmpty(RINGBUFF_T *RingBuff)
N{
N	return RB_VHEAD(RingBuff) == RB_VTAIL(RingBuff);
X	return (*(volatile uint32_t *) &(RingBuff)->head) == (*(volatile uint32_t *) &(RingBuff)->tail);
N}
N
N/**
N * @brief	Insert a single item into ring buffer
N * @param	RingBuff	: Pointer to ring buffer
N * @param	data		: pointer to item
N * @return	1 when successfully inserted,
N *			0 on error (Buffer not initialized using
N *			RingBuffer_Init() or attempted to insert
N *			when buffer is full)
N */
Nint RingBuffer_Insert(RINGBUFF_T *RingBuff, const void *data);
N
N/**
N * @brief	Insert an array of items into ring buffer
N * @param	RingBuff	: Pointer to ring buffer
N * @param	data		: Pointer to first element of the item array
N * @param	num			: Number of items in the array
N * @return	number of items successfully inserted,
N *			0 on error (Buffer not initialized using
N *			RingBuffer_Init() or attempted to insert
N *			when buffer is full)
N */
Nint RingBuffer_InsertMult(RINGBUFF_T *RingBuff, const void *data, int num);
N
N/**
N * @brief	Pop an item from the ring buffer
N * @param	RingBuff	: Pointer to ring buffer
N * @param	data		: Pointer to memory where popped item be stored
N * @return	1 when item popped successfuly onto @a data,
N *          0 When error (Buffer not initialized using
N *          RingBuffer_Init() or attempted to pop item when
N *          the buffer is empty)
N */
Nint RingBuffer_Pop(RINGBUFF_T *RingBuff, void *data);
N
N/**
N * @brief	Pop an array of items from the ring buffer
N * @param	RingBuff	: Pointer to ring buffer
N * @param	data		: Pointer to memory where popped items be stored
N * @param	num			: Max number of items array @a data can hold
N * @return	Number of items popped onto @a data,
N *          0 on error (Buffer not initialized using RingBuffer_Init()
N *          or attempted to pop when the buffer is empty)
N */
Nint RingBuffer_PopMult(RINGBUFF_T *RingBuff, void *data, int num);
N
N/**
N * @}
N */
N
N#endif /* __RING_BUFFER_H_ */
L 40 "..\..\..\chip_5411x\inc\uart_5411x.h" 2
N
N/** @defgroup UART_5411X CHIP: LPC5411X UART Driver
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/*******************
N * EXPORTED MACROS  *
N ********************/
N#define     ECHO_EN             1
N#define     ECHO_DIS            0
N
N/**	@brief	UART Registers */
Ntypedef struct {                   /* UART registers Structure          */
N	__IO uint32_t CFG;             /*!< Offset: 0x000 Configuration register  */
X	volatile uint32_t CFG;              
N	__IO uint32_t CTL;             /*!< Offset: 0x004 Control register */
X	volatile uint32_t CTL;              
N	__IO uint32_t STAT;            /*!< Offset: 0x008 Status register */
X	volatile uint32_t STAT;             
N	__IO uint32_t INTENSET;        /*!< Offset: 0x00C Interrupt Enable Read and Set register */
X	volatile uint32_t INTENSET;         
N	__O  uint32_t INTENCLR;        /*!< Offset: 0x010 Interrupt Enable Clear register @cond */
X	volatile  uint32_t INTENCLR;         
N	__I  uint32_t RESERVED0A[3];   /*!< Offset: 0x014 Reserved register @endcond */
X	volatile const  uint32_t RESERVED0A[3];    
N	__IO uint32_t BRG;             /*!< Offset: 0x020 Baud Rate Generator register */
X	volatile uint32_t BRG;              
N	__I  uint32_t INTSTAT;         /*!< Offset: 0x024 Interrupt Status register */
X	volatile const  uint32_t INTSTAT;          
N	__IO uint32_t OSR;             /*!< Offset: 0x028 Oversampling register */
X	volatile uint32_t OSR;              
N	__IO uint32_t ADDR;            /*!< Offset: 0x02C Address register (for automatic address matching) @cond */
X	volatile uint32_t ADDR;             
N	__I  uint32_t RESERVED0[884];  /*!< Offset: 0x030 Reserved member */
X	volatile const  uint32_t RESERVED0[884];   
N
N	/** UART FIFO Specific registers @endcond */
N	__IO uint32_t FIFOCFG;         /*!< Offset: 0xE00 FIFO Configuration register */
X	volatile uint32_t FIFOCFG;          
N	__IO uint32_t FIFOSTAT;        /*!< Offset: 0xE04 FIFO Status register */
X	volatile uint32_t FIFOSTAT;         
N	__IO uint32_t FIFOTRIG;        /*!< Offset: 0xE08 FIFO Trigger level register @cond */
X	volatile uint32_t FIFOTRIG;         
N	__I  uint32_t RESERVED1;       /*!< Offset: 0xE0C Reserved register @endcond */
X	volatile const  uint32_t RESERVED1;        
N	__IO uint32_t FIFOINTENSET;    /*!< Offset: 0xE10 FIFO Interrupt enable SET register */
X	volatile uint32_t FIFOINTENSET;     
N	__IO uint32_t FIFOINTENCLR;    /*!< Offset: 0xE14 FIFO Interrupt enable CLEAR register */
X	volatile uint32_t FIFOINTENCLR;     
N	__IO uint32_t FIFOINTSTAT;     /*!< Offset: 0xE18 FIFO Interrupt Status register @cond */
X	volatile uint32_t FIFOINTSTAT;      
N	__I  uint32_t RESERVED2;       /*!< Offset: 0xE1C Reserved register @endcond */
X	volatile const  uint32_t RESERVED2;        
N	__O  uint32_t FIFOWR;          /*!< Offset: 0xE20 FIFO Data write register @cond */
X	volatile  uint32_t FIFOWR;           
N	__I  uint32_t RESERVED3[3];    /*!< Offset: 0xE24 Reserved register @endcond */
X	volatile const  uint32_t RESERVED3[3];     
N	__I  uint32_t FIFORD;          /*!< Offset: 0xE30 FIFO Data read register @cond */
X	volatile const  uint32_t FIFORD;           
N	__I  uint32_t RESERVED4[3];    /*!< Offset: 0xE24 Reserved register @endcond */
X	volatile const  uint32_t RESERVED4[3];     
N	__I  uint32_t FIFORDNOPOP;     /*!< Offset: 0xE40 FIFO Data peek (read without popping out of queue) register @cond */
X	volatile const  uint32_t FIFORDNOPOP;      
N	__I  uint32_t RESERVED5[109];  /*!< Offset: 0xE44 Reserved register */
X	volatile const  uint32_t RESERVED5[109];   
N
N	/** FLEXCOMM Interface registers @endcond */
N	__IO uint32_t PSELID;          /*!< Offset: 0xFF8 Peripheral select/identification register */
X	volatile uint32_t PSELID;           
N	__I  uint32_t PID;             /*!< Offset: 0xFFC Module identification register */
X	volatile const  uint32_t PID;              
N} LPC_USART_T;
N
N/**
N * @brief UART CFG register definitions
N */
N#define UART_CFG_BITMASK      				(0x00fddbfd)
N#define UART_CFG_ENABLE        				(0x01 << 0)
N#define UART_CFG_DATALEN_7     				(0x00 << 2)							/*!< UART 7 bit length mode */
N#define UART_CFG_DATALEN_8     				(0x01 << 2)							/*!< UART 8 bit length mode */
N#define UART_CFG_DATALEN_9     				(0x02 << 2)							/*!< UART 9 bit length mode */
N#define UART_CFG_PARITY_NONE   				(0x00 << 4)							/*!< No parity */
N#define UART_CFG_PARITY_EVEN   				(0x02 << 4)							/*!< Even parity */
N#define UART_CFG_PARITY_ODD    				(0x03 << 4)							/*!< Odd parity */
N#define UART_CFG_STOPLEN_1     				(0x00 << 6)							/*!< UART One Stop Bit Select */
N#define UART_CFG_STOPLEN_2     				(0x01 << 6)							/*!< UART Two Stop Bits Select */
N#define UART_CFG_MODE32K       				(0x01 << 7)							/*!< UART 32K MODE */
N#define UART_CFG_LINMODE       				(0x01 << 8)							/*!< UART LIN MODE */
N#define UART_CFG_CTSEN         				(0x01 << 9)							/*!< CTS enable bit */
N#define UART_CFG_SYNCEN        				(0x01 << 11)						/*!< Synchronous mode enable bit */
N#define UART_CFG_CLKPOL        				(0x01 << 12)						/*!< Un_RXD rising edge sample enable bit */
N#define UART_CFG_SYNCMST       				(0x01 << 14)						/*!< Select master mode (synchronous mode) enable bit */
N#define UART_CFG_LOOP          				(0x01 << 15)						/*!< Loopback mode enable bit */
N#define UART_CFG_IOMODE        				(0x01 << 16)						/*!< enable bit standard UART / IrDA UART */
N#define UART_CFG_OETA          				(0x01 << 18)						/*!< Output Enable Turnaround time enable for RS-485 operation */
N#define UART_CFG_AUTOADDR      				(0x01 << 19)						/*!< Automatic Address matching enable */
N#define UART_CFG_OESEL         				(0x01 << 20)						/*!< Output Enable Select */
N#define UART_CFG_OEPOL         				(0x01 << 21)						/*!< Output Enable Polarity */
N#define UART_CFG_RXPOL         				(0x01 << 22)						/*!< Receive data polarity */
N#define UART_CFG_TXPOL         				(0x01 << 23)						/*!< Transmit data polarity */
N
N
N/**
N * @brief UART CTRL register definitions
N */
N#define UART_CTRL_TXBRKEN       			(0x01 << 1)							/*!< Continuous break enable bit */
N#define UART_CTRL_ADDRDET       			(0x01 << 2)							/*!< Address detect mode enable bit */
N#define UART_CTRL_TXDIS         			(0x01 << 6)							/*!< Transmit disable bit */
N#define UART_CTRL_CC            			(0x01 << 8)							/*!< Continuous Clock mode enable bit */
N#define UART_CTRL_CLRCCONRX     			(0x01 << 9)							/*!< Clear Continuous Clock bit */
N#define UART_CTRL_AUTOBAUD      			(0x01 << 16)						/*!< Auto baud bit */
N
N/**
N * @brief UART STAT register definitions
N */
N#define UART_STAT_RXIDLE        			(0x01 << 1)							/*!< Receiver idle */
N#define UART_STAT_TXIDLE        			(0x01 << 3)							/*!< Transmitter idle */
N#define UART_STAT_CTS           			(0x01 << 4)							/*!< Status of CTS signal */
N#define UART_STAT_DELTACTS      			(0x01 << 5)							/*!< Change in CTS state */
N#define UART_STAT_TXDISINT      			(0x01 << 6)							/*!< Transmitter disabled */
N#define UART_STAT_RXBRK         			(0x01 << 10)						/*!< Received break */
N#define UART_STAT_DELTARXBRK    			(0x01 << 11)						/*!< Change in receive break detection */
N#define UART_STAT_START         			(0x01 << 12)						/*!< Start detected */
N#define UART_STAT_FRM_ERRINT    			(0x01 << 13)						/*!< Framing Error interrupt flag */
N#define UART_STAT_PAR_ERRINT    			(0x01 << 14)						/*!< Parity Error interrupt flag */
N#define UART_STAT_RXNOISEINT    			(0x01 << 15)						/*!< Received Noise interrupt flag */
N#define UART_STAT_ABERR         			(0x01 << 16)						/*!< Auto baud error flag */
N
N/**
N * @brief UART INTENSET/INTENCLR/INTSTAT register definitions
N */
N#define UART_INT_TXIDLE       				(0x01 << 3)							/*!< Transmit idle interrupt */
N#define UART_INT_DELTACTS     				(0x01 << 5)							/*!< Change in CTS state interrupt */
N#define UART_INT_TXDIS        				(0x01 << 6)							/*!< Transmitter disable interrupt */
N#define UART_INT_DELTARXBRK   				(0x01 << 11)						/*!< Change in receiver break detection interrupt */
N#define UART_INT_START        				(0x01 << 12)						/*!< Start detect interrupt */
N#define UART_INT_FRAMERR      				(0x01 << 13)						/*!< Frame error interrupt */
N#define UART_INT_PARITYERR    				(0x01 << 14)						/*!< Parity error interrupt */
N#define UART_INT_RXNOISE      				(0x01 << 15)						/*!< Received noise interrupt */
N#define UART_INT_ABERR      				(0x01 << 16)						/*!< Auto-baud error interrupt */
N
N/**
N * @brief	UART FIFO Configuration register bits
N */
N#define UART_FIFOCFG_BITMASK		 		(0x7F033)							/*!< Register mask bit @endcond */
N#define UART_FIFOCFG_ENABLETX		 		(1 << 0)							/*!< Enable TX FIFO */
N#define UART_FIFOCFG_ENABLERX		 		(1 << 1)							/*!< Enable RX FIFO */
N#define UART_FIFOCFG_DMATX			 		(1 << 12)							/*!< Enable DMA TX */
N#define UART_FIFOCFG_DMARX			 		(1 << 13)							/*!< Enable DMA RX */
N#define UART_FIFOCFG_WAKETX			 		(1 << 14)							/*!< Enable wakeup triggered by TX */
N#define UART_FIFOCFG_WAKERX			 		(1 << 15)							/*!< Enable wakeup triggered by RX */
N#define UART_FIFOCFG_EMPTYTX		 		(1 << 16)							/*!< Empty the TX FIFO */
N#define UART_FIFOCFG_EMPTYRX		 		(1 << 17)							/*!< Empty the RX FIFO */
N
N/**
N * @brief	UART FIFO Status register defines
N */
N#define UART_FIFO_DEPTH						(16)								/** UART-FIFO How many entries are in the FIFO */
N#define UART_FIFOSTAT_BITMASK				(0x1F1FFB)							/** UART-FIFO STAT Register BitMask */
N#define UART_FIFOSTAT_TXERR      			(1 << 0)              				/*!< UART TX Error */
N#define UART_FIFOSTAT_RXERR      			(1 << 1)              				/*!< UART RX Error */
N#define UART_FIFOSTAT_PERIPH     			(1 << 3)              				/*!< Peripheral interrupt */
N#define UART_FIFOSTAT_TXEMPTY    			(1 << 4)              				/*!< TXFIFO Empty */
N#define UART_FIFOSTAT_TXNOTFULL  			(1 << 5)              				/*!< TXFIFO Not Full */
N#define UART_FIFOSTAT_RXNOTEMPTY 			(1 << 6)              				/*!< RXFIFO Not empty */
N#define UART_FIFOSTAT_RXFULL     			(1 << 7)              				/*!< RX FIFO Full */
N#define UART_FIFOSTAT_TXLVL(lvl)  			(((lvl) >> 8) & 0x1F)  				/*!< Get TX Level from status */
N#define UART_FIFOSTAT_RXLVL(lvl)  			(((lvl) >> 16) & 0x1F) 				/*!< Get TX Level from status */
N
N/**
N * @brief	UART FIFO trigger settings register defines
N */
N#define UART_FIFOTRIG_BITMASK				(0x000f0f03)						/**  UART FIFO trigger settings Register BitMask */
N#define UART_FIFOTRIG_TXLVLENA 				(1 << 0)              				/*!< TX level enable*/
N#define UART_FIFOTRIG_RXLVLENA 				(1 << 1)              				/*!< RX level enable */
N#define UART_FIFOTRIG_TXLVL(lvl) 			((lvl & 0x0f) << 8)  				/*!< Set TX Level trigger */
N#define UART_FIFOTRIG_RXLVL(lvl)			((lvl & 0x0f) << 16) 				/*!< Set RX Level trigger */
N
N/**
N * @brief 	UART FIFO Interrupt enable/disable/status [INTSET/INTCLR/INTSTAT and FIFOINTSET/FIFOINTCLR/FIFOINTSTAT registers]
N */
N#define UART_FIFOINT_BITMASK				(0x001F)							/** FIFO interrupt Bit mask */
N#define UART_FIFOINT_TXERR					(1 << 0)							/**	 TX error interrupt			[BIT-0 of FIFOINTENSET/FIFOINTENCLR/FIFOINTSTAT register] */
N#define UART_FIFOINT_RXERR					(1 << 1)							/**	 RX error interrupt			[BIT-1 of FIFOINTENSET/FIFOINTENCLR/FIFOINTSTAT register] */
N#define UART_FIFOINT_TXLVL					(1 << 2)							/**	 TX FIFO ready interrupt	[BIT-2 of FIFOINTENSET/FIFOINTENCLR/FIFOINTSTAT register] */
N#define UART_FIFOINT_RXLVL					(1 << 3)							/**	 RX Data ready interrupt	[BIT-3 of FIFOINTENSET/FIFOINTENCLR/FIFOINTSTAT register] */
N#define UART_FIFOINT_PERINT					(1 << 4)							/**	 UART peripheral interrupt	[BIT-4 of FIFOINTSTAT register] */
N
N/**
N * @brief	UART Baud rate calculation structure
N * @note
N * Use oversampling (@a ovr) value other than 16, only if the difference
N * between the actual baud and desired baud has an unacceptable error percentage.
N * Smaller @a ovr values can cause the sampling position within the data-bit
N * less accurate an may potentially cause more noise errors or incorrect data
N * set ovr to < 10 only when there is no other higher values suitable.
N */
Ntypedef struct {
N	uint32_t		clk;					/*!< IN: Base clock to fractional divider; OUT: "Base clock rate for UART" */
N	uint32_t		baud;					/*!< IN: Required baud rate; OUT: Actual baud rate */
N	uint8_t			ovr;					/*!< IN: Number of desired over samples [0-auto detect or values 5 to 16]; OUT: Auto detected over samples [unchanged if IN is not 0] */
N	uint8_t			mul;					/*!< IN: 0 - calculate MUL, 1 - do't calculate (@a clk) has UART base clock; OUT: MUL value to be set in FRG register */
N	uint16_t		div;					/*!< OUT: Integer divider to divide the "Base clock rate for UART" */
N} UART_BAUD_T;
N
N/**
N * @brief	UART statistics structure
N * @note
N * Maintains current UART statistics.
N */
Ntypedef struct {
N	uint32_t		interrupts;				/*!< count: interrupts */
N	uint32_t		lvl_tx;					/*!< count: transmit interrupts */
N	uint32_t		lvl_rx;					/*!< count: receive interrupts */
N	uint32_t		fifo_err_tx;			/*!< count: FIFO transmit errors */
N	uint32_t		fifo_err_rx;			/*!< count: FIFO receive errors */
N	uint32_t		uart_cts;				/*!< count: UART CTS */
N	uint32_t		uart_break;				/*!< count: UART break */
N	uint32_t		uart_start;				/*!< count: UART RX starts */
N	uint32_t		uart_err_frame;			/*!< count: UART frame errors */
N	uint32_t		uart_err_parity;		/*!< count: UART parity errors */
N	uint32_t		uart_err_rx_noise;		/*!< count: UART receive noise errors */
N	uint32_t		uart_err_auto_baud;		/*!< count: UART auto-baud errors */
N} UART_STATISTICS_T;
N
N/**
N * @brief	Enable the UART
N * @param	pUART		: Pointer to selected UARTx peripheral
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_UART_Enable(LPC_USART_T *pUART)
Xstatic __inline void Chip_UART_Enable(LPC_USART_T *pUART)
N{
N	pUART->CFG |= UART_CFG_ENABLE;
X	pUART->CFG |= (0x01 << 0);
N}
N
N/**
N * @brief	Disable the UART
N * @param	pUART	: Pointer to selected UARTx peripheral
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_UART_Disable(LPC_USART_T *pUART)
Xstatic __inline void Chip_UART_Disable(LPC_USART_T *pUART)
N{
N	pUART->CFG &= ~UART_CFG_ENABLE;
X	pUART->CFG &= ~(0x01 << 0);
N}
N
N/**
N * @brief	Enable transmission on UART TxD pin
N * @param	pUART	: Pointer to selected pUART peripheral
N * @return Nothing
N */
N__STATIC_INLINE void Chip_UART_TXEnable(LPC_USART_T *pUART)
Xstatic __inline void Chip_UART_TXEnable(LPC_USART_T *pUART)
N{
N	pUART->CTL &= ~UART_CTRL_TXDIS;
X	pUART->CTL &= ~(0x01 << 6);
N}
N
N/**
N * @brief	Disable transmission on UART TxD pin
N * @param	pUART	: Pointer to selected pUART peripheral
N * @return Nothing
N */
N__STATIC_INLINE void Chip_UART_TXDisable(LPC_USART_T *pUART)
Xstatic __inline void Chip_UART_TXDisable(LPC_USART_T *pUART)
N{
N	pUART->CTL |= UART_CTRL_TXDIS;
X	pUART->CTL |= (0x01 << 6);
N}
N
N/**
N * @brief	Set auto baud
N * @param	pUART	: Pointer to selected pUART peripheral
N * @return true if auto baud succeeds, false if fails
N */
N__STATIC_INLINE uint32_t Chip_UART_AutoBaud(LPC_USART_T *pUART)
Xstatic __inline uint32_t Chip_UART_AutoBaud(LPC_USART_T *pUART)
N{
N	while ( (pUART->STAT & UART_STAT_RXIDLE) != UART_STAT_RXIDLE ) {}
X	while ( (pUART->STAT & (0x01 << 1)) != (0x01 << 1) ) {}
N	pUART->CTL |= UART_CTRL_AUTOBAUD;
X	pUART->CTL |= (0x01 << 16);
N	while ( pUART->CTL & UART_CTRL_AUTOBAUD ) {
X	while ( pUART->CTL & (0x01 << 16) ) {
N		if ( pUART->STAT & UART_STAT_ABERR ) {
X		if ( pUART->STAT & (0x01 << 16) ) {
N			pUART->STAT = UART_STAT_ABERR;
X			pUART->STAT = (0x01 << 16);
N			return false;
X			return 0;
N		}
N	}
N	return true;
X	return 1;
N}
N
N/**
N * @brief	Transmit a single data byte through the UART peripheral
N * @param	pUART	: Pointer to selected UART peripheral
N * @param	data	: Byte to transmit
N * @return	Nothing
N * @note	This function attempts to place a byte into the UART transmit
N *			holding register regard regardless of UART state.
N */
N__STATIC_INLINE void Chip_UART_SendByte(LPC_USART_T *pUART, uint8_t data)
Xstatic __inline void Chip_UART_SendByte(LPC_USART_T *pUART, uint8_t data)
N{
N	pUART->FIFOWR = (uint32_t)data;
N}
N
N/**
N * @brief	Read a single byte data from the UART peripheral
N * @param	pUART	: Pointer to selected UART peripheral
N * @return	A single byte of data read
N * @note	This function reads a byte from the UART receive FIFO or
N *			receive hold register regard regardless of UART state.
N */
N__STATIC_INLINE uint32_t Chip_UART_ReadByte(LPC_USART_T *pUART)
Xstatic __inline uint32_t Chip_UART_ReadByte(LPC_USART_T *pUART)
N{
N	/* Strip off undefined reserved bits, keep 9 lower bits */
N	return (uint32_t) (pUART->FIFORD & 0x000001FF);
N}
N
N/**
N * @brief	Enable UART interrupts
N * @param	pUART	: Pointer to selected UART peripheral
N * @param	intMask	: OR'ed Interrupts to enable
N * @return	Nothing
N * @note	Use an OR'ed value of UART_INTEN_* definitions with this function
N *			to enable specific UART interrupts.
N */
N__STATIC_INLINE void Chip_UART_IntEnable(LPC_USART_T *pUART, uint32_t intMask)
Xstatic __inline void Chip_UART_IntEnable(LPC_USART_T *pUART, uint32_t intMask)
N{
N	pUART->INTENSET = intMask;
N}
N
N/**
N * @brief	Disable UART interrupts
N * @param	pUART	: Pointer to selected UART peripheral
N * @param	intMask	: OR'ed Interrupts to disable
N * @return	Nothing
N * @note	Use an OR'ed value of UART_INTEN_* definitions with this function
N *			to disable specific UART interrupts.
N */
N__STATIC_INLINE void Chip_UART_IntDisable(LPC_USART_T *pUART, uint32_t intMask)
Xstatic __inline void Chip_UART_IntDisable(LPC_USART_T *pUART, uint32_t intMask)
N{
N	pUART->INTENCLR = intMask;
N}
N
N/**
N * @brief	Returns UART interrupts that are enabled
N * @param	pUART	: Pointer to selected UART peripheral
N * @return	Returns the enabled UART interrupts
N * @note	Use an OR'ed value of UART_INTEN_* definitions with this function
N *			to determine which interrupts are enabled. You can check
N *			for multiple enabled bits if needed.
N */
N__STATIC_INLINE uint32_t Chip_UART_GetIntsEnabled(LPC_USART_T *pUART)
Xstatic __inline uint32_t Chip_UART_GetIntsEnabled(LPC_USART_T *pUART)
N{
N	return pUART->INTENSET;
N}
N
N/**
N * @brief	Get UART interrupt status
N * @param	pUART	: The base of UART peripheral on the chip
N * @return	The UART interrupt status register
N * @note	This register does not indicate UART pending interrupts.
N *			It indicates the enabled interrupts. To get pending interrupts,
N *			read the UART status register.
N */
N__STATIC_INLINE uint32_t Chip_UART_GetIntStatus(LPC_USART_T *pUART)
Xstatic __inline uint32_t Chip_UART_GetIntStatus(LPC_USART_T *pUART)
N{
N	return pUART->INTSTAT;
N}
N
N/**
N * @brief	Configure data width, parity and stop bits
N * @param	pUART	: Pointer to selected pUART peripheral
N * @param	config	: UART configuration, OR'ed values of select UART_CFG_* defines
N * @return	Nothing
N * @note	Select OR'ed config options for the UART from the UART_CFG_PARITY_*,
N *			UART_CFG_STOPLEN_*, and UART_CFG_DATALEN_* definitions. For example,
N *			a configuration of 8 data bits, 1 stop bit, and even (enabled) parity would be
N *			(UART_CFG_DATALEN_8 | UART_CFG_STOPLEN_1 | UART_CFG_PARITY_EVEN). Will not
N *			alter other bits in the CFG register.
N */
N__STATIC_INLINE void Chip_UART_ConfigData(LPC_USART_T *pUART, uint32_t config)
Xstatic __inline void Chip_UART_ConfigData(LPC_USART_T *pUART, uint32_t config)
N{
N	pUART->CFG = (pUART->CFG & UART_CFG_BITMASK) | config;
X	pUART->CFG = (pUART->CFG & (0x00fddbfd)) | config;
N}
N
N/**
N * @brief	Get the UART status register
N * @param	pUART	: Pointer to selected UARTx peripheral
N * @return	UART status register
N * @note	Multiple statuses may be pending. Mask the return value
N *			with one or more UART_STAT_* definitions to determine
N *			statuses.
N */
N__STATIC_INLINE uint32_t Chip_UART_GetStatus(LPC_USART_T *pUART)
Xstatic __inline uint32_t Chip_UART_GetStatus(LPC_USART_T *pUART)
N{
N	return pUART->STAT;
N}
N
N/**
N * @brief	Clear the UART status register
N * @param	pUART	: Pointer to selected UARTx peripheral
N * @param	stsMask	: OR'ed statuses to disable
N * @return	Nothing
N * @note	Multiple interrupts may be pending. Mask the return value
N *			with one or more UART_INTEN_* definitions to determine
N *			pending interrupts.
N */
N__STATIC_INLINE void Chip_UART_ClearStatus(LPC_USART_T *pUART, uint32_t stsMask)
Xstatic __inline void Chip_UART_ClearStatus(LPC_USART_T *pUART, uint32_t stsMask)
N{
N	pUART->STAT = stsMask;
N}
N
N/**
N * @brief	Get the current status of UART controller FIFO
N * @param	pUART	: The base of UART peripheral on the chip
N * @return	UART Status (Or-ed bit value of UART_FIFOSTAT_*)
N * @note	Mask the return value with a value of type UART_FIFOSTAT_* to determine
N * if that status is active.
N */
N__STATIC_INLINE uint32_t Chip_UART_GetFIFOStatus(LPC_USART_T *pUART)
Xstatic __inline uint32_t Chip_UART_GetFIFOStatus(LPC_USART_T *pUART)
N{
N	return pUART->FIFOSTAT;
N}
N
N/**
N * @brief	Clear the FIFO status register
N * @param	pUART	: The base of the UART peripheral on the chip
N * @param	mask	: Mask of the status bits that needs to be cleared
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_UART_ClearFIFOStatus(LPC_USART_T *pUART, uint32_t mask)
Xstatic __inline void Chip_UART_ClearFIFOStatus(LPC_USART_T *pUART, uint32_t mask)
N{
N	pUART->FIFOSTAT = mask;
N}
N
N/**
N * @brief	Setup the trigger level for UART FIFO
N * @param	pUART	: The base of the UART peripheral on chip
N * @param	tx_lvl	: TX Trigger level [Valid values 0 to 15]
N * @param	rx_lvl	: RX Trigger level [Valid values 0 to 15]
N * @return	Nothing
N * @note	When @a tx_lvl = 0; trigger will happen when TX FIFO is empty
N * if @a tx_lvl = 15; trigger will happen when TX FIFO has at least one free space<br>
N * When @a rx_lvl = 0; trigger will happen when RX FIFO has at least one byte in it,
N * if @a rx_lvl = 15; trigger will happen when RX FIFO is full and cannot receive anymore data
N */
N__STATIC_INLINE void Chip_UART_SetFIFOTrigLevel(LPC_USART_T *pUART, uint8_t tx_lvl, uint8_t rx_lvl)
Xstatic __inline void Chip_UART_SetFIFOTrigLevel(LPC_USART_T *pUART, uint8_t tx_lvl, uint8_t rx_lvl)
N{
N	pUART->FIFOTRIG = (UART_FIFOTRIG_TXLVLENA|UART_FIFOTRIG_RXLVLENA) | UART_FIFOTRIG_TXLVL(tx_lvl) | UART_FIFOTRIG_RXLVL(rx_lvl);
X	pUART->FIFOTRIG = ((1 << 0)|(1 << 1)) | ((tx_lvl & 0x0f) << 8) | ((rx_lvl & 0x0f) << 16);
N}
N
N/**
N * @brief	Enable a UART FIFO interrupt
N * @param	pUART	: The base of UART peripheral on the chip
N * @param	intMask	: Or'ed value of UART_FIFOINT_* values to enable
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_UART_EnableFIFOInts(LPC_USART_T *pUART, uint32_t intMask)
Xstatic __inline void Chip_UART_EnableFIFOInts(LPC_USART_T *pUART, uint32_t intMask)
N{
N	pUART->FIFOINTENSET = intMask & UART_FIFOINT_BITMASK;
X	pUART->FIFOINTENSET = intMask & (0x001F);
N}
N
N/**
N * @brief	Disable a UART FIFO interrupt
N * @param	pUART	: The base of UART peripheral on the chip
N * @param	intMask	: Or'ed value of UART_FIFOINT_* values to disable (See #UART_FIFOINT_BITMASK)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_UART_DisableFIFOInts(LPC_USART_T *pUART, uint32_t intMask)
Xstatic __inline void Chip_UART_DisableFIFOInts(LPC_USART_T *pUART, uint32_t intMask)
N{
N	pUART->FIFOINTENCLR = intMask & UART_FIFOINT_BITMASK;
X	pUART->FIFOINTENCLR = intMask & (0x001F);
N}
N
N/**
N * @brief	Return enabled UART FIFO interrupts
N * @param	pUART	: The base of UART peripheral on the chip
N * @return	An Or'ed value of UART_FIFOINT_* values
N */
N__STATIC_INLINE uint32_t Chip_UART_GetFIFOEnabledInts(LPC_USART_T *pUART)
Xstatic __inline uint32_t Chip_UART_GetFIFOEnabledInts(LPC_USART_T *pUART)
N{
N	return pUART->FIFOINTENSET & UART_FIFOINT_BITMASK;
X	return pUART->FIFOINTENSET & (0x001F);
N}
N
N/**
N * @brief	Return pending UART FIFO interrupts
N * @param	pUART	: The base of UART peripheral on the chip
N * @return	An Or'ed value of UART_FIFOINT_* values
N */
N__STATIC_INLINE uint32_t Chip_UART_GetFIFOPendingInts(LPC_USART_T *pUART)
Xstatic __inline uint32_t Chip_UART_GetFIFOPendingInts(LPC_USART_T *pUART)
N{
N	return pUART->FIFOINTSTAT & UART_FIFOINT_BITMASK;
X	return pUART->FIFOINTSTAT & (0x001F);
N}
N
N/**
N * @brief	Set FIFO Configuration register
N * @param	pUART	: The base of UART peripheral on the chip
N * @param	cfg		: Configuration value mask (OR'ed UART_FIFOCFG_* values like #UART_FIFOCFG_ENABLETX)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_UART_SetFIFOCfg(LPC_USART_T *pUART, uint32_t cfg)
Xstatic __inline void Chip_UART_SetFIFOCfg(LPC_USART_T *pUART, uint32_t cfg)
N{
N	pUART->FIFOCFG = (pUART->FIFOCFG & UART_FIFOCFG_BITMASK) | cfg;
X	pUART->FIFOCFG = (pUART->FIFOCFG & (0x7F033)) | cfg;
N}
N
N/**
N * @brief	Clear FIFO Configuration register
N * @param	pUART	: The base of UART peripheral on the chip
N * @param	cfg		: Configuration value mask (OR'ed UART_FIFOCFG_* values like #UART_FIFOCFG_ENABLETX)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_UART_ClearFIFOCfg(LPC_USART_T *pUART, uint32_t cfg)
Xstatic __inline void Chip_UART_ClearFIFOCfg(LPC_USART_T *pUART, uint32_t cfg)
N{
N	pUART->FIFOCFG = pUART->FIFOCFG & (UART_FIFOCFG_BITMASK & ~cfg);
X	pUART->FIFOCFG = pUART->FIFOCFG & ((0x7F033) & ~cfg);
N}
N
N/**
N * @brief	Flush FIFOs
N * @param	pUART	: The base of UART peripheral on the chip
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_UART_FlushFIFOs(LPC_USART_T *pUART)
Xstatic __inline void Chip_UART_FlushFIFOs(LPC_USART_T *pUART)
N{
N	Chip_UART_SetFIFOCfg(pUART, UART_FIFOCFG_EMPTYTX | UART_FIFOCFG_EMPTYRX);
X	Chip_UART_SetFIFOCfg(pUART, (1 << 16) | (1 << 17));
N}
N
N/**
N * @brief	Initialize the UART peripheral
N * @param	pUART	: The base of UART peripheral on the chip
N * @return	0 - On success; #ERR_FLEXCOMM_FUNCNOTSUPPORTED or #ERR_FLEXCOMM_NOTFREE on failure
N */
Nint Chip_UART_Init(LPC_USART_T *pUART);
N
N/**
N * @brief	Deinitialize the UART peripheral
N * @param	pUART	: The base of UART peripheral on the chip
N * @return	Nothing
N */
Nvoid Chip_UART_DeInit(LPC_USART_T *pUART);
N
N/**
N * @brief	Configure UART for DMA
N * @param	pUART	: The base of UART peripheral on the chip
N * @return	Nothing
N */
Nvoid Chip_UART_ConfigDMA(LPC_USART_T *pUART);
N
N/**
N * @brief	Transmit a byte array through the UART peripheral (non-blocking)
N * @param	pUART		: Pointer to selected UART peripheral
N * @param	data		: Pointer to bytes to transmit
N * @param	numBytes	: Number of bytes to transmit
N * @return	The actual number of bytes placed into the FIFO
N * @note	This function places data into the transmit FIFO until either
N *			all the data is in the FIFO or the FIFO is full. This function
N *			will not block in the FIFO is full. The actual number of bytes
N *			placed into the FIFO is returned. This function ignores errors.
N */
Nint Chip_UART_Send(LPC_USART_T *pUART, const void *data, int numBytes);
N
N/**
N * @brief	Read data through the UART peripheral (non-blocking)
N * @param	pUART		: Pointer to selected UART peripheral
N * @param	data		: Pointer to bytes array to fill
N * @param	numBytes	: Size of the passed data array
N * @return	The actual number of bytes read
N * @note	This function reads data from the receive FIFO until either
N *			all the data has been read or the passed buffer is completely full.
N *			This function will not block. This function ignores errors.
N */
Nint Chip_UART_Read(LPC_USART_T *pUART, void *data, int numBytes);
N
N/**
N * @brief	Set baud rate for UART
N * @param	pUART	: The base of UART peripheral on the chip
N * @param	baudrate: Baud rate to be set
N * @return	Actual baud rate set
N * @note	This function uses the FRG to generate the required
N * clock, the FRG is shared by all the UARTs, hence calling this
N * API for multiple UARTs can affect each other.
N */
Nuint32_t Chip_UART_SetBaud(LPC_USART_T *pUART, uint32_t baudrate);
N
N/**
N * @brief	Transmit a byte array through the UART peripheral (blocking)
N * @param	pUART		: Pointer to selected UART peripheral
N * @param	data		: Pointer to data to transmit
N * @param	numBytes	: Number of bytes to transmit
N * @return	The number of bytes transmitted
N * @note	This function will send or place all bytes into the transmit
N *			FIFO. This function will block until the last bytes are in the FIFO.
N */
Nint Chip_UART_SendBlocking(LPC_USART_T *pUART, const void *data, int numBytes);
N
N/**
N * @brief	Read data through the UART peripheral (blocking)
N * @param	pUART		: Pointer to selected UART peripheral
N * @param	data		: Pointer to data array to fill
N * @param	numBytes	: Size of the passed data array
N * @return	The size of the dat array
N * @note	This function reads data from the receive FIFO until the passed
N *			buffer is completely full. The function will block until full.
N *			This function ignores errors.
N */
Nint Chip_UART_ReadBlocking(LPC_USART_T *pUART, void *data, int numBytes);
N
N/**
N * @brief	UART receive-only interrupt handler for ring buffers
N * @param	pUART	: Pointer to selected UART peripheral
N * @param	pRB		: Pointer to ring buffer structure to use
N * @return	Nothing
N * @note	If ring buffer support is desired for the receive side
N *			of data transfer, the UART interrupt should call this
N *			function for a receive based interrupt status.
N */
Nvoid Chip_UART_RXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB);
N
N/**
N * @brief	UART transmit-only interrupt handler for ring buffers
N * @param	pUART	: Pointer to selected UART peripheral
N * @param	pRB		: Pointer to ring buffer structure to use
N * @return	Nothing
N * @note	If ring buffer support is desired for the transmit side
N *			of data transfer, the UART interrupt should call this
N *			function for a transmit based interrupt status.
N */
Nvoid Chip_UART_TXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB);
N
N/**
N * @brief	Populate a transmit ring buffer and start UART transmit
N * @param	pUART	: Pointer to selected UART peripheral
N * @param	pRB		: Pointer to ring buffer structure to use
N * @param	data	: Pointer to buffer to move to ring buffer
N * @param	count	: Number of bytes to move
N * @return	The number of bytes placed into the ring buffer
N * @note	Will move the data into the TX ring buffer and start the
N *			transfer. If the number of bytes returned is less than the
N *			number of bytes to send, the ring buffer is considered full.
N */
Nuint32_t Chip_UART_SendRB(LPC_USART_T *pUART, RINGBUFF_T *pRB, const void *data, int count);
N
N/**
N * @brief	Copy data from a receive ring buffer
N * @param	pUART	: Pointer to selected UART peripheral
N * @param	pRB		: Pointer to ring buffer structure to use
N * @param	data	: Pointer to buffer to fill from ring buffer
N * @param	bytes	: Size of the passed buffer in bytes
N * @return	The number of bytes placed into the ring buffer
N * @note	Will move the data from the RX ring buffer up to the
N *			the maximum passed buffer size. Returns 0 if there is
N *			no data in the ring buffer.
N */
Nint Chip_UART_ReadRB(LPC_USART_T *pUART, RINGBUFF_T *pRB, void *data, int bytes);
N
N/**
N * @brief	UART receive/transmit interrupt handler for ring buffers
N * @param	pUART		: Pointer to selected UART peripheral
N * @param	statistics	: Pointer to statistics structure
N * @param	pRXRB		: Pointer to transmit ring buffer
N * @param	pTXRB		: Pointer to receive ring buffer
N * @return	Nothing
N * @note	This provides a basic implementation of the UART IRQ
N *			handler for support of a ring buffer implementation for
N *			transmit and receive.
N */
Nvoid Chip_UART_IRQHandlerRB(LPC_USART_T *pUART, UART_STATISTICS_T* statistics, RINGBUFF_T *pRXRB, RINGBUFF_T *pTXRB);
N
N/**
N * @brief	UART receive/transmit interrupt handler for DMA
N * @param	pUART	    : Pointer to selected UART peripheral
N * @param	statistics	: Pointer to statistics structure
N * @return	Nothing
N * @note	This interrupt service routine provides a basic implementation of the UART interrupt handler for DMA
N */
Nvoid Chip_UART_IRQHandlerDMA(LPC_USART_T *pUART, UART_STATISTICS_T* statistics);
N
N#ifndef __DOXYGEN__
N
N/* USART0 Defines */
N#define LPC_USART0_BASE   __APPEND3(LPC_FLEXCOMM,USART0_FLEXCOMM,_BASE)
N#define LPC_USART0        ((LPC_USART_T *) LPC_USART0_BASE)
N#define USART0_IRQHandler __APPEND3(FLEXCOMM,USART0_FLEXCOMM,_IRQHandler)
N#define USART0_IRQn       __APPEND3(FLEXCOMM,USART0_FLEXCOMM,_IRQn)
N#define DMAREQ_USART0_RX  __APPEND3(DMAREQ_FLEXCOMM,USART0_FLEXCOMM,_RX)
N#define DMAREQ_USART0_TX  __APPEND3(DMAREQ_FLEXCOMM,USART0_FLEXCOMM,_TX)
N
N/* USART1 Defines */
N#define LPC_USART1_BASE   __APPEND3(LPC_FLEXCOMM,USART1_FLEXCOMM,_BASE)
N#define LPC_USART1        ((LPC_USART_T *) LPC_USART1_BASE)
N#define USART1_IRQHandler __APPEND3(FLEXCOMM,USART1_FLEXCOMM,_IRQHandler)
N#define USART1_IRQn       __APPEND3(FLEXCOMM,USART1_FLEXCOMM,_IRQn)
N#define DMAREQ_USART1_RX  __APPEND3(DMAREQ_FLEXCOMM,USART1_FLEXCOMM,_RX)
N#define DMAREQ_USART1_TX  __APPEND3(DMAREQ_FLEXCOMM,USART1_FLEXCOMM,_TX)
N
N/* USART2 Defines */
N#define LPC_USART2_BASE   __APPEND3(LPC_FLEXCOMM,USART2_FLEXCOMM,_BASE)
N#define LPC_USART2        ((LPC_USART_T *) LPC_USART2_BASE)
N#define USART2_IRQHandler __APPEND3(FLEXCOMM,USART2_FLEXCOMM,_IRQHandler)
N#define USART2_IRQn       __APPEND3(FLEXCOMM,USART2_FLEXCOMM,_IRQn)
N#define DMAREQ_USART2_RX  __APPEND3(DMAREQ_FLEXCOMM,USART2_FLEXCOMM,_RX)
N#define DMAREQ_USART2_TX  __APPEND3(DMAREQ_FLEXCOMM,USART2_FLEXCOMM,_TX)
N
N/* USART3 Defines */
N#define LPC_USART3_BASE   __APPEND3(LPC_FLEXCOMM,USART3_FLEXCOMM,_BASE)
N#define LPC_USART3        ((LPC_USART_T *) LPC_USART3_BASE)
N#define USART3_IRQHandler __APPEND3(FLEXCOMM,USART3_FLEXCOMM,_IRQHandler)
N#define USART3_IRQn       __APPEND3(FLEXCOMM,USART3_FLEXCOMM,_IRQn)
N#define DMAREQ_USART3_RX  __APPEND3(DMAREQ_FLEXCOMM,USART3_FLEXCOMM,_RX)
N#define DMAREQ_USART3_TX  __APPEND3(DMAREQ_FLEXCOMM,USART3_FLEXCOMM,_TX)
N
N/* USART4 Defines */
N#define LPC_USART4_BASE   __APPEND3(LPC_FLEXCOMM,USART4_FLEXCOMM,_BASE)
N#define LPC_USART4        ((LPC_USART_T *) LPC_USART4_BASE)
N#define USART4_IRQHandler __APPEND3(FLEXCOMM,USART4_FLEXCOMM,_IRQHandler)
N#define USART4_IRQn       __APPEND3(FLEXCOMM,USART4_FLEXCOMM,_IRQn)
N#define DMAREQ_USART4_RX  __APPEND3(DMAREQ_FLEXCOMM,USART4_FLEXCOMM,_RX)
N#define DMAREQ_USART4_TX  __APPEND3(DMAREQ_FLEXCOMM,USART4_FLEXCOMM,_TX)
N
N/* USART5 Defines */
N#define LPC_USART5_BASE   __APPEND3(LPC_FLEXCOMM,USART5_FLEXCOMM,_BASE)
N#define LPC_USART5        ((LPC_USART_T *) LPC_USART5_BASE)
N#define USART5_IRQHandler __APPEND3(FLEXCOMM,USART5_FLEXCOMM,_IRQHandler)
N#define USART5_IRQn       __APPEND3(FLEXCOMM,USART5_FLEXCOMM,_IRQn)
N#define DMAREQ_USART5_RX  __APPEND3(DMAREQ_FLEXCOMM,USART5_FLEXCOMM,_RX)
N#define DMAREQ_USART5_TX  __APPEND3(DMAREQ_FLEXCOMM,USART5_FLEXCOMM,_TX)
N
N/* USART6 Defines */
N#define LPC_USART6_BASE   __APPEND3(LPC_FLEXCOMM,USART6_FLEXCOMM,_BASE)
N#define LPC_USART6        ((LPC_USART_T *) LPC_USART6_BASE)
N#define USART6_IRQHandler __APPEND3(FLEXCOMM,USART6_FLEXCOMM,_IRQHandler)
N#define USART6_IRQn       __APPEND3(FLEXCOMM,USART6_FLEXCOMM,_IRQn)
N#define DMAREQ_USART6_RX  __APPEND3(DMAREQ_FLEXCOMM,USART6_FLEXCOMM,_RX)
N#define DMAREQ_USART6_TX  __APPEND3(DMAREQ_FLEXCOMM,USART6_FLEXCOMM,_TX)
N
N/* USART7 Defines */
N#define LPC_USART7_BASE   __APPEND3(LPC_FLEXCOMM,USART7_FLEXCOMM,_BASE)
N#define LPC_USART7        ((LPC_USART_T *) LPC_USART7_BASE)
N#define USART7_IRQHandler __APPEND3(FLEXCOMM,USART7_FLEXCOMM,_IRQHandler)
N#define USART7_IRQn       __APPEND3(FLEXCOMM,USART7_FLEXCOMM,_IRQn)
N#define DMAREQ_USART7_RX  __APPEND3(DMAREQ_FLEXCOMM,USART7_FLEXCOMM,_RX)
N#define DMAREQ_USART7_TX  __APPEND3(DMAREQ_FLEXCOMM,USART7_FLEXCOMM,_TX)
N
N#endif
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __UART_5411X_H_ */
L 205 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "spi_common_5411x.h"
L 1 "..\..\..\chip_5411x\inc\spi_common_5411x.h" 1
N/*
N * @brief LPC5411X SPI common functions and definitions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2015
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.	 This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __SPI_COMMON_5411X_H_
N#define __SPI_COMMON_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup SPI_COMMON_5411X CHIP: LPC5411X SPI driver
N *
N * The SPI interface is provided via FlexCOMM module in the CHIP, to associate a SPI to
N * a flexcom the source file must add a define like <b>\#define SPI0_FLEXCOMM	5</b> which
N * will make LPC_SPI0 use LPC_FLEXCOMM5, interrupt service function name and IRQ number
N * DMA REQUEST number will all be mapped automatically. <b> Note that this define must
N * be available/visible to all the sources that uses SPI.</b><br><br> The SPI driver
N * by default will use FIFOs for TX and RX. TX and RX FIFOs has a depth of 8 entries each.
N *
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/**
N * @brief SPI register block structure
N */
Ntypedef struct {																/*!< SPI Structure */
N	/** SPI registers @endcond */
N	__I	 uint32_t RESERVED0[256];
X	volatile const	 uint32_t RESERVED0[256];
N	__IO uint32_t CFG;															/*!< Offset: 0x400 SPI Configuration register */
X	volatile uint32_t CFG;															 
N	__IO uint32_t DLY;															/*!< Offset: 0x404 SPI Delay register */
X	volatile uint32_t DLY;															 
N	__IO uint32_t STAT;															/*!< Offset: 0x408 SPI Status register */
X	volatile uint32_t STAT;															 
N	__IO uint32_t INTENSET;														/*!< Offset: 0x40c SPI Interrupt Enable Set register */
X	volatile uint32_t INTENSET;														 
N	__IO uint32_t INTENCLR;														/*!< Offset: 0x410 SPI Interrupt Enable Clear register */
X	volatile uint32_t INTENCLR;														 
N	__I	 uint32_t RESERVED1[4];
X	volatile const	 uint32_t RESERVED1[4];
N	__IO uint32_t DIV;															/*!< Offset: 0x424 SPI clock Divider register */
X	volatile uint32_t DIV;															 
N	__IO uint32_t INTSTAT;														/*!< Offset: 0x428 SPI Interrupt Status register @cond */
X	volatile uint32_t INTSTAT;														 
N	__I	 uint32_t RESERVED2[629];
X	volatile const	 uint32_t RESERVED2[629];
N
N	/** SPI FIFO Specific registers @endcond */
N	__IO uint32_t FIFOCFG;														/*!< Offset: 0xE00 FIFO Configuration register */
X	volatile uint32_t FIFOCFG;														 
N	__IO uint32_t FIFOSTAT;														/*!< Offset: 0xE04 FIFO Status register */
X	volatile uint32_t FIFOSTAT;														 
N	__IO uint32_t FIFOTRIG;														/*!< Offset: 0xE08 FIFO Trigger level register @cond */
X	volatile uint32_t FIFOTRIG;														 
N	__I	 uint32_t RESERVED3;													/*!< Offset: 0xE0C Reserved register @endcond */
X	volatile const	 uint32_t RESERVED3;													 
N	__IO uint32_t FIFOINTENSET;													/*!< Offset: 0xE10 FIFO Interrupt enable SET register */
X	volatile uint32_t FIFOINTENSET;													 
N	__IO uint32_t FIFOINTENCLR;													/*!< Offset: 0xE14 FIFO Interrupt enable CLEAR register */
X	volatile uint32_t FIFOINTENCLR;													 
N	__IO uint32_t FIFOINTSTAT;													/*!< Offset: 0xE18 FIFO Interrupt Status register @cond */
X	volatile uint32_t FIFOINTSTAT;													 
N	__I	 uint32_t RESERVED4;													/*!< Offset: 0xE1C Reserved register @endcond */
X	volatile const	 uint32_t RESERVED4;													 
N	__O	 uint32_t FIFOWR;														/*!< Offset: 0xE20 FIFO Data write register @cond */
X	volatile	 uint32_t FIFOWR;														 
N	__I	 uint32_t RESERVED5[3];													/*!< Offset: 0xE24 Reserved register @endcond */
X	volatile const	 uint32_t RESERVED5[3];													 
N	__I	 uint32_t FIFORD;														/*!< Offset: 0xE30 FIFO Data read register @cond */
X	volatile const	 uint32_t FIFORD;														 
N	__I	 uint32_t RESERVED6[3];													/*!< Offset: 0xE24 Reserved register @endcond */
X	volatile const	 uint32_t RESERVED6[3];													 
N	__I	 uint32_t FIFORDNOPOP;													/*!< Offset: 0xE40 FIFO Data peek (read without popping out of queue) register @cond */
X	volatile const	 uint32_t FIFORDNOPOP;													 
N	__I	 uint32_t RESERVED7[109];												/*!< Offset: 0xE44 Reserved register */
X	volatile const	 uint32_t RESERVED7[109];												 
N
N	/** FLEXCOMM Interface registers @endcond */
N	__IO uint32_t PSELID;														/*!< Offset: 0xFF8 Peripheral select/identification register */
X	volatile uint32_t PSELID;														 
N	__I	 uint32_t PID;															/*!< Offset: 0xFFC Module identification register */
X	volatile const	 uint32_t PID;															 
N} LPC_SPI_T;
N
N/**
N * Macro defines for SPI Configuration register
N */
N#define SPI_CFG_BITMASK						(0x0FBD)							/** SPI register bit mask */
N#define SPI_CFG_SPI_EN						(1 << 0)							/** SPI Slave Mode Select */
N#define SPI_CFG_SLAVE_EN					(0 << 0)							/** SPI Master Mode Select */
N#define SPI_CFG_MASTER_EN					(1 << 2)							/** SPI MSB First mode enable */
N#define SPI_CFG_MSB_FIRST_EN				(0 << 3)							/** SPI LSB First mode enable */
N#define SPI_CFG_LSB_FIRST_EN				(1 << 3)							/** SPI Clock Phase Select */
N#define SPI_CFG_CPHA_FIRST					(0 << 4)							/** Capture data on the first edge, Change data on the following edge */
N#define SPI_CFG_CPHA_SECOND					(1 << 4)							/** SPI Clock Polarity Select */
N#define SPI_CFG_CPOL_LO						(0 << 5)							/** The rest state of the clock (between frames) is low. */
N#define SPI_CFG_CPOL_HI						(1 << 5)							/** The rest state of the clock (between frames) is high. */
N#define SPI_CFG_LBM_EN						(1 << 7)							/** SPI control 1 loopback mode enable */
N#define SPI_CFG_SPOL_LO						(0 << 8)							/** SPI SSEL0 Polarity Select */
N#define SPI_CFG_SPOL_HI						(1 << 8)							/** SSEL0 is active High */
N#define SPI_CFG_SPOLNUM_HI(n)				(1 << ((n) + 8))					/** SSELN is active High, selects 0 - 3 */
N
N/**
N * Macro defines for SPI Delay register
N */
N#define	 SPI_DLY_BITMASK					(0xFFFF)							/** SPI DLY Register Mask */
N#define	 SPI_DLY_PRE_DELAY(n)				(((n) & 0x0F) << 0)					/** Time in SPI clocks between SSEL assertion and the beginning of a data frame */
N#define	 SPI_DLY_POST_DELAY(n)				(((n) & 0x0F) << 4)					/** Time in SPI clocks between the end of a data frame and SSEL deassertion. */
N#define	 SPI_DLY_FRAME_DELAY(n)				(((n) & 0x0F) << 8)					/** Minimum time in SPI clocks between adjacent data frames. */
N#define	 SPI_DLY_TRANSFER_DELAY(n)			(((n) & 0x0F) << 12)				/** Minimum time in SPI clocks that the SSEL is deasserted between transfers. */
N
N/**
N * Macro defines for SPI Status register
N */
N#define SPI_STAT_BITMASK					(0x01F0)							/** SPI STAT Register BitMask */
N#define SPI_STAT_SSA						(1 << 4)							/** Slave Select Assert */
N#define SPI_STAT_SSD						(1 << 5)							/** Slave Select Deassert */
N#define SPI_STAT_STALLED					(1 << 6)							/** Stalled status flag */
N#define SPI_STAT_EOT						(1 << 7)							/** End Transfer flag */
N#define SPI_STAT_MSTIDLE					(1 << 8)							/** Idle status flag */
N
N/**
N * Macro defines for SPI interrupt register
N */
N#define SPI_INT_BITMASK						(0x0130)							/** SPI interrupt Enable/Disable bits */
N#define SPI_INT_SSAEN						(1 << 4)							/**	 Slave Select is asserted interrupt		[BIT-4 of INTENSET/INTENCLR/INTSTAT register] */
N#define SPI_INT_SSDEN						(1 << 5)							/**	 Slave Select is deasserted interrupt	[BIT-5 of INTENSET/INTENCLR/INTSTAT register] */
N#define SPI_INT_MSTIDLE						(1 << 8)							/**	 SPI master is Idle						[BIT-8 of INTENSET/INTENCLR/INTSTAT register] */
N
N/**
N * @brief	SPI FIFO Configuration register bits
N * @cond
N */
N#define SPI_FIFOCFG_MASK					(0x3F033)							/*!< Register mask bit @endcond */
N#define SPI_FIFOCFG_ENABLETX				(1 << 0)							/*!< Enable TX FIFO */
N#define SPI_FIFOCFG_ENABLERX				(1 << 1)							/*!< Enable RX FIFO */
N#define SPI_FIFOCFG_DMATX					(1 << 12)							/*!< Enable DMA TX */
N#define SPI_FIFOCFG_DMARX					(1 << 13)							/*!< Enable DMA RX */
N#define SPI_FIFOCFG_WAKETX					(1 << 14)							/*!< Enable wakeup triggered by TX */
N#define SPI_FIFOCFG_WAKERX					(1 << 15)							/*!< Enable wakeup triggered by RX */
N#define SPI_FIFOCFG_EMPTYTX					(1 << 16)							/*!< Empty the TX FIFO */
N#define SPI_FIFOCFG_EMPTYRX					(1 << 17)							/*!< Empty the RX FIFO */
N
N/**
N * @brief	Macro defines for FIFO Status register
N */
N#define SPI_FIFO_DEPTH						(8)									/** SPI-FIFO How many entries are in the FIFO */
N#define SPI_FIFOSTAT_BITMASK				(0x1F1FFB)							/** SPI-FIFO STAT Register BitMask */
N#define SPI_FIFOSTAT_TXERR					(1 << 0)							/** SPI-FIFO transmit error */
N#define SPI_FIFOSTAT_RXERR					(1 << 1)							/** SPI-FIFO receive error */
N#define SPI_FIFOSTAT_PERINT					(1 << 3)							/** SPI-FIFO peripheral (SPI) interrupt */
N#define SPI_FIFOSTAT_TXEMPTY				(1 << 4)							/** SPI-FIFO transmitter empty */
N#define SPI_FIFOSTAT_TXNOTFULL				(1 << 5)							/** SPI-FIFO transmitter not full */
N#define SPI_FIFOSTAT_RXNOTEMPTY				(1 << 6)							/** SPI-FIFO receiver not empty */
N#define SPI_FIFOSTAT_RXFULL					(1 << 7)							/** SPI-FIFO receiver not full */
N#define SPI_FIFOSTAT_TXLVL(val)				(((val) >> 8) & 0x1F)				/** SPI-FIFO extract transmit level */
N#define SPI_FIFOSTAT_RXLVL(val)				(((val) >> 16) & 0x1F)				/** SPI-FIFO extract receive level */
N
N/**
N * @brief	UART FIFO trigger settings register defines
N */
N#define SPI_FIFOTRIG_BITMASK				(0x000f0f03)						/**  SPI FIFO trigger settings Register BitMask */
N#define SPI_FIFOTRIG_TXLVLENA 				(1 << 0)              				/*!< TX level enable*/
N#define SPI_FIFOTRIG_RXLVLENA 				(1 << 1)              				/*!< RX level enable */
N#define SPI_FIFOTRIG_TXLVL(lvl) 			((lvl & 0x0f) << 8)  				/*!< Set TX Level trigger */
N#define SPI_FIFOTRIG_RXLVL(lvl)				((lvl & 0x0f) << 16) 				/*!< Set RX Level trigger */
N
N#define SPI_FIFOTRIG_TXLVL_DEFAULT			4  									/*!< Set TX default trigger level to half-full */
N#define SPI_FIFOTRIG_RXLVL_DEFAULT			0 									/*!< Set RX default trigger level to one item */
N
N/**
N * @brief Macro defines for SPI Interrupt enable/disable/status [INTSET/INTCLR/INTSTAT and FIFOINTSET/FIFOINTCLR/FIFOINTSTAT registers]
N */
N#define SPI_FIFOINT_BITMASK					(0x001F)							/** FIFO interrupt Bit mask */
N#define SPI_FIFOINT_TXERR					(1 << 0)							/**	 TX error interrupt			[BIT-0 of FIFOINTENSET/FIFOINTENCLR/FIFOINTSTAT register] */
N#define SPI_FIFOINT_RXERR					(1 << 1)							/**	 RX error interrupt			[BIT-1 of FIFOINTENSET/FIFOINTENCLR/FIFOINTSTAT register] */
N#define SPI_FIFOINT_TXLVL					(1 << 2)							/**	 TX FIFO ready interrupt	[BIT-2 of FIFOINTENSET/FIFOINTENCLR/FIFOINTSTAT register] */
N#define SPI_FIFOINT_RXLVL					(1 << 3)							/**	 RX Data ready interrupt	[BIT-3 of FIFOINTENSET/FIFOINTENCLR/FIFOINTSTAT register] */
N#define SPI_FIFOINT_PERINT					(1 << 4)							/**	 SPI peripheral interrupt	[BIT-4 of FIFOINTSTAT register] */
N
N/**
N * Macro defines for SPI FIFO Receiver Data register
N */
N#define SPI_RXDAT_BITMASK					(0x1FFFFF)							/** SPI RXDAT Register BitMask */
N#define SPI_RXDAT_DATA(n)					((n) & 0xFFFF)						/** Receiver Data  */
N#define SPI_RXDAT_RXSSELN(n)				((~((n >> 16) & 0x0f)) & 0x0f)		/** Determine the active SSEL pin */
N#define SPI_RXDAT_RXSSELN_ACTIVE			(0 << 16)							/** The state of SSEL pin is active */
N#define SPI_RXDAT_SOT						(1 << 20)							/** Start of Transfer flag	*/
N
N/**
N * Macro defines for SPI FIFO Transmitter Data and Control register
N */
N#define SPI_TXDAT_BITMASK					(0xF7FFFFF)							/** SPI TXDATCTL Register BitMask */
N#define SPI_TXDAT_DATA(n)					((n) & 0xFFFF)						/** SPI Transmit Data */
N#define SPI_TXDAT_CTRLMASK					(0xF7F)								/** SPI TXDATCTL Register BitMask for control bits only */
N#define SPI_TXDAT_ASSERT_SSEL				(0)									/** Assert SSEL0 pin */
N#define SPI_TXDAT_ASSERTNUM_SSEL(n)			((~(1 << (n))) & 0x0f)				/** Assert SSELN pin */
N#define SPI_TXDAT_DEASSERT_SSEL				(1)									/** Deassert SSEL0 pin */
N#define SPI_TXDAT_DEASSERTNUM_SSEL(n)		(1 << (n))							/** Deassert SSELN pin */
N#define SPI_TXDAT_DEASSERT_ALL				(0xF)								/** Deassert all SSEL pins */
N#define SPI_TXDAT_EOT						(1 << 4)							/** End of Transfer flag (TRANSFER_DELAY is applied after sending the current frame) */
N#define SPI_TXDAT_EOF						(1 << 5)							/** End of Frame flag (FRAME_DELAY is applied after sending the current part) */
N#define SPI_TXDAT_RXIGNORE					(1 << 6)							/** Receive Ignore Flag */
N#define SPI_TXDAT_FLEN(n)					(((n) & 0x0F) << 8)					/** Frame length - 1 */
N#define SPI_TXDAT_FLENMASK					(0xF << 8)							/** Frame length mask */
N
N/**
N * Macro defines for SPI Transmitter Data Register
N */
N#define SPI_TXDAT_DATA(n)					((n) & 0xFFFF)						/** SPI Transmit Data */
N
N/**
N * Macro defines for SPI Divider register
N */
N#define SPI_DIV_VAL(n)						((n) & 0xFFFF)						/** Rate divider value mask (In Master Mode only)*/
N
N/** @brief SPI Clock Mode*/
Ntypedef enum {
N	ROM_SPI_CLOCK_CPHA0_CPOL0 = 0,												/**< CPHA = 0, CPOL = 0 */
N	ROM_SPI_CLOCK_MODE0 = ROM_SPI_CLOCK_CPHA0_CPOL0,							/**< Alias for CPHA = 0, CPOL = 0 */
N	ROM_SPI_CLOCK_CPHA1_CPOL0 = 1,												/**< CPHA = 0, CPOL = 1 */
N	ROM_SPI_CLOCK_MODE1 = ROM_SPI_CLOCK_CPHA1_CPOL0,							/**< Alias for CPHA = 0, CPOL = 1 */
N	ROM_SPI_CLOCK_CPHA0_CPOL1 = 2,												/**< CPHA = 1, CPOL = 0 */
N	ROM_SPI_CLOCK_MODE2 = ROM_SPI_CLOCK_CPHA0_CPOL1,							/**< Alias for CPHA = 1, CPOL = 0 */
N	ROM_SPI_CLOCK_CPHA1_CPOL1 = 3,												/**< CPHA = 1, CPOL = 1 */
N	ROM_SPI_CLOCK_MODE3 = ROM_SPI_CLOCK_CPHA1_CPOL1,							/**< Alias for CPHA = 1, CPOL = 1 */
N} ROM_SPI_CLOCK_MODE_T;
N
N/**
N * @brief	Initialize the SPI
N * @param	pSPI	: The base SPI peripheral on the chip
N * @return	Nothing
N */
Nint Chip_SPI_Init(LPC_SPI_T *pSPI);
N
N/**
N * @brief	Disable SPI operation
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @return	Nothing
N * @note	The SPI controller is disabled.
N */
N__STATIC_INLINE void Chip_SPI_DeInit(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPI_DeInit(LPC_SPI_T *pSPI)
N{
N	Chip_FLEXCOMM_DeInit(pSPI);
N}
N
N/**
N * @brief	Set SPI CFG register values
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @param	bits	: CFG register bits to set, amd OR'ed value of SPI_CFG_* definitions
N * @return	Nothing
N * @note	This function safely sets only the selected bits in the SPI CFG register.
N * It can be used to enable multiple bits at once.
N */
N__STATIC_INLINE void Chip_SPI_SetCFGRegBits(LPC_SPI_T *pSPI, uint32_t bits)
Xstatic __inline void Chip_SPI_SetCFGRegBits(LPC_SPI_T *pSPI, uint32_t bits)
N{
N	pSPI->CFG = (pSPI->CFG & SPI_CFG_BITMASK) | bits;
X	pSPI->CFG = (pSPI->CFG & (0x0FBD)) | bits;
N}
N
N/**
N * @brief	Clear SPI CFG register values
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @param	bits	: CFG register bits to clear, amd OR'ed value of SPI_CFG_* definitions
N * @return	Nothing
N * @note	This function safely clears only the selected bits in the SPI CFG register.
N * It can be used to disable multiple bits at once.
N */
N__STATIC_INLINE void Chip_SPI_ClearCFGRegBits(LPC_SPI_T *pSPI, uint32_t bits)
Xstatic __inline void Chip_SPI_ClearCFGRegBits(LPC_SPI_T *pSPI, uint32_t bits)
N{
N	pSPI->CFG = pSPI->CFG & (~bits & SPI_CFG_BITMASK);
X	pSPI->CFG = pSPI->CFG & (~bits & (0x0FBD));
N}
N
N/**
N * @brief	Enable SPI peripheral
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SPI_Enable(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPI_Enable(LPC_SPI_T *pSPI)
N{
N	Chip_SPI_SetCFGRegBits(pSPI, SPI_CFG_SPI_EN);
X	Chip_SPI_SetCFGRegBits(pSPI, (1 << 0));
N}
N
N/**
N * @brief	Disable SPI peripheral
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SPI_Disable(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPI_Disable(LPC_SPI_T *pSPI)
N{
N	Chip_SPI_ClearCFGRegBits(pSPI, SPI_CFG_SPI_EN);
X	Chip_SPI_ClearCFGRegBits(pSPI, (1 << 0));
N}
N
N/**
N * @brief	Enable SPI slave mode
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @return	Nothing
N * @note SPI master mode will be disabled with this call.
N */
N__STATIC_INLINE void Chip_SPI_EnableSlaveMode(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPI_EnableSlaveMode(LPC_SPI_T *pSPI)
N{
N	Chip_SPI_ClearCFGRegBits(pSPI, SPI_CFG_MASTER_EN);
X	Chip_SPI_ClearCFGRegBits(pSPI, (1 << 2));
N}
N
N/**
N * @brief	Enable LSB First transfers
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SPI_EnableLSBFirst(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPI_EnableLSBFirst(LPC_SPI_T *pSPI)
N{
N	Chip_SPI_SetCFGRegBits(pSPI, SPI_CFG_LSB_FIRST_EN);
X	Chip_SPI_SetCFGRegBits(pSPI, (1 << 3));
N}
N
N/**
N * @brief	Enable MSB First transfers
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SPI_EnableMSBFirst(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPI_EnableMSBFirst(LPC_SPI_T *pSPI)
N{
N	Chip_SPI_ClearCFGRegBits(pSPI, SPI_CFG_LSB_FIRST_EN);
X	Chip_SPI_ClearCFGRegBits(pSPI, (1 << 3));
N}
N
N/** @brief SPI Clock Mode*/
Ntypedef enum IP_SPI_CLOCK_MODE {
N	SPI_CLOCK_CPHA0_CPOL0 = SPI_CFG_CPOL_LO | SPI_CFG_CPHA_FIRST,				/**< CPHA = 0, CPOL = 0 */
X	SPI_CLOCK_CPHA0_CPOL0 = (0 << 5) | (0 << 4),				 
N	SPI_CLOCK_MODE0 = SPI_CLOCK_CPHA0_CPOL0,									/**< Alias for CPHA = 0, CPOL = 0 */
N	SPI_CLOCK_CPHA1_CPOL0 = SPI_CFG_CPOL_LO | SPI_CFG_CPHA_SECOND,				/**< CPHA = 0, CPOL = 1 */
X	SPI_CLOCK_CPHA1_CPOL0 = (0 << 5) | (1 << 4),				 
N	SPI_CLOCK_MODE1 = SPI_CLOCK_CPHA1_CPOL0,									/**< Alias for CPHA = 0, CPOL = 1 */
N	SPI_CLOCK_CPHA0_CPOL1 = SPI_CFG_CPOL_HI | SPI_CFG_CPHA_FIRST,				/**< CPHA = 1, CPOL = 0 */
X	SPI_CLOCK_CPHA0_CPOL1 = (1 << 5) | (0 << 4),				 
N	SPI_CLOCK_MODE2 = SPI_CLOCK_CPHA0_CPOL1,									/**< Alias for CPHA = 1, CPOL = 0 */
N	SPI_CLOCK_CPHA1_CPOL1 = SPI_CFG_CPOL_HI | SPI_CFG_CPHA_SECOND,				/**< CPHA = 1, CPOL = 1 */
X	SPI_CLOCK_CPHA1_CPOL1 = (1 << 5) | (1 << 4),				 
N	SPI_CLOCK_MODE3 = SPI_CLOCK_CPHA1_CPOL1,									/**< Alias for CPHA = 1, CPOL = 1 */
N} SPI_CLOCK_MODE_T;
N
N/**
N * @brief	Set SPI mode
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @param	mode	: SPI mode to set the SPI interface to
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SPI_SetSPIMode(LPC_SPI_T *pSPI, SPI_CLOCK_MODE_T mode)
Xstatic __inline void Chip_SPI_SetSPIMode(LPC_SPI_T *pSPI, SPI_CLOCK_MODE_T mode)
N{
N	Chip_SPI_ClearCFGRegBits(pSPI, (SPI_CFG_CPOL_HI | SPI_CFG_CPHA_SECOND));
X	Chip_SPI_ClearCFGRegBits(pSPI, ((1 << 5) | (1 << 4)));
N	Chip_SPI_SetCFGRegBits(pSPI, (uint32_t) mode);
N}
N
N/**
N * @brief	Set polarity on the SPI chip select high
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @param	csNum	: Chip select number, 0 - 3
N * @return	Nothing
N * @note	SPI chip select polarity is active high.
N */
N__STATIC_INLINE void Chip_SPI_SetCSPolHigh(LPC_SPI_T *pSPI, uint8_t csNum)
Xstatic __inline void Chip_SPI_SetCSPolHigh(LPC_SPI_T *pSPI, uint8_t csNum)
N{
N	Chip_SPI_SetCFGRegBits(pSPI, SPI_CFG_SPOLNUM_HI(csNum));
X	Chip_SPI_SetCFGRegBits(pSPI, (1 << ((csNum) + 8)));
N}
N
N/**
N * @brief	Set polarity on the SPI chip select low
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @param	csNum	: Chip select number, 0 - 3
N * @return	Nothing
N * @note	SPI chip select polarity is active low.
N */
N__STATIC_INLINE void Chip_SPI_SetCSPolLow(LPC_SPI_T *pSPI, uint8_t csNum)
Xstatic __inline void Chip_SPI_SetCSPolLow(LPC_SPI_T *pSPI, uint8_t csNum)
N{
N	Chip_SPI_ClearCFGRegBits(pSPI, SPI_CFG_SPOLNUM_HI(csNum));
X	Chip_SPI_ClearCFGRegBits(pSPI, (1 << ((csNum) + 8)));
N}
N
N/** SPI configuration structure used for setting up master/slave mode, LSB or
N * MSB first, and SPI mode in a single function call. */
Ntypedef struct {
N	uint32_t master				: 8;											/* Set to non-0 value to use master mode, 0 for slave */
N	uint32_t lsbFirst			: 8;											/* Set to non-0 value to send LSB first, 0 for MSB first */
N	SPI_CLOCK_MODE_T mode		: 8;											/* Mode selection */
N	uint32_t reserved			: 8;											/* Reserved, for alignment only */
N} SPI_CFGSETUP_T;
N
N/**
N * @brief	Setup SPI configuration
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @param	pCFG	: Pointer to SPI configuration structure
N * @return	Nothing
N */
Nvoid Chip_SPI_ConfigureSPI(LPC_SPI_T *pSPI, SPI_CFGSETUP_T *pCFG);
N
N/**
N * @brief	Get the current status of SPI controller
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @return	SPI Status (Or-ed bit value of SPI_STAT_*)
N * @note	Mask the return value with a value of type SPI_STAT_* to determine
N * if that status is active.
N */
N__STATIC_INLINE uint32_t Chip_SPI_GetStatus(LPC_SPI_T *pSPI)
Xstatic __inline uint32_t Chip_SPI_GetStatus(LPC_SPI_T *pSPI)
N{
N	return pSPI->STAT;
N}
N
N/**
N * @brief	Clear SPI status
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @param	Flag	: Clear Flag (Or-ed bit value of SPI_STAT_*)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SPI_ClearStatus(LPC_SPI_T *pSPI, uint32_t Flag)
Xstatic __inline void Chip_SPI_ClearStatus(LPC_SPI_T *pSPI, uint32_t Flag)
N{
N	pSPI->STAT = Flag;
N}
N
N/**
N * @brief	Enable a SPI interrupt
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @param	intMask	: Or'ed value of SPI_INT_* values to enable
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SPI_EnableInts(LPC_SPI_T *pSPI, uint32_t intMask)
Xstatic __inline void Chip_SPI_EnableInts(LPC_SPI_T *pSPI, uint32_t intMask)
N{
N	pSPI->INTENSET = intMask & SPI_INT_BITMASK;
X	pSPI->INTENSET = intMask & (0x0130);
N}
N
N/**
N * @brief	Disable a SPI interrupt
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @param	intMask	: Or'ed value of SPI_INT_* values to disable (See #SPI_INT_BITMASK)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SPI_DisableInts(LPC_SPI_T *pSPI, uint32_t intMask)
Xstatic __inline void Chip_SPI_DisableInts(LPC_SPI_T *pSPI, uint32_t intMask)
N{
N	pSPI->INTENCLR = intMask & SPI_INT_BITMASK;
X	pSPI->INTENCLR = intMask & (0x0130);
N}
N
N/**
N * @brief	Return enabled SPI interrupts
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @return	An Or'ed value of SPI_INT_* values
N * @note	Mask the return value with a SPI_INT_* value to determine (See #SPI_INT_BITMASK)
N *			if the interrupt is enabled.
N * @note	INTSTAT contains enabled interrupts, not pending interrupts.
N */
N__STATIC_INLINE uint32_t Chip_SPI_GetEnabledInts(LPC_SPI_T *pSPI)
Xstatic __inline uint32_t Chip_SPI_GetEnabledInts(LPC_SPI_T *pSPI)
N{
N	return pSPI->INTSTAT & SPI_INT_BITMASK;
X	return pSPI->INTSTAT & (0x0130);
N}
N
N/**
N * @brief	Return pending SPI interrupts
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @return	An Or'ed value of SPI_INT_* values
N */
N__STATIC_INLINE uint32_t Chip_SPI_GetPendingInts(LPC_SPI_T *pSPI)
Xstatic __inline uint32_t Chip_SPI_GetPendingInts(LPC_SPI_T *pSPI)
N{
N	uint32_t stat, mask;
N
N	mask = pSPI->INTSTAT;
N	stat = pSPI->STAT;
N	stat &= mask;
N
N	return stat;
N}
N
N//------------------------------------------------------------------------------
N//
N//	End SPI functions / Start of FIFO functions
N//
N//------------------------------------------------------------------------------
N
N//------------------------------------------------------------------------------
N//	FIFO configuration functions
N//------------------------------------------------------------------------------
N/**
N * @brief	Set FIFO Configuration register
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @param	cfg		: Configuration value mask (OR'ed SPI_FIFOCFG_* values like #SPI_FIFOCFG_ENABLETX)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SPI_SetFIFOCfg(LPC_SPI_T *pSPI, uint32_t cfg)
Xstatic __inline void Chip_SPI_SetFIFOCfg(LPC_SPI_T *pSPI, uint32_t cfg)
N{
N	pSPI->FIFOCFG = (pSPI->FIFOCFG & SPI_FIFOCFG_MASK) | cfg;
X	pSPI->FIFOCFG = (pSPI->FIFOCFG & (0x3F033)) | cfg;
N}
N
N/**
N * @brief	Clear FIFO Configuration register
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @param	cfg		: Configuration value mask (OR'ed SPI_FIFOCFG_* values like #SPI_FIFOCFG_ENABLETX)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SPI_ClearFIFOCfg(LPC_SPI_T *pSPI, uint32_t cfg)
Xstatic __inline void Chip_SPI_ClearFIFOCfg(LPC_SPI_T *pSPI, uint32_t cfg)
N{
N	pSPI->FIFOCFG = pSPI->FIFOCFG & (SPI_FIFOCFG_MASK & ~cfg);
X	pSPI->FIFOCFG = pSPI->FIFOCFG & ((0x3F033) & ~cfg);
N}
N
N//------------------------------------------------------------------------------
N//	FIFO status functions
N//------------------------------------------------------------------------------
N/**
N * @brief	Get the current status of SPI controller FIFO
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @return	SPI Status (Or-ed bit value of SPI_FIFOSTAT_*)
N * @note	Mask the return value with a value of type SPI_FIFOSTAT_* to determine
N *			if that status is active.
N */
N__STATIC_INLINE uint32_t Chip_SPI_GetFIFOStatus(LPC_SPI_T *pSPI)
Xstatic __inline uint32_t Chip_SPI_GetFIFOStatus(LPC_SPI_T *pSPI)
N{
N	return pSPI->FIFOSTAT;
N}
N
N/**
N * @brief	Clear the FIFO status register
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @param	mask	: Mask of the status bits that needs to be cleared
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SPI_ClearFIFOStatus(LPC_SPI_T *pSPI, uint32_t mask)
Xstatic __inline void Chip_SPI_ClearFIFOStatus(LPC_SPI_T *pSPI, uint32_t mask)
N{
N	pSPI->FIFOSTAT = mask;
N}
N
N//------------------------------------------------------------------------------
N//	FIFO trigger functions
N//------------------------------------------------------------------------------
N/**
N * @brief	Setup SPI FIFO trigger-level
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @param	tx_lvl	: TX Trigger level [Valid values 0 to 7]
N * @param	rx_lvl	: RX Trigger level [Valid values 0 to 7]
N * @return	Nothing
N * @note	When @a tx_lvl = 0; trigger will happen when TX FIFO is empty
N *			if @a tx_lvl = 7; trigger will happen when TX FIFO has at least one free space<br>
N *			When @a rx_lvl = 0; trigger will happen when RX FIFO has at least one data in it,
N *			if @a rx_lvl = 7; trigger will happen when RX FIFO is full and cannot receive anymore data.
N */
N__STATIC_INLINE void Chip_SPI_SetFIFOTrigLevel(LPC_SPI_T *pSPI, uint8_t tx_lvl, uint8_t rx_lvl)
Xstatic __inline void Chip_SPI_SetFIFOTrigLevel(LPC_SPI_T *pSPI, uint8_t tx_lvl, uint8_t rx_lvl)
N{
N	pSPI->FIFOTRIG = SPI_FIFOTRIG_TXLVL(tx_lvl) | SPI_FIFOTRIG_RXLVL(rx_lvl) |SPI_FIFOTRIG_TXLVLENA | SPI_FIFOTRIG_TXLVLENA;
X	pSPI->FIFOTRIG = ((tx_lvl & 0x0f) << 8) | ((rx_lvl & 0x0f) << 16) |(1 << 0) | (1 << 0);
N}
N
N/**
N * @brief	Get SPI FIFO trigger-level
N * @param	pSPI	: Base of on-chip SPI peripheral
N * @return	Returns the complete raw trigger register.
N */
N__STATIC_INLINE uint32_t Chip_SPI_GetFIFOTrigLevel(LPC_SPI_T *pSPI)
Xstatic __inline uint32_t Chip_SPI_GetFIFOTrigLevel(LPC_SPI_T *pSPI)
N{
N	return pSPI->FIFOTRIG;
N}
N
N
N//------------------------------------------------------------------------------
N//	FIFO interrupt functions
N//------------------------------------------------------------------------------
N/**
N * @brief	Enable a SPI FIFO interrupt
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @param	intMask	: Or'ed value of SPI_FIFOINT_* values to enable
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SPI_EnableFIFOInts(LPC_SPI_T *pSPI, uint32_t intMask)
Xstatic __inline void Chip_SPI_EnableFIFOInts(LPC_SPI_T *pSPI, uint32_t intMask)
N{
N	pSPI->FIFOINTENSET = intMask & SPI_FIFOINT_BITMASK;
X	pSPI->FIFOINTENSET = intMask & (0x001F);
N}
N
N/**
N * @brief	Disable a SPI FIFO interrupt
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @param	intMask	: Or'ed value of SPI_FIFOINT_* values to disable (See #SPI_FIFOINT_BITMASK)
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SPI_DisableFIFOInts(LPC_SPI_T *pSPI, uint32_t intMask)
Xstatic __inline void Chip_SPI_DisableFIFOInts(LPC_SPI_T *pSPI, uint32_t intMask)
N{
N	pSPI->FIFOINTENCLR = intMask & SPI_FIFOINT_BITMASK;
X	pSPI->FIFOINTENCLR = intMask & (0x001F);
N}
N
N/**
N * @brief	Return enabled SPI FIFO interrupts
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @return	An Or'ed value of SPI_FIFOINT_* values
N */
N__STATIC_INLINE uint32_t Chip_SPI_GetFIFOEnabledInts(LPC_SPI_T *pSPI)
Xstatic __inline uint32_t Chip_SPI_GetFIFOEnabledInts(LPC_SPI_T *pSPI)
N{
N	return pSPI->FIFOINTENSET & SPI_FIFOINT_BITMASK;
X	return pSPI->FIFOINTENSET & (0x001F);
N}
N
N/**
N * @brief	Return pending SPI FIFO interrupts
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @return	An Or'ed value of SPI_FIFOINT_* values
N */
N__STATIC_INLINE uint32_t Chip_SPI_GetFIFOPendingInts(LPC_SPI_T *pSPI)
Xstatic __inline uint32_t Chip_SPI_GetFIFOPendingInts(LPC_SPI_T *pSPI)
N{
N	return pSPI->FIFOINTSTAT & SPI_FIFOINT_BITMASK;
X	return pSPI->FIFOINTSTAT & (0x001F);
N}
N
N//------------------------------------------------------------------------------
N//	FIFO I/O functions
N//------------------------------------------------------------------------------
N/**
N * @brief	Read raw data from receive FIFO with status bits
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @return	Current value in receive data FIFO plus status bits
N */
N__STATIC_INLINE uint32_t Chip_SPI_ReadRawRXFifo(LPC_SPI_T *pSPI)
Xstatic __inline uint32_t Chip_SPI_ReadRawRXFifo(LPC_SPI_T *pSPI)
N{
N	return pSPI->FIFORD;
N}
N#define	Chip_SPI_ReadFIFO			Chip_SPI_ReadRawRXFifo
N
N/**
N * @brief	Read data from receive FIFO masking off status bits
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @return	Current value in receive data FIFO
N * @note	The entire register is read, but only the low 16-bits
N *			are returned.
N */
N__STATIC_INLINE uint16_t Chip_SPI_ReadRXData(LPC_SPI_T *pSPI)
Xstatic __inline uint16_t Chip_SPI_ReadRXData(LPC_SPI_T *pSPI)
N{
N	__I void *ptr = &pSPI->FIFORD;
X	volatile const void *ptr = &pSPI->FIFORD;
N	return *((__I uint16_t *) ptr);
X	return *((volatile const uint16_t *) ptr);
N}
N#define	Chip_SPI_ReadFIFOdata		Chip_SPI_ReadRXData
N
N
N/**
N * @brief	Write FIFOWR register: writes 32-bit value to FIFO
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @param	data	: Control and Data to be transfered
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SPI_WriteFIFO(LPC_SPI_T *pSPI, uint32_t data)
Xstatic __inline void Chip_SPI_WriteFIFO(LPC_SPI_T *pSPI, uint32_t data)
N{
N	pSPI->FIFOWR = data;
N}
N
N/**
N * @brief	Write FIFOWR register: writes control options and data
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @param	ctrl	: Control bits to be set
N * @param	data	: Data to be transfered
N * @return	Nothing
N * @note	This function safely sets only set bits in FIFOWR control register.
N *			It can be used to enable multiple options at once.
N */
N__STATIC_INLINE void Chip_SPI_SetTXCTRLData(LPC_SPI_T *pSPI, uint16_t ctrl, uint16_t data)
Xstatic __inline void Chip_SPI_SetTXCTRLData(LPC_SPI_T *pSPI, uint16_t ctrl, uint16_t data)
N{
N	pSPI->FIFOWR = (ctrl << 16) | data;
N}
N#define	Chip_SPI_WriteFIFOcd		Chip_SPI_SetTXCTRLData
N
N/**
N * @brief	Write data to transmit FIFO
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @param	data	: Data to write
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SPI_WriteTXData(LPC_SPI_T *pSPI, uint16_t data)
Xstatic __inline void Chip_SPI_WriteTXData(LPC_SPI_T *pSPI, uint16_t data)
N{
N	__O void *ptr = &pSPI->FIFOWR;
X	volatile void *ptr = &pSPI->FIFOWR;
N	*((__O uint16_t *) ptr) = data;
X	*((volatile uint16_t *) ptr) = data;
N}
N#define	Chip_SPI_WriteFIFOdata		Chip_SPI_WriteTXData
N
N/**
N * @brief	Flush FIFOs
N * @param	pSPI	: Base on-chip SPI peripheral address
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SPI_FlushFifos(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPI_FlushFifos(LPC_SPI_T *pSPI)
N{
N	Chip_SPI_SetFIFOCfg(pSPI, SPI_FIFOCFG_EMPTYTX | SPI_FIFOCFG_EMPTYRX);
X	Chip_SPI_SetFIFOCfg(pSPI, (1 << 16) | (1 << 17));
N}
N#define	Chip_SPI_FlushFIFOs		Chip_SPI_FlushFifos
N
N#ifndef __DOXYGEN__
N
N/* SPI0 Defines */
N#define LPC_SPI0_BASE	__APPEND3(LPC_FLEXCOMM,SPI0_FLEXCOMM,_BASE)
N#define LPC_SPI0		((LPC_SPI_T *) LPC_SPI0_BASE)
N#define SPI0_IRQHandler __APPEND3(FLEXCOMM,SPI0_FLEXCOMM,_IRQHandler)
N#define SPI0_IRQn		__APPEND3(FLEXCOMM,SPI0_FLEXCOMM,_IRQn)
N#define DMAREQ_SPI0_RX	__APPEND3(DMAREQ_FLEXCOMM,SPI0_FLEXCOMM,_RX)
N#define DMAREQ_SPI0_TX	__APPEND3(DMAREQ_FLEXCOMM,SPI0_FLEXCOMM,_TX)
N
N/* SPI1 Defines */
N#define LPC_SPI1_BASE	__APPEND3(LPC_FLEXCOMM,SPI1_FLEXCOMM,_BASE)
N#define LPC_SPI1		((LPC_SPI_T *) LPC_SPI1_BASE)
N#define SPI1_IRQHandler __APPEND3(FLEXCOMM,SPI1_FLEXCOMM,_IRQHandler)
N#define SPI1_IRQn		__APPEND3(FLEXCOMM,SPI1_FLEXCOMM,_IRQn)
N#define DMAREQ_SPI1_RX	__APPEND3(DMAREQ_FLEXCOMM,SPI1_FLEXCOMM,_RX)
N#define DMAREQ_SPI1_TX	__APPEND3(DMAREQ_FLEXCOMM,SPI1_FLEXCOMM,_TX)
N
N/* SPI2 Defines */
N#define LPC_SPI2_BASE	__APPEND3(LPC_FLEXCOMM,SPI2_FLEXCOMM,_BASE)
N#define LPC_SPI2		((LPC_SPI_T *) LPC_SPI2_BASE)
N#define SPI2_IRQHandler __APPEND3(FLEXCOMM,SPI2_FLEXCOMM,_IRQHandler)
N#define SPI2_IRQn		__APPEND3(FLEXCOMM,SPI2_FLEXCOMM,_IRQn)
N#define DMAREQ_SPI2_RX	__APPEND3(DMAREQ_FLEXCOMM,SPI2_FLEXCOMM,_RX)
N#define DMAREQ_SPI2_TX	__APPEND3(DMAREQ_FLEXCOMM,SPI2_FLEXCOMM,_TX)
N
N/* SPI3 Defines */
N#define LPC_SPI3_BASE	__APPEND3(LPC_FLEXCOMM,SPI3_FLEXCOMM,_BASE)
N#define LPC_SPI3		((LPC_SPI_T *) LPC_SPI3_BASE)
N#define SPI3_IRQHandler __APPEND3(FLEXCOMM,SPI3_FLEXCOMM,_IRQHandler)
N#define SPI3_IRQn		__APPEND3(FLEXCOMM,SPI3_FLEXCOMM,_IRQn)
N#define DMAREQ_SPI3_RX	__APPEND3(DMAREQ_FLEXCOMM,SPI3_FLEXCOMM,_RX)
N#define DMAREQ_SPI3_TX	__APPEND3(DMAREQ_FLEXCOMM,SPI3_FLEXCOMM,_TX)
N
N/* SPI4 Defines */
N#define LPC_SPI4_BASE	__APPEND3(LPC_FLEXCOMM,SPI4_FLEXCOMM,_BASE)
N#define LPC_SPI4		((LPC_SPI_T *) LPC_SPI4_BASE)
N#define SPI4_IRQHandler __APPEND3(FLEXCOMM,SPI4_FLEXCOMM,_IRQHandler)
N#define SPI4_IRQn		__APPEND3(FLEXCOMM,SPI4_FLEXCOMM,_IRQn)
N#define DMAREQ_SPI4_RX	__APPEND3(DMAREQ_FLEXCOMM,SPI4_FLEXCOMM,_RX)
N#define DMAREQ_SPI4_TX	__APPEND3(DMAREQ_FLEXCOMM,SPI4_FLEXCOMM,_TX)
N
N/* SPI5 Defines */
N#define LPC_SPI5_BASE	__APPEND3(LPC_FLEXCOMM,SPI5_FLEXCOMM,_BASE)
N#define LPC_SPI5		((LPC_SPI_T *) LPC_SPI5_BASE)
N#define SPI5_IRQHandler __APPEND3(FLEXCOMM,SPI5_FLEXCOMM,_IRQHandler)
N#define SPI5_IRQn		__APPEND3(FLEXCOMM,SPI5_FLEXCOMM,_IRQn)
N#define DMAREQ_SPI5_RX	__APPEND3(DMAREQ_FLEXCOMM,SPI5_FLEXCOMM,_RX)
N#define DMAREQ_SPI5_TX	__APPEND3(DMAREQ_FLEXCOMM,SPI5_FLEXCOMM,_TX)
N
N/* SPI6 Defines */
N#define LPC_SPI6_BASE	__APPEND3(LPC_FLEXCOMM,SPI6_FLEXCOMM,_BASE)
N#define LPC_SPI6		((LPC_SPI_T *) LPC_SPI6_BASE)
N#define SPI6_IRQHandler __APPEND3(FLEXCOMM,SPI6_FLEXCOMM,_IRQHandler)
N#define SPI6_IRQn		__APPEND3(FLEXCOMM,SPI6_FLEXCOMM,_IRQn)
N#define DMAREQ_SPI6_RX	__APPEND3(DMAREQ_FLEXCOMM,SPI6_FLEXCOMM,_RX)
N#define DMAREQ_SPI6_TX	__APPEND3(DMAREQ_FLEXCOMM,SPI6_FLEXCOMM,_TX)
N
N/* SPI7 Defines */
N#define LPC_SPI7_BASE	__APPEND3(LPC_FLEXCOMM,SPI7_FLEXCOMM,_BASE)
N#define LPC_SPI7		((LPC_SPI_T *) LPC_SPI7_BASE)
N#define SPI7_IRQHandler __APPEND3(FLEXCOMM,SPI7_FLEXCOMM,_IRQHandler)
N#define SPI7_IRQn		__APPEND3(FLEXCOMM,SPI7_FLEXCOMM,_IRQn)
N#define DMAREQ_SPI7_RX	__APPEND3(DMAREQ_FLEXCOMM,SPI7_FLEXCOMM,_RX)
N#define DMAREQ_SPI7_TX	__APPEND3(DMAREQ_FLEXCOMM,SPI7_FLEXCOMM,_TX)
N
N#endif
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __SPI_COMMON_5411X_H_ */
L 206 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "spim_5411x.h"
L 1 "..\..\..\chip_5411x\inc\spim_5411x.h" 1
N/*
N * @brief LPC5411X SPI master driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2015
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __SPIM_5411X_H_
N#define __SPIM_5411X_H_
N
N#include "spi_common_5411x.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup SPI_MASTER_5411X CHIP: LPC5411X SPI master driver
N * @ingroup SPI_COMMON_5411X
N * @{
N */
N
N/**
N * @brief	Get SPI master bit rate
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	The actual SPI clock bit rate
N */
N__STATIC_INLINE uint32_t Chip_SPIM_GetClockRate(LPC_SPI_T *pSPI)
Xstatic __inline uint32_t Chip_SPIM_GetClockRate(LPC_SPI_T *pSPI)
N{
N	return Chip_Clock_GetFLEXCOMMClockRate(Chip_FLEXCOMM_GetIndex(pSPI)) / (pSPI->DIV + 1);
N}
N
N/**
N * @brief	Set SPI master bit rate
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	rate	: Desired clock bit rate for the SPI interface
N * @return	The actual SPI clock bit rate
N * @note	This function will set the SPI clock divider to get closest
N * to the desired rate as possible.
N */
Nuint32_t Chip_SPIM_SetClockRate(LPC_SPI_T *pSPI, uint32_t rate);
N
N/**
N * @brief	SPI Delay Configure Struct
N * @note	All values are in SPI clocks.
N */
Ntypedef struct {
N	uint8_t PreDelay;					/** Additional Pre-delay, minimum is 1 clock (SSEL asserted), 0 - 15 */
N	uint8_t PostDelay;					/** Additional Post-delay, minimum is 1 clock (SSEL asserted), 0 - 15 */
N	uint8_t FrameDelay;					/** Delay between frames (SSEL asserted), 0 - 15 */
N	uint8_t TransferDelay;				/** Additional transfer-delay, minimum is 1 clock (SSEL NOT asserted), 1 - 16 */
N} SPIM_DELAY_CONFIG_T;
N
N/**
N * @brief	Config SPI Delay parameters
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	pConfig	: SPI Delay Configure Struct (See #SPIM_DELAY_CONFIG_T)
N * @return	Nothing
N */
Nvoid Chip_SPIM_DelayConfig(LPC_SPI_T *pSPI, SPIM_DELAY_CONFIG_T *pConfig);
N
N/**
N * @brief	Forces an end of transfer for the current master transfer
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	Nothing
N * @note	Use this function to perform an immediate end of trasnfer for the
N * current master operation. If the master is currently transferring data started
N * with the Chip_SPIM_Xfer function, this terminates the transfer after the
N * current byte completes and completes the transfer.
N */
N__STATIC_INLINE void Chip_SPIM_ForceEndOfTransfer(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPIM_ForceEndOfTransfer(LPC_SPI_T *pSPI)
N{
N	pSPI->STAT = SPI_STAT_EOT;
X	pSPI->STAT = (1 << 7);
N}
N
N/**
N * @brief	Enable loopback mode
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	Nothing
N * @note	Serial input is taken from the serial output (MOSI or MISO) rather
N * than the serial input pin.
N */
N__STATIC_INLINE void Chip_SPIM_EnableLoopBack(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPIM_EnableLoopBack(LPC_SPI_T *pSPI)
N{
N	Chip_SPI_SetCFGRegBits(pSPI, SPI_CFG_LBM_EN);
X	Chip_SPI_SetCFGRegBits(pSPI, (1 << 7));
N}
N
N/**
N * @brief	Disable loopback mode
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_SPIM_DisableLoopBack(LPC_SPI_T *pSPI)
Xstatic __inline void Chip_SPIM_DisableLoopBack(LPC_SPI_T *pSPI)
N{
N	Chip_SPI_ClearCFGRegBits(pSPI, SPI_CFG_LBM_EN);
X	Chip_SPI_ClearCFGRegBits(pSPI, (1 << 7));
N}
N
Nstruct SPIM_XFER;
N
N/**
N * @brief	SPI master Xfer events
N */
Ntypedef enum {
N	SPIM_EVENT_WAIT,         /*!< SPI Xfer is waiting to be complete */
N	SPIM_EVENT_ERRORTX,      /*!< SPI TX underflow error */
N	SPIM_EVENT_ERRORRX,      /*!< SPI RX overflow error */
N	SPIM_EVENT_ERROR,        /*!< SPI Xfer ended with an error! */
N	SPIM_EVENT_DONE,         /*!< SPI Xfer completed without errors */
N}SPIM_EVENT_T;
N
N/**
N * @brief	States of SPI Master Xfer
N */
Ntypedef enum {
N	SPI_XFER_STATE_IDLE,    /*!< Transfer is idle and not started */
N	SPI_XFER_STATE_BUSY,    /*!< Transfer has started and in progress */
N	SPI_XFER_STATE_DONE,    /*!< Transfer is complete without errors */
N	SPI_XFER_STATE_STALL,   /*!< SPI Bus stalled */
N	SPI_XFER_STATE_ERROR,   /*!< SPI transfer terminated with errors */
N} SPIM_XFER_STATE_T;
N
N#define SPIM_XFER_OPT_FRAME_DLY			(1 << 0)		/* frame delay between frames */
N#define SPIM_XFER_OPT_FRAME_ASSERT		(1 << 1)		/* assert/de-assert ssel for each frame */
N#define SPIM_XFER_OPT_DMA				(1 << 2)		/* use DMA */
N
N/**
N * @brief SPI Master transfer data context
N *
N * @note When structure member @a  dataWidth > 8; @a txData and @a rxData must be of type (uint16_t *)
N * otherwise it should be of type (uint8_t *)<br> Member @a options must be OR'd values from SPI_XFER_OPT_* (see #SPI_XFER_OPT_EOF)
N *
N */
Ntypedef struct SPIM_XFER {
N	/* User initialized members */
N	int (*eventCB) (LPC_SPI_T *pSPI, SPIM_EVENT_T evt, struct SPIM_XFER *xfer); /** Pointer to SPI master transfer event callback functions */
N	void *txData;              /*!< Pointer to buffer having transmit data */
N	void *rxData;              /*!< Pointer to buffer where received data be stored */
N	uint16_t txCount;          /*!< Number of data to be transmitted [Not in bytes] */
N	uint16_t rxCount;          /*!< Number of data to be received [Not in bytes] */
N	uint16_t dataWidth;        /*!< Width of the data [Valid values: 1 to 16] */
N	uint16_t sselNum;          /*!< Slave select number to be asserted when transfering data [Valid values: 0 to 3] */
N	uint32_t option;           /*!< Dummy data to be transfered when rxCount > txCount ORed with #SPI_XFER_OPT_EOF (if this functionality is required) */
N	void *usrData;             /*!< User data associated with this Xfer structure */
N	/* Internal members */
N	uint16_t txIndex;          /*!< Index of the next item to be transfered [If this is same as txCount then tx is complete] */
N	uint16_t rxIndex;          /*!< Index of memory to which next received data be stored */
N	SPIM_XFER_STATE_T state;   /*!< State of the transfer */
N} SPIM_XFER_T;
N
N/**
N * @brief	SPI master transfer state change handler
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	xfer	: Pointer to a SPIM_XFER_T structure see notes below
N * @return	Nothing
N * @note	See @ref SPIM_XFER_T for more information on this function. When using
N * this function, the SPI master interrupts should be enabled and setup in the SPI
N * interrupt handler to call this function when they fire. This function is meant
N * to be called from the interrupt handler.
N */
Nvoid Chip_SPIM_XferHandler(LPC_SPI_T *pSPI, SPIM_XFER_T *xfer);
N
N/**
N * @brief	Start non-blocking SPI master transfer
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	xfer	: Pointer to a SPIM_XFER_T structure see notes below
N * @return	Nothing
N * @note	This function starts a non-blocking SPI master transfer with the
N * parameters setup in the passed @ref SPIM_XFER_T structure. Once the transfer is
N * started, the interrupt handler must call Chip_SPIM_XferHandler to keep the
N * transfer going and fed with data. This function should only be called when
N * the master is idle.<br>
N *
N * This function must be called with the options and sselNum fields correctly
N * setup. Initial data buffers and the callback pointer must also be setup. No
N * sanity checks are performed on the passed data.<br>
N *
N * Example call:<br>
N * SPIM_XFER_T mxfer;
N * mxfer.pCB = (&)masterCallbacks;
N * mxfer.sselNum = 2; // Use chip select 2
N * mxfer.options = SPI_TXDAT_FLEN(8); // 8 data bits, supports 1 - 16 bits
N * mxfer.options |= SPI_TXDAT_EOT | SPI_TXDAT_EOF; // Apply frame and transfer delays to master transfer
N * mxfer.options |= SPI_TXDAT_RXIGNORE; // Ignore RX data, will toss receive data regardless of pRXData8 or pRXData16 buffer
N * mxfer.pTXData8 = SendBuffer;
N * mxfer.txCount = 16; // Number of bytes to send before SPIMasterXferSend callback is called
N * mxfer.pRXData8 = RecvBuffer; // Will not receive data if pRXData8/pRXData16 is NULL or SPI_TXDAT_RXIGNORE option is set
N * mxfer.rxCount = 16; // Number of bytes to receive before SPIMasterXferRecv callback is called
N * Chip_SPIM_Xfer(LPC_SPI0, &mxfer); // Start transfer
N *
N * Note that the transfer, once started, needs to be constantly fed by the callbacks.
N * The txCount and rxCount field only indicate the buffer size before the callbacks are called.
N * To terminate the transfer, the SPIMasterXferSend callback must set the terminate field.
N */
Nvoid Chip_SPIM_Xfer(LPC_SPI_T *pSPI, SPIM_XFER_T *xfer);
N
N/**
N * @brief	Start polled SPI master transfer
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	xfer	: Pointer to a SPIM_XFER_T structure see notes below
N * @return	Nothing
N * @note	This function starts a polled SPI master transfer with the
N * parameters setup in the passed @ref SPIM_XFER_T structure. This function should
N * only be called when the master is idle.<br>
N *
N * This function forces the xfer counts to be smaller than the FIFO size.
N * For small transfers, this is very efficient as there are no interrupts or DMA.
N *
N * This function must be called with the options and sselNum fields set correctly
N * Initial data buffers. The xfer transmit buffer is limited to the size of the FIFO.
N *
N */
Nvoid Chip_SPIM_XferFIFO(LPC_SPI_T *pSPI, SPIM_XFER_T *xfer);
N
N/**
N * @brief	Perform blocking SPI master transfer
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	xfer	: Pointer to a SPIM_XFER_T structure see notes below
N * @return	Nothing
N * @note	This function starts a blocking SPI master transfer with the
N * parameters setup in the passed @ref SPIM_XFER_T structure. Once the transfer is
N * started, the callbacks in Chip_SPIM_XferHandler may be called to keep the
N * transfer going and fed with data. SPI interrupts must be disabled prior to
N * calling this function. It is not recommended to use this function.<br>
N */
Nvoid Chip_SPIM_XferBlocking(LPC_SPI_T *pSPI, SPIM_XFER_T *xfer);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __SPIM_5411X_H_ */
L 207 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "spis_5411x.h"
L 1 "..\..\..\chip_5411x\inc\spis_5411x.h" 1
N/*
N * @brief LPC5411X SPI slave driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2015
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __SPIS_5411X_H_
N#define __SPIS_5411X_H_
N
N#include "spi_common_5411x.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup SPI_SLAVE_5411X CHIP: LPC5411X SPI slave driver
N * @ingroup SPI_COMMON_5411X
N * @{
N */
N
N/** @brief	Slave callback events */
Ntypedef enum
N{
N	SPIS_EVENT_SASSERT,      /*!< Slave select line asserted */
N	SPIS_EVENT_SDEASSERT,    /*!< Slave select line de-asserted */
N	SPIS_EVENT_DONE,         /*!< Slave done with this transfer [More data can be provided] */
N	SPIS_EVENT_ERRORTX,      /*!< TX Underflow error */
N	SPIS_EVENT_ERRORRX,      /*!< RX Overflow error */
N	SPIS_EVENT_THRESHOLD,    /*!< Slave transfer has reached its threshold */
N} SPIS_EVENT_T;
N
N/** Slave transfer data context */
Ntypedef struct SPIS_XFER {
N	int    (*eventCB) (LPC_SPI_T *pSPI, SPIS_EVENT_T evt, struct SPIS_XFER *xfer); /*!< Pointer to SPI slave callback functions */
N	void    *txData;                /*!< TX Data pointer */
N	void    *rxData;                /*!< RX Data pointer */
N	uint16_t rxCount;               /*!< Size of the pRXData buffer in items (not bytes), modified by driver */
N	uint16_t txCount;               /*!< Number of items (not bytes) to send in pTXData buffer, modified by driver */
N	uint16_t txIndex;               /*!< Total items (not bytes) received, modified by driver */
N	uint16_t rxIndex;               /*!< Total items (not bytes) transmitted, modified by driver */
N	uint16_t thresCount;            /*!< Number of data to receive to trigger #SPIS_EVENT_THRESHOLD event */
N	uint16_t dataWidth;             /*!< Width of the data [Valid values: 1 to 16] */
N	uint8_t	 sselNum;               /*!< Slave number assigned to this transfer, 0 - 3, modified by driver */
N	uint32_t ss_count;				/*!< Count of ssel events from the data, modified by driver */
N	bool     ss_state;				/*!< State of slave-select true = asserted, false = de-asserted */
X	_Bool     ss_state;				 
N} SPIS_XFER_T;
N
N/**
N * @brief	SPI slave initialization
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	Nothing
N * @note Initializes a slave SPI port.
N */
Nvoid Chip_SPIS_Init(LPC_SPI_T *pSPI);
N
N/**
N * @brief	SPI slave interrupt enable
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	Nothing
N * @note Clears / enables the following SPI interrupts: SPI_INT_SSAEN, SPI_INT_SSDEN.
N * Clears / enables the following FIFO interrupts: SPI_FIFOINT_RXERR, SPI_FIFOINT_TXERR, SPI_FIFOINT_RXLVL, and SPI_FIFOINT_TXLVL.
N */
Nvoid Chip_SPIS_EnableInts(LPC_SPI_T *pSPI);
N
N/**
N * @brief	SPI slave interrupt disable
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @return	Nothing
N * @note Clears / disables the following SPI interrupts: SPI_INT_SSAEN, SPI_INT_SSDEN.
N * Clears / disables the following FIFO interrupts: SPI_FIFOINT_RXERR, SPI_FIFOINT_TXERR, SPI_FIFOINT_RXLVL, and SPI_FIFOINT_TXLVL.
N */
Nvoid Chip_SPIS_DisableInts(LPC_SPI_T *pSPI);
N
N/**
N * @brief	Load slave transmit FIFO
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	xfer	: Pointer to a SPIS_XFER_T structure see notes below
N * @return	Nothing
N * @note Prime the transmit FIFO with data prior to the master xfer start.
N * If data is not pre-buffered, the initial slave transmit data will always
N * be 0x0 with a slave transmit underflow status.
N */
Nvoid Chip_SPIS_LoadFIFO(LPC_SPI_T *pSPI, SPIS_XFER_T *xfer);
N
N/**
N * @brief	SPI slave FIFO read
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	xfer	: Pointer to a SPIS_XFER_T structure
N * @return	Nothing
N * @note	This function reads all RX FIFO data into the xfer RX buffer.
N * Interrupts are not required and should be disabled prior to calling this function.
N */
Nvoid Chip_SPIS_ReadFIFO(LPC_SPI_T *pSPI, SPIS_XFER_T *xfer);
N
N/**
N * @brief	SPI slave transfer state change handler
N * @param	pSPI	: The base of SPI peripheral on the chip
N * @param	xfer	: Pointer to a SPIS_XFER_T structure see notes below
N * @return	Nothing
N * @note	See @ref SPIS_XFER_T for more information on this function. When using
N * this function, the SPI slave interrupts should be enabled and setup in the SPI
N * interrupt handler to call this function when they fire. This function is meant
N * to be called from the interrupt handler. The @ref SPIS_XFER_T data does not need
N * to be setup prior to the call and should be setup by the callbacks instead.<br>
N *
N * The callbacks are handled in the interrupt handler. If you are getting overflow
N * or underflow errors, you might need to lower the speed of the master clock or
N * extend the master's select assetion time.<br>
N */
Nvoid Chip_SPIS_XferHandler(LPC_SPI_T *pSPI, SPIS_XFER_T *xfer);
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __SPIS_5411X_H_ */
L 208 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "i2c_common_5411x.h"
L 1 "..\..\..\chip_5411x\inc\i2c_common_5411x.h" 1
N/*
N * @brief LPC5411x I2C driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __I2C_COMMON_5411X_H_
N#define __I2C_COMMON_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup I2C_5411X CHIP: LPC5411x I2C driver
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/**
N * @brief I2C register block structure
N * @cond
N */
Ntypedef struct {					/* I2C0 Structure         */
N	__IO uint32_t RESERVED0A[512];
X	volatile uint32_t RESERVED0A[512];
N	__IO uint32_t CFG;				/*!< @endcond I2C Configuration Register common for Master, Slave and Monitor */
X	volatile uint32_t CFG;				 
N	__IO uint32_t STAT;				/*!< I2C Status Register common for Master, Slave and Monitor */
X	volatile uint32_t STAT;				 
N	__IO uint32_t INTENSET;			/*!< I2C Interrupt Enable Set Register common for Master, Slave and Monitor */
X	volatile uint32_t INTENSET;			 
N	__O  uint32_t INTENCLR;			/*!< I2C Interrupt Enable Clear Register common for Master, Slave and Monitor */
X	volatile  uint32_t INTENCLR;			 
N	__IO uint32_t TIMEOUT;			/*!< I2C Timeout value Register */
X	volatile uint32_t TIMEOUT;			 
N	__IO uint32_t CLKDIV;			/*!< I2C Clock Divider Register */
X	volatile uint32_t CLKDIV;			 
N	__IO uint32_t INTSTAT;			/*!< I2C Interrupt Status Register */
X	volatile uint32_t INTSTAT;			 
N	__I  uint32_t RESERVED0;
X	volatile const  uint32_t RESERVED0;
N	__IO uint32_t MSTCTL;			/*!< I2C Master Control Register */
X	volatile uint32_t MSTCTL;			 
N	__IO uint32_t MSTTIME;			/*!< I2C Master Time Register for SCL */
X	volatile uint32_t MSTTIME;			 
N	__IO uint32_t MSTDAT;			/*!< I2C Master Data Register */
X	volatile uint32_t MSTDAT;			 
N	__IO uint32_t RESERVED1[5];
X	volatile uint32_t RESERVED1[5];
N	__IO uint32_t SLVCTL;			/*!< I2C Slave Control Register */
X	volatile uint32_t SLVCTL;			 
N	__IO uint32_t SLVDAT;			/*!< I2C Slave Data Register */
X	volatile uint32_t SLVDAT;			 
N	__IO uint32_t SLVADR[4];		/*!< I2C Slave Address Registers */
X	volatile uint32_t SLVADR[4];		 
N	__IO uint32_t SLVQUAL0;			/*!< I2C Slave Address Qualifier 0 Register */
X	volatile uint32_t SLVQUAL0;			 
N	__IO uint32_t RESERVED2[9];
X	volatile uint32_t RESERVED2[9];
N	__I  uint32_t MONRXDAT;			/*!< I2C Monitor Data Register @cond */
X	volatile const  uint32_t MONRXDAT;			 
N	__I  uint32_t RESERVED3[477];
X	volatile const  uint32_t RESERVED3[477];
N
N	/** FLEXCOMM Interface registers @endcond */
N	__IO uint32_t PSELID;          /*!< Offset: 0xFF8 Peripheral select/identification register */
X	volatile uint32_t PSELID;           
N	__I  uint32_t PID;             /*!< Offset: 0xFFC Module identification register */ 
X	volatile const  uint32_t PID;               
N} LPC_I2C_T;
N
N/*
N * @brief I2C Configuration register Bit definition
N */
N#define I2C_CFG_MSTEN             (1 << 0)			/*!< Master Enable/Disable Bit */
N#define I2C_CFG_SLVEN             (1 << 1)			/*!< Slave Enable/Disable Bit */
N#define I2C_CFG_MONEN             (1 << 2)			/*!< Monitor Enable/Disable Bit */
N#define I2C_CFG_TIMEOUTEN         (1 << 3)			/*!< Timeout Enable/Disable Bit */
N#define I2C_CFG_MONCLKSTR         (1 << 4)			/*!< Monitor Clock Stretching Bit */
N#define I2C_CFG_MASK              ((uint32_t) 0x1F)	/*!< Configuration Register Mask */
N
N/*
N * @brief I2C Status register Bit definition
N */
N#define I2C_STAT_MSTPENDING       (1 << 0)		/*!< Master Pending Status Bit */
N#define I2C_STAT_MSTSTATE         (0x7 << 1)	/*!< Master State Code */
N#define I2C_STAT_MSTRARBLOSS      (1 << 4)		/*!< Master Arbitration Loss Bit */
N#define I2C_STAT_MSTSTSTPERR      (1 << 6)		/*!< Master Start Stop Error Bit */
N#define I2C_STAT_SLVPENDING       (1 << 8)		/*!< Slave Pending Status Bit */
N#define I2C_STAT_SLVSTATE         (0x3 << 9)	/*!< Slave State Code */
N#define I2C_STAT_SLVNOTSTR        (1 << 11)		/*!< Slave not stretching Clock Bit */
N#define I2C_STAT_SLVIDX           (0x3 << 12)	/*!< Slave Address Index */
N#define I2C_STAT_SLVSEL           (1 << 14)		/*!< Slave Selected Bit */
N#define I2C_STAT_SLVDESEL         (1 << 15)		/*!< Slave Deselect Bit */
N#define I2C_STAT_MONRDY           (1 << 16)		/*!< Monitor Ready Bit */
N#define I2C_STAT_MONOV            (1 << 17)		/*!< Monitor Overflow Flag */
N#define I2C_STAT_MONACTIVE        (1 << 18)		/*!< Monitor Active Flag */
N#define I2C_STAT_MONIDLE          (1 << 19)		/*!< Monitor Idle Flag */
N#define I2C_STAT_EVENTTIMEOUT     (1 << 24)		/*!< Event Timeout Interrupt Flag */
N#define I2C_STAT_SCLTIMEOUT       (1 << 25)		/*!< SCL Timeout Interrupt Flag */
N
N#define I2C_STAT_MSTCODE_IDLE       (0)			/*!< Master Idle State Code */
N#define I2C_STAT_MSTCODE_RXREADY    (1)			/*!< Master Receive Ready State Code */
N#define I2C_STAT_MSTCODE_TXREADY    (2)			/*!< Master Transmit Ready State Code */
N#define I2C_STAT_MSTCODE_NACKADR    (3)			/*!< Master NACK by slave on address State Code */
N#define I2C_STAT_MSTCODE_NACKDAT    (4)			/*!< Master NACK by slave on data State Code */
N
N#define I2C_STAT_SLVCODE_ADDR         (0)		/*!< Master Idle State Code */
N#define I2C_STAT_SLVCODE_RX           (1)		/*!< Received data is available Code */
N#define I2C_STAT_SLVCODE_TX           (2)		/*!< Data can be transmitted Code */
N
N/*
N * @brief I2C Interrupt Enable Set register Bit definition
N */
N#define I2C_INTENSET_MSTPENDING       (1 << 0)		/*!< Master Pending Interrupt Enable Bit */
N#define I2C_INTENSET_MSTRARBLOSS      (1 << 4)		/*!< Master Arbitration Loss Interrupt Enable Bit */
N#define I2C_INTENSET_MSTSTSTPERR      (1 << 6)		/*!< Master Start Stop Error Interrupt Enable Bit */
N#define I2C_INTENSET_SLVPENDING       (1 << 8)		/*!< Slave Pending Interrupt Enable Bit */
N#define I2C_INTENSET_SLVNOTSTR        (1 << 11)		/*!< Slave not stretching Clock Interrupt Enable Bit */
N#define I2C_INTENSET_SLVDESEL         (1 << 15)		/*!< Slave Deselect Interrupt Enable Bit */
N#define I2C_INTENSET_MONRDY           (1 << 16)		/*!< Monitor Ready Interrupt Enable Bit */
N#define I2C_INTENSET_MONOV            (1 << 17)		/*!< Monitor Overflow Interrupt Enable Bit */
N#define I2C_INTENSET_MONIDLE          (1 << 19)		/*!< Monitor Idle Interrupt Enable Bit */
N#define I2C_INTENSET_EVENTTIMEOUT     (1 << 24)		/*!< Event Timeout Interrupt Enable Bit */
N#define I2C_INTENSET_SCLTIMEOUT       (1 << 25)		/*!< SCL Timeout Interrupt Enable Bit */
N
N/*
N * @brief I2C Interrupt Enable Clear register Bit definition
N */
N#define I2C_INTENCLR_MSTPENDING       (1 << 0)		/*!< Master Pending Interrupt Clear Bit */
N#define I2C_INTENCLR_MSTRARBLOSS      (1 << 4)		/*!< Master Arbitration Loss Interrupt Clear Bit */
N#define I2C_INTENCLR_MSTSTSTPERR      (1 << 6)		/*!< Master Start Stop Error Interrupt Clear Bit */
N#define I2C_INTENCLR_SLVPENDING       (1 << 8)		/*!< Slave Pending Interrupt Clear Bit */
N#define I2C_INTENCLR_SLVNOTSTR        (1 << 11)		/*!< Slave not stretching Clock Interrupt Clear Bit */
N#define I2C_INTENCLR_SLVDESEL         (1 << 15)		/*!< Slave Deselect Interrupt Clear Bit */
N#define I2C_INTENCLR_MONRDY           (1 << 16)		/*!< Monitor Ready Interrupt Clear Bit */
N#define I2C_INTENCLR_MONOV            (1 << 17)		/*!< Monitor Overflow Interrupt Clear Bit */
N#define I2C_INTENCLR_MONIDLE          (1 << 19)		/*!< Monitor Idle Interrupt Clear Bit */
N#define I2C_INTENCLR_EVENTTIMEOUT     (1 << 24)		/*!< Event Timeout Interrupt Clear Bit */
N#define I2C_INTENCLR_SCLTIMEOUT       (1 << 25)		/*!< SCL Timeout Interrupt Clear Bit */
N
N/*
N * @brief I2C TimeOut Value Macro
N */
N#define I2C_TIMEOUT_VAL(n)              (((uint32_t) ((n) - 1) & 0xFFF0) | 0x000F)		/*!< Macro for Timeout value register */
N
N/*
N * @brief I2C Interrupt Status register Bit definition
N */
N#define I2C_INTSTAT_MSTPENDING      (1 << 0)		/*!< Master Pending Interrupt Status Bit */
N#define I2C_INTSTAT_MSTRARBLOSS     (1 << 4)		/*!< Master Arbitration Loss Interrupt Status Bit */
N#define I2C_INTSTAT_MSTSTSTPERR     (1 << 6)		/*!< Master Start Stop Error Interrupt Status Bit */
N#define I2C_INTSTAT_SLVPENDING      (1 << 8)		/*!< Slave Pending Interrupt Status Bit */
N#define I2C_INTSTAT_SLVNOTSTR       (1 << 11)		/*!< Slave not stretching Clock Interrupt Status Bit */
N#define I2C_INTSTAT_SLVDESEL        (1 << 15)		/*!< Slave Deselect Interrupt Status Bit */
N#define I2C_INTSTAT_MONRDY          (1 << 16)		/*!< Monitor Ready Interrupt Status Bit */
N#define I2C_INTSTAT_MONOV           (1 << 17)		/*!< Monitor Overflow Interrupt Status Bit */
N#define I2C_INTSTAT_MONIDLE         (1 << 19)		/*!< Monitor Idle Interrupt Status Bit */
N#define I2C_INTSTAT_EVENTTIMEOUT    (1 << 24)		/*!< Event Timeout Interrupt Status Bit */
N#define I2C_INTSTAT_SCLTIMEOUT      (1 << 25)		/*!< SCL Timeout Interrupt Status Bit */
N
N/*
N * @brief I2C Master Control register Bit definition
N */
N#define I2C_MSTCTL_MSTCONTINUE  (1 << 0)		/*!< Master Continue Bit */
N#define I2C_MSTCTL_MSTSTART     (1 << 1)		/*!< Master Start Control Bit */
N#define I2C_MSTCTL_MSTSTOP      (1 << 2)		/*!< Master Stop Control Bit */
N#define I2C_MSTCTL_MSTDMA       (1 << 3)		/*!< Master DMA Enable Bit */
N
N/*
N * @brief I2C Master Time Register Field definition
N */
N#define I2C_MSTTIME_MSTSCLLOW   (0x07 << 0)		/*!< Master SCL Low Time field */
N#define I2C_MSTTIME_MSTSCLHIGH  (0x07 << 4)		/*!< Master SCL High Time field */
N
N/*
N * @brief I2C Master Data Mask
N */
N#define I2C_MSTDAT_DATAMASK         ((uint32_t) 0x00FF << 0)	/*!< Master data mask */
N
N/*
N * @brief I2C Slave Control register Bit definition
N */
N#define I2C_SLVCTL_SLVCONTINUE    (1 << 0)		/*!< Slave Continue Bit */
N#define I2C_SLVCTL_SLVNACK        (1 << 1)		/*!< Slave NACK Bit */
N#define I2C_SLVCTL_SLVDMA         (1 << 3)		/*!< Slave DMA Enable Bit */
N
N/*
N * @brief I2C Slave Data Mask
N */
N#define I2C_SLVDAT_DATAMASK         ((uint32_t) 0x00FF << 0)	/*!< Slave data mask */
N
N/*
N * @brief I2C Slave Address register Bit definition
N */
N#define I2C_SLVADR_SADISABLE      (1 << 0)		/*!< Slave Address n Disable Bit */
N#define I2C_SLVADR_SLVADR         (0x7F << 1)	/*!< Slave Address field */
N#define I2C_SLVADR_MASK           ((uint32_t) 0x00FF)	/*!< Slave Address Mask */
N
N/*
N * @brief I2C Slave Address Qualifier 0 Register Bit definition
N */
N#define I2C_SLVQUAL_QUALMODE0     (1 << 0)		/*!< Slave Qualifier Mode Enable Bit */
N#define I2C_SLVQUAL_SLVQUAL0      (0x7F << 1)	/*!< Slave Qualifier Address for Address 0 */
N
N/*
N * @brief I2C Monitor Data Register Bit definition
N */
N#define I2C_MONRXDAT_DATA         (0xFF << 0)		/*!< Monitor Function Receive Data Field */
N#define I2C_MONRXDAT_MONSTART     (1 << 8)			/*!< Monitor Received Start Bit */
N#define I2C_MONRXDAT_MONRESTART   (1 << 9)			/*!< Monitor Received Repeated Start Bit */
N#define I2C_MONRXDAT_MONNACK      (1 << 10)			/*!< Monitor Received Nack Bit */
N
N/*
N * @brief I2C Configuration register Bit definition
N */
N#define I2C_CFG_MSTEN             (1 << 0)	/*!< Master Enable/Disable Bit */
N#define I2C_CFG_SLVEN             (1 << 1)	/*!< Slave Enable/Disable Bit */
N#define I2C_CFG_MONEN             (1 << 2)	/*!< Monitor Enable/Disable Bit */
N#define I2C_CFG_TIMEOUTEN         (1 << 3)	/*!< Timeout Enable/Disable Bit */
N#define I2C_CFG_MONCLKSTR         (1 << 4)	/*!< Monitor Clock Stretching Bit */
N#define I2C_CFG_MASK              ((uint32_t) 0x1F)	/*!< Configuration Register Mask */
N
N/*
N * @brief I2C Status register Bit definition
N */
N#define I2C_STAT_MSTPENDING       (1 << 0)		/*!< Master Pending Status Bit */
N#define I2C_STAT_MSTSTATE         (0x7 << 1)	/*!< Master State Code */
N#define I2C_STAT_MSTRARBLOSS      (1 << 4)		/*!< Master Arbitration Loss Bit */
N#define I2C_STAT_MSTSTSTPERR      (1 << 6)		/*!< Master Start Stop Error Bit */
N#define I2C_STAT_SLVPENDING       (1 << 8)		/*!< Slave Pending Status Bit */
N#define I2C_STAT_SLVSTATE         (0x3 << 9)	/*!< Slave State Code */
N#define I2C_STAT_SLVNOTSTR        (1 << 11)		/*!< Slave not stretching Clock Bit */
N#define I2C_STAT_SLVIDX           (0x3 << 12)	/*!< Slave Address Index */
N#define I2C_STAT_SLVSEL           (1 << 14)		/*!< Slave Selected Bit */
N#define I2C_STAT_SLVDESEL         (1 << 15)		/*!< Slave Deselect Bit */
N#define I2C_STAT_MONRDY           (1 << 16)		/*!< Monitor Ready Bit */
N#define I2C_STAT_MONOV            (1 << 17)		/*!< Monitor Overflow Flag */
N#define I2C_STAT_MONACTIVE        (1 << 18)		/*!< Monitor Active Flag */
N#define I2C_STAT_MONIDLE          (1 << 19)		/*!< Monitor Idle Flag */
N#define I2C_STAT_EVENTTIMEOUT     (1 << 24)		/*!< Event Timeout Interrupt Flag */
N#define I2C_STAT_SCLTIMEOUT       (1 << 25)		/*!< SCL Timeout Interrupt Flag */
N
N#define I2C_STAT_MSTCODE_IDLE       (0)			/*!< Master Idle State Code */
N#define I2C_STAT_MSTCODE_RXREADY    (1)			/*!< Master Receive Ready State Code */
N#define I2C_STAT_MSTCODE_TXREADY    (2)			/*!< Master Transmit Ready State Code */
N#define I2C_STAT_MSTCODE_NACKADR    (3)			/*!< Master NACK by slave on address State Code */
N#define I2C_STAT_MSTCODE_NACKDAT    (4)			/*!< Master NACK by slave on data State Code */
N
N#define I2C_STAT_SLVCODE_ADDR         (0)		/*!< Master Idle State Code */
N#define I2C_STAT_SLVCODE_RX           (1)		/*!< Received data is available Code */
N#define I2C_STAT_SLVCODE_TX           (2)		/*!< Data can be transmitted Code */
N
N/*
N * @brief I2C Interrupt Enable Set register Bit definition
N */
N#define I2C_INTENSET_MSTPENDING       (1 << 0)		/*!< Master Pending Interrupt Enable Bit */
N#define I2C_INTENSET_MSTRARBLOSS      (1 << 4)		/*!< Master Arbitration Loss Interrupt Enable Bit */
N#define I2C_INTENSET_MSTSTSTPERR      (1 << 6)		/*!< Master Start Stop Error Interrupt Enable Bit */
N#define I2C_INTENSET_SLVPENDING       (1 << 8)		/*!< Slave Pending Interrupt Enable Bit */
N#define I2C_INTENSET_SLVNOTSTR        (1 << 11)		/*!< Slave not stretching Clock Interrupt Enable Bit */
N#define I2C_INTENSET_SLVDESEL         (1 << 15)		/*!< Slave Deselect Interrupt Enable Bit */
N#define I2C_INTENSET_MONRDY           (1 << 16)		/*!< Monitor Ready Interrupt Enable Bit */
N#define I2C_INTENSET_MONOV            (1 << 17)		/*!< Monitor Overflow Interrupt Enable Bit */
N#define I2C_INTENSET_MONIDLE          (1 << 19)		/*!< Monitor Idle Interrupt Enable Bit */
N#define I2C_INTENSET_EVENTTIMEOUT     (1 << 24)		/*!< Event Timeout Interrupt Enable Bit */
N#define I2C_INTENSET_SCLTIMEOUT       (1 << 25)		/*!< SCL Timeout Interrupt Enable Bit */
N
N/*
N * @brief I2C Interrupt Enable Clear register Bit definition
N */
N#define I2C_INTENCLR_MSTPENDING       (1 << 0)		/*!< Master Pending Interrupt Clear Bit */
N#define I2C_INTENCLR_MSTRARBLOSS      (1 << 4)		/*!< Master Arbitration Loss Interrupt Clear Bit */
N#define I2C_INTENCLR_MSTSTSTPERR      (1 << 6)		/*!< Master Start Stop Error Interrupt Clear Bit */
N#define I2C_INTENCLR_SLVPENDING       (1 << 8)		/*!< Slave Pending Interrupt Clear Bit */
N#define I2C_INTENCLR_SLVNOTSTR        (1 << 11)		/*!< Slave not stretching Clock Interrupt Clear Bit */
N#define I2C_INTENCLR_SLVDESEL         (1 << 15)		/*!< Slave Deselect Interrupt Clear Bit */
N#define I2C_INTENCLR_MONRDY           (1 << 16)		/*!< Monitor Ready Interrupt Clear Bit */
N#define I2C_INTENCLR_MONOV            (1 << 17)		/*!< Monitor Overflow Interrupt Clear Bit */
N#define I2C_INTENCLR_MONIDLE          (1 << 19)		/*!< Monitor Idle Interrupt Clear Bit */
N#define I2C_INTENCLR_EVENTTIMEOUT     (1 << 24)		/*!< Event Timeout Interrupt Clear Bit */
N#define I2C_INTENCLR_SCLTIMEOUT       (1 << 25)		/*!< SCL Timeout Interrupt Clear Bit */
N
N/*
N * @brief I2C TimeOut Value Macro
N */
N#define I2C_TIMEOUT_VAL(n)              (((uint32_t) ((n) - 1) & 0xFFF0) | 0x000F)		/*!< Macro for Timeout value register */
N
N/*
N * @brief I2C Interrupt Status register Bit definition
N */
N#define I2C_INTSTAT_MSTPENDING      (1 << 0)		/*!< Master Pending Interrupt Status Bit */
N#define I2C_INTSTAT_MSTRARBLOSS     (1 << 4)		/*!< Master Arbitration Loss Interrupt Status Bit */
N#define I2C_INTSTAT_MSTSTSTPERR     (1 << 6)		/*!< Master Start Stop Error Interrupt Status Bit */
N#define I2C_INTSTAT_SLVPENDING      (1 << 8)		/*!< Slave Pending Interrupt Status Bit */
N#define I2C_INTSTAT_SLVNOTSTR       (1 << 11)		/*!< Slave not stretching Clock Interrupt Status Bit */
N#define I2C_INTSTAT_SLVDESEL        (1 << 15)		/*!< Slave Deselect Interrupt Status Bit */
N#define I2C_INTSTAT_MONRDY          (1 << 16)		/*!< Monitor Ready Interrupt Status Bit */
N#define I2C_INTSTAT_MONOV           (1 << 17)		/*!< Monitor Overflow Interrupt Status Bit */
N#define I2C_INTSTAT_MONIDLE         (1 << 19)		/*!< Monitor Idle Interrupt Status Bit */
N#define I2C_INTSTAT_EVENTTIMEOUT    (1 << 24)		/*!< Event Timeout Interrupt Status Bit */
N#define I2C_INTSTAT_SCLTIMEOUT      (1 << 25)		/*!< SCL Timeout Interrupt Status Bit */
N
N/*
N * @brief I2C Master Control register Bit definition
N */
N#define I2C_MSTCTL_MSTCONTINUE  (1 << 0)		/*!< Master Continue Bit */
N#define I2C_MSTCTL_MSTSTART     (1 << 1)		/*!< Master Start Control Bit */
N#define I2C_MSTCTL_MSTSTOP      (1 << 2)		/*!< Master Stop Control Bit */
N#define I2C_MSTCTL_MSTDMA       (1 << 3)		/*!< Master DMA Enable Bit */
N
N/*
N * @brief I2C Master Time Register Field definition
N */
N#define I2C_MSTTIME_MSTSCLLOW   (0x07 << 0)		/*!< Master SCL Low Time field */
N#define I2C_MSTTIME_MSTSCLHIGH  (0x07 << 4)		/*!< Master SCL High Time field */
N
N/*
N * @brief I2C Master Data Mask
N */
N#define I2C_MSTDAT_DATAMASK         ((uint32_t) 0x00FF << 0)	/*!< Master data mask */
N
N/*
N * @brief I2C Slave Control register Bit definition
N */
N#define I2C_SLVCTL_SLVCONTINUE    (1 << 0)		/*!< Slave Continue Bit */
N#define I2C_SLVCTL_SLVNACK        (1 << 1)		/*!< Slave NACK Bit */
N#define I2C_SLVCTL_SLVDMA         (1 << 3)		/*!< Slave DMA Enable Bit */
N
N/*
N * @brief I2C Slave Data Mask
N */
N#define I2C_SLVDAT_DATAMASK         ((uint32_t) 0x00FF << 0)	/*!< Slave data mask */
N
N/*
N * @brief I2C Slave Address register Bit definition
N */
N#define I2C_SLVADR_SADISABLE      (1 << 0)		/*!< Slave Address n Disable Bit */
N#define I2C_SLVADR_SLVADR         (0x7F << 1)	/*!< Slave Address field */
N#define I2C_SLVADR_MASK           ((uint32_t) 0x00FF)	/*!< Slave Address Mask */
N
N/*
N * @brief I2C Slave Address Qualifier 0 Register Bit definition
N */
N#define I2C_SLVQUAL_QUALMODE0     (1 << 0)		/*!< Slave Qualifier Mode Enable Bit */
N#define I2C_SLVQUAL_SLVQUAL0      (0x7F << 1)	/*!< Slave Qualifier Address for Address 0 */
N
N/*
N * @brief I2C Monitor Data Register Bit definition
N */
N#define I2C_MONRXDAT_DATA         (0xFF << 0)		/*!< Monitor Function Receive Data Field */
N#define I2C_MONRXDAT_MONSTART     (1 << 8)			/*!< Monitor Received Start Bit */
N#define I2C_MONRXDAT_MONRESTART   (1 << 9)			/*!< Monitor Received Repeated Start Bit */
N#define I2C_MONRXDAT_MONNACK      (1 << 10)			/*!< Monitor Received Nack Bit */
N
N/**
N * @brief	Initialize I2C Interface
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	0 - on success; #ERR_FLEXCOMM_FUNCNOTSUPPORTED or #ERR_FLEXCOMM_NOTFREE on failure
N * @note	This function enables the I2C clock for both the master and
N * slave interfaces if the I2C channel.
N
N */
N__STATIC_INLINE int Chip_I2C_Init(LPC_I2C_T *pI2C)
Xstatic __inline int Chip_I2C_Init(LPC_I2C_T *pI2C)
N{
N	return Chip_FLEXCOMM_Init(pI2C, FLEXCOMM_PERIPH_I2C);
N}
N
N/**
N * @brief	Shutdown I2C Interface
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N * @note	This function disables the I2C clock for both the master and
N * slave interfaces if the I2C channel.
N */
N__STATIC_INLINE void Chip_I2C_DeInit(LPC_I2C_T *pI2C)
Xstatic __inline void Chip_I2C_DeInit(LPC_I2C_T *pI2C)
N{
N	Chip_FLEXCOMM_DeInit(pI2C);
N}
N
N/**
N * @brief	Sets I2C Clock Divider registers
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	clkdiv	: Clock Divider value for I2C, value is between (1 - 65536)
N * @return	Nothing
N * @note	The clock to I2C block is determined by the following formula (I2C_PCLK
N *          is the frequency of the system clock): <br>
N *              I2C Clock Frequency = (I2C_PCLK)/clkdiv;<br>
N * This divider must be setup for both the master and slave modes of the
N * controller.
N */
N__STATIC_INLINE void Chip_I2C_SetClockDiv(LPC_I2C_T *pI2C, uint32_t clkdiv)
Xstatic __inline void Chip_I2C_SetClockDiv(LPC_I2C_T *pI2C, uint32_t clkdiv)
N{
N	if ((clkdiv >= 1) && (clkdiv <= 65536)) {
N		pI2C->CLKDIV = clkdiv - 1;
N	}
N	else {
N		pI2C->CLKDIV = 0;
N	}
N}
N
N/**
N * @brief	Get I2C Clock Divider registers
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Clock Divider value
N * @note	Return the divider value for the I2C block
N *          It is the CLKDIV register value + 1
N */
Nstatic INLINE uint32_t Chip_I2C_GetClockDiv(LPC_I2C_T *pI2C)
Xstatic __inline uint32_t Chip_I2C_GetClockDiv(LPC_I2C_T *pI2C)
N{
N	return (pI2C->CLKDIV & 0xFFFF) + 1;
N}
N
N/**
N * @brief	Enable I2C Interrupts
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	intEn	: ORed Value of I2C_INTENSET_* values to enable
N * @return	Nothing
N */
Nstatic INLINE void Chip_I2C_EnableInt(LPC_I2C_T *pI2C, uint32_t intEn)
Xstatic __inline void Chip_I2C_EnableInt(LPC_I2C_T *pI2C, uint32_t intEn)
N{
N	pI2C->INTENSET = intEn;
N}
N
N/**
N * @brief	Disable I2C Interrupts
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	intClr	: ORed Value of I2C_INTENSET_* values to disable
N * @return	Nothing
N */
Nstatic INLINE void Chip_I2C_DisableInt(LPC_I2C_T *pI2C, uint32_t intClr)
Xstatic __inline void Chip_I2C_DisableInt(LPC_I2C_T *pI2C, uint32_t intClr)
N{
N	pI2C->INTENCLR = intClr;
N}
N
N/**
N * @brief	Disable I2C Interrupts
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	intClr	: ORed Value of I2C_INTENSET_* values to disable
N * @return	Nothing
N * @note	It is recommended to use the Chip_I2C_DisableInt() function
N * instead of this function.
N */
Nstatic INLINE void Chip_I2C_ClearInt(LPC_I2C_T *pI2C, uint32_t intClr)
Xstatic __inline void Chip_I2C_ClearInt(LPC_I2C_T *pI2C, uint32_t intClr)
N{
N	Chip_I2C_DisableInt(pI2C, intClr);
N}
N
N/**
N * @brief	Returns pending I2C Interrupts
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	All pending interrupts, mask with I2C_INTENSET_* to determine specific interrupts
N */
Nstatic INLINE uint32_t Chip_I2C_GetPendingInt(LPC_I2C_T *pI2C)
Xstatic __inline uint32_t Chip_I2C_GetPendingInt(LPC_I2C_T *pI2C)
N{
N	return pI2C->INTSTAT;
N}
N
N#ifndef __DOXYGEN__
N
N/* I2C0 Defines */
N#define LPC_I2C0_BASE        __APPEND3(LPC_FLEXCOMM,I2C0_FLEXCOMM,_BASE)
N#define LPC_I2C0             ((LPC_I2C_T *) LPC_I2C0_BASE)
N#define I2C0_IRQHandler      __APPEND3(FLEXCOMM,I2C0_FLEXCOMM,_IRQHandler)
N#define I2C0_IRQn            __APPEND3(FLEXCOMM,I2C0_FLEXCOMM,_IRQn)
N#define DMAREQ_I2C0_SLAVE    __APPEND3(DMAREQ_FLEXCOMM,I2C0_FLEXCOMM,_RX)
N#define DMAREQ_I2C0_MASTER   __APPEND3(DMAREQ_FLEXCOMM,I2C0_FLEXCOMM,_TX)
N
N/* I2C1 Defines */
N#define LPC_I2C1_BASE        __APPEND3(LPC_FLEXCOMM,I2C1_FLEXCOMM,_BASE)
N#define LPC_I2C1             ((LPC_I2C_T *) LPC_I2C1_BASE)
N#define I2C1_IRQHandler      __APPEND3(FLEXCOMM,I2C1_FLEXCOMM,_IRQHandler)
N#define I2C1_IRQn            __APPEND3(FLEXCOMM,I2C1_FLEXCOMM,_IRQn)
N#define DMAREQ_I2C1_SLAVE    __APPEND3(DMAREQ_FLEXCOMM,I2C1_FLEXCOMM,_RX)
N#define DMAREQ_I2C1_MASTER   __APPEND3(DMAREQ_FLEXCOMM,I2C1_FLEXCOMM,_TX)
N
N/* I2C2 Defines */
N#define LPC_I2C2_BASE        __APPEND3(LPC_FLEXCOMM,I2C2_FLEXCOMM,_BASE)
N#define LPC_I2C2             ((LPC_I2C_T *) LPC_I2C2_BASE)
N#define I2C2_IRQHandler      __APPEND3(FLEXCOMM,I2C2_FLEXCOMM,_IRQHandler)
N#define I2C2_IRQn            __APPEND3(FLEXCOMM,I2C2_FLEXCOMM,_IRQn)
N#define DMAREQ_I2C2_SLAVE    __APPEND3(DMAREQ_FLEXCOMM,I2C2_FLEXCOMM,_RX)
N#define DMAREQ_I2C2_MASTER   __APPEND3(DMAREQ_FLEXCOMM,I2C2_FLEXCOMM,_TX)
N
N/* I2C3 Defines */
N#define LPC_I2C3_BASE        __APPEND3(LPC_FLEXCOMM,I2C3_FLEXCOMM,_BASE)
N#define LPC_I2C3             ((LPC_I2C_T *) LPC_I2C3_BASE)
N#define I2C3_IRQHandler      __APPEND3(FLEXCOMM,I2C3_FLEXCOMM,_IRQHandler)
N#define I2C3_IRQn            __APPEND3(FLEXCOMM,I2C3_FLEXCOMM,_IRQn)
N#define DMAREQ_I2C3_SLAVE    __APPEND3(DMAREQ_FLEXCOMM,I2C3_FLEXCOMM,_RX)
N#define DMAREQ_I2C3_MASTER   __APPEND3(DMAREQ_FLEXCOMM,I2C3_FLEXCOMM,_TX)
N
N/* I2C4 Defines */
N#define LPC_I2C4_BASE        __APPEND3(LPC_FLEXCOMM,I2C4_FLEXCOMM,_BASE)
N#define LPC_I2C4             ((LPC_I2C_T *) LPC_I2C4_BASE)
N#define I2C4_IRQHandler      __APPEND3(FLEXCOMM,I2C4_FLEXCOMM,_IRQHandler)
N#define I2C4_IRQn            __APPEND3(FLEXCOMM,I2C4_FLEXCOMM,_IRQn)
N#define DMAREQ_I2C4_SLAVE    __APPEND3(DMAREQ_FLEXCOMM,I2C4_FLEXCOMM,_RX)
N#define DMAREQ_I2C4_MASTER   __APPEND3(DMAREQ_FLEXCOMM,I2C4_FLEXCOMM,_TX)
N
N/* I2C5 Defines */
N#define LPC_I2C5_BASE        __APPEND3(LPC_FLEXCOMM,I2C5_FLEXCOMM,_BASE)
N#define LPC_I2C5             ((LPC_I2C_T *) LPC_I2C5_BASE)
N#define I2C5_IRQHandler      __APPEND3(FLEXCOMM,I2C5_FLEXCOMM,_IRQHandler)
N#define I2C5_IRQn            __APPEND3(FLEXCOMM,I2C5_FLEXCOMM,_IRQn)
N#define DMAREQ_I2C5_SLAVE    __APPEND3(DMAREQ_FLEXCOMM,I2C5_FLEXCOMM,_RX)
N#define DMAREQ_I2C5_MASTER   __APPEND3(DMAREQ_FLEXCOMM,I2C5_FLEXCOMM,_TX)
N
N/* I2C6 Defines */
N#define LPC_I2C6_BASE        __APPEND3(LPC_FLEXCOMM,I2C6_FLEXCOMM,_BASE)
N#define LPC_I2C6             ((LPC_I2C_T *) LPC_I2C6_BASE)
N#define I2C6_IRQHandler      __APPEND3(FLEXCOMM,I2C6_FLEXCOMM,_IRQHandler)
N#define I2C6_IRQn            __APPEND3(FLEXCOMM,I2C6_FLEXCOMM,_IRQn)
N#define DMAREQ_I2C6_SLAVE    __APPEND3(DMAREQ_FLEXCOMM,I2C6_FLEXCOMM,_RX)
N#define DMAREQ_I2C6_MASTER   __APPEND3(DMAREQ_FLEXCOMM,I2C6_FLEXCOMM,_TX)
N
N/* I2C7 Defines */
N#define LPC_I2C7_BASE        __APPEND3(LPC_FLEXCOMM,I2C7_FLEXCOMM,_BASE)
N#define LPC_I2C7             ((LPC_I2C_T *) LPC_I2C7_BASE)
N#define I2C7_IRQHandler      __APPEND3(FLEXCOMM,I2C7_FLEXCOMM,_IRQHandler)
N#define I2C7_IRQn            __APPEND3(FLEXCOMM,I2C7_FLEXCOMM,_IRQn)
N#define DMAREQ_I2C7_SLAVE    __APPEND3(DMAREQ_FLEXCOMM,I2C7_FLEXCOMM,_RX)
N#define DMAREQ_I2C7_MASTER   __APPEND3(DMAREQ_FLEXCOMM,I2C7_FLEXCOMM,_TX)
N
N#endif
N
N/**
N * @}
N */
N
N #ifdef __cplusplus
S}
N#endif
N
N#endif /* __I2C_COMMON_5411X_H_ */
L 209 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "i2cm_5411x.h"
L 1 "..\..\..\chip_5411x\inc\i2cm_5411x.h" 1
N/*
N * @brief LPC5411x I2C driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __I2CM_5411X_H_
N#define __I2CM_5411X_H_
N
N#include "chip.h"
L 1 "..\..\..\chip_5411x\inc\chip.h" 1
N/*
N * @brief LPC5411x basic chip inclusion file
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __CHIP_H_
S#define __CHIP_H_
S
S#include "lpc_types.h"
S#include "cmsis.h"
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S#ifndef CORE_M4
S#ifndef CORE_M0PLUS
S#error "CORE_M4 or CORE_M0PLUS is not defined for the LPC5411x architecture"
S#error "CORE_M4 or CORE_M0PLUS should be defined as part of your compiler define list"
S#endif
S#endif
S
S/* LPCXpresso macro LPCOpen macro defines */
S#ifdef __LPC5411X__
S#define CHIP_LPC5411X
S#endif
S
S#ifndef CHIP_LPC5411X
S#error "The LPC5411X Chip include path is used for this build, but"
S#error "CHIP_LPC5411X is not defined!"
S#endif
S
S#ifndef __DOXYGEN__
S/* Macros to append params */
S#define __APPEND30(x,y,z) x##y##z
S#define __APPEND3(x,y,z) __APPEND30(x,y,z)
S#endif
S
S/** @defgroup PERIPH_5411X_BASE CHIP: LPC5411X Peripheral addresses and register set declarations
S * @ingroup CHIP_5411X_DRIVERS
S * @{
S */
S
S/* Main memory addresses */
S#define LPC_FLASHMEM_BASE          0x00000000UL
S#define LPC_SRAMX_BASE             0x04000000UL
S#define LPC_SRAM0_BASE             0x20000000UL
S#define LPC_SRAM1_BASE             0x20010000UL
S#define LPC_SRAM2_BASE             0x20018000UL
S#define LPC_ROM_BASE               0x03000000UL
S
S/* APB0 peripheral group addresses */
S#define LPC_SYSCON_BASE            0x40000000UL
S#define LPC_IOCON_BASE             0x40001000UL
S#define LPC_GPIO_GROUPINT0_BASE    0x40002000UL
S#define LPC_GPIO_GROUPINT1_BASE    0x40003000UL
S#define LPC_PIN_INT_BASE           0x40004000UL
S#define LPC_INMUX_BASE             0x40005000UL
S#define LPC_TIMER0_BASE            0x40008000UL
S#define LPC_TIMER1_BASE            0x40009000UL
S#define LPC_WWDT_BASE              0x4000C000UL
S#define LPC_MRT_BASE               0x4000D000UL
S#define LPC_UTICK_BASE             0x4000E000UL
S
S/* APB1 peripheral group address */
S#define LPC_PMU_BASE               0x40020000UL
S#define LPC_TIMER2_BASE            0x40028000UL
S#define LPC_RTC_BASE               0x4002C000UL
S#define LPC_FMC_BASE               0x40034000UL
S
S/* Asynchronous APB peripheral group addresses */
S#define LPC_ASYNC_SYSCON_BASE      0x40040000UL
S#define LPC_TIMER3_BASE            0x40048000UL
S#define LPC_TIMER4_BASE            0x40049000UL
S
S/* AHB Peripherals base address */
S#define LPC_SPIFI_BASE             0x40080000UL
S#define LPC_DMA_BASE               0x40082000UL
S#define LPC_USB_BASE               0x40084000UL
S#define LPC_SCT_BASE               0x40085000UL
S#define LPC_FLEXCOMM0_BASE         0x40086000UL
S#define LPC_FLEXCOMM1_BASE         0x40087000UL
S#define LPC_FLEXCOMM2_BASE         0x40088000UL
S#define LPC_FLEXCOMM3_BASE         0x40089000UL
S#define LPC_FLEXCOMM4_BASE         0x4008A000UL
S#define LPC_MBOX_BASE              0x4008B000UL
S#define LPC_GPIO_PORT_BASE         0x4008C000UL
S#define LPC_DMIC_BASE              0x40090000UL
S#define LPC_CRC_BASE               0x40095000UL
S#define LPC_FLEXCOMM5_BASE         0x40096000UL
S#define LPC_FLEXCOMM6_BASE         0x40097000UL
S#define LPC_FLEXCOMM7_BASE         0x40098000UL
S#define LPC_ISPAP_BASE             0x4009C000UL
S#define LPC_ADC_BASE               0x400A0000UL
S
S
S
S/* Main memory register access */
S#define LPC_GPIO           ((LPC_GPIO_T            *) LPC_GPIO_PORT_BASE)
S#define LPC_DMA            ((LPC_DMA_T             *) LPC_DMA_BASE)
S#define LPC_CRC            ((LPC_CRC_T             *) LPC_CRC_BASE)
S#define LPC_SCT            ((LPC_SCT_T             *) LPC_SCT_BASE)
S#define LPC_MBOX           ((LPC_MBOX_T            *) LPC_MBOX_BASE)
S#define LPC_ADC            ((LPC_ADC_T             *) LPC_ADC_BASE)
S#define LPC_PMU            ((LPC_PMU_T             *) LPC_PMU_BASE)
S#define LPC_DMIC           ((LPC_DMIC_T            *) LPC_DMIC_BASE)
S#define LPC_USB            ((LPC_USB_T             *) LPC_USB_BASE)
S
S/* APB0 peripheral group register access */
S#define LPC_SYSCON         ((LPC_SYSCON_T          *) LPC_SYSCON_BASE)
S#define LPC_TIMER2         ((LPC_TIMER_T           *) LPC_TIMER2_BASE)
S#define LPC_TIMER3         ((LPC_TIMER_T           *) LPC_TIMER3_BASE)
S#define LPC_TIMER4         ((LPC_TIMER_T           *) LPC_TIMER4_BASE)
S#define LPC_GINT           ((LPC_GPIOGROUPINT_T    *) LPC_GPIO_GROUPINT0_BASE)
S#define LPC_PININT         ((LPC_PIN_INT_T         *) LPC_PIN_INT_BASE)
S#define LPC_IOCON          ((LPC_IOCON_T           *) LPC_IOCON_BASE)
S#define LPC_UTICK          ((LPC_UTICK_T           *) LPC_UTICK_BASE)
S#define LPC_WWDT           ((LPC_WWDT_T            *) LPC_WWDT_BASE)
S#define LPC_RTC            ((LPC_RTC_T             *) LPC_RTC_BASE)
S
S/* APB1 peripheral group register access */
S#define LPC_ASYNC_SYSCON   ((LPC_ASYNC_SYSCON_T    *) LPC_ASYNC_SYSCON_BASE)
S#define LPC_TIMER0         ((LPC_TIMER_T           *) LPC_TIMER0_BASE)
S#define LPC_TIMER1         ((LPC_TIMER_T           *) LPC_TIMER1_BASE)
S#define LPC_INMUX          ((LPC_INMUX_T           *) LPC_INMUX_BASE)
S#define LPC_MRT            ((LPC_MRT_T             *) LPC_MRT_BASE)
S
S/**
S * @}
S */
S
S/** @ingroup CHIP_5411X_DRIVER_OPTIONS
S * @{
S */
S
S/**
S * @brief	Clock rate on the CLKIN pin
S * This value is defined externally to the chip layer and contains
S * the value in Hz for the CLKIN pin for the board. If this pin isn't used,
S * this rate can be 0.
S */
Sextern const uint32_t ExtClockIn;
S
S/**
S * @}
S */
S
S/* Include order is important! */
S#include "lpc_assert.h"
S#include "romapi_5411x.h"
S#include "syscon_5411x.h"
S#include "cpuctrl_5411x.h"
S#include "clock_5411x.h"
S#include "pmu_5411x.h"
S#include "iocon_5411x.h"
S#include "pinint_5411x.h"
S#include "inmux_5411x.h"
S#include "crc_5411x.h"
S#include "gpio_5411x.h"
S#include "mrt_5411x.h"
S#include "wwdt_5411x.h"
S#include "sct_5411x.h"
S#include "sct_pwm_5411x.h"
S#include "rtc_5411x.h"
S#include "timer_5411x.h"
S#include "utick_5411x.h"
S#include "gpiogroup_5411x.h"
S#include "mailbox_5411x.h"
S#include "fpu_init.h"
S#include "power_lib_5411x.h"
S#include "flexcomm_5411x.h"
S#include "usbd_5411x.h"
S
S#include "adc_5411x.h"
S#include "dma_5411x.h"
S#include "dma_service_5411x.h"
S#include "dmic_5411x.h"
S#include "uart_5411x.h"
S#include "spi_common_5411x.h"
S#include "spim_5411x.h"
S#include "spis_5411x.h"
S#include "i2c_common_5411x.h"
S#include "i2cm_5411x.h"
S#include "i2cs_5411x.h"
S#include "i2s_5411x.h"
S
S/** @defgroup SUPPORT_5411X_FUNC CHIP: LPC5411X support functions
S * @ingroup CHIP_5411X_DRIVERS
S * @{
S */
S
S/**
S * @brief	Current system clock rate, mainly used for peripherals in SYSCON
S */
Sextern uint32_t SystemCoreClock;
S
S/**
S * @brief	Update system core and ASYNC syscon clock rate, should be called if the
S *			system has a clock rate change
S * @return	None
S */
Svoid SystemCoreClockUpdate(void);
S
S/**
S * @brief	Set up and initialize hardware prior to call to main()
S * @return	None
S * @note	Chip_SystemInit() is called prior to the application and sets up
S * system clocking prior to the application starting.
S */
Svoid Chip_SystemInit(void);
S
S/**
S * @brief	Clock and PLL initialization based on the internal oscillator
S * @param	iFreq	: Rate (in Hz) to set the main system clock to
S * @return	None
S */
Svoid Chip_SetupIrcClocking(uint32_t iFreq);
S
S/**
S * @brief	Clock and PLL initialization based on the external clock input
S * @param	iFreq	: Rate (in Hz) to set the main system clock to
S * @return	None
S */
Svoid Chip_SetupExtInClocking(uint32_t iFreq);
S
S/**
S * @brief	Initialize the Core clock to given frequency (12, 48 or 96 MHz)
S * @param	iFreq	: Desired frequency (must be one of #SYSCON_FRO12MHZ_FREQ or #SYSCON_FRO48MHZ_FREQ or #SYSCON_FRO96MHZ_FREQ)
S * @return	Nothing
S */
Svoid Chip_SetupFROClocking(uint32_t iFreq);
S
S/**
S * @brief	Initialize the USB bus
S * @return 	Nothing
S * @note	Uses FRO HF to initialize the pin-IO and the clocks.
S */
Svoid Chip_USB_Init(void);
S
S/**
S * @brief	Turn of FRO clock trimming based on USB SOF
S * @param	enable	: 0 - Disable trim based on USB SOF; Non-Zero to enable it
S * @return	Nothing
S */
S__STATIC_INLINE void Chip_USB_TrimOff(int enable)
S{
S	if (enable) {
S		/* Turn ON FRO HF and let it adjust TRIM value based on USB SOF */
S		LPC_SYSCON->FROCTRL = (LPC_SYSCON->FROCTRL & ~SYSCON_FROCTRL_MASK) | SYSCON_FROCTRL_USBCLKADJ;
S	} else {
S		/* Turn ON FRO HF and let it adjust TRIM value based on USB SOF */
S		LPC_SYSCON->FROCTRL = LPC_SYSCON->FROCTRL & ~(SYSCON_FROCTRL_MASK | SYSCON_FROCTRL_USBCLKADJ);
S	}
S}
S
S/**
S * @}
S */
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* __CHIP_H_ */
L 36 "..\..\..\chip_5411x\inc\i2cm_5411x.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup I2CM_5411X CHIP: LPC5411X I2C master-only driver
N * @ingroup I2C_5411X
N * This driver only works in master mode. To describe the I2C transactions
N * following symbols are used in driver documentation.
N *
N * Key to symbols
N * ==============
N * S     (1 bit) : Start bit
N * P     (1 bit) : Stop bit
N * Rd/Wr (1 bit) : Read/Write bit. Rd equals 1, Wr equals 0.
N * A, NA (1 bit) : Acknowledge and Not-Acknowledge bit.
N * Addr  (7 bits): I2C 7 bit address. Note that this can be expanded as usual to
N *                 get a 10 bit I2C address.
N * Data  (8 bits): A plain data byte. Sometimes, I write DataLow, DataHigh
N *                 for 16 bit data.
N * [..]: Data sent by I2C device, as opposed to data sent by the host adapter.
N * @{
N */
N
N/** I2CM_5411X_STATUS_TYPES I2C master transfer status types
N */
N
N#define I2CM_STATUS_OK              0x00		/*!< Requested Request was executed successfully. */
N#define I2CM_STATUS_ERROR           0x01		/*!< Unknown error condition. */
N#define I2CM_STATUS_NAK_ADR         0x02		/*!< No acknowledgement received from slave during address phase. */
N#define I2CM_STATUS_BUS_ERROR       0x03		/*!< I2C bus error */
N#define I2CM_STATUS_NAK_DAT           0x04		/*!< No acknowledgement received from slave during data phase. */
N#define I2CM_STATUS_ARBLOST         0x05		/*!< Arbitration lost. */
N#define I2CM_STATUS_BUSY            0xFF		/*!< I2C transmistter is busy. */
N
N/**
N * @brief Master transfer data structure definitions
N */
Ntypedef struct {
N	const uint8_t *txBuff;	/*!< Pointer to array of bytes to be transmitted */
N	uint8_t *rxBuff;				/*!< Pointer memory where bytes received from I2C be stored */
N	uint16_t txSz;					/*!< Number of bytes in transmit array,
N									                if 0 only receive transfer will be carried on */
N	uint16_t rxSz;					/*!< Number of bytes to received,
N									                if 0 only transmission we be carried on */
N	uint16_t status;				/*!< Status of the current I2C transfer */
N	uint8_t slaveAddr;			/*!< 7-bit I2C Slave address */
N} I2CM_XFER_T;
N
N/**
N * @brief	Sets HIGH and LOW duty cycle registers
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	sclH	: Number of I2C_PCLK cycles for the SCL HIGH time value between (2 - 9).
N * @param	sclL	: Number of I2C_PCLK cycles for the SCL LOW time value between (2 - 9).
N * @return	Nothing
N * @note	The I2C clock divider should be set to the appropriate value before calling this function
N *				The I2C baud is determined by the following formula: <br>
N *        I2C_bitFrequency = (I2C_PCLK)/(I2C_CLKDIV * (sclH + sclL)) <br>
N *				where I2C_PCLK is the frequency of the System clock and I2C_CLKDIV is I2C clock divider
N */
Nstatic INLINE void Chip_I2CM_SetDutyCycle(LPC_I2C_T *pI2C, uint16_t sclH, uint16_t sclL)
Xstatic __inline void Chip_I2CM_SetDutyCycle(LPC_I2C_T *pI2C, uint16_t sclH, uint16_t sclL)
N{
N	pI2C->MSTTIME = (((sclH - 2) & 0x07) << 4) | ((sclL - 2) & 0x07);
N}
N
N/**
N * @brief	Set up bus speed for LPC_I2C controller
N * @param	pI2C		: Pointer to selected I2C peripheral
N * @param	busSpeed	: I2C bus clock rate
N * @return	Nothing
N * @note	Per I2C specification the busSpeed should be
N *          @li 100000 for Standard mode
N *          @li 400000 for Fast mode
N *          @li 1000000 for Fast mode plus
N *          IOCON registers corresponding to I2C pads should be updated
N *          according to the bus mode.<br>
N *          This API will also support non-standard bus speeds provided
N *          it is an integer multiple of (18, 16, 14, 12, 10, 8, 6, 4).<br>
N *          This API will automatically calculate and set divider value.
N */
Nvoid Chip_I2CM_SetBusSpeed(LPC_I2C_T *pI2C, uint32_t busSpeed);
N
N/**
N * @brief	Enable I2C Master interface
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N * @note
N */
Nstatic INLINE void Chip_I2CM_Enable(LPC_I2C_T *pI2C)
Xstatic __inline void Chip_I2CM_Enable(LPC_I2C_T *pI2C)
N{
N	pI2C->CFG = (pI2C->CFG & I2C_CFG_MASK) | I2C_CFG_MSTEN;
X	pI2C->CFG = (pI2C->CFG & ((uint32_t) 0x1F)) | (1 << 0);
N}
N
N/**
N * @brief	Disable I2C Master interface
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N * @note
N */
Nstatic INLINE void Chip_I2CM_Disable(LPC_I2C_T *pI2C)
Xstatic __inline void Chip_I2CM_Disable(LPC_I2C_T *pI2C)
N{
N	pI2C->CFG = (pI2C->CFG & I2C_CFG_MASK) & ~I2C_CFG_MSTEN;
X	pI2C->CFG = (pI2C->CFG & ((uint32_t) 0x1F)) & ~(1 << 0);
N}
N
N/**
N * @brief	Get I2C Status
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	I2C Status register value
N * @note	This function returns the value of the status register.
N */
Nstatic INLINE uint32_t Chip_I2CM_GetStatus(LPC_I2C_T *pI2C)
Xstatic __inline uint32_t Chip_I2CM_GetStatus(LPC_I2C_T *pI2C)
N{
N	return pI2C->STAT;
N}
N
N/**
N * @brief	Clear I2C status bits (master)
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param clrStatus : Status bit to clear, ORed Value of I2C_STAT_MSTRARBLOSS and I2C_STAT_MSTSTSTPERR
N * @return	Nothing
N * @note	This function clears selected status flags.
N */
Nstatic INLINE void Chip_I2CM_ClearStatus(LPC_I2C_T *pI2C, uint32_t clrStatus)
Xstatic __inline void Chip_I2CM_ClearStatus(LPC_I2C_T *pI2C, uint32_t clrStatus)
N{
N	/* Clear Master Arbitration Loss and Start, Stop Error */
N	pI2C->STAT = clrStatus & (I2C_STAT_MSTRARBLOSS | I2C_STAT_MSTSTSTPERR);
X	pI2C->STAT = clrStatus & ((1 << 4) | (1 << 6));
N}
N
N/**
N * @brief	Check if I2C Master is pending
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Returns TRUE if the Master is pending else returns FALSE
N * @note
N */
Nstatic INLINE bool Chip_I2CM_IsMasterPending(LPC_I2C_T *pI2C)
Xstatic __inline _Bool Chip_I2CM_IsMasterPending(LPC_I2C_T *pI2C)
N{
N	return (pI2C->STAT & I2C_STAT_MSTPENDING) != 0;
X	return (pI2C->STAT & (1 << 0)) != 0;
N}
N
N/**
N * @brief	Get current state of the I2C Master
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Master State Code, a value in the range of 0 - 4
N * @note	After the Master is pending this state code tells the reason
N *        for Master pending.
N */
Nstatic INLINE uint32_t Chip_I2CM_GetMasterState(LPC_I2C_T *pI2C)
Xstatic __inline uint32_t Chip_I2CM_GetMasterState(LPC_I2C_T *pI2C)
N{
N	return (pI2C->STAT & I2C_STAT_MSTSTATE) >> 1;
X	return (pI2C->STAT & (0x7 << 1)) >> 1;
N}
N
N/**
N * @brief	Transmit START or Repeat-START signal on I2C bus
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N * @note	This function sets the controller to transmit START condition when
N *        the bus becomes free. This should be called only when master is pending.
N *				The function writes a complete value to Master Control register, ORing is not advised.
N */
Nstatic INLINE void Chip_I2CM_SendStart(LPC_I2C_T *pI2C)
Xstatic __inline void Chip_I2CM_SendStart(LPC_I2C_T *pI2C)
N{
N	pI2C->MSTCTL = I2C_MSTCTL_MSTSTART;
X	pI2C->MSTCTL = (1 << 1);
N}
N
N/**
N * @brief	Transmit STOP signal on I2C bus
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N * @note	This function sets the controller to transmit STOP condition.
N *				This should be called only when master is pending. The function writes a
N *				complete value to Master Control register, ORing is not advised.
N */
Nstatic INLINE void Chip_I2CM_SendStop(LPC_I2C_T *pI2C)
Xstatic __inline void Chip_I2CM_SendStop(LPC_I2C_T *pI2C)
N{
N	pI2C->MSTCTL = I2C_MSTCTL_MSTSTOP;
X	pI2C->MSTCTL = (1 << 2);
N}
N
N/**
N * @brief	Master Continue transfer operation
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N * @note	This function sets the master controller to continue transmission.
N *				This should be called only when master is pending. The function writes a
N *				complete value to Master Control register, ORing is not advised.
N */
Nstatic INLINE void Chip_I2CM_MasterContinue(LPC_I2C_T *pI2C)
Xstatic __inline void Chip_I2CM_MasterContinue(LPC_I2C_T *pI2C)
N{
N	pI2C->MSTCTL = I2C_MSTCTL_MSTCONTINUE;
X	pI2C->MSTCTL = (1 << 0);
N}
N
N/**
N * @brief	Transmit a single data byte through the I2C peripheral (master)
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	data	: Byte to transmit
N * @return	Nothing
N * @note	This function attempts to place a byte into the I2C Master
N *			Data Register
N *
N */
Nstatic INLINE void Chip_I2CM_WriteByte(LPC_I2C_T *pI2C, uint8_t data)
Xstatic __inline void Chip_I2CM_WriteByte(LPC_I2C_T *pI2C, uint8_t data)
N{
N	pI2C->MSTDAT = (uint32_t) data;
N}
N
N/**
N * @brief	Read a single byte data from the I2C peripheral (master)
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	A single byte of data read
N * @note	This function reads a byte from the I2C receive hold register
N *			regardless of I2C state.
N */
Nstatic INLINE uint8_t Chip_I2CM_ReadByte(LPC_I2C_T *pI2C)
Xstatic __inline uint8_t Chip_I2CM_ReadByte(LPC_I2C_T *pI2C)
N{
N	return (uint8_t) (pI2C->MSTDAT & I2C_MSTDAT_DATAMASK);
X	return (uint8_t) (pI2C->MSTDAT & ((uint32_t) 0x00FF << 0));
N}
N
N/**
N * @brief	Transfer state change handler
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	xfer	: Pointer to a I2CM_XFER_T structure see notes below
N * @return Returns non-zero value on completion of transfer. The @a status
N *         member of @a xfer structure contains the current status of the
N *         transfer at the end of the call.
N * @note
N * The parameter @a xfer should be same as the one passed to Chip_I2CM_Xfer()
N * routine. This function should be called from the I2C interrupt handler
N * only when a master interrupt occurs.
N */
Nuint32_t Chip_I2CM_XferHandler(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer);
N
N/**
N * @brief	Transmit and Receive data in master mode
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	xfer	: Pointer to a I2CM_XFER_T structure see notes below
N * @return	Nothing
N * @note
N * The parameter @a xfer should have its member @a slaveAddr initialized
N * to the 7-Bit slave address to which the master will do the xfer, Bit0
N * to bit6 should have the address and Bit8 is ignored. During the transfer
N * no code (like event handler) must change the content of the memory
N * pointed to by @a xfer. The member of @a xfer, @a txBuff and @a txSz be
N * initialized to the memory from which the I2C must pick the data to be
N * transfered to slave and the number of bytes to send respectively, similarly
N * @a rxBuff and @a rxSz must have pointer to memroy where data received
N * from slave be stored and the number of data to get from slave respectilvely.
N * Following types of transfers are possible:
N * - Write-only transfer: When @a rxSz member of @a xfer is set to 0.
N *
N *          S Addr Wr [A] txBuff0 [A] txBuff1 [A] ... txBuffN [A] P
N *
N *      - If I2CM_XFER_OPTION_IGNORE_NACK is set in @a options memeber
N *
N *          S Addr Wr [A] txBuff0 [A or NA] ... txBuffN [A or NA] P
N *
N * - Read-only transfer: When @a txSz member of @a xfer is set to 0.
N *
N *          S Addr Rd [A] [rxBuff0] A [rxBuff1] A ... [rxBuffN] NA P
N *
N *      - If I2CM_XFER_OPTION_LAST_RX_ACK is set in @a options memeber
N *
N *          S Addr Rd [A] [rxBuff0] A [rxBuff1] A ... [rxBuffN] A P
N *
N * - Read-Write transfer: When @a rxSz and @ txSz members of @a xfer are non-zero.
N *
N *          S Addr Wr [A] txBuff0 [A] txBuff1 [A] ... txBuffN [A]
N *              S Addr Rd [A] [rxBuff0] A [rxBuff1] A ... [rxBuffN] NA P
N *
N */
Nvoid Chip_I2CM_Xfer(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer);
N
N/**
N * @brief	Transmit and Receive data in master mode
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	xfer	: Pointer to a I2CM_XFER_T structure see notes below
N * @return Returns non-zero value on succesful completion of transfer.
N * @note
N * This function operates same as Chip_I2CM_Xfer(), but is a blocking call.
N */
Nuint32_t Chip_I2CM_XferBlocking(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer);
N
N/**
N * @}
N */
N
N #ifdef __cplusplus
S}
N#endif
N
N#endif /* __I2CM_5411X_H_ */
L 210 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "i2cs_5411x.h"
L 1 "..\..\..\chip_5411x\inc\i2cs_5411x.h" 1
N/*
N * @brief LPC5411X I2C slave driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2014
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __I2CS_5411X_H_
N#define __I2CS_5411X_H_
N
N#include "i2c_common_5411x.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup I2CS_5411X CHIP: LPC5411X I2C slave-only driver
N * @ingroup I2C_5411X
N * This driver only works in slave mode.
N * @{
N */
N
N/** @brief I2C slave service start callback
N * This callback is called from the I2C slave handler when an I2C slave address is
N * received and needs servicing. It's used to indicate the start of a slave transfer
N * that will happen on the slave bus.
N */
Ntypedef void (*I2CSlaveXferStart)(uint8_t addr);
N
N/** @brief I2C slave send data callback
N * This callback is called from the I2C slave handler when an I2C slave address needs
N * data to send.<br>
N * If you want to NAK the master, return I2C_SLVCTL_SLVNACK to the caller.
N * Return I2C_SLVCTL_SLVCONTINUE or 0 to the caller for normal non-DMA data transfer.
N * If you've setup a DMA descriptor for the transfer, return I2C_SLVCTL_SLVDMA to the caller.<br>
N */
Ntypedef uint8_t (*I2CSlaveXferSend)(uint8_t *data);
N
N/** @brief I2C slave receive data callback
N * This callback is called from the I2C slave handler when an I2C slave address has
N * receive data.<br>
N * If you want to NAK the master, return I2C_SLVCTL_SLVNACK to the caller.
N * Return I2C_SLVCTL_SLVCONTINUE or 0 to the caller for normal non-DMA data transfer.
N * If you've setup a DMA descriptor for the transfer, return I2C_SLVCTL_SLVDMA to the caller.<br>
N */
Ntypedef uint8_t (*I2CSlaveXferRecv)(uint8_t data);
N
N/** @brief I2C slave service done callback
N * This callback is called from the I2C slave handler when an I2C slave transfer is
N * completed. It's used to indicate the end of a slave transfer.
N */
Ntypedef void (*I2CSlaveXferDone)(void);
N
N/**
N * Slave transfer are performed using 4 callbacks. These 3 callbacks handle most I2C
N * slave transfer cases. When the slave is setup and a slave interrupt is receive
N * and processed with the Chip_I2CS_XferHandler() function in the I2C interrupt handler,
N * one of these 4 callbacks is called. The callbacks can be used for unsized transfers
N * from the master.
N *
N * When an address is received, the SlaveXferAddr() callback is called with the
N * received address. Only addresses enabled in the slave controller will be handled.
N * The slave controller can support up to 4 slave addresses.
N *
N * If the master is going to perform a read operation, the SlaveXferSend() callback
N * is called. Place the data byte to send in *data and return a value of 0 or
N * I2C_SLVCTL_SLVCONTINUE to the caller, or return a value o I2C_SLVCTL_SLVNACK to
N * NACK the master. If you are using DMA and have setup a DMA descriptor in the
N * callback, return I2C_SLVCTL_SLVDMA.<br>
N *
N * If the master performs a write operation, the SlaveXferRecv() callback is called
N * with the received data. Return a value of 0 or I2C_SLVCTL_SLVCONTINUE to the caller
N * to continue data transfer. Return I2C_SLVCTL_SLVNACK to NACk the master. If you
N * are using DMA and have setup a DMA descriptor in the callback, return
N * I2C_SLVCTL_SLVDMA.<br>
N *
N * Once the transfer completes, the SlaveXferDone() callback will be called.<br>
N */
Ntypedef struct {
N	I2CSlaveXferStart slaveStart;	/*!< Called when an matching I2C slave address is received */
N	I2CSlaveXferSend slaveSend;		/*!< Called when a byte is needed to send to master */
N	I2CSlaveXferRecv slaveRecv;		/*!< Called when a byte is received from master */
N	I2CSlaveXferDone slaveDone;		/*!< Called when a slave transfer is complete */
N} I2CS_XFER_T;
N
N/**
N * @brief	Enable I2C slave interface
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N * @note	Do not call this function until the slave interface is fully configured.
N */
N__STATIC_INLINE void Chip_I2CS_Enable(LPC_I2C_T *pI2C)
Xstatic __inline void Chip_I2CS_Enable(LPC_I2C_T *pI2C)
N{
N	pI2C->CFG = (pI2C->CFG & I2C_CFG_MASK) | I2C_CFG_SLVEN;
X	pI2C->CFG = (pI2C->CFG & ((uint32_t) 0x1F)) | (1 << 1);
N}
N
N/**
N * @brief	Disable I2C slave interface
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_I2CS_Disable(LPC_I2C_T *pI2C)
Xstatic __inline void Chip_I2CS_Disable(LPC_I2C_T *pI2C)
N{
N	pI2C->CFG = (pI2C->CFG & I2C_CFG_MASK) & ~I2C_CFG_SLVEN;
X	pI2C->CFG = (pI2C->CFG & ((uint32_t) 0x1F)) & ~(1 << 1);
N}
N
N/**
N * @brief	Get I2C Status
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	I2C Status register value
N * @note	This function returns the value of the status register.
N */
N__STATIC_INLINE uint32_t Chip_I2CS_GetStatus(LPC_I2C_T *pI2C)
Xstatic __inline uint32_t Chip_I2CS_GetStatus(LPC_I2C_T *pI2C)
N{
N	return pI2C->STAT;
N}
N
N/**
N * @brief	Clear I2C status bits (slave)
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param clrStatus : Status bit to clear, must be I2C_STAT_SLVDESEL
N * @return	Nothing
N * @note	This function clears selected status flags.
N */
N__STATIC_INLINE void Chip_I2CS_ClearStatus(LPC_I2C_T *pI2C, uint32_t clrStatus)
Xstatic __inline void Chip_I2CS_ClearStatus(LPC_I2C_T *pI2C, uint32_t clrStatus)
N{
N	pI2C->STAT = clrStatus & I2C_STAT_SLVDESEL;
X	pI2C->STAT = clrStatus & (1 << 15);
N}
N
N/**
N * @brief	Check if I2C slave is pending
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Returns TRUE if the slave is pending else returns FALSE
N * @note
N */
N__STATIC_INLINE bool Chip_I2CS_IsSlavePending(LPC_I2C_T *pI2C)
Xstatic __inline _Bool Chip_I2CS_IsSlavePending(LPC_I2C_T *pI2C)
N{
N	return (pI2C->STAT & I2C_STAT_SLVPENDING) != 0;
X	return (pI2C->STAT & (1 << 8)) != 0;
N}
N
N/**
N * @brief	Check if I2C slave is selected
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Returns TRUE if the slave is is selected, otherwise FALSE
N * @note
N */
N__STATIC_INLINE bool Chip_I2CS_IsSlaveSelected(LPC_I2C_T *pI2C)
Xstatic __inline _Bool Chip_I2CS_IsSlaveSelected(LPC_I2C_T *pI2C)
N{
N	return (pI2C->STAT & I2C_STAT_SLVSEL) != 0;
X	return (pI2C->STAT & (1 << 14)) != 0;
N}
N
N/**
N * @brief	Check if I2C slave is deselected
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Returns TRUE if the slave is is deselected, otherwise FALSE
N * @note
N */
N__STATIC_INLINE bool Chip_I2CS_IsSlaveDeSelected(LPC_I2C_T *pI2C)
Xstatic __inline _Bool Chip_I2CS_IsSlaveDeSelected(LPC_I2C_T *pI2C)
N{
N	return (pI2C->STAT & I2C_STAT_SLVDESEL) != 0;
X	return (pI2C->STAT & (1 << 15)) != 0;
N}
N
N/**
N * @brief	Get current state of the I2C slave
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	slave State Code, a value of type I2C_STAT_SLVCODE_*
N * @note	After the slave is pending this state code tells the reason
N *        for slave pending.
N */
N__STATIC_INLINE uint32_t Chip_I2CS_GetSlaveState(LPC_I2C_T *pI2C)
Xstatic __inline uint32_t Chip_I2CS_GetSlaveState(LPC_I2C_T *pI2C)
N{
N	return (pI2C->STAT & I2C_STAT_SLVSTATE) >> 9;
X	return (pI2C->STAT & (0x3 << 9)) >> 9;
N}
N
N/**
N * @brief	Returns the current slave address match index
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	slave match index, 0 - 3
N */
N__STATIC_INLINE uint32_t Chip_I2CS_GetSlaveMatchIndex(LPC_I2C_T *pI2C)
Xstatic __inline uint32_t Chip_I2CS_GetSlaveMatchIndex(LPC_I2C_T *pI2C)
N{
N	return (pI2C->STAT & I2C_STAT_SLVIDX) >> 12;
X	return (pI2C->STAT & (0x3 << 12)) >> 12;
N}
N
N/**
N * @brief	Slave Continue transfer operation (ACK)
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N * @note	This function sets the slave controller to continue transmission.
N *				This should be called only when slave is pending. The function writes a
N *				complete value to slave Control register, ORing is not advised.
N */
N__STATIC_INLINE void Chip_I2CS_SlaveContinue(LPC_I2C_T *pI2C)
Xstatic __inline void Chip_I2CS_SlaveContinue(LPC_I2C_T *pI2C)
N{
N	pI2C->SLVCTL = I2C_SLVCTL_SLVCONTINUE;
X	pI2C->SLVCTL = (1 << 0);
N}
N
N/**
N * @brief	Slave NACK operation
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N * @note	This function sets the slave controller to NAK the master.
N */
N__STATIC_INLINE void Chip_I2CS_SlaveNACK(LPC_I2C_T *pI2C)
Xstatic __inline void Chip_I2CS_SlaveNACK(LPC_I2C_T *pI2C)
N{
N	pI2C->SLVCTL = I2C_SLVCTL_SLVNACK;
X	pI2C->SLVCTL = (1 << 1);
N}
N
N/**
N * @brief	Enable slave DMA operation
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N * @note	This function enables DMA mode for the slave controller. In DMA
N * mode, the 'continue' and 'NACK' operations aren't used and the I2C slave
N * controller will automatically NACK any bytes beyond the available DMA
N * buffer size.
N */
N__STATIC_INLINE void Chip_I2CS_SlaveEnableDMA(LPC_I2C_T *pI2C)
Xstatic __inline void Chip_I2CS_SlaveEnableDMA(LPC_I2C_T *pI2C)
N{
N	pI2C->SLVCTL = I2C_SLVCTL_SLVDMA;
X	pI2C->SLVCTL = (1 << 3);
N}
N
N/**
N * @brief	Disable slave DMA operation
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	Nothing
N * @note	This function disables DMA mode for the slave controller.
N */
N__STATIC_INLINE void Chip_I2CS_SlaveDisableDMA(LPC_I2C_T *pI2C)
Xstatic __inline void Chip_I2CS_SlaveDisableDMA(LPC_I2C_T *pI2C)
N{
N	pI2C->SLVCTL = 0;
N}
N
N/**
N * @brief	Transmit a single data byte through the I2C peripheral (slave)
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	data	: Byte to transmit
N * @return	Nothing
N * @note	This function attempts to place a byte into the I2C slave
N *			Data Register
N *
N */
N__STATIC_INLINE void Chip_I2CS_WriteByte(LPC_I2C_T *pI2C, uint8_t data)
Xstatic __inline void Chip_I2CS_WriteByte(LPC_I2C_T *pI2C, uint8_t data)
N{
N	pI2C->SLVDAT = (uint32_t) data;
N}
N
N/**
N * @brief	Read a single byte data from the I2C peripheral (slave)
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @return	A single byte of data read
N * @note	This function reads a byte from the I2C receive hold register
N *			regardless of I2C state.
N */
N__STATIC_INLINE uint8_t Chip_I2CS_ReadByte(LPC_I2C_T *pI2C)
Xstatic __inline uint8_t Chip_I2CS_ReadByte(LPC_I2C_T *pI2C)
N{
N	return (uint8_t) (pI2C->SLVDAT & I2C_SLVDAT_DATAMASK);
X	return (uint8_t) (pI2C->SLVDAT & ((uint32_t) 0x00FF << 0));
N}
N
N/**
N * @brief	Set a I2C slave address for slave operation
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	slvNum	: Possible slave address number, between 0 - 3
N * @param	slvAddr	: Slave Address for the index (7-bits, bit 7 = 0)
N * @return	Nothing
N * @note	Setting a slave address also enables the slave address. Do
N * not 'pre-shift' the slave address.
N */
N__STATIC_INLINE void Chip_I2CS_SetSlaveAddr(LPC_I2C_T *pI2C, uint8_t slvNum, uint8_t slvAddr)
Xstatic __inline void Chip_I2CS_SetSlaveAddr(LPC_I2C_T *pI2C, uint8_t slvNum, uint8_t slvAddr)
N{
N	pI2C->SLVADR[slvNum] = (uint32_t) (slvAddr << 1);
N}
N
N/**
N * @brief	Return a I2C programmed slave address
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	slvNum	: Possible slave address number, between 0 - 3
N * @return	Nothing
N */
N__STATIC_INLINE uint8_t Chip_I2CS_GetSlaveAddr(LPC_I2C_T *pI2C, uint8_t slvNum)
Xstatic __inline uint8_t Chip_I2CS_GetSlaveAddr(LPC_I2C_T *pI2C, uint8_t slvNum)
N{
N	return (pI2C->SLVADR[slvNum] >> 1) & 0x7F;
N}
N
N/**
N * @brief	Enable a I2C address
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	slvNum	: Possible slave address number, between 0 - 3
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_I2CS_EnableSlaveAddr(LPC_I2C_T *pI2C, uint8_t slvNum)
Xstatic __inline void Chip_I2CS_EnableSlaveAddr(LPC_I2C_T *pI2C, uint8_t slvNum)
N{
N	pI2C->SLVADR[slvNum] = (pI2C->SLVADR[slvNum] & I2C_SLVADR_MASK) & ~I2C_SLVADR_SADISABLE;
X	pI2C->SLVADR[slvNum] = (pI2C->SLVADR[slvNum] & ((uint32_t) 0x00FF)) & ~(1 << 0);
N}
N
N/**
N * @brief	Disable a I2C address
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	slvNum	: Possible slave address number, between 0 - 3
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_I2CS_DisableSlaveAddr(LPC_I2C_T *pI2C, uint8_t slvNum)
Xstatic __inline void Chip_I2CS_DisableSlaveAddr(LPC_I2C_T *pI2C, uint8_t slvNum)
N{
N	pI2C->SLVADR[slvNum] = (pI2C->SLVADR[slvNum] & I2C_SLVADR_MASK) | I2C_SLVADR_SADISABLE;
X	pI2C->SLVADR[slvNum] = (pI2C->SLVADR[slvNum] & ((uint32_t) 0x00FF)) | (1 << 0);
N}
N
N/**
N * @brief	Setup slave qialifier address
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	extend	: true to extend I2C slave detect address 0 range, or false to match to corresponding bits
N * @param	slvAddr	: Slave address qualifier, see SLVQUAL0 register in User Manual
N * @return	Nothing
N * @note	Do not 'pre-shift' the slave address.
N */
N__STATIC_INLINE void Chip_I2CS_SetSlaveQual0(LPC_I2C_T *pI2C, bool extend, uint8_t slvAddr)
Xstatic __inline void Chip_I2CS_SetSlaveQual0(LPC_I2C_T *pI2C, _Bool extend, uint8_t slvAddr)
N{
N	slvAddr = slvAddr << 1;
N	if (extend) {
N		slvAddr |= I2C_SLVQUAL_QUALMODE0;
X		slvAddr |= (1 << 0);
N	}
N
N	pI2C->SLVQUAL0 = slvAddr;
N}
N
N/**
N * @brief	Slave transfer state change handler
N * @param	pI2C	: Pointer to selected I2C peripheral
N * @param	xfers	: Pointer to a I2CS_MULTI_XFER_T structure see notes below
N * @return	Returns non-zero value on completion of transfer or NAK
N * @note	See @ref I2CS_XFER_T for more information on this function. When using
N * this function, the I2C_INTENSET_SLVPENDING and I2C_INTENSET_SLVDESEL interrupts
N * should be enabled and setup in the I2C interrupt handler to call this function
N * when they fire.
N */
Nuint32_t Chip_I2CS_XferHandler(LPC_I2C_T *pI2C, const I2CS_XFER_T *xfers);
N
N/**
N * @}
N */
N
N #ifdef __cplusplus
S}
N#endif
N
N#endif /* __I2CS_5411X_H_ */
L 211 "..\..\..\chip_5411x\inc\chip.h" 2
N#include "i2s_5411x.h"
L 1 "..\..\..\chip_5411x\inc\i2s_5411x.h" 1
N/*
N * @brief LPC5411x I2S driver
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2015
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __I2S_5411X_H_
N#define __I2S_5411X_H_
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N * @brief I2S register block structure
N */
Ntypedef struct {					/*!< I2S Structure */
N	__IO uint32_t RESERVED0A[768];
X	volatile uint32_t RESERVED0A[768];
N	__IO uint32_t CFG1;				/*!< Offset: 0xC00 Configuration register #1 */
X	volatile uint32_t CFG1;				 
N	__IO uint32_t CFG2;				/*!< Offset: 0xC04 Configuration register #2 */
X	volatile uint32_t CFG2;				 
N	__IO uint32_t STAT;				/*!< Offset: 0xC08 Status register */
X	volatile uint32_t STAT;				 
N	__I  uint32_t RESERVED00[4];    /*!< Offset: 0xC0C Reserved registers */
X	volatile const  uint32_t RESERVED00[4];     
N	__IO uint32_t DIV;				/*!< Offset: 0xC1C Clock divider, used by all channel pairs. */
X	volatile uint32_t DIV;				 
N	__I  uint32_t RESERVED0[120];	/*!< Offset: 0xC10 Reserved member */
X	volatile const  uint32_t RESERVED0[120];	 
N
N	/** I2S FIFO Specific registers @endcond */
N	__IO uint32_t FIFOCFG;			/*!< Offset: 0xE00 FIFO Configuration register */
X	volatile uint32_t FIFOCFG;			 
N	__IO uint32_t FIFOSTAT;			/*!< Offset: 0xE04 FIFO Status register */
X	volatile uint32_t FIFOSTAT;			 
N	__IO uint32_t FIFOTRIG;			/*!< Offset: 0xE08 FIFO Trigger level register @cond */
X	volatile uint32_t FIFOTRIG;			 
N	__I  uint32_t RESERVED1;		/*!< Offset: 0xE0C Reserved register @endcond */
X	volatile const  uint32_t RESERVED1;		 
N	__IO uint32_t FIFOINTENSET;		/*!< Offset: 0xE10 FIFO Interrupt enable SET register */
X	volatile uint32_t FIFOINTENSET;		 
N	__IO uint32_t FIFOINTENCLR;		/*!< Offset: 0xE14 FIFO Interrupt enable CLEAR register */
X	volatile uint32_t FIFOINTENCLR;		 
N	__IO uint32_t FIFOINTSTAT;		/*!< Offset: 0xE18 FIFO Interrupt Status register @cond */
X	volatile uint32_t FIFOINTSTAT;		 
N	__I  uint32_t RESERVED2;		/*!< Offset: 0xE1C Reserved register @endcond */
X	volatile const  uint32_t RESERVED2;		 
N	__O  uint32_t FIFOWR;			/*!< Offset: 0xE20 FIFO Data write register @cond */
X	volatile  uint32_t FIFOWR;			 
N	__I  uint32_t FIFOWR48H;		/*!< Offset: 0xE24 FIFO write data for upper data bits */
X	volatile const  uint32_t FIFOWR48H;		 
N	__I  uint32_t RESERVED3[2];		/*!< Offset: 0xE28 Reserved register @endcond */
X	volatile const  uint32_t RESERVED3[2];		 
N	__I  uint32_t FIFORD;			/*!< Offset: 0xE30 FIFO Data read register @cond */
X	volatile const  uint32_t FIFORD;			 
N	__I  uint32_t FIFORD48H;		/*!< Offset: 0xE34 FIFO read data for upper data bits */
X	volatile const  uint32_t FIFORD48H;		 
N	__I  uint32_t RESERVED4[2];		/*!< Offset: 0xE38 Reserved register @endcond */
X	volatile const  uint32_t RESERVED4[2];		 
N	__I  uint32_t FIFORDNOPOP;		/*!< Offset: 0xE40 FIFO data read with no FIFO pop */
X	volatile const  uint32_t FIFORDNOPOP;		 
N	__I  uint32_t FIFORD48HNOPOP;	/*!< Offset: 0xE44 FIFO data read for upper data bits with no FIFO pop */
X	volatile const  uint32_t FIFORD48HNOPOP;	 
N	__I  uint32_t RESERVED5[108];	/*!< Offset: 0xE48 Reserved register */
X	volatile const  uint32_t RESERVED5[108];	 
N
N	/** FLEXCOMM Interface registers @endcond */
N	__IO uint32_t PSELID;			/*!< Offset: 0xFF8 Peripheral select/identification register */
X	volatile uint32_t PSELID;			 
N	__I  uint32_t PID;				/*!< Offset: 0xFFC Module identification register */
X	volatile const  uint32_t PID;				 
N} LPC_I2S_T;
N
N/**
N * @brief I2S CFG1 register bits
N */
N#define I2S_CFG1_MAINENABLE			(0x01 << 0)					/*!< I2S Main enable */
N#define I2S_CFG1_DATAPAUSE			(0x01 << 1)					/*!< Data flow Pause */
N#define I2S_CFG1_2NDCOUNT(p)		(((p) & 0x03) << 2)			/*!< additional I2S channel pair ct (read only) */
N#define I2S_CFG1_MSTSLVCFG(p)		(((p) & 0x03) << 4)			/*!< Master / slave configuration selection */
N#define I2S_CFG1_MODE(p)			(((p) & 0x03) << 6)			/*!< Selects basic I2S operating mode */
N#define I2S_CFG1_RIGHTLOW			(0x01 << 8)					/*!< Right channel data is in the Low portion of FIFO data */
N#define I2S_CFG1_LEFTJUST			(0x01 << 9)					/*!< Left Justify data */
N#define I2S_CFG1_ONECHANNEL			(0x01 << 10)				/*!< Single channel mode */
N#define I2S_CFG1_PDMDATA			(0x01 << 11)				/*!< PDM Data selection */
N#define I2S_CFG1_SCK_POL			(0x01 << 12)				/*!< SCK polarity */
N#define I2S_CFG1_WS_POL				(0x01 << 13)				/*!< WS polarity */
N#define I2S_CFG1_DATALEN(p)			(((p) & 0x1f) << 16)		/*!< Data Length (minus 1 encoded) */
N
N/**
N * @brief I2S CFG2 register bits
N */
N#define I2S_CFG2_FRAMELEN(p)		(((p) & 0x1ff) << 0)		/*!< I2S Main enable */
N#define I2S_CFG2_POSITION(p)		(((p) & 0x1FF) << 16)		/*!< Data flow Pause */
N
N/**
N * @brief I2S status register bits
N */
N#define I2S_STAT_BUSY				(0x01 << 0)					/*!< Busy status for the primary channel pair */
N#define I2S_STAT_SLVFRMERR			(0x01 << 1)					/*!< Slave Frame Error flag */
N#define I2S_STAT_LR					(0x01 << 2)					/*!< Left/Right indication */
N#define I2S_STAT_PAUSED				(0x01 << 3)					/*!< Data Paused status flag */
N
N/**
N * @brief I2S FIFO configuration bits
N */
N#define I2S_FIFO_CFG_ENABLETX		(0x01 << 0)					/*!< Enable the transmit FIFO */
N#define I2S_FIFO_CFG_ENABLERX		(0x01 << 1)					/*!< Enable the receive FIFO */
N#define I2S_FIFO_CFG_TXI2SE0		(0x01 << 2)					/*!< Transmit I2S empty 0 */
N#define I2S_FIFO_CFG_PACK48			(0x01 << 3)					/*!< Packing format for 48-bit data */
N#define I2S_FIFO_CFG_SIZE(p)		(((p) & 0x03) << 4)			/*!< FIFO size (READ ONLY) */
N#define I2S_FIFO_CFG_DMATX			(0x01 << 12)				/*!< DMA configuration for transmit */
N#define I2S_FIFO_CFG_DMARX			(0x01 << 13)				/*!< DMA configuration for receive */
N#define I2S_FIFO_CFG_WAKETX			(0x01 << 14)				/*!< Wake-up for transmit FIFO level */
N#define I2S_FIFO_CFG_WAKERX			(0x01 << 15)				/*!< Wake-up for receive FIFO level */
N#define I2S_FIFO_CFG_EMPTYTX		(0x01 << 16)				/*!< Empty command for the transmit FIFO */
N#define I2S_FIFO_CFG_EMPTYRX		(0x01 << 17)				/*!< Empty command for the receive FIFO */
N#define I2S_FIFO_CFG_POPDBG			(0x01 << 18)				/*!< Pop FIFO for debug reads */
N
N/**
N * @brief I2S FIFO status bits
N */
N#define I2S_FIFO_STAT_TXERR			(0x01 << 0)					/*!< TX FIFO error */
N#define I2S_FIFO_STAT_RXERR			(0x01 << 1)					/*!< RX FIFO error */
N#define I2S_FIFO_STAT_PERINT		(0x01 << 3)					/*!< Peripheral interrupt */
N#define I2S_FIFO_STAT_TXEMPTY		(0x01 << 4)					/*!< Transmit FIFO empty */
N#define I2S_FIFO_STAT_TXNOTFULL		(0x01 << 5)					/*!< Transmit FIFO not full */
N#define I2S_FIFO_STAT_RXNOTEMPTY	(0x01 << 6)					/*!< Receive FIFO not empty */
N#define I2S_FIFO_STAT_RXFULL		(0x01 << 7)					/*!< Receive FIFO full */
N#define I2S_FIFO_STAT_TXLVL(p)		(((p) & 0x0f) << 8)			/*!< Transmit FIFO current level */
N#define I2S_FIFO_STAT_RXLVL(p)		(((p) & 0x0f) << 16)		/*!< Receive FIFO current level */
N
N/**
N * @brief I2S FIFO trigger settings bits
N */
N#define I2S_FIFO_TRIG_TXLVLENA		(0x01 << 0)					/*!< Transmit FIFO level trigger enable */
N#define I2S_FIFO_TRIG_RXLVLENA		(0x01 << 1)					/*!< Receive FIFO level trigger enable */
N#define I2S_FIFO_TRIG_TXLVL(p)		(((p) & 0x0f) << 8)			/*!< Transmit FIFO level trigger point */
N#define I2S_FIFO_TRIG_RXLVL(p)		(((p) & 0x0f) << 16)		/*!< Receive FIFO level trigger point */
N
N/**
N * @brief I2S FIFO interrupt enable.
N * Used for interrupt status too.
N */
N#define I2S_FIFO_INT_BITMASK		(0x001F)					/** FIFO interrupt Bit mask */
N#define I2S_FIFO_INT_TXERR			(0x01 << 0)					/*!< Interrupt on TX error */
N#define I2S_FIFO_INT_RXERR			(0x01 << 1)					/*!< Interrupt on RX error */
N#define I2S_FIFO_INT_TXLVL			(0x01 << 2)					/*!< Interrupt on TX level */
N#define I2S_FIFO_INT_RXLVL			(0x01 << 3)					/*!< Interrupt on RX level */
N#define I2S_FIFO_INT_PERINT			(0x01 << 4)					/*!< I2S peripheral interrupt [BIT-4 of FIFOINTSTAT register] */
N
Ntypedef enum {
N	I2S_FIFO_ENABLE,
N	I2S_FIFO_DISABLE,
N	I2S_FIFO_DMA_ENABLE,
N	I2S_FIFO_DMA_DISABLE,
N	I2S_FIFO_CLEAR,
N	I2S_FIFO_TXZ_ENABLE,
N	I2S_FIFO_TXZ_DISABLE,
N} I2S_FIFO_CMD_T;
N
Ntypedef enum {
N	I2S_TX,
N	I2S_RX,
N} I2S_DIR_T;
N
Ntypedef enum {
N	NORMAL_SLAVE,
N	WS_SYNC_MASTER,
N	EXT_SCLCK_MASTER,
N	NORMAL_MASTER,
N} I2S_MSTSLVCFG_T;
N
Ntypedef enum {
N	I2S_CLASSIC,
N	DSP_WS_50,
N	DSP_WS_SHORT,
N	DSP_WS_LONG,
N} I2S_MODE_T;
N
Ntypedef struct {
N	I2S_DIR_T			Direction;			/*!< Data direction: tx or rx */
N	I2S_MSTSLVCFG_T		MSCfg;				/*!< Master / Slave configuration */
N	I2S_MODE_T			Mode;				/*!< I2S mode */
N	bool				RightLow;			/*!< right channel data in low portion of FIFO */
X	_Bool				RightLow;			 
N	bool				LeftJust;			/*!< left justify data in FIFO */
X	_Bool				LeftJust;			 
N	bool				PDMData;			/*!<  data source is the D-Mic subsystem */
X	_Bool				PDMData;			 
N	bool				SCKPol;				/*!<  SCK polarity */
X	_Bool				SCKPol;				 
N	bool				WSPol;				/*!<  WS polarity */
X	_Bool				WSPol;				 
N	uint32_t			Divider;			/*!< Flexcomm function clock divider */
N	uint8_t				ChannelNumber;		/*!< Channel Number - 1 is mono, 2 is stereo */
N	uint16_t			WordWidth;			/*!< Word Width */
N	uint16_t			FrameWidth;			/*!< Frame Width */
N	uint16_t			DataPos;			/*!< Data position in the frame */
N	uint16_t			FIFOdepth;			/*!< FIFO depth (fifo config) */
N} I2S_AUDIO_FORMAT_T;
N
N/**
N * @brief	I2S statistics structure
N * @note
N * Maintains current I2S statistics.
N */
Ntypedef struct {
N	uint32_t		interrupts;				/*!< count: interrupts */
N	uint32_t		lvl_tx;					/*!< count: transmit interrupts */
N	uint32_t		lvl_rx;					/*!< count: receive interrupts */
N	uint32_t		fifo_err_tx;			/*!< count: FIFO transmit errors */
N	uint32_t		fifo_err_rx;			/*!< count: FIFO receive errors */
N	uint32_t		i2s_busy;				/*!< count: I2S channel pair is busy */
N	uint32_t		i2s_slvfrmerr;			/*!< count: I2S slave frame error */
N	uint32_t		i2s_data_paused;		/*!< count: I2S data paused */
N} I2S_STATISTICS_T;
N
N/**
N * @brief	Initialize I2S driver
N * @param	pI2S	: The base of I2S peripheral on the chip
N * @return	0 - on success; #ERR_FLEXCOMM_FUNCNOTSUPPORTED or #ERR_FLEXCOMM_NOTFREE on failure
N */
Nint Chip_I2S_Init(LPC_I2S_T *pI2S, I2S_AUDIO_FORMAT_T *fmt);
N
N__STATIC_INLINE int Chip_I2S_TX_Init(LPC_I2S_T *pI2S)
Xstatic __inline int Chip_I2S_TX_Init(LPC_I2S_T *pI2S)
N{
N	return Chip_FLEXCOMM_Init(pI2S, FLEXCOMM_PERIPH_I2S_TX);
N}
N__STATIC_INLINE int Chip_I2S_RX_Init(LPC_I2S_T *pI2S)
Xstatic __inline int Chip_I2S_RX_Init(LPC_I2S_T *pI2S)
N{
N	return Chip_FLEXCOMM_Init(pI2S, FLEXCOMM_PERIPH_I2S_RX);
N}
N
N/**
N * @brief	Shutdown I2S driver
N * @param	pI2S	: The base of I2S peripheral on the chip
N * @return	Nothing
N * @note	Reset all relative registers (DMA, transmit/receive control, interrupt) to default value
N */
N__STATIC_INLINE void Chip_I2S_DeInit(LPC_I2S_T *pI2S)
Xstatic __inline void Chip_I2S_DeInit(LPC_I2S_T *pI2S)
N{
N	Chip_FLEXCOMM_DeInit(pI2S);
N}
N
N/**
N * @brief   Configure I2S Port
N * @param	pI2S	: The base I2S peripheral on the chip
N * @param	fmt		: Audio Format
N * @return	SUCCESS or ERROR
N */
NStatus Chip_I2S_Config(LPC_I2S_T *pI2S, I2S_AUDIO_FORMAT_T *fmt);
N
N/**
N * @brief	Get the I2S status register
N * @param	pI2S	: Pointer to selected I2Sx peripheral
N * @return	I2S status register
N * @note	Multiple statuses may be pending. Mask the return value
N *			with one or more I2S_STAT_* definitions to determine
N *			statuses.
N */
N__STATIC_INLINE uint32_t Chip_I2S_GetStatus(LPC_I2S_T *pI2S)
Xstatic __inline uint32_t Chip_I2S_GetStatus(LPC_I2S_T *pI2S)
N{
N	return pI2S->STAT;
N}
N
N/**
N * @brief	Clear the I2S status register
N * @param	pI2S	: Pointer to selected I2Sx peripheral
N * @param	stsMask	: OR'ed statuses to disable
N * @return	Nothing
N * @note	Multiple interrupts may be pending. Mask the return value
N *			with one or more I2S_INTEN_* definitions to determine
N *			pending interrupts.
N */
N__STATIC_INLINE void Chip_I2S_ClearStatus(LPC_I2S_T *pI2S, uint32_t stsMask)
Xstatic __inline void Chip_I2S_ClearStatus(LPC_I2S_T *pI2S, uint32_t stsMask)
N{
N	pI2S->STAT = stsMask;
N}
N
N/**
N * @brief	Send a 32-bit data to TXFIFO for transmition
N * @param	pI2S	: The base of I2S peripheral on the chip
N * @param	data	: Data to be transmited
N * @return	Nothing
N * @note	The function writes to TXFIFO without checking any condition.
N */
N__STATIC_INLINE void Chip_I2S_Send(LPC_I2S_T *pI2S, uint32_t data)
Xstatic __inline void Chip_I2S_Send(LPC_I2S_T *pI2S, uint32_t data)
N{
N	pI2S->FIFOWR = data;
N}
N
N/**
N * @brief	Get received data from RXFIFO
N * @param	pI2S	: The base of I2S peripheral on the chip
N * @return	Data received in RXFIFO
N * @note	The function reads from RXFIFO without checking any condition.
N */
N__STATIC_INLINE uint32_t Chip_I2S_Receive(LPC_I2S_T *pI2S)
Xstatic __inline uint32_t Chip_I2S_Receive(LPC_I2S_T *pI2S)
N{
N	return pI2S->FIFORD;
N}
N
N/**
N * @brief	Start I2S port
N * @param	pI2S	: The base of I2S peripheral on the chip
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_I2S_Start(LPC_I2S_T *pI2S)
Xstatic __inline void Chip_I2S_Start(LPC_I2S_T *pI2S)
N{
N	pI2S->CFG1 |= I2S_CFG1_MAINENABLE;
X	pI2S->CFG1 |= (0x01 << 0);
N}
N
N/**
N * @brief	Stop I2S asynchronously
N * @param	pI2S	: The base of I2S peripheral on the chip
N * @return	Nothing
N * @note	Pause, resets the transmit channel and FIFO asynchronously
N */
N__STATIC_INLINE void Chip_I2S_Stop(LPC_I2S_T *pI2S)
Xstatic __inline void Chip_I2S_Stop(LPC_I2S_T *pI2S)
N{
N	pI2S->CFG1 &= ~I2S_CFG1_MAINENABLE;
X	pI2S->CFG1 &= ~(0x01 << 0);
N}
N
N/**
N * @brief	Pause the I2S port
N * @param	pI2S	: The base of I2S peripheral on the chip
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_I2S_Pause(LPC_I2S_T *pI2S)
Xstatic __inline void Chip_I2S_Pause(LPC_I2S_T *pI2S)
N{
N	pI2S->CFG1 |= I2S_CFG1_DATAPAUSE;
X	pI2S->CFG1 |= (0x01 << 1);
N}
N
N/**
N * @brief	Play (un-Pause) the I2S port
N * @param	pI2S	: The base of I2S peripheral on the chip
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_I2S_Play(LPC_I2S_T *pI2S)
Xstatic __inline void Chip_I2S_Play(LPC_I2S_T *pI2S)
N{
N	pI2S->CFG1 &= ~I2S_CFG1_DATAPAUSE;
X	pI2S->CFG1 &= ~(0x01 << 1);
N}
N
N//------------------------------------------------------------------------------
N//
N//	End I2S functions / Start of FIFO functions
N//
N//------------------------------------------------------------------------------
N
N//------------------------------------------------------------------------------
N//	FIFO configuration functions
N//------------------------------------------------------------------------------
N
N/**
N * @brief   Configure I2S FIFO
N * @param	pI2S	: The base I2S peripheral on the chip
N * @param	fmpt	: Audio format information
N * @return	Nothing
N */
Nvoid Chip_I2S_FIFO_Config(LPC_I2S_T *pI2S, I2S_AUDIO_FORMAT_T *fmt);
N
N/**
N * @brief   Execute I2S FIFO control commands
N * @param	pI2S	: The base I2S peripheral on the chip
N * @param	fmt		: Audio format information
N * @param	cmd		: FIFO command
N * @return	Nothing
N */
Nvoid Chip_I2S_FIFO_Control(LPC_I2S_T *pI2S, I2S_AUDIO_FORMAT_T *fmt, I2S_FIFO_CMD_T cmd);
N
N//------------------------------------------------------------------------------
N//	FIFO status functions
N//------------------------------------------------------------------------------
N
N/**
N * @brief	Get FIFO status
N * @param	pI2S	: The base of I2S peripheral on the chip
N * @return	Current FIFO status
N */
N__STATIC_INLINE uint32_t Chip_I2S_GetFIFOStatus(LPC_I2S_T *pI2S)
Xstatic __inline uint32_t Chip_I2S_GetFIFOStatus(LPC_I2S_T *pI2S)
N{
N	return (pI2S->FIFOSTAT);
N}
N
N/**
N * @brief	Clear FIFO status
N * @param	pI2S	: The base of I2S peripheral on the chip
N * @param	mask	: Mask of the status bits that needs to be cleared
N * @return	mothing
N */
N__STATIC_INLINE void Chip_I2S_ClrFIFOStatus(LPC_I2S_T *pI2S, uint32_t mask)
Xstatic __inline void Chip_I2S_ClrFIFOStatus(LPC_I2S_T *pI2S, uint32_t mask)
N{
N	pI2S->FIFOSTAT = mask;
N}
N
N//------------------------------------------------------------------------------
N//	FIFO trigger functions
N//------------------------------------------------------------------------------
N
N/**
N * @brief	Setup I2S FIFO trigger-level
N * @param	pI2S	: Base on-chip I2S peripheral address
N * @param	tx_lvl	: TX Trigger level [Valid values 0 to 7]
N * @param	rx_lvl	: RX Trigger level [Valid values 0 to 7]
N * @return	Nothing
N * @note	When @a tx_lvl = 0; trigger will happen when TX FIFO is empty
N *			if @a tx_lvl = 7; trigger will happen when TX FIFO has at least one free space<br>
N *			When @a rx_lvl = 0; trigger will happen when RX FIFO has at least one data in it,
N *			if @a rx_lvl = 7; trigger will happen when RX FIFO is full and cannot receive anymore data.
N */
N__STATIC_INLINE void Chip_I2S_SetFIFOTrigLevel(LPC_I2S_T *pI2S, uint8_t tx_lvl, uint8_t rx_lvl)
Xstatic __inline void Chip_I2S_SetFIFOTrigLevel(LPC_I2S_T *pI2S, uint8_t tx_lvl, uint8_t rx_lvl)
N{
N	pI2S->FIFOTRIG = I2S_FIFO_TRIG_TXLVL(tx_lvl) | I2S_FIFO_TRIG_RXLVL(rx_lvl) | I2S_FIFO_TRIG_TXLVLENA | I2S_FIFO_TRIG_TXLVLENA;
X	pI2S->FIFOTRIG = (((tx_lvl) & 0x0f) << 8) | (((rx_lvl) & 0x0f) << 16) | (0x01 << 0) | (0x01 << 0);
N}
N
N/**
N * @brief	Get I2S FIFO trigger-level
N * @param	pI2S	: Base of on-chip I2S peripheral
N * @return	Returns the complete raw trigger register.
N */
N__STATIC_INLINE uint32_t Chip_I2S_GetFIFOTrigLevel(LPC_I2S_T *pI2S)
Xstatic __inline uint32_t Chip_I2S_GetFIFOTrigLevel(LPC_I2S_T *pI2S)
N{
N	return pI2S->FIFOTRIG;
N}
N
N//------------------------------------------------------------------------------
N//	FIFO get level functions
N//------------------------------------------------------------------------------
N/**
N * @brief	Get the current level of the Transmit FIFO
N * @param	pI2S	: The base of I2S peripheral on the chip
N * @return	Current level of the Transmit FIFO
N */
N__STATIC_INLINE uint8_t Chip_I2S_GetFIFOTxLevel(LPC_I2S_T *pI2S)
Xstatic __inline uint8_t Chip_I2S_GetFIFOTxLevel(LPC_I2S_T *pI2S)
N{
N	return (pI2S->FIFOSTAT >> 8) & 0xF;
N}
N
N/**
N * @brief	Get the current level of the Receive FIFO
N * @param	pI2S	: The base of I2S peripheral on the chip
N * @return	Current level of the Receive FIFO
N */
N__STATIC_INLINE uint8_t Chip_I2S_GetFIFORxLevel(LPC_I2S_T *pI2S)
Xstatic __inline uint8_t Chip_I2S_GetFIFORxLevel(LPC_I2S_T *pI2S)
N{
N	return (pI2S->FIFOSTAT >> 16) & 0xF;
N}
N
N//------------------------------------------------------------------------------
N//	FIFO interrupt functions
N//------------------------------------------------------------------------------
N/**
N * @brief   Set I2S FIFO interrupts
N * @param	pI2S	: The base I2S peripheral on the chip
N * @param	int_val	: Interrupts to set
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_I2S_FIFO_SetInterrupt(LPC_I2S_T *pI2S, uint32_t int_val)
Xstatic __inline void Chip_I2S_FIFO_SetInterrupt(LPC_I2S_T *pI2S, uint32_t int_val)
N{
N	pI2S->FIFOINTENSET = int_val;
N}
N
N/**
N * @brief   Clear I2S FIFO interrupts
N * @param	pI2S	: The base I2S peripheral on the chip
N * @param	int_val	: Interrupts to clear
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_I2S_FIFO_ClrInterrupt(LPC_I2S_T *pI2S, uint32_t int_val)
Xstatic __inline void Chip_I2S_FIFO_ClrInterrupt(LPC_I2S_T *pI2S, uint32_t int_val)
N{
N	pI2S->FIFOINTENCLR = int_val;
N}
N
N/**
N * @brief   Get I2S FIFO interrupts status
N * @param	pI2S	: The base I2S peripheral on the chip
N * @return	interrupt status
N */
N__STATIC_INLINE uint32_t Chip_I2S_FIFO_GetPendingInts(LPC_I2S_T *pI2S)
Xstatic __inline uint32_t Chip_I2S_FIFO_GetPendingInts(LPC_I2S_T *pI2S)
N{
N	return pI2S->FIFOINTSTAT & I2S_FIFO_INT_BITMASK;
X	return pI2S->FIFOINTSTAT & (0x001F);
N}
N
N/**
N * @brief	Clear the FIFO status register
N * @param	I2S		: The base of the I2S peripheral on the chip
N * @param	mask	: Mask of the status bits that needs to be cleared
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_I2S_FIFO_ClearStatus(LPC_I2S_T *pI2S, uint32_t mask)
Xstatic __inline void Chip_I2S_FIFO_ClearStatus(LPC_I2S_T *pI2S, uint32_t mask)
N{
N	pI2S->FIFOSTAT = mask;
N}
N
N/**
N * @brief	I2S error handler
N * @param	I2S		: The base of the I2S peripheral on the chip
N * @param	stat	: Statistics structure
N * @return	Nothing
N */
Nvoid Chip_I2S_ErrorHandler(LPC_I2S_T *pI2S, I2S_STATISTICS_T* stat);
N
N
N/* I2S6 Defines */
N#define LPC_I2S6_BASE		__APPEND3(LPC_FLEXCOMM,I2S6_FLEXCOMM,_BASE)
N#define LPC_I2S6			((LPC_I2S_T *) LPC_I2S6_BASE)
N#define I2S6_IRQHandler		__APPEND3(FLEXCOMM,I2S6_FLEXCOMM,_IRQHandler)
N#define I2S6_IRQn			__APPEND3(FLEXCOMM,I2S6_FLEXCOMM,_IRQn)
N#define DMAREQ_I2S6_RX		__APPEND3(DMAREQ_FLEXCOMM,I2S6_FLEXCOMM,_RX)
N#define DMAREQ_I2S6_TX		__APPEND3(DMAREQ_FLEXCOMM,I2S6_FLEXCOMM,_TX)
N
N/* I2S7 Defines */
N#define LPC_I2S7_BASE		__APPEND3(LPC_FLEXCOMM,I2S7_FLEXCOMM,_BASE)
N#define LPC_I2S7			((LPC_I2S_T *) LPC_I2S7_BASE)
N#define I2S7_IRQHandler		__APPEND3(FLEXCOMM,I2S7_FLEXCOMM,_IRQHandler)
N#define I2S7_IRQn			__APPEND3(FLEXCOMM,I2S7_FLEXCOMM,_IRQn)
N#define DMAREQ_I2S7_RX		__APPEND3(DMAREQ_FLEXCOMM,I2S7_FLEXCOMM,_RX)
N#define DMAREQ_I2S7_TX		__APPEND3(DMAREQ_FLEXCOMM,I2S7_FLEXCOMM,_TX)
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __I2S_5411X_H_ */
L 212 "..\..\..\chip_5411x\inc\chip.h" 2
N
N/** @defgroup SUPPORT_5411X_FUNC CHIP: LPC5411X support functions
N * @ingroup CHIP_5411X_DRIVERS
N * @{
N */
N
N/**
N * @brief	Current system clock rate, mainly used for peripherals in SYSCON
N */
Nextern uint32_t SystemCoreClock;
N
N/**
N * @brief	Update system core and ASYNC syscon clock rate, should be called if the
N *			system has a clock rate change
N * @return	None
N */
Nvoid SystemCoreClockUpdate(void);
N
N/**
N * @brief	Set up and initialize hardware prior to call to main()
N * @return	None
N * @note	Chip_SystemInit() is called prior to the application and sets up
N * system clocking prior to the application starting.
N */
Nvoid Chip_SystemInit(void);
N
N/**
N * @brief	Clock and PLL initialization based on the internal oscillator
N * @param	iFreq	: Rate (in Hz) to set the main system clock to
N * @return	None
N */
Nvoid Chip_SetupIrcClocking(uint32_t iFreq);
N
N/**
N * @brief	Clock and PLL initialization based on the external clock input
N * @param	iFreq	: Rate (in Hz) to set the main system clock to
N * @return	None
N */
Nvoid Chip_SetupExtInClocking(uint32_t iFreq);
N
N/**
N * @brief	Initialize the Core clock to given frequency (12, 48 or 96 MHz)
N * @param	iFreq	: Desired frequency (must be one of #SYSCON_FRO12MHZ_FREQ or #SYSCON_FRO48MHZ_FREQ or #SYSCON_FRO96MHZ_FREQ)
N * @return	Nothing
N */
Nvoid Chip_SetupFROClocking(uint32_t iFreq);
N
N/**
N * @brief	Initialize the USB bus
N * @return 	Nothing
N * @note	Uses FRO HF to initialize the pin-IO and the clocks.
N */
Nvoid Chip_USB_Init(void);
N
N/**
N * @brief	Turn of FRO clock trimming based on USB SOF
N * @param	enable	: 0 - Disable trim based on USB SOF; Non-Zero to enable it
N * @return	Nothing
N */
N__STATIC_INLINE void Chip_USB_TrimOff(int enable)
Xstatic __inline void Chip_USB_TrimOff(int enable)
N{
N	if (enable) {
N		/* Turn ON FRO HF and let it adjust TRIM value based on USB SOF */
N		LPC_SYSCON->FROCTRL = (LPC_SYSCON->FROCTRL & ~SYSCON_FROCTRL_MASK) | SYSCON_FROCTRL_USBCLKADJ;
X		((LPC_SYSCON_T *) 0x40000000UL)->FROCTRL = (((LPC_SYSCON_T *) 0x40000000UL)->FROCTRL & ~((1 << 15) | (0xF << 26))) | (1UL << 24);
N	} else {
N		/* Turn ON FRO HF and let it adjust TRIM value based on USB SOF */
N		LPC_SYSCON->FROCTRL = LPC_SYSCON->FROCTRL & ~(SYSCON_FROCTRL_MASK | SYSCON_FROCTRL_USBCLKADJ);
X		((LPC_SYSCON_T *) 0x40000000UL)->FROCTRL = ((LPC_SYSCON_T *) 0x40000000UL)->FROCTRL & ~(((1 << 15) | (0xF << 26)) | (1UL << 24));
N	}
N}
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CHIP_H_ */
L 36 "..\..\..\brd_xpresso54114\inc\board.h" 2
N/* board_api.h is included at the bottom of this file after DEBUG setup */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup BOARD_LPCXPRESSO_54114 LPC54114 LPCXpresso LQFP board support software API functions
N * @ingroup LPCOPEN_5410X_BOARD_LPCXPRESSO_54114
N * The board support software API functions provide some simple abstracted
N * functions used across multiple LPCOpen board examples. See @ref BOARD_COMMON_API
N * for the functions defined by this board support layer.<br>
N * <br>
N * @notes:
N * Board Information page: http://www.nxp.com/OM13090
N * Add on board (Mic-Audio-OLED board): http://www.nxp.com/O13089
N * @{
N */
N
N/** @defgroup BOARD_LPCXPRESSO_54114_OPTIONS BOARD: LPC54114 LPCXpresso LQFP board build options
N * This board has options that configure its operation at build-time.<br>
N * @{
N */
N
N/** Define DEBUG_ENABLE to enable IO via the DEBUGSTR, DEBUGOUT, and
N    DEBUGIN macros. If not defined, DEBUG* functions will be optimized
N    out of the code at build time.
N */
N#define DEBUG_ENABLE
N
N/** Define DEBUG_SEMIHOSTING along with DEBUG_ENABLE to enable IO support
N    via semihosting. You may need to use a C library that supports
N    semihosting with this option.
N */
N// #define DEBUG_SEMIHOSTING
N
N/** Board UART used for debug output and input using the DEBUG* macros. This
N    is also the port used for Board_UARTPutChar, Board_UARTGetChar, and
N    Board_UARTPutSTR functions. Although you can setup multiple UARTs here,
N    the board code only supports UART0 in the Board_UART_Init() function,
N    so be sure to change it there too if not using UART0.
N */
N#define DEBUG_UART                      LPC_USART0
N#define USART0_FLEXCOMM                 0
N
N/** Bit rate for the debug UART in Hz */
N#define DEBUGBAUDRATE       (115200)
N
N/** Main system clock rate in Hz for this board. Select a clock rate between
N    12MHz and 96MHz for the main system (CPU) clock for this board. */
N#define BOARD_MAINCLOCKRATE     (48000000)
N
N/** External clock rate on the CLKIN pin in Hz for this board. If not used,
N    set this to 0. Otherwise, set it to the exact rate in Hz this pin is
N    being driven at. */
N#define BOARD_EXTCLKINRATE      (0)
N
N/** Set the BOARD_USECLKINSRC definition to (1) to use the external clock
N    input pin as the PLL source. The BOARD_ECTCLKINRATE definition must
N    be setup with the correct rate in the CLKIN pin. Set this to (0) to
N    use the IRC for the PLL source. */
N#define BOARD_USECLKINSRC       (0)
N
N/**
N * @}
N */
N
N/* Board name */
N#define BOARD_NXP_LPCXPRESSO_54114
N
N/** Board version definition, supports LQFP version of the board */
N#define BOARD_REV1_LQFP
N
N/**
N * @}
N */
N
N#include "board_api.h"
L 1 "..\..\..\brd_xpresso54114\inc\board_api.h" 1
N/*
N * @brief Common board API functions
N *
N * @note
N * Copyright(C) NXP Semiconductors, 2013
N * All rights reserved.
N *
N * @par
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * LPC products.  This software is supplied "AS IS" without any warranties of
N * any kind, and NXP Semiconductors and its licensor disclaim any and
N * all warranties, express or implied, including all implied warranties of
N * merchantability, fitness for a particular purpose and non-infringement of
N * intellectual property rights.  NXP Semiconductors assumes no responsibility
N * or liability for the use of the software, conveys no license or rights under any
N * patent, copyright, mask work right, or any other intellectual property rights in
N * or to any products. NXP Semiconductors reserves the right to make changes
N * in the software without notification. NXP Semiconductors also makes no
N * representation or warranty that such application will be suitable for the
N * specified use without further testing or modification.
N *
N * @par
N * Permission to use, copy, modify, and distribute this software and its
N * documentation is hereby granted, under NXP Semiconductors' and its
N * licensor's relevant copyrights in the software, without fee, provided that it
N * is used in conjunction with NXP Semiconductors microcontrollers.  This
N * copyright, permission, and disclaimer notice must appear in all copies of
N * this code.
N */
N
N#ifndef __BOARD_API_H_
N#define __BOARD_API_H_
N
N#include "lpc_types.h"
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060019
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 37 "..\..\..\brd_xpresso54114\inc\board_api.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup BOARD_COMMON_API BOARD: Common board functions
N * @ingroup BOARD_Common
N * This file contains common board definitions that are shared across
N * boards and devices. All of these functions do not need to be
N * implemented for a specific board, but if they are implemented, they
N * should use this API standard.
N * @{
N */
N
N/**
N * @brief	Setup and initialize hardware prior to call to main()
N * @return	None
N * @note	Board_SystemInit() is called prior to the application and sets up system
N * clocking, memory, and any resources needed prior to the application
N * starting.
N */
Nvoid Board_SystemInit(void);
N
N/**
N * @brief	Setup pin multiplexer per board schematics
N * @return	None
N * @note	Board_SetupMuxing() should be called from SystemInit() prior to application
N * main() is called. So that the PINs are set in proper state.
N */
Nvoid Board_SetupMuxing(void);
N
N/**
N * @brief	Setup system clocking 
N * @return	None
N * @note	This sets up board clocking.
N */
Nvoid Board_SetupClocking(void);
N
N/**
N * @brief	Setup external system memory
N * @return	None
N * @note	This function is typically called after pin mux setup and clock setup and
N * sets up any external memory needed by the system (DRAM, SRAM, etc.). Not all
N * boards need this function.
N */
Nvoid Board_SetupExtMemory(void);
N
N/**
N * @brief	Set up and initialize all required blocks and functions related to the board hardware.
N * @return	None
N */
Nvoid Board_Init(void);
N
N/**
N * @brief	Initializes board UART for output, required for printf redirection
N * @return	None
N */
Nvoid Board_Debug_Init(void);
N
N/**
N * @brief	Sends a single character on the UART, required for printf redirection
N * @param	ch	: character to send
N * @return	None
N */
Nvoid Board_UARTPutChar(char ch);
N
N/**
N * @brief	Get a single character from the UART, required for scanf input
N * @return	EOF if not character was received, or character value
N */
Nint Board_UARTGetChar(void);
N
N/**
N * @brief	Prints a string to the UART
N * @param	str	: Terminated string to output
N * @return	None
N */
Nvoid Board_UARTPutSTR(char *str);
N
N/**
N * @brief	Gets state of a board button
N * @param	btnNum		: Button number to test
N * @return	true if button asserted
N */
Nbool Board_Button_Get(uint8_t btnNum);
X_Bool Board_Button_Get(uint8_t btnNum);
N
N/**
N * @brief	Set state of all colors in RGB LED
N * @param	uint8_t		: LED_BLUE|LED_GREEN|LED_RED
N * @return	None
N */
N#define	LED_RGB_OFF			0x00
N#define	LED_RGB_RED			0x01
N#define	LED_RGB_GREEN		0x02
N#define	LED_RGB_YELLOW		0x03
N#define	LED_RGB_BLUE		0x04
N#define	LED_RGB_MAGENTA		0x05
N#define	LED_RGB_CYAN		0x06
N#define	LED_RGB_WHITE		0x07
Nvoid Board_LED_RGB_Set(uint8_t led);
N
N/**
N * @brief	Exingush all LEDs at once
N * @return	None
N */
Nvoid Board_LED_RGB_Off(void);
N
N/**
N * @brief	Sets the state of a board LED to on or off
N * @param	LEDNumber	: LED number to set state for
N * @param	State		: true for on, false for off
N * @return	None
N */
Nvoid Board_LED_Set(uint8_t LEDNumber, bool State);
Xvoid Board_LED_Set(uint8_t LEDNumber, _Bool State);
N
N/**
N * @brief	Returns the current state of a board LED
N * @param	LEDNumber	: LED number to set state for
N * @return	true if the LED is on, otherwise false
N */
Nbool Board_LED_Test(uint8_t LEDNumber);
X_Bool Board_LED_Test(uint8_t LEDNumber);
N
N/**
N * @brief	Toggles the current state of a board LED
N * @param	LEDNumber	: LED number to change state for
N * @return	None
N */
Nvoid Board_LED_Toggle(uint8_t LEDNumber);
N
N/**
N * @brief	Sets / Clears the board generic I/O bits
N * @param	tst_num		: TEST I/O to control
N * @param	state		: true for on, false for off
N * @return	None
N */
Nvoid Board_TestIO_Set(uint8_t tst_num, bool state);
Xvoid Board_TestIO_Set(uint8_t tst_num, _Bool state);
N
N/**
N * @brief	Turn on Board LCD Backlight
N * @param	Intensity	: Backlight intensity (0 = off, >=1 = on)
N * @return	None
N * @note	On boards where a GPIO is used to control backlight on/off state, a '0' or '1'
N * value will turn off or on the backlight. On some boards, a non-0 value will
N * control backlight intensity via a PWN. For PWM systems, the intensity value
N * is a percentage value between 0 and 100%.
N */
Nvoid Board_SetLCDBacklight(uint8_t Intensity);
N
N/**
N * @brief Function prototype for a MS delay function. Board layers or example code may
N *        define this function as needed.
N */
Ntypedef void (*p_msDelay_func_t)(uint32_t);
N
N/* The DEBUG* functions are selected based on system configuration.
N   Code that uses the DEBUG* functions will have their I/O routed to
N   the UART, semihosting, or nowhere. */
N#if defined(DEBUG_ENABLE)
X#if 1L
N#if defined(DEBUG_SEMIHOSTING)
X#if 0L
S#define DEBUGINIT()
S#define DEBUGOUT(...) printf(__VA_ARGS__)
S#define DEBUGSTR(str) printf(str)
S#define DEBUGIN() (int) EOF
S
N#else
N#define DEBUGINIT() Board_Debug_Init()
N#define DEBUGOUT(...) printf(__VA_ARGS__)
N#define DEBUGSTR(str) Board_UARTPutSTR(str)
N#define DEBUGIN() Board_UARTGetChar()
N#endif /* defined(DEBUG_SEMIHOSTING) */
N
N#else
S#define DEBUGINIT()
S#define DEBUGOUT(...)
S#define DEBUGSTR(str)
S#define DEBUGIN() (int) EOF
N#endif /* defined(DEBUG_ENABLE) */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __BOARD_API_H_ */
L 113 "..\..\..\brd_xpresso54114\inc\board.h" 2
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __BOARD_H_ */
L 4 "..\..\..\..\..\..\COMMON\SRC\TEST\CM_TEST.c" 2
N	  #include "cr_section_macros.h"
L 1 "..\..\..\..\..\..\COMMON\SRC\TEST\cr_section_macros.h" 1
N//*****************************************************************************
N// cr_section_macros.h
N//
N// Set of macros to allow code/data to be placed into alternate memory banks
N//*****************************************************************************
N//
N// Copyright(C) NXP Semiconductors, 2014
N// All rights reserved.
N//
N// Software that is described herein is for illustrative purposes only
N// which provides customers with programming information regarding the
N// LPC products.  This software is supplied "AS IS" without any warranties of
N// any kind, and NXP Semiconductors and its licensor disclaim any and
N// all warranties, express or implied, including all implied warranties of
N// merchantability, fitness for a particular purpose and non-infringement of
N// intellectual property rights.  NXP Semiconductors assumes no responsibility
N// or liability for the use of the software, conveys no license or rights under any
N// patent, copyright, mask work right, or any other intellectual property rights in
N// or to any products. NXP Semiconductors reserves the right to make changes
N// in the software without notification. NXP Semiconductors also makes no
N// representation or warranty that such application will be suitable for the
N// specified use without further testing or modification.
N//
N// Permission to use, copy, modify, and distribute this software and its
N// documentation is hereby granted, under NXP Semiconductors' and its
N// licensor's relevant copyrights in the software, without fee, provided that it
N// is used in conjunction with NXP Semiconductors microcontrollers.  This
N// copyright, permission, and disclaimer notice must appear in all copies of
N// this code.
N//*****************************************************************************
N#ifndef CR_SECTION_MACROS_H_INCLUDED
N#define CR_SECTION_MACROS_H_INCLUDED
N
N// A macro for placing text (code), data, or bss into a named RAM section
N// These will be automatically placed into the named section by the linker.
N//
N// RAM banks are numbered starting from 1. The actual configuration is 
N// dependent on the selected MCU type.
N//
N// Example:
N//        __SECTION(data,RAM1) char buffer[1024] ;
N//
N// This will place the 1024 byte buffer into the RAM1
N//
N#define __SECTION_EXT(type, bank, name) __attribute__ ((section("." #type ".$" #bank "." #name)))
N#define __SECTION(type, bank) __attribute__ ((section("." #type ".$" #bank)))
N#define __SECTION_SIMPLE(type) __attribute__ ((section("." #type)))
N
N#define __DATA_EXT(bank, name) __SECTION_EXT(data, bank, name)
N#define __DATA(bank) __SECTION(data, bank)
N
N#define __BSS_EXT(bank, name) __SECTION_EXT(bss, bank, name)
N#define __BSS(bank) __SECTION(bss, bank)
N
N// Macros for placing text (code), data, or bss into a section that is automatically
N// placed after the vectors in the target image.
N#define __AFTER_VECTORS_EXT(name) __attribute__ ((section(".after_vectors.$" #name)))
N#define __AFTER_VECTORS __attribute__ ((section(".after_vectors")))
N
N// Macros for causing functions to be relocated to RAM
N#define __RAM_FUNC_EXT(name) __attribute__ ((section(".ramfunc.$" #name)))
N#define __RAM_FUNC __attribute__ ((section(".ramfunc")))
N
N// Macros to be used in preference to __RAM_FUNC to better match __DATA behaviour
N#define __RAMFUNC_EXT(bank, name) __SECTION_EXT(ramfunc, bank, name)
N#define __RAMFUNC(bank) __SECTION(ramfunc, bank)
N
N// Macros for placing data or bss into a section that has the NOLOAD option set in the linker script
N#define __NOINIT_DEF __SECTION_SIMPLE(noinit)
N#define __NOINIT_EXT(bank, name) __SECTION_EXT(noinit, bank, name)
N#define __NOINIT(bank) __SECTION(noinit, bank)
N
N// Macros for placing text (code), or rodata into a different (flash) bank
N#define __RODATA_EXT(bank,name) __SECTION_EXT(rodata, bank, name)
N#define __RODATA(bank) __SECTION(rodata, bank)
N
N#define __TEXT_EXT(bank,name) __SECTION_EXT(text, bank, name)
N#define __TEXT(bank) __SECTION(text, bank)
N
N#endif /* CR_SECTION_MACROS_H_INCLUDED */
L 5 "..\..\..\..\..\..\COMMON\SRC\TEST\CM_TEST.c" 2
N
N    #define	CM_PRINTF printf
N
N#endif
N
N
N
N		
N#if (BOARD==3)
X#if (2==3)
S
S	#include "board.h"
S	#include "pin_mux.h"
S	#include "clock_config.h"
S	#include "fsl_debug_console.h"
S	#define	CM_PRINTF DbgConsole_Printf
S
N#endif
N
N#include "CM_TEST_CONFIG.h"
L 1 "..\..\..\..\..\..\COMMON\SRC\TEST\CM_TEST_CONFIG.h" 1
N#ifndef CM_TEST_CONFIG
N#define CM_TEST_CONFIG
N
N//#define _f32
N//#define _q31
N#define _q15
N
N#define ENABLE_BLOCK_PROCESSING
N#define ENABLE_CFFT_BR
N#define ENABLE_CFFT_NBR
N#define ENABLE_RFFT_BR
N#define ENABLE_RFFT_NBR
N#define COMPLEX_MAG
N#define COMPLEX_MAG_SQUARED
N#define ENABLE_GOERTZEL
N#define ENABLE_BLOCK_IIR
N#define ENABLE_BLOCK_FIR
N
N#define ENABLE_PER_SAMPLE
N
N//#define KV5_TCM_TEST
N
N//#define DATA_IN_ALTERNATE_AHB_BANK
N
N
N#endif
L 24 "..\..\..\..\..\..\COMMON\SRC\TEST\CM_TEST.c" 2
N#include "arm_math.h"
L 1 "..\..\..\..\..\..\COMMON\SRC\CMSIS_DSP_4_5\inc\arm_math.h" 1
N/* ----------------------------------------------------------------------
N* Copyright (C) 2010-2014 ARM Limited. All rights reserved.
N*
N* $Date:        12. March 2014
N* $Revision: 	V1.4.4
N*
N* Project: 	    CMSIS DSP Library
N* Title:	    arm_math.h
N*
N* Description:	Public header file for CMSIS DSP Library
N*
N* Target Processor: Cortex-M7/Cortex-M4/Cortex-M3/Cortex-M0
N*
N* Redistribution and use in source and binary forms, with or without
N* modification, are permitted provided that the following conditions
N* are met:
N*   - Redistributions of source code must retain the above copyright
N*     notice, this list of conditions and the following disclaimer.
N*   - Redistributions in binary form must reproduce the above copyright
N*     notice, this list of conditions and the following disclaimer in
N*     the documentation and/or other materials provided with the
N*     distribution.
N*   - Neither the name of ARM LIMITED nor the names of its contributors
N*     may be used to endorse or promote products derived from this
N*     software without specific prior written permission.
N*
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
N* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
N* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
N* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
N* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
N* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
N* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
N* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N* POSSIBILITY OF SUCH DAMAGE.
N * -------------------------------------------------------------------- */
N
N/**
N   \mainpage CMSIS DSP Software Library
N   *
N   * Introduction
N   * ------------
N   *
N   * This user manual describes the CMSIS DSP software library,
N   * a suite of common signal processing functions for use on Cortex-M processor based devices.
N   *
N   * The library is divided into a number of functions each covering a specific category:
N   * - Basic math functions
N   * - Fast math functions
N   * - Complex math functions
N   * - Filters
N   * - Matrix functions
N   * - Transforms
N   * - Motor control functions
N   * - Statistical functions
N   * - Support functions
N   * - Interpolation functions
N   *
N   * The library has separate functions for operating on 8-bit integers, 16-bit integers,
N   * 32-bit integer and 32-bit floating-point values.
N   *
N   * Using the Library
N   * ------------
N   *
N   * The library installer contains prebuilt versions of the libraries in the <code>Lib</code> folder.
N   * - arm_cortexM4lf_math.lib (Little endian and Floating Point Unit on Cortex-M4)
N   * - arm_cortexM4bf_math.lib (Big endian and Floating Point Unit on Cortex-M4)
N   * - arm_cortexM4l_math.lib (Little endian on Cortex-M4)
N   * - arm_cortexM4b_math.lib (Big endian on Cortex-M4)
N   * - arm_cortexM3l_math.lib (Little endian on Cortex-M3)
N   * - arm_cortexM3b_math.lib (Big endian on Cortex-M3)
N   * - arm_cortexM0l_math.lib (Little endian on Cortex-M0)
N   * - arm_cortexM0b_math.lib (Big endian on Cortex-M3)
N   *
N   * The library functions are declared in the public file <code>arm_math.h</code> which is placed in the <code>Include</code> folder.
N   * Simply include this file and link the appropriate library in the application and begin calling the library functions. The Library supports single
N   * public header file <code> arm_math.h</code> for Cortex-M4/M3/M0 with little endian and big endian. Same header file will be used for floating point unit(FPU) variants.
N   * Define the appropriate pre processor MACRO ARM_MATH_CM4 or  ARM_MATH_CM3 or
N   * ARM_MATH_CM0 or ARM_MATH_CM0PLUS depending on the target processor in the application.
N   *
N   * Examples
N   * --------
N   *
N   * The library ships with a number of examples which demonstrate how to use the library functions.
N   *
N   * Toolchain Support
N   * ------------
N   *
N   * The library has been developed and tested with MDK-ARM version 4.60.
N   * The library is being tested in GCC and IAR toolchains and updates on this activity will be made available shortly.
N   *
N   * Building the Library
N   * ------------
N   *
N   * The library installer contains a project file to re build libraries on MDK-ARM Tool chain in the <code>CMSIS\\DSP_Lib\\Source\\ARM</code> folder.
N   * - arm_cortexM_math.uvproj
N   *
N   *
N   * The libraries can be built by opening the arm_cortexM_math.uvproj project in MDK-ARM, selecting a specific target, and defining the optional pre processor MACROs detailed above.
N   *
N   * Pre-processor Macros
N   * ------------
N   *
N   * Each library project have differant pre-processor macros.
N   *
N   * - UNALIGNED_SUPPORT_DISABLE:
N   *
N   * Define macro UNALIGNED_SUPPORT_DISABLE, If the silicon does not support unaligned memory access
N   *
N   * - ARM_MATH_BIG_ENDIAN:
N   *
N   * Define macro ARM_MATH_BIG_ENDIAN to build the library for big endian targets. By default library builds for little endian targets.
N   *
N   * - ARM_MATH_MATRIX_CHECK:
N   *
N   * Define macro ARM_MATH_MATRIX_CHECK for checking on the input and output sizes of matrices
N   *
N   * - ARM_MATH_ROUNDING:
N   *
N   * Define macro ARM_MATH_ROUNDING for rounding on support functions
N   *
N   * - ARM_MATH_CMx:
N   *
N   * Define macro ARM_MATH_CM4 for building the library on Cortex-M4 target, ARM_MATH_CM3 for building library on Cortex-M3 target
N   * and ARM_MATH_CM0 for building library on cortex-M0 target, ARM_MATH_CM0PLUS for building library on cortex-M0+ target.
N   *
N   * - __FPU_PRESENT:
N   *
N   * Initialize macro __FPU_PRESENT = 1 when building on FPU supported Targets. Enable this macro for M4bf and M4lf libraries
N   *
N   * <hr>
N   * CMSIS-DSP in ARM::CMSIS Pack
N   * -----------------------------
N   * 
N   * The following files relevant to CMSIS-DSP are present in the <b>ARM::CMSIS</b> Pack directories:
N   * |File/Folder                   |Content                                                                 |
N   * |------------------------------|------------------------------------------------------------------------|
N   * |\b CMSIS\\Documentation\\DSP  | This documentation                                                     |
N   * |\b CMSIS\\DSP_Lib             | Software license agreement (license.txt)                               |
N   * |\b CMSIS\\DSP_Lib\\Examples   | Example projects demonstrating the usage of the library functions      |
N   * |\b CMSIS\\DSP_Lib\\Source     | Source files for rebuilding the library                                |
N   * 
N   * <hr>
N   * Revision History of CMSIS-DSP
N   * ------------
N   * Please refer to \ref ChangeLog_pg.
N   *
N   * Copyright Notice
N   * ------------
N   *
N   * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
N   */
N
N
N/**
N * @defgroup groupMath Basic Math Functions
N */
N
N/**
N * @defgroup groupFastMath Fast Math Functions
N * This set of functions provides a fast approximation to sine, cosine, and square root.
N * As compared to most of the other functions in the CMSIS math library, the fast math functions
N * operate on individual values and not arrays.
N * There are separate functions for Q15, Q31, and floating-point data.
N *
N */
N
N/**
N * @defgroup groupCmplxMath Complex Math Functions
N * This set of functions operates on complex data vectors.
N * The data in the complex arrays is stored in an interleaved fashion
N * (real, imag, real, imag, ...).
N * In the API functions, the number of samples in a complex array refers
N * to the number of complex values; the array contains twice this number of
N * real values.
N */
N
N/**
N * @defgroup groupFilters Filtering Functions
N */
N
N/**
N * @defgroup groupMatrix Matrix Functions
N *
N * This set of functions provides basic matrix math operations.
N * The functions operate on matrix data structures.  For example,
N * the type
N * definition for the floating-point matrix structure is shown
N * below:
N * <pre>
N *     typedef struct
N *     {
N *       uint16_t numRows;     // number of rows of the matrix.
N *       uint16_t numCols;     // number of columns of the matrix.
N *       float32_t *pData;     // points to the data of the matrix.
N *     } arm_matrix_instance_f32;
N * </pre>
N * There are similar definitions for Q15 and Q31 data types.
N *
N * The structure specifies the size of the matrix and then points to
N * an array of data.  The array is of size <code>numRows X numCols</code>
N * and the values are arranged in row order.  That is, the
N * matrix element (i, j) is stored at:
N * <pre>
N *     pData[i*numCols + j]
N * </pre>
N *
N * \par Init Functions
N * There is an associated initialization function for each type of matrix
N * data structure.
N * The initialization function sets the values of the internal structure fields.
N * Refer to the function <code>arm_mat_init_f32()</code>, <code>arm_mat_init_q31()</code>
N * and <code>arm_mat_init_q15()</code> for floating-point, Q31 and Q15 types,  respectively.
N *
N * \par
N * Use of the initialization function is optional. However, if initialization function is used
N * then the instance structure cannot be placed into a const data section.
N * To place the instance structure in a const data
N * section, manually initialize the data structure.  For example:
N * <pre>
N * <code>arm_matrix_instance_f32 S = {nRows, nColumns, pData};</code>
N * <code>arm_matrix_instance_q31 S = {nRows, nColumns, pData};</code>
N * <code>arm_matrix_instance_q15 S = {nRows, nColumns, pData};</code>
N * </pre>
N * where <code>nRows</code> specifies the number of rows, <code>nColumns</code>
N * specifies the number of columns, and <code>pData</code> points to the
N * data array.
N *
N * \par Size Checking
N * By default all of the matrix functions perform size checking on the input and
N * output matrices.  For example, the matrix addition function verifies that the
N * two input matrices and the output matrix all have the same number of rows and
N * columns.  If the size check fails the functions return:
N * <pre>
N *     ARM_MATH_SIZE_MISMATCH
N * </pre>
N * Otherwise the functions return
N * <pre>
N *     ARM_MATH_SUCCESS
N * </pre>
N * There is some overhead associated with this matrix size checking.
N * The matrix size checking is enabled via the \#define
N * <pre>
N *     ARM_MATH_MATRIX_CHECK
N * </pre>
N * within the library project settings.  By default this macro is defined
N * and size checking is enabled.  By changing the project settings and
N * undefining this macro size checking is eliminated and the functions
N * run a bit faster.  With size checking disabled the functions always
N * return <code>ARM_MATH_SUCCESS</code>.
N */
N
N/**
N * @defgroup groupTransforms Transform Functions
N */
N
N/**
N * @defgroup groupController Controller Functions
N */
N
N/**
N * @defgroup groupStats Statistics Functions
N */
N/**
N * @defgroup groupSupport Support Functions
N */
N
N/**
N * @defgroup groupInterpolation Interpolation Functions
N * These functions perform 1- and 2-dimensional interpolation of data.
N * Linear interpolation is used for 1-dimensional data and
N * bilinear interpolation is used for 2-dimensional data.
N */
N
N/**
N * @defgroup groupExamples Examples
N */
N#ifndef _ARM_MATH_H
N#define _ARM_MATH_H
N
N#define __CMSIS_GENERIC         /* disable NVIC and Systick functions */
N
N#if defined(ARM_MATH_CM7)
X#if 0L
S  #include "core_cm7.h"
N#elif defined (ARM_MATH_CM4)
X#elif 1L
N  #include "core_cm4.h"
L 1 "..\..\..\..\..\..\COMMON\SRC\CMSIS_DSP_4_5\inc\core_cm4.h" 1
N/**************************************************************************//**
N * @file     core_cm4.h
N * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
N * @version  V4.00
N * @date     22. August 2014
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifndef __CORE_CM4_H_GENERIC
S#define __CORE_CM4_H_GENERIC
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
S  CMSIS violates the following MISRA-C:2004 rules:
S
S   \li Required Rule 8.5, object/function definition in header file.<br>
S     Function definitions in header files are used to allow 'inlining'.
S
S   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
S     Unions are used for effective representation of core registers.
S
S   \li Advisory Rule 19.7, Function-like macro defined.<br>
S     Function-like macros are used to allow more efficient code.
S */
S
S
S/*******************************************************************************
S *                 CMSIS definitions
S ******************************************************************************/
S/** \ingroup Cortex_M4
S  @{
S */
S
S/*  CMSIS CM4 definitions */
S#define __CM4_CMSIS_VERSION_MAIN  (0x04)                                   /*!< [31:16] CMSIS HAL main version   */
S#define __CM4_CMSIS_VERSION_SUB   (0x00)                                   /*!< [15:0]  CMSIS HAL sub version    */
S#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16) | \
S                                    __CM4_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16) |                                     __CM4_CMSIS_VERSION_SUB          )      
S
S#define __CORTEX_M                (0x04)                                   /*!< Cortex-M Core                    */
S
S
S#if   defined ( __CC_ARM )
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler      */
S  #define __INLINE         inline                                    /*use -pc99 on compile line !< inline keyword for COSMIC Compiler   */
S  #define __STATIC_INLINE  static inline
S
S#endif
S
S/** __FPU_USED indicates whether an FPU is used or not.
S    For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
S*/
S#if defined ( __CC_ARM )
S  #if defined __TARGET_FPU_VFP
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __CSMC__ )		/* Cosmic */
S  #if ( __CSMC__ & 0x400)		// FPU present for parser
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S#endif
S
S#include <stdint.h>                      /* standard types definitions                      */
S#include <core_cmInstr.h>                /* Core Instruction Access                         */
S#include <core_cmFunc.h>                 /* Core Function Access                            */
S#include <core_cmSimd.h>                 /* Compiler specific SIMD Intrinsics               */
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* __CORE_CM4_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
S
S#ifndef __CORE_CM4_H_DEPENDANT
S#define __CORE_CM4_H_DEPENDANT
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/* check device defines and use defaults */
S#if defined __CHECK_DEVICE_DEFINES
S  #ifndef __CM4_REV
S    #define __CM4_REV               0x0000
S    #warning "__CM4_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __FPU_PRESENT
S    #define __FPU_PRESENT             0
S    #warning "__FPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
S#endif
S
S/* IO definitions (access restrictions to peripheral registers) */
S/**
S    \defgroup CMSIS_glob_defs CMSIS Global Defines
S
S    <strong>IO Type Qualifiers</strong> are used
S    \li to specify the access to peripheral variables.
S    \li for automatic generation of peripheral register debug information.
S*/
S#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
S#else
S  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
S#endif
S#define     __O     volatile             /*!< Defines 'write only' permissions                */
S#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
S
S/*@} end of group Cortex_M4 */
S
S
S
S/*******************************************************************************
S *                 Register Abstraction
S  Core Register contain:
S  - Core Register
S  - Core NVIC Register
S  - Core SCB Register
S  - Core SysTick Register
S  - Core Debug Register
S  - Core MPU Register
S  - Core FPU Register
S ******************************************************************************/
S/** \defgroup CMSIS_core_register Defines and Type Definitions
S    \brief Type definitions and defines for Cortex-M processor based devices.
S*/
S
S/** \ingroup    CMSIS_core_register
S    \defgroup   CMSIS_CORE  Status and Control Registers
S    \brief  Core Register type definitions.
S  @{
S */
S
S/** \brief  Union type to access the Application Program Status Register (APSR).
S */
Stypedef union
S{
S  struct
S  {
S#if (__CORTEX_M != 0x04)
S    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
S#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
S#endif
S    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
S  } b;                                   /*!< Structure used for bit  access                  */
S  uint32_t w;                            /*!< Type      used for word access                  */
S} APSR_Type;
S
S
S/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
S    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
S  } b;                                   /*!< Structure used for bit  access                  */
S  uint32_t w;                            /*!< Type      used for word access                  */
S} IPSR_Type;
S
S
S/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
S#if (__CORTEX_M != 0x04)
S    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
S#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
S#endif
S    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
S    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
S    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
S  } b;                                   /*!< Structure used for bit  access                  */
S  uint32_t w;                            /*!< Type      used for word access                  */
S} xPSR_Type;
S
S
S/** \brief  Union type to access the Control Registers (CONTROL).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
S    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
S    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
S    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
S  } b;                                   /*!< Structure used for bit  access                  */
S  uint32_t w;                            /*!< Type      used for word access                  */
S} CONTROL_Type;
S
S/*@} end of group CMSIS_CORE */
S
S
S/** \ingroup    CMSIS_core_register
S    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
S    \brief      Type definitions for the NVIC Registers
S  @{
S */
S
S/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
S */
Stypedef struct
S{
S  __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
S       uint32_t RESERVED0[24];
S  __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register         */
S       uint32_t RSERVED1[24];
S  __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register          */
S       uint32_t RESERVED2[24];
S  __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register        */
S       uint32_t RESERVED3[24];
S  __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register           */
S       uint32_t RESERVED4[56];
S  __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
S       uint32_t RESERVED5[644];
S  __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register     */
S}  NVIC_Type;
S
S/* Software Triggered Interrupt Register Definitions */
S#define NVIC_STIR_INTID_Pos                 0                                          /*!< STIR: INTLINESNUM Position */
S#define NVIC_STIR_INTID_Msk                (0x1FFUL << NVIC_STIR_INTID_Pos)            /*!< STIR: INTLINESNUM Mask */
S
S/*@} end of group CMSIS_NVIC */
S
S
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_SCB     System Control Block (SCB)
S    \brief      Type definitions for the System Control Block Registers
S  @{
S */
S
S/** \brief  Structure type to access the System Control Block (SCB).
S */
Stypedef struct
S{
S  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
S  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
S  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
S  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
S  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
S  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
S  __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
S  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
S  __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register                    */
S  __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  HardFault Status Register                             */
S  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
S  __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register                      */
S  __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  BusFault Address Register                             */
S  __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register                       */
S  __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register                            */
S  __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register                                */
S  __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register                            */
S  __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register                         */
S  __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register                   */
S       uint32_t RESERVED0[5];
S  __IO uint32_t CPACR;                   /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register                   */
S} SCB_Type;
S
S/* SCB CPUID Register Definitions */
S#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
S#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
S
S#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
S#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
S
S#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
S#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
S
S#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
S#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
S
S#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
S#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
S
S/* SCB Interrupt Control State Register Definitions */
S#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
S#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
S
S#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
S#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
S
S#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
S#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
S
S#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
S#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
S
S#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
S#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
S
S#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
S#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
S
S#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
S#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
S
S#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
S#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
S
S#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
S#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
S
S#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
S#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
S
S/* SCB Vector Table Offset Register Definitions */
S#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
S
S/* SCB Application Interrupt and Reset Control Register Definitions */
S#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
S#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
S
S#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
S#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
S
S#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
S#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
S
S#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
S#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
S
S#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
S#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
S
S#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
S#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
S
S#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
S#define SCB_AIRCR_VECTRESET_Msk            (1UL << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
S
S/* SCB System Control Register Definitions */
S#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
S#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
S
S#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
S#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
S
S#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
S#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
S
S/* SCB Configuration Control Register Definitions */
S#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
S#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
S
S#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
S#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
S
S#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
S#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
S
S#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
S#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
S
S#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
S#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
S
S#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
S#define SCB_CCR_NONBASETHRDENA_Msk         (1UL << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
S
S/* SCB System Handler Control and State Register Definitions */
S#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
S#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
S
S#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
S#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
S
S#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
S#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
S
S#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
S#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
S
S#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
S#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
S
S#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
S#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
S
S#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
S#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
S
S#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
S#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
S
S#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
S#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
S
S#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
S#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
S
S#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
S#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
S
S#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
S#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
S
S#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
S#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
S
S#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
S#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
S
S/* SCB Configurable Fault Status Registers Definitions */
S#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
S#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
S
S#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
S#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
S
S#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
S#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
S
S/* SCB Hard Fault Status Registers Definitions */
S#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
S#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
S
S#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
S#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
S
S#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
S#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
S
S/* SCB Debug Fault Status Register Definitions */
S#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
S#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
S
S#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
S#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
S
S#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
S#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
S
S#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
S#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
S
S#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
S#define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
S
S/*@} end of group CMSIS_SCB */
S
S
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
S    \brief      Type definitions for the System Control and ID Register not in the SCB
S  @{
S */
S
S/** \brief  Structure type to access the System Control and ID Register not in the SCB.
S */
Stypedef struct
S{
S       uint32_t RESERVED0[1];
S  __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register      */
S  __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register              */
S} SCnSCB_Type;
S
S/* Interrupt Controller Type Register Definitions */
S#define SCnSCB_ICTR_INTLINESNUM_Pos         0                                          /*!< ICTR: INTLINESNUM Position */
S#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL << SCnSCB_ICTR_INTLINESNUM_Pos)      /*!< ICTR: INTLINESNUM Mask */
S
S/* Auxiliary Control Register Definitions */
S#define SCnSCB_ACTLR_DISOOFP_Pos            9                                          /*!< ACTLR: DISOOFP Position */
S#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
S
S#define SCnSCB_ACTLR_DISFPCA_Pos            8                                          /*!< ACTLR: DISFPCA Position */
S#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
S
S#define SCnSCB_ACTLR_DISFOLD_Pos            2                                          /*!< ACTLR: DISFOLD Position */
S#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
S
S#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1                                          /*!< ACTLR: DISDEFWBUF Position */
S#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
S
S#define SCnSCB_ACTLR_DISMCYCINT_Pos         0                                          /*!< ACTLR: DISMCYCINT Position */
S#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL << SCnSCB_ACTLR_DISMCYCINT_Pos)        /*!< ACTLR: DISMCYCINT Mask */
S
S/*@} end of group CMSIS_SCnotSCB */
S
S
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
S    \brief      Type definitions for the System Timer Registers.
S  @{
S */
S
S/** \brief  Structure type to access the System Timer (SysTick).
S */
Stypedef struct
S{
S  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
S  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
S  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
S  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
S} SysTick_Type;
S
S/* SysTick Control / Status Register Definitions */
S#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
S#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
S
S#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
S#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
S
S#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
S#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
S
S#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
S#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
S
S/* SysTick Reload Register Definitions */
S#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
S#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
S
S/* SysTick Current Register Definitions */
S#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
S#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
S
S/* SysTick Calibration Register Definitions */
S#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
S#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
S
S#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
S#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
S
S#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
S#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_CALIB_TENMS_Pos)        /*!< SysTick CALIB: TENMS Mask */
S
S/*@} end of group CMSIS_SysTick */
S
S
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
S    \brief      Type definitions for the Instrumentation Trace Macrocell (ITM)
S  @{
S */
S
S/** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
S */
Stypedef struct
S{
S  __O  union
S  {
S    __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit                   */
S    __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit                  */
S    __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit                  */
S  }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers               */
S       uint32_t RESERVED0[864];
S  __IO uint32_t TER;                     /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register                 */
S       uint32_t RESERVED1[15];
S  __IO uint32_t TPR;                     /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register              */
S       uint32_t RESERVED2[15];
S  __IO uint32_t TCR;                     /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register                */
S       uint32_t RESERVED3[29];
S  __O  uint32_t IWR;                     /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register            */
S  __I  uint32_t IRR;                     /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register             */
S  __IO uint32_t IMCR;                    /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register     */
S       uint32_t RESERVED4[43];
S  __O  uint32_t LAR;                     /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register                  */
S  __I  uint32_t LSR;                     /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register                  */
S       uint32_t RESERVED5[6];
S  __I  uint32_t PID4;                    /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
S  __I  uint32_t PID5;                    /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
S  __I  uint32_t PID6;                    /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
S  __I  uint32_t PID7;                    /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
S  __I  uint32_t PID0;                    /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
S  __I  uint32_t PID1;                    /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
S  __I  uint32_t PID2;                    /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
S  __I  uint32_t PID3;                    /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
S  __I  uint32_t CID0;                    /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
S  __I  uint32_t CID1;                    /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
S  __I  uint32_t CID2;                    /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
S  __I  uint32_t CID3;                    /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
S} ITM_Type;
S
S/* ITM Trace Privilege Register Definitions */
S#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
S#define ITM_TPR_PRIVMASK_Msk               (0xFUL << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */
S
S/* ITM Trace Control Register Definitions */
S#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
S#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
S
S#define ITM_TCR_TraceBusID_Pos             16                                             /*!< ITM TCR: ATBID Position */
S#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
S
S#define ITM_TCR_GTSFREQ_Pos                10                                             /*!< ITM TCR: Global timestamp frequency Position */
S#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
S
S#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
S#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
S
S#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
S#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
S
S#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
S#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
S
S#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
S#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
S
S#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
S#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
S
S#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
S#define ITM_TCR_ITMENA_Msk                 (1UL << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */
S
S/* ITM Integration Write Register Definitions */
S#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
S#define ITM_IWR_ATVALIDM_Msk               (1UL << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */
S
S/* ITM Integration Read Register Definitions */
S#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
S#define ITM_IRR_ATREADYM_Msk               (1UL << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */
S
S/* ITM Integration Mode Control Register Definitions */
S#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
S#define ITM_IMCR_INTEGRATION_Msk           (1UL << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */
S
S/* ITM Lock Status Register Definitions */
S#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
S#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
S
S#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
S#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
S
S#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
S#define ITM_LSR_Present_Msk                (1UL << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */
S
S/*@}*/ /* end of group CMSIS_ITM */
S
S
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
S    \brief      Type definitions for the Data Watchpoint and Trace (DWT)
S  @{
S */
S
S/** \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
S */
Stypedef struct
S{
S  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  Control Register                          */
S  __IO uint32_t CYCCNT;                  /*!< Offset: 0x004 (R/W)  Cycle Count Register                      */
S  __IO uint32_t CPICNT;                  /*!< Offset: 0x008 (R/W)  CPI Count Register                        */
S  __IO uint32_t EXCCNT;                  /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register         */
S  __IO uint32_t SLEEPCNT;                /*!< Offset: 0x010 (R/W)  Sleep Count Register                      */
S  __IO uint32_t LSUCNT;                  /*!< Offset: 0x014 (R/W)  LSU Count Register                        */
S  __IO uint32_t FOLDCNT;                 /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register         */
S  __I  uint32_t PCSR;                    /*!< Offset: 0x01C (R/ )  Program Counter Sample Register           */
S  __IO uint32_t COMP0;                   /*!< Offset: 0x020 (R/W)  Comparator Register 0                     */
S  __IO uint32_t MASK0;                   /*!< Offset: 0x024 (R/W)  Mask Register 0                           */
S  __IO uint32_t FUNCTION0;               /*!< Offset: 0x028 (R/W)  Function Register 0                       */
S       uint32_t RESERVED0[1];
S  __IO uint32_t COMP1;                   /*!< Offset: 0x030 (R/W)  Comparator Register 1                     */
S  __IO uint32_t MASK1;                   /*!< Offset: 0x034 (R/W)  Mask Register 1                           */
S  __IO uint32_t FUNCTION1;               /*!< Offset: 0x038 (R/W)  Function Register 1                       */
S       uint32_t RESERVED1[1];
S  __IO uint32_t COMP2;                   /*!< Offset: 0x040 (R/W)  Comparator Register 2                     */
S  __IO uint32_t MASK2;                   /*!< Offset: 0x044 (R/W)  Mask Register 2                           */
S  __IO uint32_t FUNCTION2;               /*!< Offset: 0x048 (R/W)  Function Register 2                       */
S       uint32_t RESERVED2[1];
S  __IO uint32_t COMP3;                   /*!< Offset: 0x050 (R/W)  Comparator Register 3                     */
S  __IO uint32_t MASK3;                   /*!< Offset: 0x054 (R/W)  Mask Register 3                           */
S  __IO uint32_t FUNCTION3;               /*!< Offset: 0x058 (R/W)  Function Register 3                       */
S} DWT_Type;
S
S/* DWT Control Register Definitions */
S#define DWT_CTRL_NUMCOMP_Pos               28                                          /*!< DWT CTRL: NUMCOMP Position */
S#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
S
S#define DWT_CTRL_NOTRCPKT_Pos              27                                          /*!< DWT CTRL: NOTRCPKT Position */
S#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
S
S#define DWT_CTRL_NOEXTTRIG_Pos             26                                          /*!< DWT CTRL: NOEXTTRIG Position */
S#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
S
S#define DWT_CTRL_NOCYCCNT_Pos              25                                          /*!< DWT CTRL: NOCYCCNT Position */
S#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
S
S#define DWT_CTRL_NOPRFCNT_Pos              24                                          /*!< DWT CTRL: NOPRFCNT Position */
S#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
S
S#define DWT_CTRL_CYCEVTENA_Pos             22                                          /*!< DWT CTRL: CYCEVTENA Position */
S#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
S
S#define DWT_CTRL_FOLDEVTENA_Pos            21                                          /*!< DWT CTRL: FOLDEVTENA Position */
S#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
S
S#define DWT_CTRL_LSUEVTENA_Pos             20                                          /*!< DWT CTRL: LSUEVTENA Position */
S#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
S
S#define DWT_CTRL_SLEEPEVTENA_Pos           19                                          /*!< DWT CTRL: SLEEPEVTENA Position */
S#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
S
S#define DWT_CTRL_EXCEVTENA_Pos             18                                          /*!< DWT CTRL: EXCEVTENA Position */
S#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
S
S#define DWT_CTRL_CPIEVTENA_Pos             17                                          /*!< DWT CTRL: CPIEVTENA Position */
S#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
S
S#define DWT_CTRL_EXCTRCENA_Pos             16                                          /*!< DWT CTRL: EXCTRCENA Position */
S#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
S
S#define DWT_CTRL_PCSAMPLENA_Pos            12                                          /*!< DWT CTRL: PCSAMPLENA Position */
S#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
S
S#define DWT_CTRL_SYNCTAP_Pos               10                                          /*!< DWT CTRL: SYNCTAP Position */
S#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
S
S#define DWT_CTRL_CYCTAP_Pos                 9                                          /*!< DWT CTRL: CYCTAP Position */
S#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
S
S#define DWT_CTRL_POSTINIT_Pos               5                                          /*!< DWT CTRL: POSTINIT Position */
S#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
S
S#define DWT_CTRL_POSTPRESET_Pos             1                                          /*!< DWT CTRL: POSTPRESET Position */
S#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
S
S#define DWT_CTRL_CYCCNTENA_Pos              0                                          /*!< DWT CTRL: CYCCNTENA Position */
S#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL << DWT_CTRL_CYCCNTENA_Pos)           /*!< DWT CTRL: CYCCNTENA Mask */
S
S/* DWT CPI Count Register Definitions */
S#define DWT_CPICNT_CPICNT_Pos               0                                          /*!< DWT CPICNT: CPICNT Position */
S#define DWT_CPICNT_CPICNT_Msk              (0xFFUL << DWT_CPICNT_CPICNT_Pos)           /*!< DWT CPICNT: CPICNT Mask */
S
S/* DWT Exception Overhead Count Register Definitions */
S#define DWT_EXCCNT_EXCCNT_Pos               0                                          /*!< DWT EXCCNT: EXCCNT Position */
S#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL << DWT_EXCCNT_EXCCNT_Pos)           /*!< DWT EXCCNT: EXCCNT Mask */
S
S/* DWT Sleep Count Register Definitions */
S#define DWT_SLEEPCNT_SLEEPCNT_Pos           0                                          /*!< DWT SLEEPCNT: SLEEPCNT Position */
S#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL << DWT_SLEEPCNT_SLEEPCNT_Pos)       /*!< DWT SLEEPCNT: SLEEPCNT Mask */
S
S/* DWT LSU Count Register Definitions */
S#define DWT_LSUCNT_LSUCNT_Pos               0                                          /*!< DWT LSUCNT: LSUCNT Position */
S#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL << DWT_LSUCNT_LSUCNT_Pos)           /*!< DWT LSUCNT: LSUCNT Mask */
S
S/* DWT Folded-instruction Count Register Definitions */
S#define DWT_FOLDCNT_FOLDCNT_Pos             0                                          /*!< DWT FOLDCNT: FOLDCNT Position */
S#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL << DWT_FOLDCNT_FOLDCNT_Pos)         /*!< DWT FOLDCNT: FOLDCNT Mask */
S
S/* DWT Comparator Mask Register Definitions */
S#define DWT_MASK_MASK_Pos                   0                                          /*!< DWT MASK: MASK Position */
S#define DWT_MASK_MASK_Msk                  (0x1FUL << DWT_MASK_MASK_Pos)               /*!< DWT MASK: MASK Mask */
S
S/* DWT Comparator Function Register Definitions */
S#define DWT_FUNCTION_MATCHED_Pos           24                                          /*!< DWT FUNCTION: MATCHED Position */
S#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
S
S#define DWT_FUNCTION_DATAVADDR1_Pos        16                                          /*!< DWT FUNCTION: DATAVADDR1 Position */
S#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
S
S#define DWT_FUNCTION_DATAVADDR0_Pos        12                                          /*!< DWT FUNCTION: DATAVADDR0 Position */
S#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
S
S#define DWT_FUNCTION_DATAVSIZE_Pos         10                                          /*!< DWT FUNCTION: DATAVSIZE Position */
S#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
S
S#define DWT_FUNCTION_LNK1ENA_Pos            9                                          /*!< DWT FUNCTION: LNK1ENA Position */
S#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
S
S#define DWT_FUNCTION_DATAVMATCH_Pos         8                                          /*!< DWT FUNCTION: DATAVMATCH Position */
S#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
S
S#define DWT_FUNCTION_CYCMATCH_Pos           7                                          /*!< DWT FUNCTION: CYCMATCH Position */
S#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
S
S#define DWT_FUNCTION_EMITRANGE_Pos          5                                          /*!< DWT FUNCTION: EMITRANGE Position */
S#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
S
S#define DWT_FUNCTION_FUNCTION_Pos           0                                          /*!< DWT FUNCTION: FUNCTION Position */
S#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL << DWT_FUNCTION_FUNCTION_Pos)        /*!< DWT FUNCTION: FUNCTION Mask */
S
S/*@}*/ /* end of group CMSIS_DWT */
S
S
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_TPI     Trace Port Interface (TPI)
S    \brief      Type definitions for the Trace Port Interface (TPI)
S  @{
S */
S
S/** \brief  Structure type to access the Trace Port Interface Register (TPI).
S */
Stypedef struct
S{
S  __IO uint32_t SSPSR;                   /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register     */
S  __IO uint32_t CSPSR;                   /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
S       uint32_t RESERVED0[2];
S  __IO uint32_t ACPR;                    /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
S       uint32_t RESERVED1[55];
S  __IO uint32_t SPPR;                    /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
S       uint32_t RESERVED2[131];
S  __I  uint32_t FFSR;                    /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
S  __IO uint32_t FFCR;                    /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
S  __I  uint32_t FSCR;                    /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
S       uint32_t RESERVED3[759];
S  __I  uint32_t TRIGGER;                 /*!< Offset: 0xEE8 (R/ )  TRIGGER */
S  __I  uint32_t FIFO0;                   /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
S  __I  uint32_t ITATBCTR2;               /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
S       uint32_t RESERVED4[1];
S  __I  uint32_t ITATBCTR0;               /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
S  __I  uint32_t FIFO1;                   /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
S  __IO uint32_t ITCTRL;                  /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
S       uint32_t RESERVED5[39];
S  __IO uint32_t CLAIMSET;                /*!< Offset: 0xFA0 (R/W)  Claim tag set */
S  __IO uint32_t CLAIMCLR;                /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
S       uint32_t RESERVED7[8];
S  __I  uint32_t DEVID;                   /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
S  __I  uint32_t DEVTYPE;                 /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
S} TPI_Type;
S
S/* TPI Asynchronous Clock Prescaler Register Definitions */
S#define TPI_ACPR_PRESCALER_Pos              0                                          /*!< TPI ACPR: PRESCALER Position */
S#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL << TPI_ACPR_PRESCALER_Pos)        /*!< TPI ACPR: PRESCALER Mask */
S
S/* TPI Selected Pin Protocol Register Definitions */
S#define TPI_SPPR_TXMODE_Pos                 0                                          /*!< TPI SPPR: TXMODE Position */
S#define TPI_SPPR_TXMODE_Msk                (0x3UL << TPI_SPPR_TXMODE_Pos)              /*!< TPI SPPR: TXMODE Mask */
S
S/* TPI Formatter and Flush Status Register Definitions */
S#define TPI_FFSR_FtNonStop_Pos              3                                          /*!< TPI FFSR: FtNonStop Position */
S#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
S
S#define TPI_FFSR_TCPresent_Pos              2                                          /*!< TPI FFSR: TCPresent Position */
S#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
S
S#define TPI_FFSR_FtStopped_Pos              1                                          /*!< TPI FFSR: FtStopped Position */
S#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
S
S#define TPI_FFSR_FlInProg_Pos               0                                          /*!< TPI FFSR: FlInProg Position */
S#define TPI_FFSR_FlInProg_Msk              (0x1UL << TPI_FFSR_FlInProg_Pos)            /*!< TPI FFSR: FlInProg Mask */
S
S/* TPI Formatter and Flush Control Register Definitions */
S#define TPI_FFCR_TrigIn_Pos                 8                                          /*!< TPI FFCR: TrigIn Position */
S#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
S
S#define TPI_FFCR_EnFCont_Pos                1                                          /*!< TPI FFCR: EnFCont Position */
S#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
S
S/* TPI TRIGGER Register Definitions */
S#define TPI_TRIGGER_TRIGGER_Pos             0                                          /*!< TPI TRIGGER: TRIGGER Position */
S#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL << TPI_TRIGGER_TRIGGER_Pos)          /*!< TPI TRIGGER: TRIGGER Mask */
S
S/* TPI Integration ETM Data Register Definitions (FIFO0) */
S#define TPI_FIFO0_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO0: ITM_ATVALID Position */
S#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
S
S#define TPI_FIFO0_ITM_bytecount_Pos        27                                          /*!< TPI FIFO0: ITM_bytecount Position */
S#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
S
S#define TPI_FIFO0_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO0: ETM_ATVALID Position */
S#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
S
S#define TPI_FIFO0_ETM_bytecount_Pos        24                                          /*!< TPI FIFO0: ETM_bytecount Position */
S#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
S
S#define TPI_FIFO0_ETM2_Pos                 16                                          /*!< TPI FIFO0: ETM2 Position */
S#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
S
S#define TPI_FIFO0_ETM1_Pos                  8                                          /*!< TPI FIFO0: ETM1 Position */
S#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
S
S#define TPI_FIFO0_ETM0_Pos                  0                                          /*!< TPI FIFO0: ETM0 Position */
S#define TPI_FIFO0_ETM0_Msk                 (0xFFUL << TPI_FIFO0_ETM0_Pos)              /*!< TPI FIFO0: ETM0 Mask */
S
S/* TPI ITATBCTR2 Register Definitions */
S#define TPI_ITATBCTR2_ATREADY_Pos           0                                          /*!< TPI ITATBCTR2: ATREADY Position */
S#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL << TPI_ITATBCTR2_ATREADY_Pos)        /*!< TPI ITATBCTR2: ATREADY Mask */
S
S/* TPI Integration ITM Data Register Definitions (FIFO1) */
S#define TPI_FIFO1_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO1: ITM_ATVALID Position */
S#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
S
S#define TPI_FIFO1_ITM_bytecount_Pos        27                                          /*!< TPI FIFO1: ITM_bytecount Position */
S#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
S
S#define TPI_FIFO1_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO1: ETM_ATVALID Position */
S#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
S
S#define TPI_FIFO1_ETM_bytecount_Pos        24                                          /*!< TPI FIFO1: ETM_bytecount Position */
S#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
S
S#define TPI_FIFO1_ITM2_Pos                 16                                          /*!< TPI FIFO1: ITM2 Position */
S#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
S
S#define TPI_FIFO1_ITM1_Pos                  8                                          /*!< TPI FIFO1: ITM1 Position */
S#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
S
S#define TPI_FIFO1_ITM0_Pos                  0                                          /*!< TPI FIFO1: ITM0 Position */
S#define TPI_FIFO1_ITM0_Msk                 (0xFFUL << TPI_FIFO1_ITM0_Pos)              /*!< TPI FIFO1: ITM0 Mask */
S
S/* TPI ITATBCTR0 Register Definitions */
S#define TPI_ITATBCTR0_ATREADY_Pos           0                                          /*!< TPI ITATBCTR0: ATREADY Position */
S#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL << TPI_ITATBCTR0_ATREADY_Pos)        /*!< TPI ITATBCTR0: ATREADY Mask */
S
S/* TPI Integration Mode Control Register Definitions */
S#define TPI_ITCTRL_Mode_Pos                 0                                          /*!< TPI ITCTRL: Mode Position */
S#define TPI_ITCTRL_Mode_Msk                (0x1UL << TPI_ITCTRL_Mode_Pos)              /*!< TPI ITCTRL: Mode Mask */
S
S/* TPI DEVID Register Definitions */
S#define TPI_DEVID_NRZVALID_Pos             11                                          /*!< TPI DEVID: NRZVALID Position */
S#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
S
S#define TPI_DEVID_MANCVALID_Pos            10                                          /*!< TPI DEVID: MANCVALID Position */
S#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
S
S#define TPI_DEVID_PTINVALID_Pos             9                                          /*!< TPI DEVID: PTINVALID Position */
S#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
S
S#define TPI_DEVID_MinBufSz_Pos              6                                          /*!< TPI DEVID: MinBufSz Position */
S#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
S
S#define TPI_DEVID_AsynClkIn_Pos             5                                          /*!< TPI DEVID: AsynClkIn Position */
S#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
S
S#define TPI_DEVID_NrTraceInput_Pos          0                                          /*!< TPI DEVID: NrTraceInput Position */
S#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL << TPI_DEVID_NrTraceInput_Pos)      /*!< TPI DEVID: NrTraceInput Mask */
S
S/* TPI DEVTYPE Register Definitions */
S#define TPI_DEVTYPE_SubType_Pos             0                                          /*!< TPI DEVTYPE: SubType Position */
S#define TPI_DEVTYPE_SubType_Msk            (0xFUL << TPI_DEVTYPE_SubType_Pos)          /*!< TPI DEVTYPE: SubType Mask */
S
S#define TPI_DEVTYPE_MajorType_Pos           4                                          /*!< TPI DEVTYPE: MajorType Position */
S#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
S
S/*@}*/ /* end of group CMSIS_TPI */
S
S
S#if (__MPU_PRESENT == 1)
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
S    \brief      Type definitions for the Memory Protection Unit (MPU)
S  @{
S */
S
S/** \brief  Structure type to access the Memory Protection Unit (MPU).
S */
Stypedef struct
S{
S  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
S  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
S  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
S  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
S  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
S  __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register       */
S  __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
S  __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register       */
S  __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
S  __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register       */
S  __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
S} MPU_Type;
S
S/* MPU Type Register */
S#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
S#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
S
S#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
S#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
S
S#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
S#define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
S
S/* MPU Control Register */
S#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
S#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
S
S#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
S#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
S
S#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
S#define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
S
S/* MPU Region Number Register */
S#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
S#define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
S
S/* MPU Region Base Address Register */
S#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
S#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
S
S#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
S#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
S
S#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
S#define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
S
S/* MPU Region Attribute and Size Register */
S#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
S#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
S
S#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
S#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
S
S#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
S#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
S
S#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
S#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
S
S#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
S#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
S
S#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
S#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
S
S#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
S#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
S
S#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
S#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
S
S#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
S#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
S
S#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
S#define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU RASR: Region enable bit Disable Mask */
S
S/*@} end of group CMSIS_MPU */
S#endif
S
S
S#if (__FPU_PRESENT == 1)
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_FPU     Floating Point Unit (FPU)
S    \brief      Type definitions for the Floating Point Unit (FPU)
S  @{
S */
S
S/** \brief  Structure type to access the Floating Point Unit (FPU).
S */
Stypedef struct
S{
S       uint32_t RESERVED0[1];
S  __IO uint32_t FPCCR;                   /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register               */
S  __IO uint32_t FPCAR;                   /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register               */
S  __IO uint32_t FPDSCR;                  /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register        */
S  __I  uint32_t MVFR0;                   /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0                       */
S  __I  uint32_t MVFR1;                   /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1                       */
S} FPU_Type;
S
S/* Floating-Point Context Control Register */
S#define FPU_FPCCR_ASPEN_Pos                31                                             /*!< FPCCR: ASPEN bit Position */
S#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
S
S#define FPU_FPCCR_LSPEN_Pos                30                                             /*!< FPCCR: LSPEN Position */
S#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
S
S#define FPU_FPCCR_MONRDY_Pos                8                                             /*!< FPCCR: MONRDY Position */
S#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
S
S#define FPU_FPCCR_BFRDY_Pos                 6                                             /*!< FPCCR: BFRDY Position */
S#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
S
S#define FPU_FPCCR_MMRDY_Pos                 5                                             /*!< FPCCR: MMRDY Position */
S#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
S
S#define FPU_FPCCR_HFRDY_Pos                 4                                             /*!< FPCCR: HFRDY Position */
S#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
S
S#define FPU_FPCCR_THREAD_Pos                3                                             /*!< FPCCR: processor mode bit Position */
S#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
S
S#define FPU_FPCCR_USER_Pos                  1                                             /*!< FPCCR: privilege level bit Position */
S#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
S
S#define FPU_FPCCR_LSPACT_Pos                0                                             /*!< FPCCR: Lazy state preservation active bit Position */
S#define FPU_FPCCR_LSPACT_Msk               (1UL << FPU_FPCCR_LSPACT_Pos)                  /*!< FPCCR: Lazy state preservation active bit Mask */
S
S/* Floating-Point Context Address Register */
S#define FPU_FPCAR_ADDRESS_Pos               3                                             /*!< FPCAR: ADDRESS bit Position */
S#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
S
S/* Floating-Point Default Status Control Register */
S#define FPU_FPDSCR_AHP_Pos                 26                                             /*!< FPDSCR: AHP bit Position */
S#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
S
S#define FPU_FPDSCR_DN_Pos                  25                                             /*!< FPDSCR: DN bit Position */
S#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
S
S#define FPU_FPDSCR_FZ_Pos                  24                                             /*!< FPDSCR: FZ bit Position */
S#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
S
S#define FPU_FPDSCR_RMode_Pos               22                                             /*!< FPDSCR: RMode bit Position */
S#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
S
S/* Media and FP Feature Register 0 */
S#define FPU_MVFR0_FP_rounding_modes_Pos    28                                             /*!< MVFR0: FP rounding modes bits Position */
S#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
S
S#define FPU_MVFR0_Short_vectors_Pos        24                                             /*!< MVFR0: Short vectors bits Position */
S#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
S
S#define FPU_MVFR0_Square_root_Pos          20                                             /*!< MVFR0: Square root bits Position */
S#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
S
S#define FPU_MVFR0_Divide_Pos               16                                             /*!< MVFR0: Divide bits Position */
S#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
S
S#define FPU_MVFR0_FP_excep_trapping_Pos    12                                             /*!< MVFR0: FP exception trapping bits Position */
S#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
S
S#define FPU_MVFR0_Double_precision_Pos      8                                             /*!< MVFR0: Double-precision bits Position */
S#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
S
S#define FPU_MVFR0_Single_precision_Pos      4                                             /*!< MVFR0: Single-precision bits Position */
S#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
S
S#define FPU_MVFR0_A_SIMD_registers_Pos      0                                             /*!< MVFR0: A_SIMD registers bits Position */
S#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL << FPU_MVFR0_A_SIMD_registers_Pos)      /*!< MVFR0: A_SIMD registers bits Mask */
S
S/* Media and FP Feature Register 1 */
S#define FPU_MVFR1_FP_fused_MAC_Pos         28                                             /*!< MVFR1: FP fused MAC bits Position */
S#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
S
S#define FPU_MVFR1_FP_HPFP_Pos              24                                             /*!< MVFR1: FP HPFP bits Position */
S#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
S
S#define FPU_MVFR1_D_NaN_mode_Pos            4                                             /*!< MVFR1: D_NaN mode bits Position */
S#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
S
S#define FPU_MVFR1_FtZ_mode_Pos              0                                             /*!< MVFR1: FtZ mode bits Position */
S#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL << FPU_MVFR1_FtZ_mode_Pos)              /*!< MVFR1: FtZ mode bits Mask */
S
S/*@} end of group CMSIS_FPU */
S#endif
S
S
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
S    \brief      Type definitions for the Core Debug Registers
S  @{
S */
S
S/** \brief  Structure type to access the Core Debug Register (CoreDebug).
S */
Stypedef struct
S{
S  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
S  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
S  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
S  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
S} CoreDebug_Type;
S
S/* Debug Halting Control and Status Register */
S#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
S#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
S
S#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
S#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
S
S#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
S#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
S
S#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
S#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
S
S#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
S#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
S
S#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
S#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
S
S#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
S#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
S
S#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
S#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
S
S#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
S#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
S
S#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
S#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
S
S#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
S#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
S
S#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
S#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
S
S/* Debug Core Register Selector Register */
S#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
S#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
S
S#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
S#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
S
S/* Debug Exception and Monitor Control Register */
S#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
S#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
S
S#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
S#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
S
S#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
S#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
S
S#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
S#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
S
S#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
S#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
S
S#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
S#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
S
S#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
S#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
S
S#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
S#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
S
S#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
S#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
S
S#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
S#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
S
S#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
S#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
S
S#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
S#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
S
S#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
S#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
S
S/*@} end of group CMSIS_CoreDebug */
S
S
S/** \ingroup    CMSIS_core_register
S    \defgroup   CMSIS_core_base     Core Definitions
S    \brief      Definitions for base addresses, unions, and structures.
S  @{
S */
S
S/* Memory mapping of Cortex-M4 Hardware */
S#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address  */
S#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address                   */
S#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address                   */
S#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address                   */
S#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address            */
S#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address               */
S#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                  */
S#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address  */
S
S#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
S#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
S#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
S#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
S#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct           */
S#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct           */
S#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct           */
S#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct    */
S
S#if (__MPU_PRESENT == 1)
S  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
S  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
S#endif
S
S#if (__FPU_PRESENT == 1)
S  #define FPU_BASE          (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit                */
S  #define FPU               ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit                */
S#endif
S
S/*@} */
S
S
S
S/*******************************************************************************
S *                Hardware Abstraction Layer
S  Core Function Interface contains:
S  - Core NVIC Functions
S  - Core SysTick Functions
S  - Core Debug Functions
S  - Core Register Access Functions
S ******************************************************************************/
S/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
S*/
S
S
S
S/* ##########################   NVIC functions  #################################### */
S/** \ingroup  CMSIS_Core_FunctionInterface
S    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
S    \brief      Functions that manage interrupts and exceptions via the NVIC.
S    @{
S */
S
S/** \brief  Set Priority Grouping
S
S  The function sets the priority grouping field using the required unlock sequence.
S  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
S  Only values from 0..7 are used.
S  In case of a conflict between priority grouping and available
S  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
S
S    \param [in]      PriorityGroup  Priority grouping field.
S */
S__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
S{
S  uint32_t reg_value;
S  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
S
S  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
S  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
S  reg_value  =  (reg_value                                 |
S                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
S                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
S  SCB->AIRCR =  reg_value;
S}
S
S
S/** \brief  Get Priority Grouping
S
S  The function reads the priority grouping field from the NVIC Interrupt Controller.
S
S    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
S */
S__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
S{
S  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
S}
S
S
S/** \brief  Enable External Interrupt
S
S    The function enables a device-specific interrupt in the NVIC interrupt controller.
S
S    \param [in]      IRQn  External interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
S{
S/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
S  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
S}
S
S
S/** \brief  Disable External Interrupt
S
S    The function disables a device-specific interrupt in the NVIC interrupt controller.
S
S    \param [in]      IRQn  External interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
S{
S  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
S}
S
S
S/** \brief  Get Pending Interrupt
S
S    The function reads the pending register in the NVIC and returns the pending bit
S    for the specified interrupt.
S
S    \param [in]      IRQn  Interrupt number.
S
S    \return             0  Interrupt status is not pending.
S    \return             1  Interrupt status is pending.
S */
S__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
S{
S  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
S}
S
S
S/** \brief  Set Pending Interrupt
S
S    The function sets the pending bit of an external interrupt.
S
S    \param [in]      IRQn  Interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
S{
S  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
S}
S
S
S/** \brief  Clear Pending Interrupt
S
S    The function clears the pending bit of an external interrupt.
S
S    \param [in]      IRQn  External interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
S{
S  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
S}
S
S
S/** \brief  Get Active Interrupt
S
S    The function reads the active register in NVIC and returns the active bit.
S
S    \param [in]      IRQn  Interrupt number.
S
S    \return             0  Interrupt status is not active.
S    \return             1  Interrupt status is active.
S */
S__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
S{
S  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
S}
S
S
S/** \brief  Set Interrupt Priority
S
S    The function sets the priority of an interrupt.
S
S    \note The priority cannot be set for every core interrupt.
S
S    \param [in]      IRQn  Interrupt number.
S    \param [in]  priority  Priority to set.
S */
S__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
S{
S  if(IRQn < 0) {
S    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
S  else {
S    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
S}
S
S
S/** \brief  Get Interrupt Priority
S
S    The function reads the priority of an interrupt. The interrupt
S    number can be positive to specify an external (device specific)
S    interrupt, or negative to specify an internal (core) interrupt.
S
S
S    \param [in]   IRQn  Interrupt number.
S    \return             Interrupt Priority. Value is aligned automatically to the implemented
S                        priority bits of the microcontroller.
S */
S__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
S{
S
S  if(IRQn < 0) {
S    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M  system interrupts */
S  else {
S    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
S}
S
S
S/** \brief  Encode Priority
S
S    The function encodes the priority for an interrupt with the given priority group,
S    preemptive priority value, and subpriority value.
S    In case of a conflict between priority grouping and available
S    priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
S
S    \param [in]     PriorityGroup  Used priority group.
S    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
S    \param [in]       SubPriority  Subpriority value (starting from 0).
S    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
S */
S__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
S{
S  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
S  uint32_t PreemptPriorityBits;
S  uint32_t SubPriorityBits;
S
S  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
S  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
S
S  return (
S           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
S           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
S         );
S}
S
S
S/** \brief  Decode Priority
S
S    The function decodes an interrupt priority value with a given priority group to
S    preemptive priority value and subpriority value.
S    In case of a conflict between priority grouping and available
S    priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
S
S    \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
S    \param [in]     PriorityGroup  Used priority group.
S    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
S    \param [out]     pSubPriority  Subpriority value (starting from 0).
S */
S__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
S{
S  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
S  uint32_t PreemptPriorityBits;
S  uint32_t SubPriorityBits;
S
S  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
S  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
S
S  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
S  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
S}
S
S
S/** \brief  System Reset
S
S    The function initiates a system reset request to reset the MCU.
S */
S__STATIC_INLINE void NVIC_SystemReset(void)
S{
S  __DSB();                                                     /* Ensure all outstanding memory accesses included
S                                                                  buffered write are completed before reset */
S  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
S                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
S                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
S  __DSB();                                                     /* Ensure completion of memory access */
S  while(1);                                                    /* wait until reset */
S}
S
S/*@} end of CMSIS_Core_NVICFunctions */
S
S
S
S/* ##################################    SysTick function  ############################################ */
S/** \ingroup  CMSIS_Core_FunctionInterface
S    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
S    \brief      Functions that configure the System.
S  @{
S */
S
S#if (__Vendor_SysTickConfig == 0)
S
S/** \brief  System Tick Configuration
S
S    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
S    Counter is in free running mode to generate periodic interrupts.
S
S    \param [in]  ticks  Number of ticks between two interrupts.
S
S    \return          0  Function succeeded.
S    \return          1  Function failed.
S
S    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
S    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
S    must contain a vendor-specific implementation of this function.
S
S */
S__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
S{
S  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
S
S  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
S  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
S  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
S  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
S                   SysTick_CTRL_TICKINT_Msk   |
S                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
S  return (0);                                                  /* Function successful */
S}
S
S#endif
S
S/*@} end of CMSIS_Core_SysTickFunctions */
S
S
S
S/* ##################################### Debug In/Output function ########################################### */
S/** \ingroup  CMSIS_Core_FunctionInterface
S    \defgroup CMSIS_core_DebugFunctions ITM Functions
S    \brief   Functions that access the ITM debug interface.
S  @{
S */
S
Sextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters.                         */
S#define                 ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
S
S
S/** \brief  ITM Send Character
S
S    The function transmits a character via the ITM channel 0, and
S    \li Just returns when no debugger is connected that has booked the output.
S    \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
S
S    \param [in]     ch  Character to transmit.
S
S    \returns            Character to transmit.
S */
S__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
S{
S  if ((ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
S      (ITM->TER & (1UL << 0)        )                    )     /* ITM Port #0 enabled */
S  {
S    while (ITM->PORT[0].u32 == 0);
S    ITM->PORT[0].u8 = (uint8_t) ch;
S  }
S  return (ch);
S}
S
S
S/** \brief  ITM Receive Character
S
S    The function inputs a character via the external variable \ref ITM_RxBuffer.
S
S    \return             Received character.
S    \return         -1  No character pending.
S */
S__STATIC_INLINE int32_t ITM_ReceiveChar (void) {
S  int32_t ch = -1;                           /* no character available */
S
S  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
S    ch = ITM_RxBuffer;
S    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
S  }
S
S  return (ch);
S}
S
S
S/** \brief  ITM Check Character
S
S    The function checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
S
S    \return          0  No character available.
S    \return          1  Character available.
S */
S__STATIC_INLINE int32_t ITM_CheckChar (void) {
S
S  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
S    return (0);                                 /* no character available */
S  } else {
S    return (1);                                 /*    character available */
S  }
S}
S
S/*@} end of CMSIS_core_DebugFunctions */
S
S
S
S
S#ifdef __cplusplus
S}
S#endif
S
S#endif /* __CORE_CM4_H_DEPENDANT */
S
N#endif /* __CMSIS_GENERIC */
L 290 "..\..\..\..\..\..\COMMON\SRC\CMSIS_DSP_4_5\inc\arm_math.h" 2
N#elif defined (ARM_MATH_CM3)
S  #include "core_cm3.h"
S#elif defined (ARM_MATH_CM0)
S  #include "core_cm0.h"
S#define ARM_MATH_CM0_FAMILY
S  #elif defined (ARM_MATH_CM0PLUS)
S#include "core_cm0plus.h"
S  #define ARM_MATH_CM0_FAMILY
S#else
S  #error "Define according the used Cortex core ARM_MATH_CM7, ARM_MATH_CM4, ARM_MATH_CM3, ARM_MATH_CM0PLUS or ARM_MATH_CM0"
N#endif
N
N#undef  __CMSIS_GENERIC         /* enable NVIC and Systick functions */
N#include "string.h"
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060019
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 304 "..\..\..\..\..\..\COMMON\SRC\CMSIS_DSP_4_5\inc\arm_math.h" 2
N#include "math.h"
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006,2014 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision$ Codemist 0.03
N * Checkin $Date$
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N#define __ARMCLIB_VERSION 5060019
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X  #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#ifdef __TARGET_ARCH_AARCH64
S# define _ARMABI_SOFTFP __declspec(__nothrow)
N#else
N# define _ARMABI_SOFTFP __declspec(__nothrow) __attribute__((__pcs__("aapcs")))
N# define __HAVE_LONGDOUBLE 1
N#endif
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __attribute__((const))
N#endif
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF inline
S#elif defined __GNUC__ || defined _USE_STATIC_INLINE
X#elif 0L || 0L
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
N#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif (1L && 199901L <= 199901L)
N#define _ARMABI_INLINE inline
N#define _ARMABI_INLINE_DEF static inline
N#else
S#define _ARMABI_INLINE __inline
S#define _ARMABI_INLINE_DEF __inline
N#endif
N
N#ifdef __TARGET_ARCH_AARCH64
S#  define _SOFTFP
N#else
N#  define _SOFTFP __attribute__((__pcs__("aapcs")))
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#if defined(__ARM_BIG_ENDIAN) || defined(__BIG_ENDIAN)
X#if 0L || 0L
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N#   ifdef __cplusplus
S      extern "C" {
N#   endif /* __cplusplus */
N
Nextern _SOFTFP unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_dcmp4(double  , double  );
Nextern _SOFTFP unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_fcmp4(float  , float  );
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
S      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
S      namespace std {
S#       define __CLIBNS ::std::
S        extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#ifndef __has_builtin
N  #define __has_builtin(x) 0
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#if __has_builtin(__builtin_inf)
X#if 0
S#   define HUGE_VALF __builtin_inff()
S#   define HUGE_VALL __builtin_infl()
S#   define INFINITY __builtin_inff()
S#   define NAN __builtin_nanf("")
N# else
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N#endif
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#if __has_builtin(__builtin_inf)
X#if 0
S# define HUGE_VAL __builtin_inf()
N#else
N# define HUGE_VAL ((double)__INFINITY__)
N#endif
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !0L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 1L && !0L
N    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
X    inline float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
S    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __attribute__((const)) double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
Xinline __declspec(__nothrow) __attribute__((const)) double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
Xinline __declspec(__nothrow) __attribute__((const)) float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __attribute__((const)) float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
Xinline __declspec(__nothrow) __attribute__((const)) float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
X#if (0L && !0L) || 1L
N/*
N * Functions new in C99.
N */
Nextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Xextern __declspec(__nothrow) double exp2(double  );  
Nextern _ARMABI float exp2f(float /*x*/);
Xextern __declspec(__nothrow) float exp2f(float  );
N_ARMDEFLD1(exp2);
X__declspec(__nothrow) long double exp2l(long double );
Nextern _ARMABI double fdim(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fdim(double  , double  );
Nextern _ARMABI float fdimf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fdimf(float  , float  );
N_ARMDEFLD2(fdim);
X__declspec(__nothrow) long double fdiml(long double , long double );
N#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
N#endif
N#ifdef __FP_FAST_FMAF
N#define FP_FAST_FMAF
N#endif
N#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
N#endif
Nextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Xextern __declspec(__nothrow) double fma(double  , double  , double  );
Nextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
Xextern __declspec(__nothrow) float fmaf(float  , float  , float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
N    { return (long double)fma((double)__x, (double)__y, (double)__z); }
Xinline __declspec(__nothrow) long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
N#endif
Nextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fmax(double  , double  );
Nextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) float fmaxf(float  , float  );
N_ARMDEFLD2(fmax);
X__declspec(__nothrow) long double fmaxl(long double , long double );
Nextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fmin(double  , double  );
Nextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) float fminf(float  , float  );
N_ARMDEFLD2(fmin);
X__declspec(__nothrow) long double fminl(long double , long double );
Nextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Xextern __declspec(__nothrow) double log2(double  );  
Nextern _ARMABI float log2f(float /*x*/);
Xextern __declspec(__nothrow) float log2f(float  );
N_ARMDEFLD1(log2);
X__declspec(__nothrow) long double log2l(long double );
Nextern _ARMABI long lrint(double /*x*/);
Xextern __declspec(__nothrow) long lrint(double  );
Nextern _ARMABI long lrintf(float /*x*/);
Xextern __declspec(__nothrow) long lrintf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
N    { return lrint((double)__x); }
Xinline __declspec(__nothrow) long lrintl(long double __x)     { return lrint((double)__x); }
N#endif
Nextern _ARMABI __LONGLONG llrint(double /*x*/);
Xextern __declspec(__nothrow) long long llrint(double  );
Nextern _ARMABI __LONGLONG llrintf(float /*x*/);
Xextern __declspec(__nothrow) long long llrintf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x) \
N    { return llrint((double)__x); }
Xinline __declspec(__nothrow) long long llrintl(long double __x)     { return llrint((double)__x); }
N#endif
Nextern _ARMABI long lround(double /*x*/);
Xextern __declspec(__nothrow) long lround(double  );
Nextern _ARMABI long lroundf(float /*x*/);
Xextern __declspec(__nothrow) long lroundf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
N    { return lround((double)__x); }
Xinline __declspec(__nothrow) long lroundl(long double __x)     { return lround((double)__x); }
N#endif
Nextern _ARMABI __LONGLONG llround(double /*x*/);
Xextern __declspec(__nothrow) long long llround(double  );
Nextern _ARMABI __LONGLONG llroundf(float /*x*/);
Xextern __declspec(__nothrow) long long llroundf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x) \
N    { return llround((double)__x); }
Xinline __declspec(__nothrow) long long llroundl(long double __x)     { return llround((double)__x); }
N#endif
Nextern _ARMABI_PURE double nan(const char */*tagp*/);
Xextern __declspec(__nothrow) __attribute__((const)) double nan(const char * );
Nextern _ARMABI_PURE float nanf(const char */*tagp*/);
Xextern __declspec(__nothrow) __attribute__((const)) float nanf(const char * );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
N    { return (long double)nan(__t); }
Xinline __declspec(__nothrow) __attribute__((const)) long double nanl(const char *__t)     { return (long double)nan(__t); }
N#endif
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif
N#endif 
Nextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double nearbyint(double  );
Nextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float nearbyintf(float  );
N_ARMDEFLD1(nearbyint);
X__declspec(__nothrow) long double nearbyintl(long double );
Nextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Nextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
N    { return (long double)remquo((double)__x, (double)__y, __q); }
Xinline long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
N#endif
Nextern _ARMABI_FPEXCEPT double round(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double round(double  );
Nextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float roundf(float  );
N_ARMDEFLD1(round);
X__declspec(__nothrow) long double roundl(long double );
Nextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Xextern __declspec(__nothrow) double tgamma(double  );  
Nextern _ARMABI float tgammaf(float /*x*/);
Xextern __declspec(__nothrow) float tgammaf(float  );
N_ARMDEFLD1(tgamma);
X__declspec(__nothrow) long double tgammal(long double );
Nextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double trunc(double  );
Nextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float truncf(float  );
N_ARMDEFLD1(trunc);
X__declspec(__nothrow) long double truncl(long double );
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#if defined(__cplusplus) && ((!defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)) || defined(__ARMCOMPILER_LIBCXX))
X#if 0L && ((!0L || 1L) || 0L)
S  extern "C++" {
S    inline int (fpclassify)(double __x) { return fpclassify(__x); }
S    inline bool (isfinite)(double __x) { return isfinite(__x); }
S    inline bool (isgreater)(double __x, double __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(double __x, double __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(double __x) { return isinf(__x); }
S    inline bool (isless)(double __x, double __y) { return isless(__x, __y); }
S    inline bool (islessequal)(double __x, double __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(double __x, double __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(double __x) { return isnan(__x); }
S    inline bool (isnormal)(double __x) { return isnormal(__x); }
S    inline bool (isunordered)(double __x, double __y) { return isunordered(__x, __y); }
S
S  }
N#endif
N
N#if defined(__cplusplus) && !defined(__ARMCOMPILER_LIBCXX)
X#if 0L && !0L
S  extern "C++" {
S    inline float abs(float __x)   { return fabsf(__x); }
S    inline float acos(float __x)  { return acosf(__x); }
S    inline float asin(float __x)  { return asinf(__x); }
S    inline float atan(float __x)  { return atanf(__x); }
S    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
S    inline float ceil(float __x)  { return ceilf(__x); }
S    inline float cos(float __x)   { return cosf(__x); }
S    inline float cosh(float __x)  { return coshf(__x); }
S    inline float exp(float __x)   { return expf(__x); }
S    inline float fabs(float __x)  { return fabsf(__x); }
S    inline float floor(float __x) { return floorf(__x); }
S    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
S    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
S    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
S    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
S    inline float log(float __x)   { return logf(__x); }
S    inline float log10(float __x) { return log10f(__x); }
S    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
S    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
S    inline float pow(float __x, float __y)      { return powf(__x,__y); }
S    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
S    inline float sin(float __x)   { return sinf(__x); }
S    inline float sinh(float __x)  { return sinhf(__x); }
S    inline float sqrt(float __x)  { return sqrtf(__x); }
S    inline float _sqrt(float __x) { return _sqrtf(__x); }
S    inline float tan(float __x)   { return tanf(__x); }
S    inline float tanh(float __x)  { return tanhf(__x); }
S
S    inline double abs(double __x) { return fabs(__x); }
S    inline double pow(double __x, int __y)
S                { return pow(__x, (double) __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double abs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double acos(long double __x)
S                { return (long double)acosl(__x); }
S    inline long double asin(long double __x)
S                { return (long double)asinl(__x); }
S    inline long double atan(long double __x)
S                { return (long double)atanl(__x); }
S    inline long double atan2(long double __y, long double __x)
S                { return (long double)atan2l(__y, __x); }
S    inline long double ceil(long double __x)
S                { return (long double)ceill( __x); }
S    inline long double cos(long double __x)
S                { return (long double)cosl(__x); }
S    inline long double cosh(long double __x)
S                { return (long double)coshl(__x); }
S    inline long double exp(long double __x)
S                { return (long double)expl(__x); }
S    inline long double fabs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double floor(long double __x)
S                { return (long double)floorl(__x); }
S    inline long double fmod(long double __x, long double __y)
S                { return (long double)fmodl(__x, __y); }
S    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
S    inline long double frexp(long double __x, int* __p)
S                { return (long double)frexpl(__x, __p); }
S    inline long double ldexp(long double __x, int __exp)
S                { return (long double)ldexpl(__x, __exp); }
S    inline long double log(long double __x)
S                { return (long double)logl(__x); }
S    inline long double log10(long double __x)
S                { return (long double)log10l(__x); }
S    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
S    inline long double modf(long double __x, long double* __p)
S                { return (long double)modfl(__x, __p); }
S    inline long double pow(long double __x, long double __y)
S                { return (long double)powl(__x, __y); }
S    inline long double pow(long double __x, int __y)
S                { return (long double)powl(__x, __y); }
S    inline long double sin(long double __x)
S                { return (long double)sinl(__x); }
S    inline long double sinh(long double __x)
S                { return (long double)sinhl(__x); }
S    inline long double sqrt(long double __x)
S                { return (long double)sqrtl(__x); }
S    inline long double _sqrt(long double __x)
S                { return (long double)_sqrt((double) __x); }
S    inline long double tan(long double __x)
S                { return (long double)tanl(__x); }
S    inline long double tanh(long double __x)
S                { return (long double)tanhl(__x); }
S#endif
S
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S    inline float acosh(float __x) { return acoshf(__x); }
S    inline float asinh(float __x) { return asinhf(__x); }
S    inline float atanh(float __x) { return atanhf(__x); }
S    inline float cbrt(float __x) { return cbrtf(__x); }
S    inline float erf(float __x) { return erff(__x); }
S    inline float erfc(float __x) { return erfcf(__x); }
S    inline float expm1(float __x) { return expm1f(__x); }
S    inline float log1p(float __x) { return log1pf(__x); }
S    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
S    inline float lgamma(float __x) { return lgammaf(__x); }
S    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
S    inline float rint(float __x) { return rintf(__x); }
S#endif
S
S#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __LONGLONG llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __LONGLONG llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S    inline int (fpclassify)(float __x) { return fpclassify(__x); }
S    inline bool (isfinite)(float __x) { return isfinite(__x); }
S    inline bool (isgreater)(float __x, float __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(float __x, float __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(float __x) { return isinf(__x); }
S    inline bool (isless)(float __x, float __y) { return isless(__x, __y); }
S    inline bool (islessequal)(float __x, float __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(float __x, float __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(float __x) { return isnan(__x); }
S    inline bool (isnormal)(float __x) { return isnormal(__x); }
S    inline bool (isunordered)(float __x, float __y) { return isunordered(__x, __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __LONGLONG llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __LONGLONG llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S    inline int (fpclassify)(long double __x) { return fpclassify(__x); }
S    inline bool (isfinite)(long double __x) { return isfinite(__x); }
S    inline bool (isgreater)(long double __x, long double __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(long double __x, long double __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(long double __x) { return isinf(__x); }
S    inline bool (isless)(long double __x, long double __y) { return isless(__x, __y); }
S    inline bool (islessequal)(long double __x, long double __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(long double __x, long double __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(long double __x) { return isnan(__x); }
S    inline bool (isnormal)(long double __x) { return isnormal(__x); }
S    inline bool (isunordered)(long double __x, long double __y) { return isunordered(__x, __y); }
S#endif
S
S#undef fpclassify
S#undef isfinite
S#undef isgreater
S#undef isgreaterequal
S#undef isinf
S#undef isless
S#undef islessequal
S#undef islessgreater
S#undef isnan
S#undef isnormal
S#undef isunordered
S
S#endif
S
S  }
N#endif
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::__use_accurate_range_reduction;
S    #ifndef __ARMCOMPILER_LIBCXX
S      using ::std::abs;
S    #endif
S    using ::std::acos;
S    using ::std::asin;
S    using ::std::atan2;
S    using ::std::atan;
S    using ::std::ceil;
S    using ::std::cos;
S    using ::std::cosh;
S    using ::std::exp;
S    using ::std::fabs;
S    using ::std::floor;
S    using ::std::fmod;
S    using ::std::frexp;
S    using ::std::ldexp;
S    using ::std::log10;
S    using ::std::log;
S    using ::std::modf;
S    using ::std::pow;
S    using ::std::sin;
S    using ::std::sinh;
S    using ::std::sqrt;
S    using ::std::_sqrt;
S    using ::std::_sqrtf;
S    using ::std::tan;
S    using ::std::tanh;
S    using ::std::_fabsf;
S    /* C99 float and long double versions in already-C89-reserved namespace */
S    using ::std::acosf;
S    using ::std::acosl;
S    using ::std::asinf;
S    using ::std::asinl;
S    using ::std::atan2f;
S    using ::std::atan2l;
S    using ::std::atanf;
S    using ::std::atanl;
S    using ::std::ceilf;
S    using ::std::ceill;
S    using ::std::cosf;
S    using ::std::coshf;
S    using ::std::coshl;
S    using ::std::cosl;
S    using ::std::expf;
S    using ::std::expl;
S    using ::std::fabsf;
S    using ::std::fabsl;
S    using ::std::floorf;
S    using ::std::floorl;
S    using ::std::fmodf;
S    using ::std::fmodl;
S    using ::std::frexpf;
S    using ::std::frexpl;
S    using ::std::ldexpf;
S    using ::std::ldexpl;
S    using ::std::log10f;
S    using ::std::log10l;
S    using ::std::logf;
S    using ::std::logl;
S    using ::std::modff;
S    using ::std::modfl;
S    using ::std::powf;
S    using ::std::powl;
S    using ::std::sinf;
S    using ::std::sinhf;
S    using ::std::sinhl;
S    using ::std::sinl;
S    using ::std::sqrtf;
S    using ::std::sqrtl;
S    using ::std::tanf;
S    using ::std::tanhf;
S    using ::std::tanhl;
S    using ::std::tanl;
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which for historical reasons appear in non-strict mode */
S      using ::std::acosh;
S      using ::std::asinh;
S      using ::std::atanh;
S      using ::std::cbrt;
S      using ::std::copysign;
S      using ::std::copysignf;
S      using ::std::erf;
S      using ::std::erfc;
S      using ::std::expm1;
S      using ::std::hypot;
S      using ::std::ilogb;
S      using ::std::ilogbf;
S      using ::std::ilogbl;
S      using ::std::lgamma;
S      using ::std::log1p;
S      using ::std::logb;
S      using ::std::logbf;
S      using ::std::logbl;
S      using ::std::nextafter;
S      using ::std::nextafterf;
S      using ::std::nextafterl;
S      using ::std::nexttoward;
S      using ::std::nexttowardf;
S      using ::std::nexttowardl;
S      using ::std::remainder;
S      using ::std::rint;
S      using ::std::scalbln;
S      using ::std::scalblnf;
S      using ::std::scalblnl;
S      using ::std::scalbn;
S      using ::std::scalbnf;
S      using ::std::scalbnl;
S      using ::std::math_errhandling;
S      using ::std::acoshf;
S      using ::std::acoshl;
S      using ::std::asinhf;
S      using ::std::asinhl;
S      using ::std::atanhf;
S      using ::std::atanhl;
S      using ::std::copysignl;
S      using ::std::cbrtf;
S      using ::std::cbrtl;
S      using ::std::erff;
S      using ::std::erfl;
S      using ::std::erfcf;
S      using ::std::erfcl;
S      using ::std::expm1f;
S      using ::std::expm1l;
S      using ::std::log1pf;
S      using ::std::log1pl;
S      using ::std::hypotf;
S      using ::std::hypotl;
S      using ::std::lgammaf;
S      using ::std::lgammal;
S      using ::std::remainderf;
S      using ::std::remainderl;
S      using ::std::rintf;
S      using ::std::rintl;
S      /* New in C99. */
S      using ::std::float_t;
S      using ::std::double_t;
S    #endif
S    #if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::fmal;
S#endif
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lrintl;
S#endif
S      using ::std::llrint;
S      using ::std::llrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llrintl;
S#endif
S      using ::std::lround;
S      using ::std::lroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lroundl;
S#endif
S      using ::std::llround;
S      using ::std::llroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llroundl;
S#endif
S      using ::std::nan;
S      using ::std::nanf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::nanl;
S#endif
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::remquol;
S#endif
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
S    #endif
S
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      using ::std::fpclassify;
S      using ::std::isfinite;
S      using ::std::isgreater;
S      using ::std::isgreaterequal;
S      using ::std::isinf;
S      using ::std::isless;
S      using ::std::islessequal;
S      using ::std::islessgreater;
S      using ::std::isnan;
S      using ::std::isnormal;
S      using ::std::isunordered;
S    #endif
N  #endif
N
N#undef __LONGLONG
N
N#endif /* __math_h */
N
N/* end of math.h */
L 305 "..\..\..\..\..\..\COMMON\SRC\CMSIS_DSP_4_5\inc\arm_math.h" 2
N#ifdef	__cplusplus
Sextern "C"
S{
N#endif
N
N
N  /**
N   * @brief Macros required for reciprocal calculation in Normalized LMS
N   */
N
N#define DELTA_Q31 			(0x100)
N#define DELTA_Q15 			0x5
N#define INDEX_MASK 			0x0000003F
N#ifndef PI
N#define PI					3.14159265358979f
N#endif
N
N  /**
N   * @brief Macros required for SINE and COSINE Fast math approximations
N   */
N
N#define FAST_MATH_TABLE_SIZE  512
N#define FAST_MATH_Q31_SHIFT   (32 - 10)
N#define FAST_MATH_Q15_SHIFT   (16 - 10)
N#define CONTROLLER_Q31_SHIFT  (32 - 9)
N#define TABLE_SIZE  256
N#define TABLE_SPACING_Q31	   0x400000
N#define TABLE_SPACING_Q15	   0x80
N
N  /**
N   * @brief Macros required for SINE and COSINE Controller functions
N   */
N  /* 1.31(q31) Fixed value of 2/360 */
N  /* -1 to +1 is divided into 360 values so total spacing is (2/360) */
N#define INPUT_SPACING			0xB60B61
N
N  /**
N   * @brief Macro for Unaligned Support
N   */
N#ifndef UNALIGNED_SUPPORT_DISABLE
N    #define ALIGN4
N#else
S  #if defined  (__GNUC__)
S    #define ALIGN4 __attribute__((aligned(4)))
S  #else
S    #define ALIGN4 __align(4)
S  #endif
N#endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
N
N  /**
N   * @brief Error status returned by some functions in the library.
N   */
N
N  typedef enum
N  {
N    ARM_MATH_SUCCESS = 0,                /**< No error */
N    ARM_MATH_ARGUMENT_ERROR = -1,        /**< One or more arguments are incorrect */
N    ARM_MATH_LENGTH_ERROR = -2,          /**< Length of data buffer is incorrect */
N    ARM_MATH_SIZE_MISMATCH = -3,         /**< Size of matrices is not compatible with the operation. */
N    ARM_MATH_NANINF = -4,                /**< Not-a-number (NaN) or infinity is generated */
N    ARM_MATH_SINGULAR = -5,              /**< Generated by matrix inversion if the input matrix is singular and cannot be inverted. */
N    ARM_MATH_TEST_FAILURE = -6           /**< Test Failed  */
N  } arm_status;
N
N  /**
N   * @brief 8-bit fractional data type in 1.7 format.
N   */
N  typedef int8_t q7_t;
N
N  /**
N   * @brief 16-bit fractional data type in 1.15 format.
N   */
N  typedef int16_t q15_t;
N
N  /**
N   * @brief 32-bit fractional data type in 1.31 format.
N   */
N  typedef int32_t q31_t;
N
N  /**
N   * @brief 64-bit fractional data type in 1.63 format.
N   */
N  typedef int64_t q63_t;
N
N  /**
N   * @brief 32-bit floating-point type definition.
N   */
N  typedef float float32_t;
N
N  /**
N   * @brief 64-bit floating-point type definition.
N   */
N  typedef double float64_t;
N
N  /**
N   * @brief definition to read/write two 16 bit values.
N   */
N#if defined __CC_ARM
X#if 1L
N#define __SIMD32_TYPE int32_t __packed
N#define CMSIS_UNUSED __attribute__((unused))
N#elif defined __ICCARM__
S#define CMSIS_UNUSED
S#define __SIMD32_TYPE int32_t __packed
S#elif defined __GNUC__
S#define __SIMD32_TYPE int32_t
S#define CMSIS_UNUSED __attribute__((unused))
S#elif defined __CSMC__			/* Cosmic */
S#define CMSIS_UNUSED
S#define __SIMD32_TYPE int32_t
S#else
S#error Unknown compiler
N#endif
N
N#define __SIMD32(addr)  (*(__SIMD32_TYPE **) & (addr))
N#define __SIMD32_CONST(addr)  ((__SIMD32_TYPE *)(addr))
N
N#define _SIMD32_OFFSET(addr)  (*(__SIMD32_TYPE *)  (addr))
N
N#define __SIMD64(addr)  (*(int64_t **) & (addr))
N
N#if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY)
X#if 0L || 0L
S  /**
S   * @brief definition to pack two 16 bit values.
S   */
S#define __PKHBT(ARG1, ARG2, ARG3)      ( (((int32_t)(ARG1) <<  0) & (int32_t)0x0000FFFF) | \
S                                         (((int32_t)(ARG2) << ARG3) & (int32_t)0xFFFF0000)  )
X#define __PKHBT(ARG1, ARG2, ARG3)      ( (((int32_t)(ARG1) <<  0) & (int32_t)0x0000FFFF) |                                          (((int32_t)(ARG2) << ARG3) & (int32_t)0xFFFF0000)  )
S#define __PKHTB(ARG1, ARG2, ARG3)      ( (((int32_t)(ARG1) <<  0) & (int32_t)0xFFFF0000) | \
S                                         (((int32_t)(ARG2) >> ARG3) & (int32_t)0x0000FFFF)  )
X#define __PKHTB(ARG1, ARG2, ARG3)      ( (((int32_t)(ARG1) <<  0) & (int32_t)0xFFFF0000) |                                          (((int32_t)(ARG2) >> ARG3) & (int32_t)0x0000FFFF)  )
S
N#endif
N
N
N   /**
N   * @brief definition to pack four 8 bit values.
N   */
N#ifndef ARM_MATH_BIG_ENDIAN
N
N#define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v0) <<  0) & (int32_t)0x000000FF) |	\
N                                (((int32_t)(v1) <<  8) & (int32_t)0x0000FF00) |	\
N							    (((int32_t)(v2) << 16) & (int32_t)0x00FF0000) |	\
N							    (((int32_t)(v3) << 24) & (int32_t)0xFF000000)  )
X#define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v0) <<  0) & (int32_t)0x000000FF) |	                                (((int32_t)(v1) <<  8) & (int32_t)0x0000FF00) |								    (((int32_t)(v2) << 16) & (int32_t)0x00FF0000) |								    (((int32_t)(v3) << 24) & (int32_t)0xFF000000)  )
N#else
S
S#define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v3) <<  0) & (int32_t)0x000000FF) |	\
S                                (((int32_t)(v2) <<  8) & (int32_t)0x0000FF00) |	\
S							    (((int32_t)(v1) << 16) & (int32_t)0x00FF0000) |	\
S							    (((int32_t)(v0) << 24) & (int32_t)0xFF000000)  )
X#define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v3) <<  0) & (int32_t)0x000000FF) |	                                (((int32_t)(v2) <<  8) & (int32_t)0x0000FF00) |								    (((int32_t)(v1) << 16) & (int32_t)0x00FF0000) |								    (((int32_t)(v0) << 24) & (int32_t)0xFF000000)  )
S
N#endif
N
N
N  /**
N   * @brief Clips Q63 to Q31 values.
N   */
N  static __INLINE q31_t clip_q63_to_q31(
X  static __inline q31_t clip_q63_to_q31(
N  q63_t x)
N  {
N    return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
N      ((0x7FFFFFFF ^ ((q31_t) (x >> 63)))) : (q31_t) x;
N  }
N
N  /**
N   * @brief Clips Q63 to Q15 values.
N   */
N  static __INLINE q15_t clip_q63_to_q15(
X  static __inline q15_t clip_q63_to_q15(
N  q63_t x)
N  {
N    return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
N      ((0x7FFF ^ ((q15_t) (x >> 63)))) : (q15_t) (x >> 15);
N  }
N
N  /**
N   * @brief Clips Q31 to Q7 values.
N   */
N  static __INLINE q7_t clip_q31_to_q7(
X  static __inline q7_t clip_q31_to_q7(
N  q31_t x)
N  {
N    return ((q31_t) (x >> 24) != ((q31_t) x >> 23)) ?
N      ((0x7F ^ ((q7_t) (x >> 31)))) : (q7_t) x;
N  }
N
N  /**
N   * @brief Clips Q31 to Q15 values.
N   */
N  static __INLINE q15_t clip_q31_to_q15(
X  static __inline q15_t clip_q31_to_q15(
N  q31_t x)
N  {
N    return ((q31_t) (x >> 16) != ((q31_t) x >> 15)) ?
N      ((0x7FFF ^ ((q15_t) (x >> 31)))) : (q15_t) x;
N  }
N
N  /**
N   * @brief Multiplies 32 X 64 and returns 32 bit result in 2.30 format.
N   */
N
N  static __INLINE q63_t mult32x64(
X  static __inline q63_t mult32x64(
N  q63_t x,
N  q31_t y)
N  {
N    return ((((q63_t) (x & 0x00000000FFFFFFFF) * y) >> 32) +
N            (((q63_t) (x >> 32) * y)));
N  }
N
N
N#if defined (ARM_MATH_CM0_FAMILY) && defined ( __CC_ARM   )
X#if 0L && 1L
S#define __CLZ __clz
N#endif
N
N#if defined (ARM_MATH_CM0_FAMILY) && ((defined (__ICCARM__)) ||(defined (__GNUC__)) || defined (__TASKING__) )
X#if 0L && ((0L) ||(0L) || 0L )
S
S  static __INLINE uint32_t __CLZ(
S  q31_t data);
S
S
S  static __INLINE uint32_t __CLZ(
S  q31_t data)
S  {
S    uint32_t count = 0;
S    uint32_t mask = 0x80000000;
S
S    while((data & mask) == 0)
S    {
S      count += 1u;
S      mask = mask >> 1u;
S    }
S
S    return (count);
S
S  }
S
N#endif
N
N  /**
N   * @brief Function to Calculates 1/in (reciprocal) value of Q31 Data type.
N   */
N
N  static __INLINE uint32_t arm_recip_q31(
X  static __inline uint32_t arm_recip_q31(
N  q31_t in,
N  q31_t * dst,
N  q31_t * pRecipTable)
N  {
N
N    uint32_t out, tempVal;
N    uint32_t index, i;
N    uint32_t signBits;
N
N    if(in > 0)
N    {
N      signBits = __CLZ(in) - 1;
X      signBits = __clz(in) - 1;
N    }
N    else
N    {
N      signBits = __CLZ(-in) - 1;
X      signBits = __clz(-in) - 1;
N    }
N
N    /* Convert input sample to 1.31 format */
N    in = in << signBits;
N
N    /* calculation of index for initial approximated Val */
N    index = (uint32_t) (in >> 24u);
N    index = (index & INDEX_MASK);
X    index = (index & 0x0000003F);
N
N    /* 1.31 with exp 1 */
N    out = pRecipTable[index];
N
N    /* calculation of reciprocal value */
N    /* running approximation for two iterations */
N    for (i = 0u; i < 2u; i++)
N    {
N      tempVal = (q31_t) (((q63_t) in * out) >> 31u);
N      tempVal = 0x7FFFFFFF - tempVal;
N      /*      1.31 with exp 1 */
N      //out = (q31_t) (((q63_t) out * tempVal) >> 30u);
N      out = (q31_t) clip_q63_to_q31(((q63_t) out * tempVal) >> 30u);
N    }
N
N    /* write output */
N    *dst = out;
N
N    /* return num of signbits of out = 1/in value */
N    return (signBits + 1u);
N
N  }
N
N  /**
N   * @brief Function to Calculates 1/in (reciprocal) value of Q15 Data type.
N   */
N  static __INLINE uint32_t arm_recip_q15(
X  static __inline uint32_t arm_recip_q15(
N  q15_t in,
N  q15_t * dst,
N  q15_t * pRecipTable)
N  {
N
N    uint32_t out = 0, tempVal = 0;
N    uint32_t index = 0, i = 0;
N    uint32_t signBits = 0;
N
N    if(in > 0)
N    {
N      signBits = __CLZ(in) - 17;
X      signBits = __clz(in) - 17;
N    }
N    else
N    {
N      signBits = __CLZ(-in) - 17;
X      signBits = __clz(-in) - 17;
N    }
N
N    /* Convert input sample to 1.15 format */
N    in = in << signBits;
N
N    /* calculation of index for initial approximated Val */
N    index = in >> 8;
N    index = (index & INDEX_MASK);
X    index = (index & 0x0000003F);
N
N    /*      1.15 with exp 1  */
N    out = pRecipTable[index];
N
N    /* calculation of reciprocal value */
N    /* running approximation for two iterations */
N    for (i = 0; i < 2; i++)
N    {
N      tempVal = (q15_t) (((q31_t) in * out) >> 15);
N      tempVal = 0x7FFF - tempVal;
N      /*      1.15 with exp 1 */
N      out = (q15_t) (((q31_t) out * tempVal) >> 14);
N    }
N
N    /* write output */
N    *dst = out;
N
N    /* return num of signbits of out = 1/in value */
N    return (signBits + 1);
N
N  }
N
N
N  /*
N   * @brief C custom defined intrinisic function for only M0 processors
N   */
N#if defined(ARM_MATH_CM0_FAMILY)
X#if 0L
S
S  static __INLINE q31_t __SSAT(
S  q31_t x,
S  uint32_t y)
S  {
S    int32_t posMax, negMin;
S    uint32_t i;
S
S    posMax = 1;
S    for (i = 0; i < (y - 1); i++)
S    {
S      posMax = posMax * 2;
S    }
S
S    if(x > 0)
S    {
S      posMax = (posMax - 1);
S
S      if(x > posMax)
S      {
S        x = posMax;
S      }
S    }
S    else
S    {
S      negMin = -posMax;
S
S      if(x < negMin)
S      {
S        x = negMin;
S      }
S    }
S    return (x);
S
S
S  }
S
N#endif /* end of ARM_MATH_CM0_FAMILY */
N
N
N
N  /*
N   * @brief C custom defined intrinsic function for M3 and M0 processors
N   */
N#if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY)
X#if 0L || 0L
S
S  /*
S   * @brief C custom defined QADD8 for M3 and M0 processors
S   */
S  static __INLINE q31_t __QADD8(
S  q31_t x,
S  q31_t y)
S  {
S
S    q31_t sum;
S    q7_t r, s, t, u;
S
S    r = (q7_t) x;
S    s = (q7_t) y;
S
S    r = __SSAT((q31_t) (r + s), 8);
S    s = __SSAT(((q31_t) (((x << 16) >> 24) + ((y << 16) >> 24))), 8);
S    t = __SSAT(((q31_t) (((x << 8) >> 24) + ((y << 8) >> 24))), 8);
S    u = __SSAT(((q31_t) ((x >> 24) + (y >> 24))), 8);
S
S    sum =
S      (((q31_t) u << 24) & 0xFF000000) | (((q31_t) t << 16) & 0x00FF0000) |
S      (((q31_t) s << 8) & 0x0000FF00) | (r & 0x000000FF);
S
S    return sum;
S
S  }
S
S  /*
S   * @brief C custom defined QSUB8 for M3 and M0 processors
S   */
S  static __INLINE q31_t __QSUB8(
S  q31_t x,
S  q31_t y)
S  {
S
S    q31_t sum;
S    q31_t r, s, t, u;
S
S    r = (q7_t) x;
S    s = (q7_t) y;
S
S    r = __SSAT((r - s), 8);
S    s = __SSAT(((q31_t) (((x << 16) >> 24) - ((y << 16) >> 24))), 8) << 8;
S    t = __SSAT(((q31_t) (((x << 8) >> 24) - ((y << 8) >> 24))), 8) << 16;
S    u = __SSAT(((q31_t) ((x >> 24) - (y >> 24))), 8) << 24;
S
S    sum =
S      (u & 0xFF000000) | (t & 0x00FF0000) | (s & 0x0000FF00) | (r &
S                                                                0x000000FF);
S
S    return sum;
S  }
S
S  /*
S   * @brief C custom defined QADD16 for M3 and M0 processors
S   */
S
S  /*
S   * @brief C custom defined QADD16 for M3 and M0 processors
S   */
S  static __INLINE q31_t __QADD16(
S  q31_t x,
S  q31_t y)
S  {
S
S    q31_t sum;
S    q31_t r, s;
S
S    r = (q15_t) x;
S    s = (q15_t) y;
S
S    r = __SSAT(r + s, 16);
S    s = __SSAT(((q31_t) ((x >> 16) + (y >> 16))), 16) << 16;
S
S    sum = (s & 0xFFFF0000) | (r & 0x0000FFFF);
S
S    return sum;
S
S  }
S
S  /*
S   * @brief C custom defined SHADD16 for M3 and M0 processors
S   */
S  static __INLINE q31_t __SHADD16(
S  q31_t x,
S  q31_t y)
S  {
S
S    q31_t sum;
S    q31_t r, s;
S
S    r = (q15_t) x;
S    s = (q15_t) y;
S
S    r = ((r >> 1) + (s >> 1));
S    s = ((q31_t) ((x >> 17) + (y >> 17))) << 16;
S
S    sum = (s & 0xFFFF0000) | (r & 0x0000FFFF);
S
S    return sum;
S
S  }
S
S  /*
S   * @brief C custom defined QSUB16 for M3 and M0 processors
S   */
S  static __INLINE q31_t __QSUB16(
S  q31_t x,
S  q31_t y)
S  {
S
S    q31_t sum;
S    q31_t r, s;
S
S    r = (q15_t) x;
S    s = (q15_t) y;
S
S    r = __SSAT(r - s, 16);
S    s = __SSAT(((q31_t) ((x >> 16) - (y >> 16))), 16) << 16;
S
S    sum = (s & 0xFFFF0000) | (r & 0x0000FFFF);
S
S    return sum;
S  }
S
S  /*
S   * @brief C custom defined SHSUB16 for M3 and M0 processors
S   */
S  static __INLINE q31_t __SHSUB16(
S  q31_t x,
S  q31_t y)
S  {
S
S    q31_t diff;
S    q31_t r, s;
S
S    r = (q15_t) x;
S    s = (q15_t) y;
S
S    r = ((r >> 1) - (s >> 1));
S    s = (((x >> 17) - (y >> 17)) << 16);
S
S    diff = (s & 0xFFFF0000) | (r & 0x0000FFFF);
S
S    return diff;
S  }
S
S  /*
S   * @brief C custom defined QASX for M3 and M0 processors
S   */
S  static __INLINE q31_t __QASX(
S  q31_t x,
S  q31_t y)
S  {
S
S    q31_t sum = 0;
S
S    sum =
S      ((sum +
S        clip_q31_to_q15((q31_t) ((q15_t) (x >> 16) + (q15_t) y))) << 16) +
S      clip_q31_to_q15((q31_t) ((q15_t) x - (q15_t) (y >> 16)));
S
S    return sum;
S  }
S
S  /*
S   * @brief C custom defined SHASX for M3 and M0 processors
S   */
S  static __INLINE q31_t __SHASX(
S  q31_t x,
S  q31_t y)
S  {
S
S    q31_t sum;
S    q31_t r, s;
S
S    r = (q15_t) x;
S    s = (q15_t) y;
S
S    r = ((r >> 1) - (y >> 17));
S    s = (((x >> 17) + (s >> 1)) << 16);
S
S    sum = (s & 0xFFFF0000) | (r & 0x0000FFFF);
S
S    return sum;
S  }
S
S
S  /*
S   * @brief C custom defined QSAX for M3 and M0 processors
S   */
S  static __INLINE q31_t __QSAX(
S  q31_t x,
S  q31_t y)
S  {
S
S    q31_t sum = 0;
S
S    sum =
S      ((sum +
S        clip_q31_to_q15((q31_t) ((q15_t) (x >> 16) - (q15_t) y))) << 16) +
S      clip_q31_to_q15((q31_t) ((q15_t) x + (q15_t) (y >> 16)));
S
S    return sum;
S  }
S
S  /*
S   * @brief C custom defined SHSAX for M3 and M0 processors
S   */
S  static __INLINE q31_t __SHSAX(
S  q31_t x,
S  q31_t y)
S  {
S
S    q31_t sum;
S    q31_t r, s;
S
S    r = (q15_t) x;
S    s = (q15_t) y;
S
S    r = ((r >> 1) + (y >> 17));
S    s = (((x >> 17) - (s >> 1)) << 16);
S
S    sum = (s & 0xFFFF0000) | (r & 0x0000FFFF);
S
S    return sum;
S  }
S
S  /*
S   * @brief C custom defined SMUSDX for M3 and M0 processors
S   */
S  static __INLINE q31_t __SMUSDX(
S  q31_t x,
S  q31_t y)
S  {
S
S    return ((q31_t) (((q15_t) x * (q15_t) (y >> 16)) -
S                     ((q15_t) (x >> 16) * (q15_t) y)));
S  }
S
S  /*
S   * @brief C custom defined SMUADX for M3 and M0 processors
S   */
S  static __INLINE q31_t __SMUADX(
S  q31_t x,
S  q31_t y)
S  {
S
S    return ((q31_t) (((q15_t) x * (q15_t) (y >> 16)) +
S                     ((q15_t) (x >> 16) * (q15_t) y)));
S  }
S
S  /*
S   * @brief C custom defined QADD for M3 and M0 processors
S   */
S  static __INLINE q31_t __QADD(
S  q31_t x,
S  q31_t y)
S  {
S    return clip_q63_to_q31((q63_t) x + y);
S  }
S
S  /*
S   * @brief C custom defined QSUB for M3 and M0 processors
S   */
S  static __INLINE q31_t __QSUB(
S  q31_t x,
S  q31_t y)
S  {
S    return clip_q63_to_q31((q63_t) x - y);
S  }
S
S  /*
S   * @brief C custom defined SMLAD for M3 and M0 processors
S   */
S  static __INLINE q31_t __SMLAD(
S  q31_t x,
S  q31_t y,
S  q31_t sum)
S  {
S
S    return (sum + ((q15_t) (x >> 16) * (q15_t) (y >> 16)) +
S            ((q15_t) x * (q15_t) y));
S  }
S
S  /*
S   * @brief C custom defined SMLADX for M3 and M0 processors
S   */
S  static __INLINE q31_t __SMLADX(
S  q31_t x,
S  q31_t y,
S  q31_t sum)
S  {
S
S    return (sum + ((q15_t) (x >> 16) * (q15_t) (y)) +
S            ((q15_t) x * (q15_t) (y >> 16)));
S  }
S
S  /*
S   * @brief C custom defined SMLSDX for M3 and M0 processors
S   */
S  static __INLINE q31_t __SMLSDX(
S  q31_t x,
S  q31_t y,
S  q31_t sum)
S  {
S
S    return (sum - ((q15_t) (x >> 16) * (q15_t) (y)) +
S            ((q15_t) x * (q15_t) (y >> 16)));
S  }
S
S  /*
S   * @brief C custom defined SMLALD for M3 and M0 processors
S   */
S  static __INLINE q63_t __SMLALD(
S  q31_t x,
S  q31_t y,
S  q63_t sum)
S  {
S
S    return (sum + ((q15_t) (x >> 16) * (q15_t) (y >> 16)) +
S            ((q15_t) x * (q15_t) y));
S  }
S
S  /*
S   * @brief C custom defined SMLALDX for M3 and M0 processors
S   */
S  static __INLINE q63_t __SMLALDX(
S  q31_t x,
S  q31_t y,
S  q63_t sum)
S  {
S
S    return (sum + ((q15_t) (x >> 16) * (q15_t) y)) +
S      ((q15_t) x * (q15_t) (y >> 16));
S  }
S
S  /*
S   * @brief C custom defined SMUAD for M3 and M0 processors
S   */
S  static __INLINE q31_t __SMUAD(
S  q31_t x,
S  q31_t y)
S  {
S
S    return (((x >> 16) * (y >> 16)) +
S            (((x << 16) >> 16) * ((y << 16) >> 16)));
S  }
S
S  /*
S   * @brief C custom defined SMUSD for M3 and M0 processors
S   */
S  static __INLINE q31_t __SMUSD(
S  q31_t x,
S  q31_t y)
S  {
S
S    return (-((x >> 16) * (y >> 16)) +
S            (((x << 16) >> 16) * ((y << 16) >> 16)));
S  }
S
S
S  /*
S   * @brief C custom defined SXTB16 for M3 and M0 processors
S   */
S  static __INLINE q31_t __SXTB16(
S  q31_t x)
S  {
S
S    return ((((x << 24) >> 24) & 0x0000FFFF) |
S            (((x << 8) >> 8) & 0xFFFF0000));
S  }
S
S
N#endif /* defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
N
N
N  /**
N   * @brief Instance structure for the Q7 FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;        /**< number of filter coefficients in the filter. */
N    q7_t *pState;            /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q7_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/
N  } arm_fir_instance_q7;
N
N  /**
N   * @brief Instance structure for the Q15 FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;         /**< number of filter coefficients in the filter. */
N    q15_t *pState;            /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q15_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/
N  } arm_fir_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;         /**< number of filter coefficients in the filter. */
N    q31_t *pState;            /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q31_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps. */
N  } arm_fir_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;     /**< number of filter coefficients in the filter. */
N    float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
N  } arm_fir_instance_f32;
N
N
N  /**
N   * @brief Processing function for the Q7 FIR filter.
N   * @param[in] *S points to an instance of the Q7 FIR filter structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N  void arm_fir_q7(
N  const arm_fir_instance_q7 * S,
N  q7_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q7 FIR filter.
N   * @param[in,out] *S points to an instance of the Q7 FIR structure.
N   * @param[in] numTaps  Number of filter coefficients in the filter.
N   * @param[in] *pCoeffs points to the filter coefficients.
N   * @param[in] *pState points to the state buffer.
N   * @param[in] blockSize number of samples that are processed.
N   * @return none
N   */
N  void arm_fir_init_q7(
N  arm_fir_instance_q7 * S,
N  uint16_t numTaps,
N  q7_t * pCoeffs,
N  q7_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q15 FIR filter.
N   * @param[in] *S points to an instance of the Q15 FIR structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N  void arm_fir_q15(
N  const arm_fir_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the fast Q15 FIR filter for Cortex-M3 and Cortex-M4.
N   * @param[in] *S points to an instance of the Q15 FIR filter structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N  void arm_fir_fast_q15(
N  const arm_fir_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the Q15 FIR filter.
N   * @param[in,out] *S points to an instance of the Q15 FIR filter structure.
N   * @param[in] numTaps  Number of filter coefficients in the filter. Must be even and greater than or equal to 4.
N   * @param[in] *pCoeffs points to the filter coefficients.
N   * @param[in] *pState points to the state buffer.
N   * @param[in] blockSize number of samples that are processed at a time.
N   * @return The function returns ARM_MATH_SUCCESS if initialization was successful or ARM_MATH_ARGUMENT_ERROR if
N   * <code>numTaps</code> is not a supported value.
N   */
N
N  arm_status arm_fir_init_q15(
N  arm_fir_instance_q15 * S,
N  uint16_t numTaps,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the Q31 FIR filter.
N   * @param[in] *S points to an instance of the Q31 FIR filter structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N  void arm_fir_q31(
N  const arm_fir_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the fast Q31 FIR filter for Cortex-M3 and Cortex-M4.
N   * @param[in] *S points to an instance of the Q31 FIR structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N  void arm_fir_fast_q31(
N  const arm_fir_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the Q31 FIR filter.
N   * @param[in,out] *S points to an instance of the Q31 FIR structure.
N   * @param[in] 	numTaps  Number of filter coefficients in the filter.
N   * @param[in] 	*pCoeffs points to the filter coefficients.
N   * @param[in] 	*pState points to the state buffer.
N   * @param[in] 	blockSize number of samples that are processed at a time.
N   * @return 		none.
N   */
N  void arm_fir_init_q31(
N  arm_fir_instance_q31 * S,
N  uint16_t numTaps,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the floating-point FIR filter.
N   * @param[in] *S points to an instance of the floating-point FIR structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N  void arm_fir_f32(
N  const arm_fir_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the floating-point FIR filter.
N   * @param[in,out] *S points to an instance of the floating-point FIR filter structure.
N   * @param[in] 	numTaps  Number of filter coefficients in the filter.
N   * @param[in] 	*pCoeffs points to the filter coefficients.
N   * @param[in] 	*pState points to the state buffer.
N   * @param[in] 	blockSize number of samples that are processed at a time.
N   * @return    	none.
N   */
N  void arm_fir_init_f32(
N  arm_fir_instance_f32 * S,
N  uint16_t numTaps,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the Q15 Biquad cascade filter.
N   */
N  typedef struct
N  {
N    int8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    q15_t *pState;            /**< Points to the array of state coefficients.  The array is of length 4*numStages. */
N    q15_t *pCoeffs;           /**< Points to the array of coefficients.  The array is of length 5*numStages. */
N    int8_t postShift;         /**< Additional shift, in bits, applied to each output sample. */
N
N  } arm_biquad_casd_df1_inst_q15;
N
N
N  /**
N   * @brief Instance structure for the Q31 Biquad cascade filter.
N   */
N  typedef struct
N  {
N    uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    q31_t *pState;           /**< Points to the array of state coefficients.  The array is of length 4*numStages. */
N    q31_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*numStages. */
N    uint8_t postShift;       /**< Additional shift, in bits, applied to each output sample. */
N
N  } arm_biquad_casd_df1_inst_q31;
N
N  /**
N   * @brief Instance structure for the floating-point Biquad cascade filter.
N   */
N  typedef struct
N  {
N    uint32_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    float32_t *pState;          /**< Points to the array of state coefficients.  The array is of length 4*numStages. */
N    float32_t *pCoeffs;         /**< Points to the array of coefficients.  The array is of length 5*numStages. */
N
N
N  } arm_biquad_casd_df1_inst_f32;
N
N
N
N  /**
N   * @brief Processing function for the Q15 Biquad cascade filter.
N   * @param[in]  *S points to an instance of the Q15 Biquad cascade structure.
N   * @param[in]  *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in]  blockSize number of samples to process.
N   * @return     none.
N   */
N
N  void arm_biquad_cascade_df1_q15(
N  const arm_biquad_casd_df1_inst_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the Q15 Biquad cascade filter.
N   * @param[in,out] *S           points to an instance of the Q15 Biquad cascade structure.
N   * @param[in]     numStages    number of 2nd order stages in the filter.
N   * @param[in]     *pCoeffs     points to the filter coefficients.
N   * @param[in]     *pState      points to the state buffer.
N   * @param[in]     postShift    Shift to be applied to the output. Varies according to the coefficients format
N   * @return        none
N   */
N
N  void arm_biquad_cascade_df1_init_q15(
N  arm_biquad_casd_df1_inst_q15 * S,
N  uint8_t numStages,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  int8_t postShift);
N
N
N  /**
N   * @brief Fast but less precise processing function for the Q15 Biquad cascade filter for Cortex-M3 and Cortex-M4.
N   * @param[in]  *S points to an instance of the Q15 Biquad cascade structure.
N   * @param[in]  *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in]  blockSize number of samples to process.
N   * @return     none.
N   */
N
N  void arm_biquad_cascade_df1_fast_q15(
N  const arm_biquad_casd_df1_inst_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q31 Biquad cascade filter
N   * @param[in]  *S         points to an instance of the Q31 Biquad cascade structure.
N   * @param[in]  *pSrc      points to the block of input data.
N   * @param[out] *pDst      points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   * @return     none.
N   */
N
N  void arm_biquad_cascade_df1_q31(
N  const arm_biquad_casd_df1_inst_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Fast but less precise processing function for the Q31 Biquad cascade filter for Cortex-M3 and Cortex-M4.
N   * @param[in]  *S         points to an instance of the Q31 Biquad cascade structure.
N   * @param[in]  *pSrc      points to the block of input data.
N   * @param[out] *pDst      points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   * @return     none.
N   */
N
N  void arm_biquad_cascade_df1_fast_q31(
N  const arm_biquad_casd_df1_inst_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the Q31 Biquad cascade filter.
N   * @param[in,out] *S           points to an instance of the Q31 Biquad cascade structure.
N   * @param[in]     numStages      number of 2nd order stages in the filter.
N   * @param[in]     *pCoeffs     points to the filter coefficients.
N   * @param[in]     *pState      points to the state buffer.
N   * @param[in]     postShift    Shift to be applied to the output. Varies according to the coefficients format
N   * @return        none
N   */
N
N  void arm_biquad_cascade_df1_init_q31(
N  arm_biquad_casd_df1_inst_q31 * S,
N  uint8_t numStages,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  int8_t postShift);
N
N  /**
N   * @brief Processing function for the floating-point Biquad cascade filter.
N   * @param[in]  *S         points to an instance of the floating-point Biquad cascade structure.
N   * @param[in]  *pSrc      points to the block of input data.
N   * @param[out] *pDst      points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   * @return     none.
N   */
N
N  void arm_biquad_cascade_df1_f32(
N  const arm_biquad_casd_df1_inst_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the floating-point Biquad cascade filter.
N   * @param[in,out] *S           points to an instance of the floating-point Biquad cascade structure.
N   * @param[in]     numStages    number of 2nd order stages in the filter.
N   * @param[in]     *pCoeffs     points to the filter coefficients.
N   * @param[in]     *pState      points to the state buffer.
N   * @return        none
N   */
N
N  void arm_biquad_cascade_df1_init_f32(
N  arm_biquad_casd_df1_inst_f32 * S,
N  uint8_t numStages,
N  float32_t * pCoeffs,
N  float32_t * pState);
N
N
N  /**
N   * @brief Instance structure for the floating-point matrix structure.
N   */
N
N  typedef struct
N  {
N    uint16_t numRows;     /**< number of rows of the matrix.     */
N    uint16_t numCols;     /**< number of columns of the matrix.  */
N    float32_t *pData;     /**< points to the data of the matrix. */
N  } arm_matrix_instance_f32;
N
N
N  /**
N   * @brief Instance structure for the floating-point matrix structure.
N   */
N
N  typedef struct
N  {
N    uint16_t numRows;     /**< number of rows of the matrix.     */
N    uint16_t numCols;     /**< number of columns of the matrix.  */
N    float64_t *pData;     /**< points to the data of the matrix. */
N  } arm_matrix_instance_f64;
N
N  /**
N   * @brief Instance structure for the Q15 matrix structure.
N   */
N
N  typedef struct
N  {
N    uint16_t numRows;     /**< number of rows of the matrix.     */
N    uint16_t numCols;     /**< number of columns of the matrix.  */
N    q15_t *pData;         /**< points to the data of the matrix. */
N
N  } arm_matrix_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 matrix structure.
N   */
N
N  typedef struct
N  {
N    uint16_t numRows;     /**< number of rows of the matrix.     */
N    uint16_t numCols;     /**< number of columns of the matrix.  */
N    q31_t *pData;         /**< points to the data of the matrix. */
N
N  } arm_matrix_instance_q31;
N
N
N
N  /**
N   * @brief Floating-point matrix addition.
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_add_f32(
N  const arm_matrix_instance_f32 * pSrcA,
N  const arm_matrix_instance_f32 * pSrcB,
N  arm_matrix_instance_f32 * pDst);
N
N  /**
N   * @brief Q15 matrix addition.
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_add_q15(
N  const arm_matrix_instance_q15 * pSrcA,
N  const arm_matrix_instance_q15 * pSrcB,
N  arm_matrix_instance_q15 * pDst);
N
N  /**
N   * @brief Q31 matrix addition.
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_add_q31(
N  const arm_matrix_instance_q31 * pSrcA,
N  const arm_matrix_instance_q31 * pSrcB,
N  arm_matrix_instance_q31 * pDst);
N
N  /**
N   * @brief Floating-point, complex, matrix multiplication.
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_cmplx_mult_f32(
N  const arm_matrix_instance_f32 * pSrcA,
N  const arm_matrix_instance_f32 * pSrcB,
N  arm_matrix_instance_f32 * pDst);
N
N  /**
N   * @brief Q15, complex,  matrix multiplication.
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_cmplx_mult_q15(
N  const arm_matrix_instance_q15 * pSrcA,
N  const arm_matrix_instance_q15 * pSrcB,
N  arm_matrix_instance_q15 * pDst,
N  q15_t * pScratch);
N
N  /**
N   * @brief Q31, complex, matrix multiplication.
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_cmplx_mult_q31(
N  const arm_matrix_instance_q31 * pSrcA,
N  const arm_matrix_instance_q31 * pSrcB,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief Floating-point matrix transpose.
N   * @param[in]  *pSrc points to the input matrix
N   * @param[out] *pDst points to the output matrix
N   * @return 	The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
N   * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_trans_f32(
N  const arm_matrix_instance_f32 * pSrc,
N  arm_matrix_instance_f32 * pDst);
N
N
N  /**
N   * @brief Q15 matrix transpose.
N   * @param[in]  *pSrc points to the input matrix
N   * @param[out] *pDst points to the output matrix
N   * @return 	The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
N   * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_trans_q15(
N  const arm_matrix_instance_q15 * pSrc,
N  arm_matrix_instance_q15 * pDst);
N
N  /**
N   * @brief Q31 matrix transpose.
N   * @param[in]  *pSrc points to the input matrix
N   * @param[out] *pDst points to the output matrix
N   * @return 	The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
N   * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_trans_q31(
N  const arm_matrix_instance_q31 * pSrc,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief Floating-point matrix multiplication
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_mult_f32(
N  const arm_matrix_instance_f32 * pSrcA,
N  const arm_matrix_instance_f32 * pSrcB,
N  arm_matrix_instance_f32 * pDst);
N
N  /**
N   * @brief Q15 matrix multiplication
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @param[in]		 *pState points to the array for storing intermediate results
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_mult_q15(
N  const arm_matrix_instance_q15 * pSrcA,
N  const arm_matrix_instance_q15 * pSrcB,
N  arm_matrix_instance_q15 * pDst,
N  q15_t * pState);
N
N  /**
N   * @brief Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
N   * @param[in]       *pSrcA  points to the first input matrix structure
N   * @param[in]       *pSrcB  points to the second input matrix structure
N   * @param[out]      *pDst   points to output matrix structure
N   * @param[in]		  *pState points to the array for storing intermediate results
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_mult_fast_q15(
N  const arm_matrix_instance_q15 * pSrcA,
N  const arm_matrix_instance_q15 * pSrcB,
N  arm_matrix_instance_q15 * pDst,
N  q15_t * pState);
N
N  /**
N   * @brief Q31 matrix multiplication
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_mult_q31(
N  const arm_matrix_instance_q31 * pSrcA,
N  const arm_matrix_instance_q31 * pSrcB,
N  arm_matrix_instance_q31 * pDst);
N
N  /**
N   * @brief Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_mult_fast_q31(
N  const arm_matrix_instance_q31 * pSrcA,
N  const arm_matrix_instance_q31 * pSrcB,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief Floating-point matrix subtraction
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_sub_f32(
N  const arm_matrix_instance_f32 * pSrcA,
N  const arm_matrix_instance_f32 * pSrcB,
N  arm_matrix_instance_f32 * pDst);
N
N  /**
N   * @brief Q15 matrix subtraction
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_sub_q15(
N  const arm_matrix_instance_q15 * pSrcA,
N  const arm_matrix_instance_q15 * pSrcB,
N  arm_matrix_instance_q15 * pDst);
N
N  /**
N   * @brief Q31 matrix subtraction
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_sub_q31(
N  const arm_matrix_instance_q31 * pSrcA,
N  const arm_matrix_instance_q31 * pSrcB,
N  arm_matrix_instance_q31 * pDst);
N
N  /**
N   * @brief Floating-point matrix scaling.
N   * @param[in]  *pSrc points to the input matrix
N   * @param[in]  scale scale factor
N   * @param[out] *pDst points to the output matrix
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_scale_f32(
N  const arm_matrix_instance_f32 * pSrc,
N  float32_t scale,
N  arm_matrix_instance_f32 * pDst);
N
N  /**
N   * @brief Q15 matrix scaling.
N   * @param[in]       *pSrc points to input matrix
N   * @param[in]       scaleFract fractional portion of the scale factor
N   * @param[in]       shift number of bits to shift the result by
N   * @param[out]      *pDst points to output matrix
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_scale_q15(
N  const arm_matrix_instance_q15 * pSrc,
N  q15_t scaleFract,
N  int32_t shift,
N  arm_matrix_instance_q15 * pDst);
N
N  /**
N   * @brief Q31 matrix scaling.
N   * @param[in]       *pSrc points to input matrix
N   * @param[in]       scaleFract fractional portion of the scale factor
N   * @param[in]       shift number of bits to shift the result by
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_scale_q31(
N  const arm_matrix_instance_q31 * pSrc,
N  q31_t scaleFract,
N  int32_t shift,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief  Q31 matrix initialization.
N   * @param[in,out] *S             points to an instance of the floating-point matrix structure.
N   * @param[in]     nRows          number of rows in the matrix.
N   * @param[in]     nColumns       number of columns in the matrix.
N   * @param[in]     *pData	       points to the matrix data array.
N   * @return        none
N   */
N
N  void arm_mat_init_q31(
N  arm_matrix_instance_q31 * S,
N  uint16_t nRows,
N  uint16_t nColumns,
N  q31_t * pData);
N
N  /**
N   * @brief  Q15 matrix initialization.
N   * @param[in,out] *S             points to an instance of the floating-point matrix structure.
N   * @param[in]     nRows          number of rows in the matrix.
N   * @param[in]     nColumns       number of columns in the matrix.
N   * @param[in]     *pData	       points to the matrix data array.
N   * @return        none
N   */
N
N  void arm_mat_init_q15(
N  arm_matrix_instance_q15 * S,
N  uint16_t nRows,
N  uint16_t nColumns,
N  q15_t * pData);
N
N  /**
N   * @brief  Floating-point matrix initialization.
N   * @param[in,out] *S             points to an instance of the floating-point matrix structure.
N   * @param[in]     nRows          number of rows in the matrix.
N   * @param[in]     nColumns       number of columns in the matrix.
N   * @param[in]     *pData	       points to the matrix data array.
N   * @return        none
N   */
N
N  void arm_mat_init_f32(
N  arm_matrix_instance_f32 * S,
N  uint16_t nRows,
N  uint16_t nColumns,
N  float32_t * pData);
N
N
N
N  /**
N   * @brief Instance structure for the Q15 PID Control.
N   */
N  typedef struct
N  {
N    q15_t A0;    /**< The derived gain, A0 = Kp + Ki + Kd . */
N#ifdef ARM_MATH_CM0_FAMILY
S    q15_t A1;
S    q15_t A2;
N#else
N    q31_t A1;           /**< The derived gain A1 = -Kp - 2Kd | Kd.*/
N#endif
N    q15_t state[3];       /**< The state array of length 3. */
N    q15_t Kp;           /**< The proportional gain. */
N    q15_t Ki;           /**< The integral gain. */
N    q15_t Kd;           /**< The derivative gain. */
N  } arm_pid_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 PID Control.
N   */
N  typedef struct
N  {
N    q31_t A0;            /**< The derived gain, A0 = Kp + Ki + Kd . */
N    q31_t A1;            /**< The derived gain, A1 = -Kp - 2Kd. */
N    q31_t A2;            /**< The derived gain, A2 = Kd . */
N    q31_t state[3];      /**< The state array of length 3. */
N    q31_t Kp;            /**< The proportional gain. */
N    q31_t Ki;            /**< The integral gain. */
N    q31_t Kd;            /**< The derivative gain. */
N
N  } arm_pid_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point PID Control.
N   */
N  typedef struct
N  {
N    float32_t A0;          /**< The derived gain, A0 = Kp + Ki + Kd . */
N    float32_t A1;          /**< The derived gain, A1 = -Kp - 2Kd. */
N    float32_t A2;          /**< The derived gain, A2 = Kd . */
N    float32_t state[3];    /**< The state array of length 3. */
N    float32_t Kp;               /**< The proportional gain. */
N    float32_t Ki;               /**< The integral gain. */
N    float32_t Kd;               /**< The derivative gain. */
N  } arm_pid_instance_f32;
N
N
N
N  /**
N   * @brief  Initialization function for the floating-point PID Control.
N   * @param[in,out] *S      points to an instance of the PID structure.
N   * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state.
N   * @return none.
N   */
N  void arm_pid_init_f32(
N  arm_pid_instance_f32 * S,
N  int32_t resetStateFlag);
N
N  /**
N   * @brief  Reset function for the floating-point PID Control.
N   * @param[in,out] *S is an instance of the floating-point PID Control structure
N   * @return none
N   */
N  void arm_pid_reset_f32(
N  arm_pid_instance_f32 * S);
N
N
N  /**
N   * @brief  Initialization function for the Q31 PID Control.
N   * @param[in,out] *S points to an instance of the Q15 PID structure.
N   * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state.
N   * @return none.
N   */
N  void arm_pid_init_q31(
N  arm_pid_instance_q31 * S,
N  int32_t resetStateFlag);
N
N
N  /**
N   * @brief  Reset function for the Q31 PID Control.
N   * @param[in,out] *S points to an instance of the Q31 PID Control structure
N   * @return none
N   */
N
N  void arm_pid_reset_q31(
N  arm_pid_instance_q31 * S);
N
N  /**
N   * @brief  Initialization function for the Q15 PID Control.
N   * @param[in,out] *S points to an instance of the Q15 PID structure.
N   * @param[in] resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state.
N   * @return none.
N   */
N  void arm_pid_init_q15(
N  arm_pid_instance_q15 * S,
N  int32_t resetStateFlag);
N
N  /**
N   * @brief  Reset function for the Q15 PID Control.
N   * @param[in,out] *S points to an instance of the q15 PID Control structure
N   * @return none
N   */
N  void arm_pid_reset_q15(
N  arm_pid_instance_q15 * S);
N
N
N  /**
N   * @brief Instance structure for the floating-point Linear Interpolate function.
N   */
N  typedef struct
N  {
N    uint32_t nValues;           /**< nValues */
N    float32_t x1;               /**< x1 */
N    float32_t xSpacing;         /**< xSpacing */
N    float32_t *pYData;          /**< pointer to the table of Y values */
N  } arm_linear_interp_instance_f32;
N
N  /**
N   * @brief Instance structure for the floating-point bilinear interpolation function.
N   */
N
N  typedef struct
N  {
N    uint16_t numRows;   /**< number of rows in the data table. */
N    uint16_t numCols;   /**< number of columns in the data table. */
N    float32_t *pData;   /**< points to the data table. */
N  } arm_bilinear_interp_instance_f32;
N
N   /**
N   * @brief Instance structure for the Q31 bilinear interpolation function.
N   */
N
N  typedef struct
N  {
N    uint16_t numRows;   /**< number of rows in the data table. */
N    uint16_t numCols;   /**< number of columns in the data table. */
N    q31_t *pData;       /**< points to the data table. */
N  } arm_bilinear_interp_instance_q31;
N
N   /**
N   * @brief Instance structure for the Q15 bilinear interpolation function.
N   */
N
N  typedef struct
N  {
N    uint16_t numRows;   /**< number of rows in the data table. */
N    uint16_t numCols;   /**< number of columns in the data table. */
N    q15_t *pData;       /**< points to the data table. */
N  } arm_bilinear_interp_instance_q15;
N
N   /**
N   * @brief Instance structure for the Q15 bilinear interpolation function.
N   */
N
N  typedef struct
N  {
N    uint16_t numRows;   /**< number of rows in the data table. */
N    uint16_t numCols;   /**< number of columns in the data table. */
N    q7_t *pData;                /**< points to the data table. */
N  } arm_bilinear_interp_instance_q7;
N
N
N  /**
N   * @brief Q7 vector multiplication.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst  points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_mult_q7(
N  q7_t * pSrcA,
N  q7_t * pSrcB,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q15 vector multiplication.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst  points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_mult_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q31 vector multiplication.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_mult_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Floating-point vector multiplication.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_mult_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N
N
N
N
N  /**
N   * @brief Instance structure for the Q15 CFFT/CIFFT function.
N   */
N
N  typedef struct
N  {
N    uint16_t fftLen;                 /**< length of the FFT. */
N    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    q15_t *pTwiddle;                     /**< points to the Sin twiddle factor table. */
N    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N  } arm_cfft_radix2_instance_q15;
N
N/* Deprecated */
N  arm_status arm_cfft_radix2_init_q15(
N  arm_cfft_radix2_instance_q15 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N/* Deprecated */
N  void arm_cfft_radix2_q15(
N  const arm_cfft_radix2_instance_q15 * S,
N  q15_t * pSrc);
N
N
N
N  /**
N   * @brief Instance structure for the Q15 CFFT/CIFFT function.
N   */
N
N  typedef struct
N  {
N    uint16_t fftLen;                 /**< length of the FFT. */
N    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    q15_t *pTwiddle;                 /**< points to the twiddle factor table. */
N    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N  } arm_cfft_radix4_instance_q15;
N
N/* Deprecated */
N  arm_status arm_cfft_radix4_init_q15(
N  arm_cfft_radix4_instance_q15 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N/* Deprecated */
N  void arm_cfft_radix4_q15(
N  const arm_cfft_radix4_instance_q15 * S,
N  q15_t * pSrc);
N
N  /**
N   * @brief Instance structure for the Radix-2 Q31 CFFT/CIFFT function.
N   */
N
N  typedef struct
N  {
N    uint16_t fftLen;                 /**< length of the FFT. */
N    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    q31_t *pTwiddle;                     /**< points to the Twiddle factor table. */
N    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N  } arm_cfft_radix2_instance_q31;
N
N/* Deprecated */
N  arm_status arm_cfft_radix2_init_q31(
N  arm_cfft_radix2_instance_q31 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N/* Deprecated */
N  void arm_cfft_radix2_q31(
N  const arm_cfft_radix2_instance_q31 * S,
N  q31_t * pSrc);
N
N  /**
N   * @brief Instance structure for the Q31 CFFT/CIFFT function.
N   */
N
N  typedef struct
N  {
N    uint16_t fftLen;                 /**< length of the FFT. */
N    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    q31_t *pTwiddle;                 /**< points to the twiddle factor table. */
N    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N  } arm_cfft_radix4_instance_q31;
N
N/* Deprecated */
N  void arm_cfft_radix4_q31(
N  const arm_cfft_radix4_instance_q31 * S,
N  q31_t * pSrc);
N
N/* Deprecated */
N  arm_status arm_cfft_radix4_init_q31(
N  arm_cfft_radix4_instance_q31 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N  /**
N   * @brief Instance structure for the floating-point CFFT/CIFFT function.
N   */
N
N  typedef struct
N  {
N    uint16_t fftLen;                   /**< length of the FFT. */
N    uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
N    uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N    float32_t onebyfftLen;                 /**< value of 1/fftLen. */
N  } arm_cfft_radix2_instance_f32;
N
N/* Deprecated */
N  arm_status arm_cfft_radix2_init_f32(
N  arm_cfft_radix2_instance_f32 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N/* Deprecated */
N  void arm_cfft_radix2_f32(
N  const arm_cfft_radix2_instance_f32 * S,
N  float32_t * pSrc);
N
N  /**
N   * @brief Instance structure for the floating-point CFFT/CIFFT function.
N   */
N
N  typedef struct
N  {
N    uint16_t fftLen;                   /**< length of the FFT. */
N    uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
N    uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N    float32_t onebyfftLen;                 /**< value of 1/fftLen. */
N  } arm_cfft_radix4_instance_f32;
N
N/* Deprecated */
N  arm_status arm_cfft_radix4_init_f32(
N  arm_cfft_radix4_instance_f32 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N/* Deprecated */
N  void arm_cfft_radix4_f32(
N  const arm_cfft_radix4_instance_f32 * S,
N  float32_t * pSrc);
N
N  /**
N   * @brief Instance structure for the fixed-point CFFT/CIFFT function.
N   */
N
N  typedef struct
N  {
N    uint16_t fftLen;                   /**< length of the FFT. */
N    const q15_t *pTwiddle;             /**< points to the Twiddle factor table. */
N    const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
N    uint16_t bitRevLength;             /**< bit reversal table length. */
N  } arm_cfft_instance_q15;
N
Nvoid arm_cfft_q15( 
N    const arm_cfft_instance_q15 * S, 
N    q15_t * p1,
N    uint8_t ifftFlag,
N    uint8_t bitReverseFlag);  
N
N  /**
N   * @brief Instance structure for the fixed-point CFFT/CIFFT function.
N   */
N
N  typedef struct
N  {
N    uint16_t fftLen;                   /**< length of the FFT. */
N    const q31_t *pTwiddle;             /**< points to the Twiddle factor table. */
N    const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
N    uint16_t bitRevLength;             /**< bit reversal table length. */
N  } arm_cfft_instance_q31;
N
Nvoid arm_cfft_q31( 
N    const arm_cfft_instance_q31 * S, 
N    q31_t * p1,
N    uint8_t ifftFlag,
N    uint8_t bitReverseFlag);  
N  
N  /**
N   * @brief Instance structure for the floating-point CFFT/CIFFT function.
N   */
N
N  typedef struct
N  {
N    uint16_t fftLen;                   /**< length of the FFT. */
N    const float32_t *pTwiddle;         /**< points to the Twiddle factor table. */
N    const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
N    uint16_t bitRevLength;             /**< bit reversal table length. */
N  } arm_cfft_instance_f32;
N
N  void arm_cfft_f32(
N  const arm_cfft_instance_f32 * S,
N  float32_t * p1,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N  /**
N   * @brief Instance structure for the Q15 RFFT/RIFFT function.
N   */
N
N  typedef struct
N  {
N    uint32_t fftLenReal;                      /**< length of the real FFT. */
N    uint8_t ifftFlagR;                        /**< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform. */
N    uint8_t bitReverseFlagR;                  /**< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output. */
N    uint32_t twidCoefRModifier;               /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    q15_t *pTwiddleAReal;                     /**< points to the real twiddle factor table. */
N    q15_t *pTwiddleBReal;                     /**< points to the imag twiddle factor table. */
N    const arm_cfft_instance_q15 *pCfft;       /**< points to the complex FFT instance. */
N  } arm_rfft_instance_q15;
N
N  arm_status arm_rfft_init_q15(
N  arm_rfft_instance_q15 * S,
N  uint32_t fftLenReal,
N  uint32_t ifftFlagR,
N  uint32_t bitReverseFlag);
N
N  void arm_rfft_q15(
N  const arm_rfft_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst);
N
N  /**
N   * @brief Instance structure for the Q31 RFFT/RIFFT function.
N   */
N
N  typedef struct
N  {
N    uint32_t fftLenReal;                        /**< length of the real FFT. */
N    uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform. */
N    uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output. */
N    uint32_t twidCoefRModifier;                 /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    q31_t *pTwiddleAReal;                       /**< points to the real twiddle factor table. */
N    q31_t *pTwiddleBReal;                       /**< points to the imag twiddle factor table. */
N    const arm_cfft_instance_q31 *pCfft;         /**< points to the complex FFT instance. */
N  } arm_rfft_instance_q31;
N
N  arm_status arm_rfft_init_q31(
N  arm_rfft_instance_q31 * S,
N  uint32_t fftLenReal,
N  uint32_t ifftFlagR,
N  uint32_t bitReverseFlag);
N
N  void arm_rfft_q31(
N  const arm_rfft_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst);
N
N  /**
N   * @brief Instance structure for the floating-point RFFT/RIFFT function.
N   */
N
N  typedef struct
N  {
N    uint32_t fftLenReal;                        /**< length of the real FFT. */
N    uint16_t fftLenBy2;                         /**< length of the complex FFT. */
N    uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform. */
N    uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output. */
N    uint32_t twidCoefRModifier;                     /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    float32_t *pTwiddleAReal;                   /**< points to the real twiddle factor table. */
N    float32_t *pTwiddleBReal;                   /**< points to the imag twiddle factor table. */
N    arm_cfft_radix4_instance_f32 *pCfft;        /**< points to the complex FFT instance. */
N  } arm_rfft_instance_f32;
N
N  arm_status arm_rfft_init_f32(
N  arm_rfft_instance_f32 * S,
N  arm_cfft_radix4_instance_f32 * S_CFFT,
N  uint32_t fftLenReal,
N  uint32_t ifftFlagR,
N  uint32_t bitReverseFlag);
N
N  void arm_rfft_f32(
N  const arm_rfft_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst);
N
N  /**
N   * @brief Instance structure for the floating-point RFFT/RIFFT function.
N   */
N
Ntypedef struct
N  {
N    arm_cfft_instance_f32 Sint;      /**< Internal CFFT structure. */
N    uint16_t fftLenRFFT;                        /**< length of the real sequence */
N	float32_t * pTwiddleRFFT;					/**< Twiddle factors real stage  */
N  } arm_rfft_fast_instance_f32 ;
N
Narm_status arm_rfft_fast_init_f32 (
N	arm_rfft_fast_instance_f32 * S,
N	uint16_t fftLen);
N
Nvoid arm_rfft_fast_f32(
N  arm_rfft_fast_instance_f32 * S,
N  float32_t * p, float32_t * pOut,
N  uint8_t ifftFlag);
N
N  /**
N   * @brief Instance structure for the floating-point DCT4/IDCT4 function.
N   */
N
N  typedef struct
N  {
N    uint16_t N;                         /**< length of the DCT4. */
N    uint16_t Nby2;                      /**< half of the length of the DCT4. */
N    float32_t normalize;                /**< normalizing factor. */
N    float32_t *pTwiddle;                /**< points to the twiddle factor table. */
N    float32_t *pCosFactor;              /**< points to the cosFactor table. */
N    arm_rfft_instance_f32 *pRfft;        /**< points to the real FFT instance. */
N    arm_cfft_radix4_instance_f32 *pCfft; /**< points to the complex FFT instance. */
N  } arm_dct4_instance_f32;
N
N  /**
N   * @brief  Initialization function for the floating-point DCT4/IDCT4.
N   * @param[in,out] *S         points to an instance of floating-point DCT4/IDCT4 structure.
N   * @param[in]     *S_RFFT    points to an instance of floating-point RFFT/RIFFT structure.
N   * @param[in]     *S_CFFT    points to an instance of floating-point CFFT/CIFFT structure.
N   * @param[in]     N          length of the DCT4.
N   * @param[in]     Nby2       half of the length of the DCT4.
N   * @param[in]     normalize  normalizing factor.
N   * @return		arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>fftLenReal</code> is not a supported transform length.
N   */
N
N  arm_status arm_dct4_init_f32(
N  arm_dct4_instance_f32 * S,
N  arm_rfft_instance_f32 * S_RFFT,
N  arm_cfft_radix4_instance_f32 * S_CFFT,
N  uint16_t N,
N  uint16_t Nby2,
N  float32_t normalize);
N
N  /**
N   * @brief Processing function for the floating-point DCT4/IDCT4.
N   * @param[in]       *S             points to an instance of the floating-point DCT4/IDCT4 structure.
N   * @param[in]       *pState        points to state buffer.
N   * @param[in,out]   *pInlineBuffer points to the in-place input and output buffer.
N   * @return none.
N   */
N
N  void arm_dct4_f32(
N  const arm_dct4_instance_f32 * S,
N  float32_t * pState,
N  float32_t * pInlineBuffer);
N
N  /**
N   * @brief Instance structure for the Q31 DCT4/IDCT4 function.
N   */
N
N  typedef struct
N  {
N    uint16_t N;                         /**< length of the DCT4. */
N    uint16_t Nby2;                      /**< half of the length of the DCT4. */
N    q31_t normalize;                    /**< normalizing factor. */
N    q31_t *pTwiddle;                    /**< points to the twiddle factor table. */
N    q31_t *pCosFactor;                  /**< points to the cosFactor table. */
N    arm_rfft_instance_q31 *pRfft;        /**< points to the real FFT instance. */
N    arm_cfft_radix4_instance_q31 *pCfft; /**< points to the complex FFT instance. */
N  } arm_dct4_instance_q31;
N
N  /**
N   * @brief  Initialization function for the Q31 DCT4/IDCT4.
N   * @param[in,out] *S         points to an instance of Q31 DCT4/IDCT4 structure.
N   * @param[in]     *S_RFFT    points to an instance of Q31 RFFT/RIFFT structure
N   * @param[in]     *S_CFFT    points to an instance of Q31 CFFT/CIFFT structure
N   * @param[in]     N          length of the DCT4.
N   * @param[in]     Nby2       half of the length of the DCT4.
N   * @param[in]     normalize  normalizing factor.
N   * @return		arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>N</code> is not a supported transform length.
N   */
N
N  arm_status arm_dct4_init_q31(
N  arm_dct4_instance_q31 * S,
N  arm_rfft_instance_q31 * S_RFFT,
N  arm_cfft_radix4_instance_q31 * S_CFFT,
N  uint16_t N,
N  uint16_t Nby2,
N  q31_t normalize);
N
N  /**
N   * @brief Processing function for the Q31 DCT4/IDCT4.
N   * @param[in]       *S             points to an instance of the Q31 DCT4 structure.
N   * @param[in]       *pState        points to state buffer.
N   * @param[in,out]   *pInlineBuffer points to the in-place input and output buffer.
N   * @return none.
N   */
N
N  void arm_dct4_q31(
N  const arm_dct4_instance_q31 * S,
N  q31_t * pState,
N  q31_t * pInlineBuffer);
N
N  /**
N   * @brief Instance structure for the Q15 DCT4/IDCT4 function.
N   */
N
N  typedef struct
N  {
N    uint16_t N;                         /**< length of the DCT4. */
N    uint16_t Nby2;                      /**< half of the length of the DCT4. */
N    q15_t normalize;                    /**< normalizing factor. */
N    q15_t *pTwiddle;                    /**< points to the twiddle factor table. */
N    q15_t *pCosFactor;                  /**< points to the cosFactor table. */
N    arm_rfft_instance_q15 *pRfft;        /**< points to the real FFT instance. */
N    arm_cfft_radix4_instance_q15 *pCfft; /**< points to the complex FFT instance. */
N  } arm_dct4_instance_q15;
N
N  /**
N   * @brief  Initialization function for the Q15 DCT4/IDCT4.
N   * @param[in,out] *S         points to an instance of Q15 DCT4/IDCT4 structure.
N   * @param[in]     *S_RFFT    points to an instance of Q15 RFFT/RIFFT structure.
N   * @param[in]     *S_CFFT    points to an instance of Q15 CFFT/CIFFT structure.
N   * @param[in]     N          length of the DCT4.
N   * @param[in]     Nby2       half of the length of the DCT4.
N   * @param[in]     normalize  normalizing factor.
N   * @return		arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>N</code> is not a supported transform length.
N   */
N
N  arm_status arm_dct4_init_q15(
N  arm_dct4_instance_q15 * S,
N  arm_rfft_instance_q15 * S_RFFT,
N  arm_cfft_radix4_instance_q15 * S_CFFT,
N  uint16_t N,
N  uint16_t Nby2,
N  q15_t normalize);
N
N  /**
N   * @brief Processing function for the Q15 DCT4/IDCT4.
N   * @param[in]       *S             points to an instance of the Q15 DCT4 structure.
N   * @param[in]       *pState        points to state buffer.
N   * @param[in,out]   *pInlineBuffer points to the in-place input and output buffer.
N   * @return none.
N   */
N
N  void arm_dct4_q15(
N  const arm_dct4_instance_q15 * S,
N  q15_t * pState,
N  q15_t * pInlineBuffer);
N
N  /**
N   * @brief Floating-point vector addition.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_add_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q7 vector addition.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_add_q7(
N  q7_t * pSrcA,
N  q7_t * pSrcB,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q15 vector addition.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_add_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q31 vector addition.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_add_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Floating-point vector subtraction.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_sub_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q7 vector subtraction.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_sub_q7(
N  q7_t * pSrcA,
N  q7_t * pSrcB,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q15 vector subtraction.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_sub_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q31 vector subtraction.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_sub_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Multiplies a floating-point vector by a scalar.
N   * @param[in]       *pSrc points to the input vector
N   * @param[in]       scale scale factor to be applied
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_scale_f32(
N  float32_t * pSrc,
N  float32_t scale,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Multiplies a Q7 vector by a scalar.
N   * @param[in]       *pSrc points to the input vector
N   * @param[in]       scaleFract fractional portion of the scale value
N   * @param[in]       shift number of bits to shift the result by
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_scale_q7(
N  q7_t * pSrc,
N  q7_t scaleFract,
N  int8_t shift,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Multiplies a Q15 vector by a scalar.
N   * @param[in]       *pSrc points to the input vector
N   * @param[in]       scaleFract fractional portion of the scale value
N   * @param[in]       shift number of bits to shift the result by
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_scale_q15(
N  q15_t * pSrc,
N  q15_t scaleFract,
N  int8_t shift,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Multiplies a Q31 vector by a scalar.
N   * @param[in]       *pSrc points to the input vector
N   * @param[in]       scaleFract fractional portion of the scale value
N   * @param[in]       shift number of bits to shift the result by
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_scale_q31(
N  q31_t * pSrc,
N  q31_t scaleFract,
N  int8_t shift,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q7 vector absolute value.
N   * @param[in]       *pSrc points to the input buffer
N   * @param[out]      *pDst points to the output buffer
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_abs_q7(
N  q7_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Floating-point vector absolute value.
N   * @param[in]       *pSrc points to the input buffer
N   * @param[out]      *pDst points to the output buffer
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_abs_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q15 vector absolute value.
N   * @param[in]       *pSrc points to the input buffer
N   * @param[out]      *pDst points to the output buffer
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_abs_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q31 vector absolute value.
N   * @param[in]       *pSrc points to the input buffer
N   * @param[out]      *pDst points to the output buffer
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_abs_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Dot product of floating-point vectors.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[in]       blockSize number of samples in each vector
N   * @param[out]      *result output result returned here
N   * @return none.
N   */
N
N  void arm_dot_prod_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  uint32_t blockSize,
N  float32_t * result);
N
N  /**
N   * @brief Dot product of Q7 vectors.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[in]       blockSize number of samples in each vector
N   * @param[out]      *result output result returned here
N   * @return none.
N   */
N
N  void arm_dot_prod_q7(
N  q7_t * pSrcA,
N  q7_t * pSrcB,
N  uint32_t blockSize,
N  q31_t * result);
N
N  /**
N   * @brief Dot product of Q15 vectors.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[in]       blockSize number of samples in each vector
N   * @param[out]      *result output result returned here
N   * @return none.
N   */
N
N  void arm_dot_prod_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  uint32_t blockSize,
N  q63_t * result);
N
N  /**
N   * @brief Dot product of Q31 vectors.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[in]       blockSize number of samples in each vector
N   * @param[out]      *result output result returned here
N   * @return none.
N   */
N
N  void arm_dot_prod_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  uint32_t blockSize,
N  q63_t * result);
N
N  /**
N   * @brief  Shifts the elements of a Q7 vector a specified number of bits.
N   * @param[in]  *pSrc points to the input vector
N   * @param[in]  shiftBits number of bits to shift.  A positive value shifts left; a negative value shifts right.
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_shift_q7(
N  q7_t * pSrc,
N  int8_t shiftBits,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Shifts the elements of a Q15 vector a specified number of bits.
N   * @param[in]  *pSrc points to the input vector
N   * @param[in]  shiftBits number of bits to shift.  A positive value shifts left; a negative value shifts right.
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_shift_q15(
N  q15_t * pSrc,
N  int8_t shiftBits,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Shifts the elements of a Q31 vector a specified number of bits.
N   * @param[in]  *pSrc points to the input vector
N   * @param[in]  shiftBits number of bits to shift.  A positive value shifts left; a negative value shifts right.
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_shift_q31(
N  q31_t * pSrc,
N  int8_t shiftBits,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Adds a constant offset to a floating-point vector.
N   * @param[in]  *pSrc points to the input vector
N   * @param[in]  offset is the offset to be added
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_offset_f32(
N  float32_t * pSrc,
N  float32_t offset,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Adds a constant offset to a Q7 vector.
N   * @param[in]  *pSrc points to the input vector
N   * @param[in]  offset is the offset to be added
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_offset_q7(
N  q7_t * pSrc,
N  q7_t offset,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Adds a constant offset to a Q15 vector.
N   * @param[in]  *pSrc points to the input vector
N   * @param[in]  offset is the offset to be added
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_offset_q15(
N  q15_t * pSrc,
N  q15_t offset,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Adds a constant offset to a Q31 vector.
N   * @param[in]  *pSrc points to the input vector
N   * @param[in]  offset is the offset to be added
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_offset_q31(
N  q31_t * pSrc,
N  q31_t offset,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Negates the elements of a floating-point vector.
N   * @param[in]  *pSrc points to the input vector
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_negate_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Negates the elements of a Q7 vector.
N   * @param[in]  *pSrc points to the input vector
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_negate_q7(
N  q7_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Negates the elements of a Q15 vector.
N   * @param[in]  *pSrc points to the input vector
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_negate_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Negates the elements of a Q31 vector.
N   * @param[in]  *pSrc points to the input vector
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_negate_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N  /**
N   * @brief  Copies the elements of a floating-point vector.
N   * @param[in]  *pSrc input pointer
N   * @param[out]  *pDst output pointer
N   * @param[in]  blockSize number of samples to process
N   * @return none.
N   */
N  void arm_copy_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Copies the elements of a Q7 vector.
N   * @param[in]  *pSrc input pointer
N   * @param[out]  *pDst output pointer
N   * @param[in]  blockSize number of samples to process
N   * @return none.
N   */
N  void arm_copy_q7(
N  q7_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Copies the elements of a Q15 vector.
N   * @param[in]  *pSrc input pointer
N   * @param[out]  *pDst output pointer
N   * @param[in]  blockSize number of samples to process
N   * @return none.
N   */
N  void arm_copy_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Copies the elements of a Q31 vector.
N   * @param[in]  *pSrc input pointer
N   * @param[out]  *pDst output pointer
N   * @param[in]  blockSize number of samples to process
N   * @return none.
N   */
N  void arm_copy_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N  /**
N   * @brief  Fills a constant value into a floating-point vector.
N   * @param[in]  value input value to be filled
N   * @param[out]  *pDst output pointer
N   * @param[in]  blockSize number of samples to process
N   * @return none.
N   */
N  void arm_fill_f32(
N  float32_t value,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Fills a constant value into a Q7 vector.
N   * @param[in]  value input value to be filled
N   * @param[out]  *pDst output pointer
N   * @param[in]  blockSize number of samples to process
N   * @return none.
N   */
N  void arm_fill_q7(
N  q7_t value,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Fills a constant value into a Q15 vector.
N   * @param[in]  value input value to be filled
N   * @param[out]  *pDst output pointer
N   * @param[in]  blockSize number of samples to process
N   * @return none.
N   */
N  void arm_fill_q15(
N  q15_t value,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Fills a constant value into a Q31 vector.
N   * @param[in]  value input value to be filled
N   * @param[out]  *pDst output pointer
N   * @param[in]  blockSize number of samples to process
N   * @return none.
N   */
N  void arm_fill_q31(
N  q31_t value,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N/**
N * @brief Convolution of floating-point sequences.
N * @param[in] *pSrcA points to the first input sequence.
N * @param[in] srcALen length of the first input sequence.
N * @param[in] *pSrcB points to the second input sequence.
N * @param[in] srcBLen length of the second input sequence.
N * @param[out] *pDst points to the location where the output result is written.  Length srcALen+srcBLen-1.
N * @return none.
N */
N
N  void arm_conv_f32(
N  float32_t * pSrcA,
N  uint32_t srcALen,
N  float32_t * pSrcB,
N  uint32_t srcBLen,
N  float32_t * pDst);
N
N
N  /**
N   * @brief Convolution of Q15 sequences.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length srcALen+srcBLen-1.
N   * @param[in]  *pScratch1 points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  *pScratch2 points to scratch buffer of size min(srcALen, srcBLen).
N   * @return none.
N   */
N
N
N  void arm_conv_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N/**
N * @brief Convolution of Q15 sequences.
N * @param[in] *pSrcA points to the first input sequence.
N * @param[in] srcALen length of the first input sequence.
N * @param[in] *pSrcB points to the second input sequence.
N * @param[in] srcBLen length of the second input sequence.
N * @param[out] *pDst points to the location where the output result is written.  Length srcALen+srcBLen-1.
N * @return none.
N */
N
N  void arm_conv_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst);
N
N  /**
N   * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length srcALen+srcBLen-1.
N   * @return none.
N   */
N
N  void arm_conv_fast_q15(
N			  q15_t * pSrcA,
N			 uint32_t srcALen,
N			  q15_t * pSrcB,
N			 uint32_t srcBLen,
N			 q15_t * pDst);
N
N  /**
N   * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length srcALen+srcBLen-1.
N   * @param[in]  *pScratch1 points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  *pScratch2 points to scratch buffer of size min(srcALen, srcBLen).
N   * @return none.
N   */
N
N  void arm_conv_fast_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N
N  /**
N   * @brief Convolution of Q31 sequences.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length srcALen+srcBLen-1.
N   * @return none.
N   */
N
N  void arm_conv_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst);
N
N  /**
N   * @brief Convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length srcALen+srcBLen-1.
N   * @return none.
N   */
N
N  void arm_conv_fast_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst);
N
N
N    /**
N   * @brief Convolution of Q7 sequences.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length srcALen+srcBLen-1.
N   * @param[in]  *pScratch1 points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  *pScratch2 points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
N   * @return none.
N   */
N
N  void arm_conv_opt_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N
N  /**
N   * @brief Convolution of Q7 sequences.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length srcALen+srcBLen-1.
N   * @return none.
N   */
N
N  void arm_conv_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst);
N
N
N  /**
N   * @brief Partial convolution of floating-point sequences.
N   * @param[in]       *pSrcA points to the first input sequence.
N   * @param[in]       srcALen length of the first input sequence.
N   * @param[in]       *pSrcB points to the second input sequence.
N   * @param[in]       srcBLen length of the second input sequence.
N   * @param[out]      *pDst points to the block of output data
N   * @param[in]       firstIndex is the first output sample to start with.
N   * @param[in]       numPoints is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N
N  arm_status arm_conv_partial_f32(
N  float32_t * pSrcA,
N  uint32_t srcALen,
N  float32_t * pSrcB,
N  uint32_t srcBLen,
N  float32_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N    /**
N   * @brief Partial convolution of Q15 sequences.
N   * @param[in]       *pSrcA points to the first input sequence.
N   * @param[in]       srcALen length of the first input sequence.
N   * @param[in]       *pSrcB points to the second input sequence.
N   * @param[in]       srcBLen length of the second input sequence.
N   * @param[out]      *pDst points to the block of output data
N   * @param[in]       firstIndex is the first output sample to start with.
N   * @param[in]       numPoints is the number of output points to be computed.
N   * @param[in]       * pScratch1 points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]       * pScratch2 points to scratch buffer of size min(srcALen, srcBLen).
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N
N  arm_status arm_conv_partial_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N/**
N   * @brief Partial convolution of Q15 sequences.
N   * @param[in]       *pSrcA points to the first input sequence.
N   * @param[in]       srcALen length of the first input sequence.
N   * @param[in]       *pSrcB points to the second input sequence.
N   * @param[in]       srcBLen length of the second input sequence.
N   * @param[out]      *pDst points to the block of output data
N   * @param[in]       firstIndex is the first output sample to start with.
N   * @param[in]       numPoints is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N
N  arm_status arm_conv_partial_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N  /**
N   * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in]       *pSrcA points to the first input sequence.
N   * @param[in]       srcALen length of the first input sequence.
N   * @param[in]       *pSrcB points to the second input sequence.
N   * @param[in]       srcBLen length of the second input sequence.
N   * @param[out]      *pDst points to the block of output data
N   * @param[in]       firstIndex is the first output sample to start with.
N   * @param[in]       numPoints is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N
N  arm_status arm_conv_partial_fast_q15(
N				        q15_t * pSrcA,
N				       uint32_t srcALen,
N				        q15_t * pSrcB,
N				       uint32_t srcBLen,
N				       q15_t * pDst,
N				       uint32_t firstIndex,
N				       uint32_t numPoints);
N
N
N  /**
N   * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in]       *pSrcA points to the first input sequence.
N   * @param[in]       srcALen length of the first input sequence.
N   * @param[in]       *pSrcB points to the second input sequence.
N   * @param[in]       srcBLen length of the second input sequence.
N   * @param[out]      *pDst points to the block of output data
N   * @param[in]       firstIndex is the first output sample to start with.
N   * @param[in]       numPoints is the number of output points to be computed.
N   * @param[in]       * pScratch1 points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]       * pScratch2 points to scratch buffer of size min(srcALen, srcBLen).
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N
N  arm_status arm_conv_partial_fast_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N  /**
N   * @brief Partial convolution of Q31 sequences.
N   * @param[in]       *pSrcA points to the first input sequence.
N   * @param[in]       srcALen length of the first input sequence.
N   * @param[in]       *pSrcB points to the second input sequence.
N   * @param[in]       srcBLen length of the second input sequence.
N   * @param[out]      *pDst points to the block of output data
N   * @param[in]       firstIndex is the first output sample to start with.
N   * @param[in]       numPoints is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N
N  arm_status arm_conv_partial_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N
N  /**
N   * @brief Partial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in]       *pSrcA points to the first input sequence.
N   * @param[in]       srcALen length of the first input sequence.
N   * @param[in]       *pSrcB points to the second input sequence.
N   * @param[in]       srcBLen length of the second input sequence.
N   * @param[out]      *pDst points to the block of output data
N   * @param[in]       firstIndex is the first output sample to start with.
N   * @param[in]       numPoints is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N
N  arm_status arm_conv_partial_fast_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N
N  /**
N   * @brief Partial convolution of Q7 sequences
N   * @param[in]       *pSrcA points to the first input sequence.
N   * @param[in]       srcALen length of the first input sequence.
N   * @param[in]       *pSrcB points to the second input sequence.
N   * @param[in]       srcBLen length of the second input sequence.
N   * @param[out]      *pDst points to the block of output data
N   * @param[in]       firstIndex is the first output sample to start with.
N   * @param[in]       numPoints is the number of output points to be computed.
N   * @param[in]  *pScratch1 points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  *pScratch2 points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N
N  arm_status arm_conv_partial_opt_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N/**
N   * @brief Partial convolution of Q7 sequences.
N   * @param[in]       *pSrcA points to the first input sequence.
N   * @param[in]       srcALen length of the first input sequence.
N   * @param[in]       *pSrcB points to the second input sequence.
N   * @param[in]       srcBLen length of the second input sequence.
N   * @param[out]      *pDst points to the block of output data
N   * @param[in]       firstIndex is the first output sample to start with.
N   * @param[in]       numPoints is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N
N  arm_status arm_conv_partial_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N
N
N  /**
N   * @brief Instance structure for the Q15 FIR decimator.
N   */
N
N  typedef struct
N  {
N    uint8_t M;                      /**< decimation factor. */
N    uint16_t numTaps;               /**< number of coefficients in the filter. */
N    q15_t *pCoeffs;                  /**< points to the coefficient array. The array is of length numTaps.*/
N    q15_t *pState;                   /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N  } arm_fir_decimate_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 FIR decimator.
N   */
N
N  typedef struct
N  {
N    uint8_t M;                  /**< decimation factor. */
N    uint16_t numTaps;           /**< number of coefficients in the filter. */
N    q31_t *pCoeffs;              /**< points to the coefficient array. The array is of length numTaps.*/
N    q31_t *pState;               /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N
N  } arm_fir_decimate_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point FIR decimator.
N   */
N
N  typedef struct
N  {
N    uint8_t M;                          /**< decimation factor. */
N    uint16_t numTaps;                   /**< number of coefficients in the filter. */
N    float32_t *pCoeffs;                  /**< points to the coefficient array. The array is of length numTaps.*/
N    float32_t *pState;                   /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N
N  } arm_fir_decimate_instance_f32;
N
N
N
N  /**
N   * @brief Processing function for the floating-point FIR decimator.
N   * @param[in] *S points to an instance of the floating-point FIR decimator structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data
N   * @param[in] blockSize number of input samples to process per call.
N   * @return none
N   */
N
N  void arm_fir_decimate_f32(
N  const arm_fir_decimate_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the floating-point FIR decimator.
N   * @param[in,out] *S points to an instance of the floating-point FIR decimator structure.
N   * @param[in] numTaps  number of coefficients in the filter.
N   * @param[in] M  decimation factor.
N   * @param[in] *pCoeffs points to the filter coefficients.
N   * @param[in] *pState points to the state buffer.
N   * @param[in] blockSize number of input samples to process per call.
N   * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * <code>blockSize</code> is not a multiple of <code>M</code>.
N   */
N
N  arm_status arm_fir_decimate_init_f32(
N  arm_fir_decimate_instance_f32 * S,
N  uint16_t numTaps,
N  uint8_t M,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the Q15 FIR decimator.
N   * @param[in] *S points to an instance of the Q15 FIR decimator structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data
N   * @param[in] blockSize number of input samples to process per call.
N   * @return none
N   */
N
N  void arm_fir_decimate_q15(
N  const arm_fir_decimate_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the Q15 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4.
N   * @param[in] *S points to an instance of the Q15 FIR decimator structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data
N   * @param[in] blockSize number of input samples to process per call.
N   * @return none
N   */
N
N  void arm_fir_decimate_fast_q15(
N  const arm_fir_decimate_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N
N  /**
N   * @brief  Initialization function for the Q15 FIR decimator.
N   * @param[in,out] *S points to an instance of the Q15 FIR decimator structure.
N   * @param[in] numTaps  number of coefficients in the filter.
N   * @param[in] M  decimation factor.
N   * @param[in] *pCoeffs points to the filter coefficients.
N   * @param[in] *pState points to the state buffer.
N   * @param[in] blockSize number of input samples to process per call.
N   * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * <code>blockSize</code> is not a multiple of <code>M</code>.
N   */
N
N  arm_status arm_fir_decimate_init_q15(
N  arm_fir_decimate_instance_q15 * S,
N  uint16_t numTaps,
N  uint8_t M,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the Q31 FIR decimator.
N   * @param[in] *S points to an instance of the Q31 FIR decimator structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data
N   * @param[in] blockSize number of input samples to process per call.
N   * @return none
N   */
N
N  void arm_fir_decimate_q31(
N  const arm_fir_decimate_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the Q31 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4.
N   * @param[in] *S points to an instance of the Q31 FIR decimator structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data
N   * @param[in] blockSize number of input samples to process per call.
N   * @return none
N   */
N
N  void arm_fir_decimate_fast_q31(
N  arm_fir_decimate_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q31 FIR decimator.
N   * @param[in,out] *S points to an instance of the Q31 FIR decimator structure.
N   * @param[in] numTaps  number of coefficients in the filter.
N   * @param[in] M  decimation factor.
N   * @param[in] *pCoeffs points to the filter coefficients.
N   * @param[in] *pState points to the state buffer.
N   * @param[in] blockSize number of input samples to process per call.
N   * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * <code>blockSize</code> is not a multiple of <code>M</code>.
N   */
N
N  arm_status arm_fir_decimate_init_q31(
N  arm_fir_decimate_instance_q31 * S,
N  uint16_t numTaps,
N  uint8_t M,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  uint32_t blockSize);
N
N
N
N  /**
N   * @brief Instance structure for the Q15 FIR interpolator.
N   */
N
N  typedef struct
N  {
N    uint8_t L;                      /**< upsample factor. */
N    uint16_t phaseLength;           /**< length of each polyphase filter component. */
N    q15_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*phaseLength. */
N    q15_t *pState;                  /**< points to the state variable array. The array is of length blockSize+phaseLength-1. */
N  } arm_fir_interpolate_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 FIR interpolator.
N   */
N
N  typedef struct
N  {
N    uint8_t L;                      /**< upsample factor. */
N    uint16_t phaseLength;           /**< length of each polyphase filter component. */
N    q31_t *pCoeffs;                  /**< points to the coefficient array. The array is of length L*phaseLength. */
N    q31_t *pState;                   /**< points to the state variable array. The array is of length blockSize+phaseLength-1. */
N  } arm_fir_interpolate_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point FIR interpolator.
N   */
N
N  typedef struct
N  {
N    uint8_t L;                     /**< upsample factor. */
N    uint16_t phaseLength;          /**< length of each polyphase filter component. */
N    float32_t *pCoeffs;             /**< points to the coefficient array. The array is of length L*phaseLength. */
N    float32_t *pState;              /**< points to the state variable array. The array is of length phaseLength+numTaps-1. */
N  } arm_fir_interpolate_instance_f32;
N
N
N  /**
N   * @brief Processing function for the Q15 FIR interpolator.
N   * @param[in] *S        points to an instance of the Q15 FIR interpolator structure.
N   * @param[in] *pSrc     points to the block of input data.
N   * @param[out] *pDst    points to the block of output data.
N   * @param[in] blockSize number of input samples to process per call.
N   * @return none.
N   */
N
N  void arm_fir_interpolate_q15(
N  const arm_fir_interpolate_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q15 FIR interpolator.
N   * @param[in,out] *S        points to an instance of the Q15 FIR interpolator structure.
N   * @param[in]     L         upsample factor.
N   * @param[in]     numTaps   number of filter coefficients in the filter.
N   * @param[in]     *pCoeffs  points to the filter coefficient buffer.
N   * @param[in]     *pState   points to the state buffer.
N   * @param[in]     blockSize number of input samples to process per call.
N   * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>.
N   */
N
N  arm_status arm_fir_interpolate_init_q15(
N  arm_fir_interpolate_instance_q15 * S,
N  uint8_t L,
N  uint16_t numTaps,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the Q31 FIR interpolator.
N   * @param[in] *S        points to an instance of the Q15 FIR interpolator structure.
N   * @param[in] *pSrc     points to the block of input data.
N   * @param[out] *pDst    points to the block of output data.
N   * @param[in] blockSize number of input samples to process per call.
N   * @return none.
N   */
N
N  void arm_fir_interpolate_q31(
N  const arm_fir_interpolate_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the Q31 FIR interpolator.
N   * @param[in,out] *S        points to an instance of the Q31 FIR interpolator structure.
N   * @param[in]     L         upsample factor.
N   * @param[in]     numTaps   number of filter coefficients in the filter.
N   * @param[in]     *pCoeffs  points to the filter coefficient buffer.
N   * @param[in]     *pState   points to the state buffer.
N   * @param[in]     blockSize number of input samples to process per call.
N   * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>.
N   */
N
N  arm_status arm_fir_interpolate_init_q31(
N  arm_fir_interpolate_instance_q31 * S,
N  uint8_t L,
N  uint16_t numTaps,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the floating-point FIR interpolator.
N   * @param[in] *S        points to an instance of the floating-point FIR interpolator structure.
N   * @param[in] *pSrc     points to the block of input data.
N   * @param[out] *pDst    points to the block of output data.
N   * @param[in] blockSize number of input samples to process per call.
N   * @return none.
N   */
N
N  void arm_fir_interpolate_f32(
N  const arm_fir_interpolate_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the floating-point FIR interpolator.
N   * @param[in,out] *S        points to an instance of the floating-point FIR interpolator structure.
N   * @param[in]     L         upsample factor.
N   * @param[in]     numTaps   number of filter coefficients in the filter.
N   * @param[in]     *pCoeffs  points to the filter coefficient buffer.
N   * @param[in]     *pState   points to the state buffer.
N   * @param[in]     blockSize number of input samples to process per call.
N   * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>.
N   */
N
N  arm_status arm_fir_interpolate_init_f32(
N  arm_fir_interpolate_instance_f32 * S,
N  uint8_t L,
N  uint16_t numTaps,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  uint32_t blockSize);
N
N  /**
N   * @brief Instance structure for the high precision Q31 Biquad cascade filter.
N   */
N
N  typedef struct
N  {
N    uint8_t numStages;       /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    q63_t *pState;           /**< points to the array of state coefficients.  The array is of length 4*numStages. */
N    q31_t *pCoeffs;          /**< points to the array of coefficients.  The array is of length 5*numStages. */
N    uint8_t postShift;       /**< additional shift, in bits, applied to each output sample. */
N
N  } arm_biquad_cas_df1_32x64_ins_q31;
N
N
N  /**
N   * @param[in]  *S        points to an instance of the high precision Q31 Biquad cascade filter structure.
N   * @param[in]  *pSrc     points to the block of input data.
N   * @param[out] *pDst     points to the block of output data
N   * @param[in]  blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_biquad_cas_df1_32x64_q31(
N  const arm_biquad_cas_df1_32x64_ins_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @param[in,out] *S           points to an instance of the high precision Q31 Biquad cascade filter structure.
N   * @param[in]     numStages    number of 2nd order stages in the filter.
N   * @param[in]     *pCoeffs     points to the filter coefficients.
N   * @param[in]     *pState      points to the state buffer.
N   * @param[in]     postShift    shift to be applied to the output. Varies according to the coefficients format
N   * @return        none
N   */
N
N  void arm_biquad_cas_df1_32x64_init_q31(
N  arm_biquad_cas_df1_32x64_ins_q31 * S,
N  uint8_t numStages,
N  q31_t * pCoeffs,
N  q63_t * pState,
N  uint8_t postShift);
N
N
N
N  /**
N   * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter.
N   */
N
N  typedef struct
N  {
N    uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    float32_t *pState;         /**< points to the array of state coefficients.  The array is of length 2*numStages. */
N    float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*numStages. */
N  } arm_biquad_cascade_df2T_instance_f32;
N
N
N
N  /**
N   * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter.
N   */
N
N  typedef struct
N  {
N    uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    float32_t *pState;         /**< points to the array of state coefficients.  The array is of length 4*numStages. */
N    float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*numStages. */
N  } arm_biquad_cascade_stereo_df2T_instance_f32;
N
N
N
N  /**
N   * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter.
N   */
N
N  typedef struct
N  {
N    uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    float64_t *pState;         /**< points to the array of state coefficients.  The array is of length 2*numStages. */
N    float64_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*numStages. */
N  } arm_biquad_cascade_df2T_instance_f64;
N
N
N  /**
N   * @brief Processing function for the floating-point transposed direct form II Biquad cascade filter.
N   * @param[in]  *S        points to an instance of the filter data structure.
N   * @param[in]  *pSrc     points to the block of input data.
N   * @param[out] *pDst     points to the block of output data
N   * @param[in]  blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_biquad_cascade_df2T_f32(
N  const arm_biquad_cascade_df2T_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the floating-point transposed direct form II Biquad cascade filter. 2 channels
N   * @param[in]  *S        points to an instance of the filter data structure.
N   * @param[in]  *pSrc     points to the block of input data.
N   * @param[out] *pDst     points to the block of output data
N   * @param[in]  blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_biquad_cascade_stereo_df2T_f32(
N  const arm_biquad_cascade_stereo_df2T_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the floating-point transposed direct form II Biquad cascade filter.
N   * @param[in]  *S        points to an instance of the filter data structure.
N   * @param[in]  *pSrc     points to the block of input data.
N   * @param[out] *pDst     points to the block of output data
N   * @param[in]  blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_biquad_cascade_df2T_f64(
N  const arm_biquad_cascade_df2T_instance_f64 * S,
N  float64_t * pSrc,
N  float64_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter.
N   * @param[in,out] *S           points to an instance of the filter data structure.
N   * @param[in]     numStages    number of 2nd order stages in the filter.
N   * @param[in]     *pCoeffs     points to the filter coefficients.
N   * @param[in]     *pState      points to the state buffer.
N   * @return        none
N   */
N
N  void arm_biquad_cascade_df2T_init_f32(
N  arm_biquad_cascade_df2T_instance_f32 * S,
N  uint8_t numStages,
N  float32_t * pCoeffs,
N  float32_t * pState);
N
N
N  /**
N   * @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter.
N   * @param[in,out] *S           points to an instance of the filter data structure.
N   * @param[in]     numStages    number of 2nd order stages in the filter.
N   * @param[in]     *pCoeffs     points to the filter coefficients.
N   * @param[in]     *pState      points to the state buffer.
N   * @return        none
N   */
N
N  void arm_biquad_cascade_stereo_df2T_init_f32(
N  arm_biquad_cascade_stereo_df2T_instance_f32 * S,
N  uint8_t numStages,
N  float32_t * pCoeffs,
N  float32_t * pState);
N
N
N  /**
N   * @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter.
N   * @param[in,out] *S           points to an instance of the filter data structure.
N   * @param[in]     numStages    number of 2nd order stages in the filter.
N   * @param[in]     *pCoeffs     points to the filter coefficients.
N   * @param[in]     *pState      points to the state buffer.
N   * @return        none
N   */
N
N  void arm_biquad_cascade_df2T_init_f64(
N  arm_biquad_cascade_df2T_instance_f64 * S,
N  uint8_t numStages,
N  float64_t * pCoeffs,
N  float64_t * pState);
N
N
N
N  /**
N   * @brief Instance structure for the Q15 FIR lattice filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numStages;                          /**< number of filter stages. */
N    q15_t *pState;                               /**< points to the state variable array. The array is of length numStages. */
N    q15_t *pCoeffs;                              /**< points to the coefficient array. The array is of length numStages. */
N  } arm_fir_lattice_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 FIR lattice filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numStages;                          /**< number of filter stages. */
N    q31_t *pState;                               /**< points to the state variable array. The array is of length numStages. */
N    q31_t *pCoeffs;                              /**< points to the coefficient array. The array is of length numStages. */
N  } arm_fir_lattice_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point FIR lattice filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numStages;                  /**< number of filter stages. */
N    float32_t *pState;                   /**< points to the state variable array. The array is of length numStages. */
N    float32_t *pCoeffs;                  /**< points to the coefficient array. The array is of length numStages. */
N  } arm_fir_lattice_instance_f32;
N
N  /**
N   * @brief Initialization function for the Q15 FIR lattice filter.
N   * @param[in] *S points to an instance of the Q15 FIR lattice structure.
N   * @param[in] numStages  number of filter stages.
N   * @param[in] *pCoeffs points to the coefficient buffer.  The array is of length numStages.
N   * @param[in] *pState points to the state buffer.  The array is of length numStages.
N   * @return none.
N   */
N
N  void arm_fir_lattice_init_q15(
N  arm_fir_lattice_instance_q15 * S,
N  uint16_t numStages,
N  q15_t * pCoeffs,
N  q15_t * pState);
N
N
N  /**
N   * @brief Processing function for the Q15 FIR lattice filter.
N   * @param[in] *S points to an instance of the Q15 FIR lattice structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N  void arm_fir_lattice_q15(
N  const arm_fir_lattice_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Initialization function for the Q31 FIR lattice filter.
N   * @param[in] *S points to an instance of the Q31 FIR lattice structure.
N   * @param[in] numStages  number of filter stages.
N   * @param[in] *pCoeffs points to the coefficient buffer.  The array is of length numStages.
N   * @param[in] *pState points to the state buffer.   The array is of length numStages.
N   * @return none.
N   */
N
N  void arm_fir_lattice_init_q31(
N  arm_fir_lattice_instance_q31 * S,
N  uint16_t numStages,
N  q31_t * pCoeffs,
N  q31_t * pState);
N
N
N  /**
N   * @brief Processing function for the Q31 FIR lattice filter.
N   * @param[in]  *S        points to an instance of the Q31 FIR lattice structure.
N   * @param[in]  *pSrc     points to the block of input data.
N   * @param[out] *pDst     points to the block of output data
N   * @param[in]  blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_fir_lattice_q31(
N  const arm_fir_lattice_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N/**
N * @brief Initialization function for the floating-point FIR lattice filter.
N * @param[in] *S points to an instance of the floating-point FIR lattice structure.
N * @param[in] numStages  number of filter stages.
N * @param[in] *pCoeffs points to the coefficient buffer.  The array is of length numStages.
N * @param[in] *pState points to the state buffer.  The array is of length numStages.
N * @return none.
N */
N
N  void arm_fir_lattice_init_f32(
N  arm_fir_lattice_instance_f32 * S,
N  uint16_t numStages,
N  float32_t * pCoeffs,
N  float32_t * pState);
N
N  /**
N   * @brief Processing function for the floating-point FIR lattice filter.
N   * @param[in]  *S        points to an instance of the floating-point FIR lattice structure.
N   * @param[in]  *pSrc     points to the block of input data.
N   * @param[out] *pDst     points to the block of output data
N   * @param[in]  blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_fir_lattice_f32(
N  const arm_fir_lattice_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Instance structure for the Q15 IIR lattice filter.
N   */
N  typedef struct
N  {
N    uint16_t numStages;                         /**< number of stages in the filter. */
N    q15_t *pState;                              /**< points to the state variable array. The array is of length numStages+blockSize. */
N    q15_t *pkCoeffs;                            /**< points to the reflection coefficient array. The array is of length numStages. */
N    q15_t *pvCoeffs;                            /**< points to the ladder coefficient array. The array is of length numStages+1. */
N  } arm_iir_lattice_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 IIR lattice filter.
N   */
N  typedef struct
N  {
N    uint16_t numStages;                         /**< number of stages in the filter. */
N    q31_t *pState;                              /**< points to the state variable array. The array is of length numStages+blockSize. */
N    q31_t *pkCoeffs;                            /**< points to the reflection coefficient array. The array is of length numStages. */
N    q31_t *pvCoeffs;                            /**< points to the ladder coefficient array. The array is of length numStages+1. */
N  } arm_iir_lattice_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point IIR lattice filter.
N   */
N  typedef struct
N  {
N    uint16_t numStages;                         /**< number of stages in the filter. */
N    float32_t *pState;                          /**< points to the state variable array. The array is of length numStages+blockSize. */
N    float32_t *pkCoeffs;                        /**< points to the reflection coefficient array. The array is of length numStages. */
N    float32_t *pvCoeffs;                        /**< points to the ladder coefficient array. The array is of length numStages+1. */
N  } arm_iir_lattice_instance_f32;
N
N  /**
N   * @brief Processing function for the floating-point IIR lattice filter.
N   * @param[in] *S points to an instance of the floating-point IIR lattice structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_iir_lattice_f32(
N  const arm_iir_lattice_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Initialization function for the floating-point IIR lattice filter.
N   * @param[in] *S points to an instance of the floating-point IIR lattice structure.
N   * @param[in] numStages number of stages in the filter.
N   * @param[in] *pkCoeffs points to the reflection coefficient buffer.  The array is of length numStages.
N   * @param[in] *pvCoeffs points to the ladder coefficient buffer.  The array is of length numStages+1.
N   * @param[in] *pState points to the state buffer.  The array is of length numStages+blockSize-1.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_iir_lattice_init_f32(
N  arm_iir_lattice_instance_f32 * S,
N  uint16_t numStages,
N  float32_t * pkCoeffs,
N  float32_t * pvCoeffs,
N  float32_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q31 IIR lattice filter.
N   * @param[in] *S points to an instance of the Q31 IIR lattice structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_iir_lattice_q31(
N  const arm_iir_lattice_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Initialization function for the Q31 IIR lattice filter.
N   * @param[in] *S points to an instance of the Q31 IIR lattice structure.
N   * @param[in] numStages number of stages in the filter.
N   * @param[in] *pkCoeffs points to the reflection coefficient buffer.  The array is of length numStages.
N   * @param[in] *pvCoeffs points to the ladder coefficient buffer.  The array is of length numStages+1.
N   * @param[in] *pState points to the state buffer.  The array is of length numStages+blockSize.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_iir_lattice_init_q31(
N  arm_iir_lattice_instance_q31 * S,
N  uint16_t numStages,
N  q31_t * pkCoeffs,
N  q31_t * pvCoeffs,
N  q31_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q15 IIR lattice filter.
N   * @param[in] *S points to an instance of the Q15 IIR lattice structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_iir_lattice_q15(
N  const arm_iir_lattice_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N/**
N * @brief Initialization function for the Q15 IIR lattice filter.
N * @param[in] *S points to an instance of the fixed-point Q15 IIR lattice structure.
N * @param[in] numStages  number of stages in the filter.
N * @param[in] *pkCoeffs points to reflection coefficient buffer.  The array is of length numStages.
N * @param[in] *pvCoeffs points to ladder coefficient buffer.  The array is of length numStages+1.
N * @param[in] *pState points to state buffer.  The array is of length numStages+blockSize.
N * @param[in] blockSize number of samples to process per call.
N * @return none.
N */
N
N  void arm_iir_lattice_init_q15(
N  arm_iir_lattice_instance_q15 * S,
N  uint16_t numStages,
N  q15_t * pkCoeffs,
N  q15_t * pvCoeffs,
N  q15_t * pState,
N  uint32_t blockSize);
N
N  /**
N   * @brief Instance structure for the floating-point LMS filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numTaps;    /**< number of coefficients in the filter. */
N    float32_t *pState;   /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    float32_t *pCoeffs;  /**< points to the coefficient array. The array is of length numTaps. */
N    float32_t mu;        /**< step size that controls filter coefficient updates. */
N  } arm_lms_instance_f32;
N
N  /**
N   * @brief Processing function for floating-point LMS filter.
N   * @param[in]  *S points to an instance of the floating-point LMS filter structure.
N   * @param[in]  *pSrc points to the block of input data.
N   * @param[in]  *pRef points to the block of reference data.
N   * @param[out] *pOut points to the block of output data.
N   * @param[out] *pErr points to the block of error data.
N   * @param[in]  blockSize number of samples to process.
N   * @return     none.
N   */
N
N  void arm_lms_f32(
N  const arm_lms_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pRef,
N  float32_t * pOut,
N  float32_t * pErr,
N  uint32_t blockSize);
N
N  /**
N   * @brief Initialization function for floating-point LMS filter.
N   * @param[in] *S points to an instance of the floating-point LMS filter structure.
N   * @param[in] numTaps  number of filter coefficients.
N   * @param[in] *pCoeffs points to the coefficient buffer.
N   * @param[in] *pState points to state buffer.
N   * @param[in] mu step size that controls filter coefficient updates.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_lms_init_f32(
N  arm_lms_instance_f32 * S,
N  uint16_t numTaps,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  float32_t mu,
N  uint32_t blockSize);
N
N  /**
N   * @brief Instance structure for the Q15 LMS filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numTaps;    /**< number of coefficients in the filter. */
N    q15_t *pState;       /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q15_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
N    q15_t mu;            /**< step size that controls filter coefficient updates. */
N    uint32_t postShift;  /**< bit shift applied to coefficients. */
N  } arm_lms_instance_q15;
N
N
N  /**
N   * @brief Initialization function for the Q15 LMS filter.
N   * @param[in] *S points to an instance of the Q15 LMS filter structure.
N   * @param[in] numTaps  number of filter coefficients.
N   * @param[in] *pCoeffs points to the coefficient buffer.
N   * @param[in] *pState points to the state buffer.
N   * @param[in] mu step size that controls filter coefficient updates.
N   * @param[in] blockSize number of samples to process.
N   * @param[in] postShift bit shift applied to coefficients.
N   * @return    none.
N   */
N
N  void arm_lms_init_q15(
N  arm_lms_instance_q15 * S,
N  uint16_t numTaps,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  q15_t mu,
N  uint32_t blockSize,
N  uint32_t postShift);
N
N  /**
N   * @brief Processing function for Q15 LMS filter.
N   * @param[in] *S points to an instance of the Q15 LMS filter structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[in] *pRef points to the block of reference data.
N   * @param[out] *pOut points to the block of output data.
N   * @param[out] *pErr points to the block of error data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_lms_q15(
N  const arm_lms_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pRef,
N  q15_t * pOut,
N  q15_t * pErr,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the Q31 LMS filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numTaps;    /**< number of coefficients in the filter. */
N    q31_t *pState;       /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q31_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
N    q31_t mu;            /**< step size that controls filter coefficient updates. */
N    uint32_t postShift;  /**< bit shift applied to coefficients. */
N
N  } arm_lms_instance_q31;
N
N  /**
N   * @brief Processing function for Q31 LMS filter.
N   * @param[in]  *S points to an instance of the Q15 LMS filter structure.
N   * @param[in]  *pSrc points to the block of input data.
N   * @param[in]  *pRef points to the block of reference data.
N   * @param[out] *pOut points to the block of output data.
N   * @param[out] *pErr points to the block of error data.
N   * @param[in]  blockSize number of samples to process.
N   * @return     none.
N   */
N
N  void arm_lms_q31(
N  const arm_lms_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pRef,
N  q31_t * pOut,
N  q31_t * pErr,
N  uint32_t blockSize);
N
N  /**
N   * @brief Initialization function for Q31 LMS filter.
N   * @param[in] *S points to an instance of the Q31 LMS filter structure.
N   * @param[in] numTaps  number of filter coefficients.
N   * @param[in] *pCoeffs points to coefficient buffer.
N   * @param[in] *pState points to state buffer.
N   * @param[in] mu step size that controls filter coefficient updates.
N   * @param[in] blockSize number of samples to process.
N   * @param[in] postShift bit shift applied to coefficients.
N   * @return none.
N   */
N
N  void arm_lms_init_q31(
N  arm_lms_instance_q31 * S,
N  uint16_t numTaps,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  q31_t mu,
N  uint32_t blockSize,
N  uint32_t postShift);
N
N  /**
N   * @brief Instance structure for the floating-point normalized LMS filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numTaps;     /**< number of coefficients in the filter. */
N    float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
N    float32_t mu;        /**< step size that control filter coefficient updates. */
N    float32_t energy;    /**< saves previous frame energy. */
N    float32_t x0;        /**< saves previous input sample. */
N  } arm_lms_norm_instance_f32;
N
N  /**
N   * @brief Processing function for floating-point normalized LMS filter.
N   * @param[in] *S points to an instance of the floating-point normalized LMS filter structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[in] *pRef points to the block of reference data.
N   * @param[out] *pOut points to the block of output data.
N   * @param[out] *pErr points to the block of error data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_lms_norm_f32(
N  arm_lms_norm_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pRef,
N  float32_t * pOut,
N  float32_t * pErr,
N  uint32_t blockSize);
N
N  /**
N   * @brief Initialization function for floating-point normalized LMS filter.
N   * @param[in] *S points to an instance of the floating-point LMS filter structure.
N   * @param[in] numTaps  number of filter coefficients.
N   * @param[in] *pCoeffs points to coefficient buffer.
N   * @param[in] *pState points to state buffer.
N   * @param[in] mu step size that controls filter coefficient updates.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_lms_norm_init_f32(
N  arm_lms_norm_instance_f32 * S,
N  uint16_t numTaps,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  float32_t mu,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the Q31 normalized LMS filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;     /**< number of coefficients in the filter. */
N    q31_t *pState;        /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q31_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
N    q31_t mu;             /**< step size that controls filter coefficient updates. */
N    uint8_t postShift;    /**< bit shift applied to coefficients. */
N    q31_t *recipTable;    /**< points to the reciprocal initial value table. */
N    q31_t energy;         /**< saves previous frame energy. */
N    q31_t x0;             /**< saves previous input sample. */
N  } arm_lms_norm_instance_q31;
N
N  /**
N   * @brief Processing function for Q31 normalized LMS filter.
N   * @param[in] *S points to an instance of the Q31 normalized LMS filter structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[in] *pRef points to the block of reference data.
N   * @param[out] *pOut points to the block of output data.
N   * @param[out] *pErr points to the block of error data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_lms_norm_q31(
N  arm_lms_norm_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pRef,
N  q31_t * pOut,
N  q31_t * pErr,
N  uint32_t blockSize);
N
N  /**
N   * @brief Initialization function for Q31 normalized LMS filter.
N   * @param[in] *S points to an instance of the Q31 normalized LMS filter structure.
N   * @param[in] numTaps  number of filter coefficients.
N   * @param[in] *pCoeffs points to coefficient buffer.
N   * @param[in] *pState points to state buffer.
N   * @param[in] mu step size that controls filter coefficient updates.
N   * @param[in] blockSize number of samples to process.
N   * @param[in] postShift bit shift applied to coefficients.
N   * @return none.
N   */
N
N  void arm_lms_norm_init_q31(
N  arm_lms_norm_instance_q31 * S,
N  uint16_t numTaps,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  q31_t mu,
N  uint32_t blockSize,
N  uint8_t postShift);
N
N  /**
N   * @brief Instance structure for the Q15 normalized LMS filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numTaps;    /**< Number of coefficients in the filter. */
N    q15_t *pState;        /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q15_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
N    q15_t mu;            /**< step size that controls filter coefficient updates. */
N    uint8_t postShift;   /**< bit shift applied to coefficients. */
N    q15_t *recipTable;   /**< Points to the reciprocal initial value table. */
N    q15_t energy;        /**< saves previous frame energy. */
N    q15_t x0;            /**< saves previous input sample. */
N  } arm_lms_norm_instance_q15;
N
N  /**
N   * @brief Processing function for Q15 normalized LMS filter.
N   * @param[in] *S points to an instance of the Q15 normalized LMS filter structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[in] *pRef points to the block of reference data.
N   * @param[out] *pOut points to the block of output data.
N   * @param[out] *pErr points to the block of error data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_lms_norm_q15(
N  arm_lms_norm_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pRef,
N  q15_t * pOut,
N  q15_t * pErr,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Initialization function for Q15 normalized LMS filter.
N   * @param[in] *S points to an instance of the Q15 normalized LMS filter structure.
N   * @param[in] numTaps  number of filter coefficients.
N   * @param[in] *pCoeffs points to coefficient buffer.
N   * @param[in] *pState points to state buffer.
N   * @param[in] mu step size that controls filter coefficient updates.
N   * @param[in] blockSize number of samples to process.
N   * @param[in] postShift bit shift applied to coefficients.
N   * @return none.
N   */
N
N  void arm_lms_norm_init_q15(
N  arm_lms_norm_instance_q15 * S,
N  uint16_t numTaps,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  q15_t mu,
N  uint32_t blockSize,
N  uint8_t postShift);
N
N  /**
N   * @brief Correlation of floating-point sequences.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @return none.
N   */
N
N  void arm_correlate_f32(
N  float32_t * pSrcA,
N  uint32_t srcALen,
N  float32_t * pSrcB,
N  uint32_t srcBLen,
N  float32_t * pDst);
N
N
N   /**
N   * @brief Correlation of Q15 sequences
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @param[in]  *pScratch points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @return none.
N   */
N  void arm_correlate_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  q15_t * pScratch);
N
N
N  /**
N   * @brief Correlation of Q15 sequences.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @return none.
N   */
N
N  void arm_correlate_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst);
N
N  /**
N   * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @return none.
N   */
N
N  void arm_correlate_fast_q15(
N			       q15_t * pSrcA,
N			      uint32_t srcALen,
N			       q15_t * pSrcB,
N			      uint32_t srcBLen,
N			      q15_t * pDst);
N
N
N
N  /**
N   * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @param[in]  *pScratch points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @return none.
N   */
N
N  void arm_correlate_fast_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  q15_t * pScratch);
N
N  /**
N   * @brief Correlation of Q31 sequences.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @return none.
N   */
N
N  void arm_correlate_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst);
N
N  /**
N   * @brief Correlation of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @return none.
N   */
N
N  void arm_correlate_fast_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst);
N
N
N
N /**
N   * @brief Correlation of Q7 sequences.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @param[in]  *pScratch1 points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  *pScratch2 points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
N   * @return none.
N   */
N
N  void arm_correlate_opt_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N  /**
N   * @brief Correlation of Q7 sequences.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @return none.
N   */
N
N  void arm_correlate_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst);
N
N
N  /**
N   * @brief Instance structure for the floating-point sparse FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;             /**< number of coefficients in the filter. */
N    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
N    float32_t *pState;            /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
N    float32_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/
N    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
N    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
N  } arm_fir_sparse_instance_f32;
N
N  /**
N   * @brief Instance structure for the Q31 sparse FIR filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numTaps;             /**< number of coefficients in the filter. */
N    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
N    q31_t *pState;                /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
N    q31_t *pCoeffs;               /**< points to the coefficient array. The array is of length numTaps.*/
N    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
N    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
N  } arm_fir_sparse_instance_q31;
N
N  /**
N   * @brief Instance structure for the Q15 sparse FIR filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numTaps;             /**< number of coefficients in the filter. */
N    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
N    q15_t *pState;                /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
N    q15_t *pCoeffs;               /**< points to the coefficient array. The array is of length numTaps.*/
N    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
N    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
N  } arm_fir_sparse_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q7 sparse FIR filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numTaps;             /**< number of coefficients in the filter. */
N    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
N    q7_t *pState;                 /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
N    q7_t *pCoeffs;                /**< points to the coefficient array. The array is of length numTaps.*/
N    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
N    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
N  } arm_fir_sparse_instance_q7;
N
N  /**
N   * @brief Processing function for the floating-point sparse FIR filter.
N   * @param[in]  *S          points to an instance of the floating-point sparse FIR structure.
N   * @param[in]  *pSrc       points to the block of input data.
N   * @param[out] *pDst       points to the block of output data
N   * @param[in]  *pScratchIn points to a temporary buffer of size blockSize.
N   * @param[in]  blockSize   number of input samples to process per call.
N   * @return none.
N   */
N
N  void arm_fir_sparse_f32(
N  arm_fir_sparse_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  float32_t * pScratchIn,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the floating-point sparse FIR filter.
N   * @param[in,out] *S         points to an instance of the floating-point sparse FIR structure.
N   * @param[in]     numTaps    number of nonzero coefficients in the filter.
N   * @param[in]     *pCoeffs   points to the array of filter coefficients.
N   * @param[in]     *pState    points to the state buffer.
N   * @param[in]     *pTapDelay points to the array of offset times.
N   * @param[in]     maxDelay   maximum offset time supported.
N   * @param[in]     blockSize  number of samples that will be processed per block.
N   * @return none
N   */
N
N  void arm_fir_sparse_init_f32(
N  arm_fir_sparse_instance_f32 * S,
N  uint16_t numTaps,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  int32_t * pTapDelay,
N  uint16_t maxDelay,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the Q31 sparse FIR filter.
N   * @param[in]  *S          points to an instance of the Q31 sparse FIR structure.
N   * @param[in]  *pSrc       points to the block of input data.
N   * @param[out] *pDst       points to the block of output data
N   * @param[in]  *pScratchIn points to a temporary buffer of size blockSize.
N   * @param[in]  blockSize   number of input samples to process per call.
N   * @return none.
N   */
N
N  void arm_fir_sparse_q31(
N  arm_fir_sparse_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  q31_t * pScratchIn,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the Q31 sparse FIR filter.
N   * @param[in,out] *S         points to an instance of the Q31 sparse FIR structure.
N   * @param[in]     numTaps    number of nonzero coefficients in the filter.
N   * @param[in]     *pCoeffs   points to the array of filter coefficients.
N   * @param[in]     *pState    points to the state buffer.
N   * @param[in]     *pTapDelay points to the array of offset times.
N   * @param[in]     maxDelay   maximum offset time supported.
N   * @param[in]     blockSize  number of samples that will be processed per block.
N   * @return none
N   */
N
N  void arm_fir_sparse_init_q31(
N  arm_fir_sparse_instance_q31 * S,
N  uint16_t numTaps,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  int32_t * pTapDelay,
N  uint16_t maxDelay,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the Q15 sparse FIR filter.
N   * @param[in]  *S           points to an instance of the Q15 sparse FIR structure.
N   * @param[in]  *pSrc        points to the block of input data.
N   * @param[out] *pDst        points to the block of output data
N   * @param[in]  *pScratchIn  points to a temporary buffer of size blockSize.
N   * @param[in]  *pScratchOut points to a temporary buffer of size blockSize.
N   * @param[in]  blockSize    number of input samples to process per call.
N   * @return none.
N   */
N
N  void arm_fir_sparse_q15(
N  arm_fir_sparse_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  q15_t * pScratchIn,
N  q31_t * pScratchOut,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q15 sparse FIR filter.
N   * @param[in,out] *S         points to an instance of the Q15 sparse FIR structure.
N   * @param[in]     numTaps    number of nonzero coefficients in the filter.
N   * @param[in]     *pCoeffs   points to the array of filter coefficients.
N   * @param[in]     *pState    points to the state buffer.
N   * @param[in]     *pTapDelay points to the array of offset times.
N   * @param[in]     maxDelay   maximum offset time supported.
N   * @param[in]     blockSize  number of samples that will be processed per block.
N   * @return none
N   */
N
N  void arm_fir_sparse_init_q15(
N  arm_fir_sparse_instance_q15 * S,
N  uint16_t numTaps,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  int32_t * pTapDelay,
N  uint16_t maxDelay,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the Q7 sparse FIR filter.
N   * @param[in]  *S           points to an instance of the Q7 sparse FIR structure.
N   * @param[in]  *pSrc        points to the block of input data.
N   * @param[out] *pDst        points to the block of output data
N   * @param[in]  *pScratchIn  points to a temporary buffer of size blockSize.
N   * @param[in]  *pScratchOut points to a temporary buffer of size blockSize.
N   * @param[in]  blockSize    number of input samples to process per call.
N   * @return none.
N   */
N
N  void arm_fir_sparse_q7(
N  arm_fir_sparse_instance_q7 * S,
N  q7_t * pSrc,
N  q7_t * pDst,
N  q7_t * pScratchIn,
N  q31_t * pScratchOut,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the Q7 sparse FIR filter.
N   * @param[in,out] *S         points to an instance of the Q7 sparse FIR structure.
N   * @param[in]     numTaps    number of nonzero coefficients in the filter.
N   * @param[in]     *pCoeffs   points to the array of filter coefficients.
N   * @param[in]     *pState    points to the state buffer.
N   * @param[in]     *pTapDelay points to the array of offset times.
N   * @param[in]     maxDelay   maximum offset time supported.
N   * @param[in]     blockSize  number of samples that will be processed per block.
N   * @return none
N   */
N
N  void arm_fir_sparse_init_q7(
N  arm_fir_sparse_instance_q7 * S,
N  uint16_t numTaps,
N  q7_t * pCoeffs,
N  q7_t * pState,
N  int32_t * pTapDelay,
N  uint16_t maxDelay,
N  uint32_t blockSize);
N
N
N  /*
N   * @brief  Floating-point sin_cos function.
N   * @param[in]  theta    input value in degrees
N   * @param[out] *pSinVal points to the processed sine output.
N   * @param[out] *pCosVal points to the processed cos output.
N   * @return none.
N   */
N
N  void arm_sin_cos_f32(
N  float32_t theta,
N  float32_t * pSinVal,
N  float32_t * pCcosVal);
N
N  /*
N   * @brief  Q31 sin_cos function.
N   * @param[in]  theta    scaled input value in degrees
N   * @param[out] *pSinVal points to the processed sine output.
N   * @param[out] *pCosVal points to the processed cosine output.
N   * @return none.
N   */
N
N  void arm_sin_cos_q31(
N  q31_t theta,
N  q31_t * pSinVal,
N  q31_t * pCosVal);
N
N
N  /**
N   * @brief  Floating-point complex conjugate.
N   * @param[in]  *pSrc points to the input vector
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  numSamples number of complex samples in each vector
N   * @return none.
N   */
N
N  void arm_cmplx_conj_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Q31 complex conjugate.
N   * @param[in]  *pSrc points to the input vector
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  numSamples number of complex samples in each vector
N   * @return none.
N   */
N
N  void arm_cmplx_conj_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Q15 complex conjugate.
N   * @param[in]  *pSrc points to the input vector
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  numSamples number of complex samples in each vector
N   * @return none.
N   */
N
N  void arm_cmplx_conj_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t numSamples);
N
N
N
N  /**
N   * @brief  Floating-point complex magnitude squared
N   * @param[in]  *pSrc points to the complex input vector
N   * @param[out]  *pDst points to the real output vector
N   * @param[in]  numSamples number of complex samples in the input vector
N   * @return none.
N   */
N
N  void arm_cmplx_mag_squared_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Q31 complex magnitude squared
N   * @param[in]  *pSrc points to the complex input vector
N   * @param[out]  *pDst points to the real output vector
N   * @param[in]  numSamples number of complex samples in the input vector
N   * @return none.
N   */
N
N  void arm_cmplx_mag_squared_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Q15 complex magnitude squared
N   * @param[in]  *pSrc points to the complex input vector
N   * @param[out]  *pDst points to the real output vector
N   * @param[in]  numSamples number of complex samples in the input vector
N   * @return none.
N   */
N
N  void arm_cmplx_mag_squared_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t numSamples);
N
N
N /**
N   * @ingroup groupController
N   */
N
N  /**
N   * @defgroup PID PID Motor Control
N   *
N   * A Proportional Integral Derivative (PID) controller is a generic feedback control
N   * loop mechanism widely used in industrial control systems.
N   * A PID controller is the most commonly used type of feedback controller.
N   *
N   * This set of functions implements (PID) controllers
N   * for Q15, Q31, and floating-point data types.  The functions operate on a single sample
N   * of data and each call to the function returns a single processed value.
N   * <code>S</code> points to an instance of the PID control data structure.  <code>in</code>
N   * is the input sample value. The functions return the output value.
N   *
N   * \par Algorithm:
N   * <pre>
N   *    y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]
N   *    A0 = Kp + Ki + Kd
N   *    A1 = (-Kp ) - (2 * Kd )
N   *    A2 = Kd  </pre>
N   *
N   * \par
N   * where \c Kp is proportional constant, \c Ki is Integral constant and \c Kd is Derivative constant
N   *
N   * \par
N   * \image html PID.gif "Proportional Integral Derivative Controller"
N   *
N   * \par
N   * The PID controller calculates an "error" value as the difference between
N   * the measured output and the reference input.
N   * The controller attempts to minimize the error by adjusting the process control inputs.
N   * The proportional value determines the reaction to the current error,
N   * the integral value determines the reaction based on the sum of recent errors,
N   * and the derivative value determines the reaction based on the rate at which the error has been changing.
N   *
N   * \par Instance Structure
N   * The Gains A0, A1, A2 and state variables for a PID controller are stored together in an instance data structure.
N   * A separate instance structure must be defined for each PID Controller.
N   * There are separate instance structure declarations for each of the 3 supported data types.
N   *
N   * \par Reset Functions
N   * There is also an associated reset function for each data type which clears the state array.
N   *
N   * \par Initialization Functions
N   * There is also an associated initialization function for each data type.
N   * The initialization function performs the following operations:
N   * - Initializes the Gains A0, A1, A2 from Kp,Ki, Kd gains.
N   * - Zeros out the values in the state buffer.
N   *
N   * \par
N   * Instance structure cannot be placed into a const data section and it is recommended to use the initialization function.
N   *
N   * \par Fixed-Point Behavior
N   * Care must be taken when using the fixed-point versions of the PID Controller functions.
N   * In particular, the overflow and saturation behavior of the accumulator used in each function must be considered.
N   * Refer to the function specific documentation below for usage guidelines.
N   */
N
N  /**
N   * @addtogroup PID
N   * @{
N   */
N
N  /**
N   * @brief  Process function for the floating-point PID Control.
N   * @param[in,out] *S is an instance of the floating-point PID Control structure
N   * @param[in] in input sample to process
N   * @return out processed output sample.
N   */
N
N  static __INLINE float32_t arm_pid_f32
X  static __inline float32_t arm_pid_f32
N  (
N  arm_pid_instance_f32 * S,
N  float32_t in)
N  {
N    float32_t out;
N
N    /* y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]  */
N    out = (S->A0 * in) +
N      (S->A1 * S->state[0]) + (S->A2 * S->state[1]) + (S->state[2]);
N
N    /* Update state */
N    S->state[1] = S->state[0];
N    S->state[0] = in;
N    S->state[2] = out;
N
N    /* return to application */
N    return (out);
N
N  }
N
N  /**
N   * @brief  Process function for the Q31 PID Control.
N   * @param[in,out] *S points to an instance of the Q31 PID Control structure
N   * @param[in] in input sample to process
N   * @return out processed output sample.
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using an internal 64-bit accumulator.
N   * The accumulator has a 2.62 format and maintains full precision of the intermediate multiplication results but provides only a single guard bit.
N   * Thus, if the accumulator result overflows it wraps around rather than clip.
N   * In order to avoid overflows completely the input signal must be scaled down by 2 bits as there are four additions.
N   * After all multiply-accumulates are performed, the 2.62 accumulator is truncated to 1.32 format and then saturated to 1.31 format.
N   */
N
N  static __INLINE q31_t arm_pid_q31(
X  static __inline q31_t arm_pid_q31(
N  arm_pid_instance_q31 * S,
N  q31_t in)
N  {
N    q63_t acc;
N    q31_t out;
N
N    /* acc = A0 * x[n]  */
N    acc = (q63_t) S->A0 * in;
N
N    /* acc += A1 * x[n-1] */
N    acc += (q63_t) S->A1 * S->state[0];
N
N    /* acc += A2 * x[n-2]  */
N    acc += (q63_t) S->A2 * S->state[1];
N
N    /* convert output to 1.31 format to add y[n-1] */
N    out = (q31_t) (acc >> 31u);
N
N    /* out += y[n-1] */
N    out += S->state[2];
N
N    /* Update state */
N    S->state[1] = S->state[0];
N    S->state[0] = in;
N    S->state[2] = out;
N
N    /* return to application */
N    return (out);
N
N  }
N
N  /**
N   * @brief  Process function for the Q15 PID Control.
N   * @param[in,out] *S points to an instance of the Q15 PID Control structure
N   * @param[in] in input sample to process
N   * @return out processed output sample.
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using a 64-bit internal accumulator.
N   * Both Gains and state variables are represented in 1.15 format and multiplications yield a 2.30 result.
N   * The 2.30 intermediate results are accumulated in a 64-bit accumulator in 34.30 format.
N   * There is no risk of internal overflow with this approach and the full precision of intermediate multiplications is preserved.
N   * After all additions have been performed, the accumulator is truncated to 34.15 format by discarding low 15 bits.
N   * Lastly, the accumulator is saturated to yield a result in 1.15 format.
N   */
N
N  static __INLINE q15_t arm_pid_q15(
X  static __inline q15_t arm_pid_q15(
N  arm_pid_instance_q15 * S,
N  q15_t in)
N  {
N    q63_t acc;
N    q15_t out;
N
N#ifndef ARM_MATH_CM0_FAMILY
N    __SIMD32_TYPE *vstate;
X    int32_t __packed *vstate;
N
N    /* Implementation of PID controller */
N
N    /* acc = A0 * x[n]  */
N    acc = (q31_t) __SMUAD(S->A0, in);
X    acc = (q31_t) __smuad(S->A0, in);
N
N    /* acc += A1 * x[n-1] + A2 * x[n-2]  */
N    vstate = __SIMD32_CONST(S->state);
X    vstate = ((int32_t __packed *)(S->state));
N    acc = __SMLALD(S->A1, (q31_t) *vstate, acc);
X    acc = __smlald(S->A1, (q31_t) *vstate, acc);
N
N#else
S    /* acc = A0 * x[n]  */
S    acc = ((q31_t) S->A0) * in;
S
S    /* acc += A1 * x[n-1] + A2 * x[n-2]  */
S    acc += (q31_t) S->A1 * S->state[0];
S    acc += (q31_t) S->A2 * S->state[1];
S
N#endif
N
N    /* acc += y[n-1] */
N    acc += (q31_t) S->state[2] << 15;
N
N    /* saturate the output */
N    out = (q15_t) (__SSAT((acc >> 15), 16));
X    out = (q15_t) (__ssat((acc >> 15), 16));
N
N    /* Update state */
N    S->state[1] = S->state[0];
N    S->state[0] = in;
N    S->state[2] = out;
N
N    /* return to application */
N    return (out);
N
N  }
N
N  /**
N   * @} end of PID group
N   */
N
N
N  /**
N   * @brief Floating-point matrix inverse.
N   * @param[in]  *src points to the instance of the input floating-point matrix structure.
N   * @param[out] *dst points to the instance of the output floating-point matrix structure.
N   * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
N   * If the input matrix is singular (does not have an inverse), then the algorithm terminates and returns error status ARM_MATH_SINGULAR.
N   */
N
N  arm_status arm_mat_inverse_f32(
N  const arm_matrix_instance_f32 * src,
N  arm_matrix_instance_f32 * dst);
N
N
N  /**
N   * @brief Floating-point matrix inverse.
N   * @param[in]  *src points to the instance of the input floating-point matrix structure.
N   * @param[out] *dst points to the instance of the output floating-point matrix structure.
N   * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
N   * If the input matrix is singular (does not have an inverse), then the algorithm terminates and returns error status ARM_MATH_SINGULAR.
N   */
N
N  arm_status arm_mat_inverse_f64(
N  const arm_matrix_instance_f64 * src,
N  arm_matrix_instance_f64 * dst);
N
N
N
N  /**
N   * @ingroup groupController
N   */
N
N
N  /**
N   * @defgroup clarke Vector Clarke Transform
N   * Forward Clarke transform converts the instantaneous stator phases into a two-coordinate time invariant vector.
N   * Generally the Clarke transform uses three-phase currents <code>Ia, Ib and Ic</code> to calculate currents
N   * in the two-phase orthogonal stator axis <code>Ialpha</code> and <code>Ibeta</code>.
N   * When <code>Ialpha</code> is superposed with <code>Ia</code> as shown in the figure below
N   * \image html clarke.gif Stator current space vector and its components in (a,b).
N   * and <code>Ia + Ib + Ic = 0</code>, in this condition <code>Ialpha</code> and <code>Ibeta</code>
N   * can be calculated using only <code>Ia</code> and <code>Ib</code>.
N   *
N   * The function operates on a single sample of data and each call to the function returns the processed output.
N   * The library provides separate functions for Q31 and floating-point data types.
N   * \par Algorithm
N   * \image html clarkeFormula.gif
N   * where <code>Ia</code> and <code>Ib</code> are the instantaneous stator phases and
N   * <code>pIalpha</code> and <code>pIbeta</code> are the two coordinates of time invariant vector.
N   * \par Fixed-Point Behavior
N   * Care must be taken when using the Q31 version of the Clarke transform.
N   * In particular, the overflow and saturation behavior of the accumulator used must be considered.
N   * Refer to the function specific documentation below for usage guidelines.
N   */
N
N  /**
N   * @addtogroup clarke
N   * @{
N   */
N
N  /**
N   *
N   * @brief  Floating-point Clarke transform
N   * @param[in]       Ia       input three-phase coordinate <code>a</code>
N   * @param[in]       Ib       input three-phase coordinate <code>b</code>
N   * @param[out]      *pIalpha points to output two-phase orthogonal vector axis alpha
N   * @param[out]      *pIbeta  points to output two-phase orthogonal vector axis beta
N   * @return none.
N   */
N
N  static __INLINE void arm_clarke_f32(
X  static __inline void arm_clarke_f32(
N  float32_t Ia,
N  float32_t Ib,
N  float32_t * pIalpha,
N  float32_t * pIbeta)
N  {
N    /* Calculate pIalpha using the equation, pIalpha = Ia */
N    *pIalpha = Ia;
N
N    /* Calculate pIbeta using the equation, pIbeta = (1/sqrt(3)) * Ia + (2/sqrt(3)) * Ib */
N    *pIbeta =
N      ((float32_t) 0.57735026919 * Ia + (float32_t) 1.15470053838 * Ib);
N
N  }
N
N  /**
N   * @brief  Clarke transform for Q31 version
N   * @param[in]       Ia       input three-phase coordinate <code>a</code>
N   * @param[in]       Ib       input three-phase coordinate <code>b</code>
N   * @param[out]      *pIalpha points to output two-phase orthogonal vector axis alpha
N   * @param[out]      *pIbeta  points to output two-phase orthogonal vector axis beta
N   * @return none.
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using an internal 32-bit accumulator.
N   * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multiplication in 2.62 format.
N   * There is saturation on the addition, hence there is no risk of overflow.
N   */
N
N  static __INLINE void arm_clarke_q31(
X  static __inline void arm_clarke_q31(
N  q31_t Ia,
N  q31_t Ib,
N  q31_t * pIalpha,
N  q31_t * pIbeta)
N  {
N    q31_t product1, product2;                    /* Temporary variables used to store intermediate results */
N
N    /* Calculating pIalpha from Ia by equation pIalpha = Ia */
N    *pIalpha = Ia;
N
N    /* Intermediate product is calculated by (1/(sqrt(3)) * Ia) */
N    product1 = (q31_t) (((q63_t) Ia * 0x24F34E8B) >> 30);
N
N    /* Intermediate product is calculated by (2/sqrt(3) * Ib) */
N    product2 = (q31_t) (((q63_t) Ib * 0x49E69D16) >> 30);
N
N    /* pIbeta is calculated by adding the intermediate products */
N    *pIbeta = __QADD(product1, product2);
X    *pIbeta = __qadd(product1, product2);
N  }
N
N  /**
N   * @} end of clarke group
N   */
N
N  /**
N   * @brief  Converts the elements of the Q7 vector to Q31 vector.
N   * @param[in]  *pSrc     input pointer
N   * @param[out]  *pDst    output pointer
N   * @param[in]  blockSize number of samples to process
N   * @return none.
N   */
N  void arm_q7_to_q31(
N  q7_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N
N
N  /**
N   * @ingroup groupController
N   */
N
N  /**
N   * @defgroup inv_clarke Vector Inverse Clarke Transform
N   * Inverse Clarke transform converts the two-coordinate time invariant vector into instantaneous stator phases.
N   *
N   * The function operates on a single sample of data and each call to the function returns the processed output.
N   * The library provides separate functions for Q31 and floating-point data types.
N   * \par Algorithm
N   * \image html clarkeInvFormula.gif
N   * where <code>pIa</code> and <code>pIb</code> are the instantaneous stator phases and
N   * <code>Ialpha</code> and <code>Ibeta</code> are the two coordinates of time invariant vector.
N   * \par Fixed-Point Behavior
N   * Care must be taken when using the Q31 version of the Clarke transform.
N   * In particular, the overflow and saturation behavior of the accumulator used must be considered.
N   * Refer to the function specific documentation below for usage guidelines.
N   */
N
N  /**
N   * @addtogroup inv_clarke
N   * @{
N   */
N
N   /**
N   * @brief  Floating-point Inverse Clarke transform
N   * @param[in]       Ialpha  input two-phase orthogonal vector axis alpha
N   * @param[in]       Ibeta   input two-phase orthogonal vector axis beta
N   * @param[out]      *pIa    points to output three-phase coordinate <code>a</code>
N   * @param[out]      *pIb    points to output three-phase coordinate <code>b</code>
N   * @return none.
N   */
N
N
N  static __INLINE void arm_inv_clarke_f32(
X  static __inline void arm_inv_clarke_f32(
N  float32_t Ialpha,
N  float32_t Ibeta,
N  float32_t * pIa,
N  float32_t * pIb)
N  {
N    /* Calculating pIa from Ialpha by equation pIa = Ialpha */
N    *pIa = Ialpha;
N
N    /* Calculating pIb from Ialpha and Ibeta by equation pIb = -(1/2) * Ialpha + (sqrt(3)/2) * Ibeta */
N    *pIb = -0.5 * Ialpha + (float32_t) 0.8660254039 *Ibeta;
N
N  }
N
N  /**
N   * @brief  Inverse Clarke transform for Q31 version
N   * @param[in]       Ialpha  input two-phase orthogonal vector axis alpha
N   * @param[in]       Ibeta   input two-phase orthogonal vector axis beta
N   * @param[out]      *pIa    points to output three-phase coordinate <code>a</code>
N   * @param[out]      *pIb    points to output three-phase coordinate <code>b</code>
N   * @return none.
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using an internal 32-bit accumulator.
N   * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multiplication in 2.62 format.
N   * There is saturation on the subtraction, hence there is no risk of overflow.
N   */
N
N  static __INLINE void arm_inv_clarke_q31(
X  static __inline void arm_inv_clarke_q31(
N  q31_t Ialpha,
N  q31_t Ibeta,
N  q31_t * pIa,
N  q31_t * pIb)
N  {
N    q31_t product1, product2;                    /* Temporary variables used to store intermediate results */
N
N    /* Calculating pIa from Ialpha by equation pIa = Ialpha */
N    *pIa = Ialpha;
N
N    /* Intermediate product is calculated by (1/(2*sqrt(3)) * Ia) */
N    product1 = (q31_t) (((q63_t) (Ialpha) * (0x40000000)) >> 31);
N
N    /* Intermediate product is calculated by (1/sqrt(3) * pIb) */
N    product2 = (q31_t) (((q63_t) (Ibeta) * (0x6ED9EBA1)) >> 31);
N
N    /* pIb is calculated by subtracting the products */
N    *pIb = __QSUB(product2, product1);
X    *pIb = __qsub(product2, product1);
N
N  }
N
N  /**
N   * @} end of inv_clarke group
N   */
N
N  /**
N   * @brief  Converts the elements of the Q7 vector to Q15 vector.
N   * @param[in]  *pSrc     input pointer
N   * @param[out] *pDst     output pointer
N   * @param[in]  blockSize number of samples to process
N   * @return none.
N   */
N  void arm_q7_to_q15(
N  q7_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N
N  /**
N   * @ingroup groupController
N   */
N
N  /**
N   * @defgroup park Vector Park Transform
N   *
N   * Forward Park transform converts the input two-coordinate vector to flux and torque components.
N   * The Park transform can be used to realize the transformation of the <code>Ialpha</code> and the <code>Ibeta</code> currents
N   * from the stationary to the moving reference frame and control the spatial relationship between
N   * the stator vector current and rotor flux vector.
N   * If we consider the d axis aligned with the rotor flux, the diagram below shows the
N   * current vector and the relationship from the two reference frames:
N   * \image html park.gif "Stator current space vector and its component in (a,b) and in the d,q rotating reference frame"
N   *
N   * The function operates on a single sample of data and each call to the function returns the processed output.
N   * The library provides separate functions for Q31 and floating-point data types.
N   * \par Algorithm
N   * \image html parkFormula.gif
N   * where <code>Ialpha</code> and <code>Ibeta</code> are the stator vector components,
N   * <code>pId</code> and <code>pIq</code> are rotor vector components and <code>cosVal</code> and <code>sinVal</code> are the
N   * cosine and sine values of theta (rotor flux position).
N   * \par Fixed-Point Behavior
N   * Care must be taken when using the Q31 version of the Park transform.
N   * In particular, the overflow and saturation behavior of the accumulator used must be considered.
N   * Refer to the function specific documentation below for usage guidelines.
N   */
N
N  /**
N   * @addtogroup park
N   * @{
N   */
N
N  /**
N   * @brief Floating-point Park transform
N   * @param[in]       Ialpha input two-phase vector coordinate alpha
N   * @param[in]       Ibeta  input two-phase vector coordinate beta
N   * @param[out]      *pId   points to output	rotor reference frame d
N   * @param[out]      *pIq   points to output	rotor reference frame q
N   * @param[in]       sinVal sine value of rotation angle theta
N   * @param[in]       cosVal cosine value of rotation angle theta
N   * @return none.
N   *
N   * The function implements the forward Park transform.
N   *
N   */
N
N  static __INLINE void arm_park_f32(
X  static __inline void arm_park_f32(
N  float32_t Ialpha,
N  float32_t Ibeta,
N  float32_t * pId,
N  float32_t * pIq,
N  float32_t sinVal,
N  float32_t cosVal)
N  {
N    /* Calculate pId using the equation, pId = Ialpha * cosVal + Ibeta * sinVal */
N    *pId = Ialpha * cosVal + Ibeta * sinVal;
N
N    /* Calculate pIq using the equation, pIq = - Ialpha * sinVal + Ibeta * cosVal */
N    *pIq = -Ialpha * sinVal + Ibeta * cosVal;
N
N  }
N
N  /**
N   * @brief  Park transform for Q31 version
N   * @param[in]       Ialpha input two-phase vector coordinate alpha
N   * @param[in]       Ibeta  input two-phase vector coordinate beta
N   * @param[out]      *pId   points to output rotor reference frame d
N   * @param[out]      *pIq   points to output rotor reference frame q
N   * @param[in]       sinVal sine value of rotation angle theta
N   * @param[in]       cosVal cosine value of rotation angle theta
N   * @return none.
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using an internal 32-bit accumulator.
N   * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multiplication in 2.62 format.
N   * There is saturation on the addition and subtraction, hence there is no risk of overflow.
N   */
N
N
N  static __INLINE void arm_park_q31(
X  static __inline void arm_park_q31(
N  q31_t Ialpha,
N  q31_t Ibeta,
N  q31_t * pId,
N  q31_t * pIq,
N  q31_t sinVal,
N  q31_t cosVal)
N  {
N    q31_t product1, product2;                    /* Temporary variables used to store intermediate results */
N    q31_t product3, product4;                    /* Temporary variables used to store intermediate results */
N
N    /* Intermediate product is calculated by (Ialpha * cosVal) */
N    product1 = (q31_t) (((q63_t) (Ialpha) * (cosVal)) >> 31);
N
N    /* Intermediate product is calculated by (Ibeta * sinVal) */
N    product2 = (q31_t) (((q63_t) (Ibeta) * (sinVal)) >> 31);
N
N
N    /* Intermediate product is calculated by (Ialpha * sinVal) */
N    product3 = (q31_t) (((q63_t) (Ialpha) * (sinVal)) >> 31);
N
N    /* Intermediate product is calculated by (Ibeta * cosVal) */
N    product4 = (q31_t) (((q63_t) (Ibeta) * (cosVal)) >> 31);
N
N    /* Calculate pId by adding the two intermediate products 1 and 2 */
N    *pId = __QADD(product1, product2);
X    *pId = __qadd(product1, product2);
N
N    /* Calculate pIq by subtracting the two intermediate products 3 from 4 */
N    *pIq = __QSUB(product4, product3);
X    *pIq = __qsub(product4, product3);
N  }
N
N  /**
N   * @} end of park group
N   */
N
N  /**
N   * @brief  Converts the elements of the Q7 vector to floating-point vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[out]  *pDst is output pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @return none.
N   */
N  void arm_q7_to_float(
N  q7_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @ingroup groupController
N   */
N
N  /**
N   * @defgroup inv_park Vector Inverse Park transform
N   * Inverse Park transform converts the input flux and torque components to two-coordinate vector.
N   *
N   * The function operates on a single sample of data and each call to the function returns the processed output.
N   * The library provides separate functions for Q31 and floating-point data types.
N   * \par Algorithm
N   * \image html parkInvFormula.gif
N   * where <code>pIalpha</code> and <code>pIbeta</code> are the stator vector components,
N   * <code>Id</code> and <code>Iq</code> are rotor vector components and <code>cosVal</code> and <code>sinVal</code> are the
N   * cosine and sine values of theta (rotor flux position).
N   * \par Fixed-Point Behavior
N   * Care must be taken when using the Q31 version of the Park transform.
N   * In particular, the overflow and saturation behavior of the accumulator used must be considered.
N   * Refer to the function specific documentation below for usage guidelines.
N   */
N
N  /**
N   * @addtogroup inv_park
N   * @{
N   */
N
N   /**
N   * @brief  Floating-point Inverse Park transform
N   * @param[in]       Id        input coordinate of rotor reference frame d
N   * @param[in]       Iq        input coordinate of rotor reference frame q
N   * @param[out]      *pIalpha  points to output two-phase orthogonal vector axis alpha
N   * @param[out]      *pIbeta   points to output two-phase orthogonal vector axis beta
N   * @param[in]       sinVal    sine value of rotation angle theta
N   * @param[in]       cosVal    cosine value of rotation angle theta
N   * @return none.
N   */
N
N  static __INLINE void arm_inv_park_f32(
X  static __inline void arm_inv_park_f32(
N  float32_t Id,
N  float32_t Iq,
N  float32_t * pIalpha,
N  float32_t * pIbeta,
N  float32_t sinVal,
N  float32_t cosVal)
N  {
N    /* Calculate pIalpha using the equation, pIalpha = Id * cosVal - Iq * sinVal */
N    *pIalpha = Id * cosVal - Iq * sinVal;
N
N    /* Calculate pIbeta using the equation, pIbeta = Id * sinVal + Iq * cosVal */
N    *pIbeta = Id * sinVal + Iq * cosVal;
N
N  }
N
N
N  /**
N   * @brief  Inverse Park transform for	Q31 version
N   * @param[in]       Id        input coordinate of rotor reference frame d
N   * @param[in]       Iq        input coordinate of rotor reference frame q
N   * @param[out]      *pIalpha  points to output two-phase orthogonal vector axis alpha
N   * @param[out]      *pIbeta   points to output two-phase orthogonal vector axis beta
N   * @param[in]       sinVal    sine value of rotation angle theta
N   * @param[in]       cosVal    cosine value of rotation angle theta
N   * @return none.
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using an internal 32-bit accumulator.
N   * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multiplication in 2.62 format.
N   * There is saturation on the addition, hence there is no risk of overflow.
N   */
N
N
N  static __INLINE void arm_inv_park_q31(
X  static __inline void arm_inv_park_q31(
N  q31_t Id,
N  q31_t Iq,
N  q31_t * pIalpha,
N  q31_t * pIbeta,
N  q31_t sinVal,
N  q31_t cosVal)
N  {
N    q31_t product1, product2;                    /* Temporary variables used to store intermediate results */
N    q31_t product3, product4;                    /* Temporary variables used to store intermediate results */
N
N    /* Intermediate product is calculated by (Id * cosVal) */
N    product1 = (q31_t) (((q63_t) (Id) * (cosVal)) >> 31);
N
N    /* Intermediate product is calculated by (Iq * sinVal) */
N    product2 = (q31_t) (((q63_t) (Iq) * (sinVal)) >> 31);
N
N
N    /* Intermediate product is calculated by (Id * sinVal) */
N    product3 = (q31_t) (((q63_t) (Id) * (sinVal)) >> 31);
N
N    /* Intermediate product is calculated by (Iq * cosVal) */
N    product4 = (q31_t) (((q63_t) (Iq) * (cosVal)) >> 31);
N
N    /* Calculate pIalpha by using the two intermediate products 1 and 2 */
N    *pIalpha = __QSUB(product1, product2);
X    *pIalpha = __qsub(product1, product2);
N
N    /* Calculate pIbeta by using the two intermediate products 3 and 4 */
N    *pIbeta = __QADD(product4, product3);
X    *pIbeta = __qadd(product4, product3);
N
N  }
N
N  /**
N   * @} end of Inverse park group
N   */
N
N
N  /**
N   * @brief  Converts the elements of the Q31 vector to floating-point vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[out]  *pDst is output pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @return none.
N   */
N  void arm_q31_to_float(
N  q31_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @ingroup groupInterpolation
N   */
N
N  /**
N   * @defgroup LinearInterpolate Linear Interpolation
N   *
N   * Linear interpolation is a method of curve fitting using linear polynomials.
N   * Linear interpolation works by effectively drawing a straight line between two neighboring samples and returning the appropriate point along that line
N   *
N   * \par
N   * \image html LinearInterp.gif "Linear interpolation"
N   *
N   * \par
N   * A  Linear Interpolate function calculates an output value(y), for the input(x)
N   * using linear interpolation of the input values x0, x1( nearest input values) and the output values y0 and y1(nearest output values)
N   *
N   * \par Algorithm:
N   * <pre>
N   *       y = y0 + (x - x0) * ((y1 - y0)/(x1-x0))
N   *       where x0, x1 are nearest values of input x
N   *             y0, y1 are nearest values to output y
N   * </pre>
N   *
N   * \par
N   * This set of functions implements Linear interpolation process
N   * for Q7, Q15, Q31, and floating-point data types.  The functions operate on a single
N   * sample of data and each call to the function returns a single processed value.
N   * <code>S</code> points to an instance of the Linear Interpolate function data structure.
N   * <code>x</code> is the input sample value. The functions returns the output value.
N   *
N   * \par
N   * if x is outside of the table boundary, Linear interpolation returns first value of the table
N   * if x is below input range and returns last value of table if x is above range.
N   */
N
N  /**
N   * @addtogroup LinearInterpolate
N   * @{
N   */
N
N  /**
N   * @brief  Process function for the floating-point Linear Interpolation Function.
N   * @param[in,out] *S is an instance of the floating-point Linear Interpolation structure
N   * @param[in] x input sample to process
N   * @return y processed output sample.
N   *
N   */
N
N  static __INLINE float32_t arm_linear_interp_f32(
X  static __inline float32_t arm_linear_interp_f32(
N  arm_linear_interp_instance_f32 * S,
N  float32_t x)
N  {
N
N    float32_t y;
N    float32_t x0, x1;                            /* Nearest input values */
N    float32_t y0, y1;                            /* Nearest output values */
N    float32_t xSpacing = S->xSpacing;            /* spacing between input values */
N    int32_t i;                                   /* Index variable */
N    float32_t *pYData = S->pYData;               /* pointer to output table */
N
N    /* Calculation of index */
N    i = (int32_t) ((x - S->x1) / xSpacing);
N
N    if(i < 0)
N    {
N      /* Iniatilize output for below specified range as least output value of table */
N      y = pYData[0];
N    }
N    else if((uint32_t)i >= S->nValues)
N    {
N      /* Iniatilize output for above specified range as last output value of table */
N      y = pYData[S->nValues - 1];
N    }
N    else
N    {
N      /* Calculation of nearest input values */
N      x0 = S->x1 + i * xSpacing;
N      x1 = S->x1 + (i + 1) * xSpacing;
N
N      /* Read of nearest output values */
N      y0 = pYData[i];
N      y1 = pYData[i + 1];
N
N      /* Calculation of output */
N      y = y0 + (x - x0) * ((y1 - y0) / (x1 - x0));
N
N    }
N
N    /* returns output value */
N    return (y);
N  }
N
N   /**
N   *
N   * @brief  Process function for the Q31 Linear Interpolation Function.
N   * @param[in] *pYData  pointer to Q31 Linear Interpolation table
N   * @param[in] x input sample to process
N   * @param[in] nValues number of table values
N   * @return y processed output sample.
N   *
N   * \par
N   * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 bits for fractional part.
N   * This function can support maximum of table size 2^12.
N   *
N   */
N
N
N  static __INLINE q31_t arm_linear_interp_q31(
X  static __inline q31_t arm_linear_interp_q31(
N  q31_t * pYData,
N  q31_t x,
N  uint32_t nValues)
N  {
N    q31_t y;                                     /* output */
N    q31_t y0, y1;                                /* Nearest output values */
N    q31_t fract;                                 /* fractional part */
N    int32_t index;                               /* Index to read nearest output values */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    index = ((x & 0xFFF00000) >> 20);
N
N    if(index >= (int32_t)(nValues - 1))
N    {
N      return (pYData[nValues - 1]);
N    }
N    else if(index < 0)
N    {
N      return (pYData[0]);
N    }
N    else
N    {
N
N      /* 20 bits for the fractional part */
N      /* shift left by 11 to keep fract in 1.31 format */
N      fract = (x & 0x000FFFFF) << 11;
N
N      /* Read two nearest output values from the index in 1.31(q31) format */
N      y0 = pYData[index];
N      y1 = pYData[index + 1u];
N
N      /* Calculation of y0 * (1-fract) and y is in 2.30 format */
N      y = ((q31_t) ((q63_t) y0 * (0x7FFFFFFF - fract) >> 32));
N
N      /* Calculation of y0 * (1-fract) + y1 *fract and y is in 2.30 format */
N      y += ((q31_t) (((q63_t) y1 * fract) >> 32));
N
N      /* Convert y to 1.31 format */
N      return (y << 1u);
N
N    }
N
N  }
N
N  /**
N   *
N   * @brief  Process function for the Q15 Linear Interpolation Function.
N   * @param[in] *pYData  pointer to Q15 Linear Interpolation table
N   * @param[in] x input sample to process
N   * @param[in] nValues number of table values
N   * @return y processed output sample.
N   *
N   * \par
N   * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 bits for fractional part.
N   * This function can support maximum of table size 2^12.
N   *
N   */
N
N
N  static __INLINE q15_t arm_linear_interp_q15(
X  static __inline q15_t arm_linear_interp_q15(
N  q15_t * pYData,
N  q31_t x,
N  uint32_t nValues)
N  {
N    q63_t y;                                     /* output */
N    q15_t y0, y1;                                /* Nearest output values */
N    q31_t fract;                                 /* fractional part */
N    int32_t index;                               /* Index to read nearest output values */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    index = ((x & 0xFFF00000) >> 20u);
N
N    if(index >= (int32_t)(nValues - 1))
N    {
N      return (pYData[nValues - 1]);
N    }
N    else if(index < 0)
N    {
N      return (pYData[0]);
N    }
N    else
N    {
N      /* 20 bits for the fractional part */
N      /* fract is in 12.20 format */
N      fract = (x & 0x000FFFFF);
N
N      /* Read two nearest output values from the index */
N      y0 = pYData[index];
N      y1 = pYData[index + 1u];
N
N      /* Calculation of y0 * (1-fract) and y is in 13.35 format */
N      y = ((q63_t) y0 * (0xFFFFF - fract));
N
N      /* Calculation of (y0 * (1-fract) + y1 * fract) and y is in 13.35 format */
N      y += ((q63_t) y1 * (fract));
N
N      /* convert y to 1.15 format */
N      return (y >> 20);
N    }
N
N
N  }
N
N  /**
N   *
N   * @brief  Process function for the Q7 Linear Interpolation Function.
N   * @param[in] *pYData  pointer to Q7 Linear Interpolation table
N   * @param[in] x input sample to process
N   * @param[in] nValues number of table values
N   * @return y processed output sample.
N   *
N   * \par
N   * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 bits for fractional part.
N   * This function can support maximum of table size 2^12.
N   */
N
N
N  static __INLINE q7_t arm_linear_interp_q7(
X  static __inline q7_t arm_linear_interp_q7(
N  q7_t * pYData,
N  q31_t x,
N  uint32_t nValues)
N  {
N    q31_t y;                                     /* output */
N    q7_t y0, y1;                                 /* Nearest output values */
N    q31_t fract;                                 /* fractional part */
N    uint32_t index;                              /* Index to read nearest output values */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    if (x < 0)
N    {
N      return (pYData[0]);
N    }
N    index = (x >> 20) & 0xfff;
N
N
N    if(index >= (nValues - 1))
N    {
N      return (pYData[nValues - 1]);
N    }
N    else
N    {
N
N      /* 20 bits for the fractional part */
N      /* fract is in 12.20 format */
N      fract = (x & 0x000FFFFF);
N
N      /* Read two nearest output values from the index and are in 1.7(q7) format */
N      y0 = pYData[index];
N      y1 = pYData[index + 1u];
N
N      /* Calculation of y0 * (1-fract ) and y is in 13.27(q27) format */
N      y = ((y0 * (0xFFFFF - fract)));
N
N      /* Calculation of y1 * fract + y0 * (1-fract) and y is in 13.27(q27) format */
N      y += (y1 * fract);
N
N      /* convert y to 1.7(q7) format */
N      return (y >> 20u);
N
N    }
N
N  }
N  /**
N   * @} end of LinearInterpolate group
N   */
N
N  /**
N   * @brief  Fast approximation to the trigonometric sine function for floating-point data.
N   * @param[in] x input value in radians.
N   * @return  sin(x).
N   */
N
N  float32_t arm_sin_f32(
N  float32_t x);
N
N  /**
N   * @brief  Fast approximation to the trigonometric sine function for Q31 data.
N   * @param[in] x Scaled input value in radians.
N   * @return  sin(x).
N   */
N
N  q31_t arm_sin_q31(
N  q31_t x);
N
N  /**
N   * @brief  Fast approximation to the trigonometric sine function for Q15 data.
N   * @param[in] x Scaled input value in radians.
N   * @return  sin(x).
N   */
N
N  q15_t arm_sin_q15(
N  q15_t x);
N
N  /**
N   * @brief  Fast approximation to the trigonometric cosine function for floating-point data.
N   * @param[in] x input value in radians.
N   * @return  cos(x).
N   */
N
N  float32_t arm_cos_f32(
N  float32_t x);
N
N  /**
N   * @brief Fast approximation to the trigonometric cosine function for Q31 data.
N   * @param[in] x Scaled input value in radians.
N   * @return  cos(x).
N   */
N
N  q31_t arm_cos_q31(
N  q31_t x);
N
N  /**
N   * @brief  Fast approximation to the trigonometric cosine function for Q15 data.
N   * @param[in] x Scaled input value in radians.
N   * @return  cos(x).
N   */
N
N  q15_t arm_cos_q15(
N  q15_t x);
N
N
N  /**
N   * @ingroup groupFastMath
N   */
N
N
N  /**
N   * @defgroup SQRT Square Root
N   *
N   * Computes the square root of a number.
N   * There are separate functions for Q15, Q31, and floating-point data types.
N   * The square root function is computed using the Newton-Raphson algorithm.
N   * This is an iterative algorithm of the form:
N   * <pre>
N   *      x1 = x0 - f(x0)/f'(x0)
N   * </pre>
N   * where <code>x1</code> is the current estimate,
N   * <code>x0</code> is the previous estimate, and
N   * <code>f'(x0)</code> is the derivative of <code>f()</code> evaluated at <code>x0</code>.
N   * For the square root function, the algorithm reduces to:
N   * <pre>
N   *     x0 = in/2                         [initial guess]
N   *     x1 = 1/2 * ( x0 + in / x0)        [each iteration]
N   * </pre>
N   */
N
N
N  /**
N   * @addtogroup SQRT
N   * @{
N   */
N
N  /**
N   * @brief  Floating-point square root function.
N   * @param[in]  in     input value.
N   * @param[out] *pOut  square root of input value.
N   * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARGUMENT_ERROR if
N   * <code>in</code> is negative value and returns zero output for negative values.
N   */
N
N  static __INLINE arm_status arm_sqrt_f32(
X  static __inline arm_status arm_sqrt_f32(
N  float32_t in,
N  float32_t * pOut)
N  {
N    if(in > 0)
N    {
N
N//      #if __FPU_USED
N#if (__FPU_USED == 1) && defined ( __CC_ARM   )
X#if (1 == 1) && 1L
N      *pOut = __sqrtf(in);
N#else
S      *pOut = sqrtf(in);
N#endif
N
N      return (ARM_MATH_SUCCESS);
N    }
N    else
N    {
N      *pOut = 0.0f;
N      return (ARM_MATH_ARGUMENT_ERROR);
N    }
N
N  }
N
N
N  /**
N   * @brief Q31 square root function.
N   * @param[in]   in    input value.  The range of the input value is [0 +1) or 0x00000000 to 0x7FFFFFFF.
N   * @param[out]  *pOut square root of input value.
N   * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARGUMENT_ERROR if
N   * <code>in</code> is negative value and returns zero output for negative values.
N   */
N  arm_status arm_sqrt_q31(
N  q31_t in,
N  q31_t * pOut);
N
N  /**
N   * @brief  Q15 square root function.
N   * @param[in]   in     input value.  The range of the input value is [0 +1) or 0x0000 to 0x7FFF.
N   * @param[out]  *pOut  square root of input value.
N   * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARGUMENT_ERROR if
N   * <code>in</code> is negative value and returns zero output for negative values.
N   */
N  arm_status arm_sqrt_q15(
N  q15_t in,
N  q15_t * pOut);
N
N  /**
N   * @} end of SQRT group
N   */
N
N
N
N
N
N
N  /**
N   * @brief floating-point Circular write function.
N   */
N
N  static __INLINE void arm_circularWrite_f32(
X  static __inline void arm_circularWrite_f32(
N  int32_t * circBuffer,
N  int32_t L,
N  uint16_t * writeOffset,
N  int32_t bufferInc,
N  const int32_t * src,
N  int32_t srcInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0u;
N    int32_t wOffset;
N
N    /* Copy the value of Index pointer that points
N     * to the current location where the input samples to be copied */
N    wOffset = *writeOffset;
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while(i > 0u)
N    {
N      /* copy the input sample to the circular buffer */
N      circBuffer[wOffset] = *src;
N
N      /* Update the input pointer */
N      src += srcInc;
N
N      /* Circularly update wOffset.  Watch out for positive and negative value */
N      wOffset += bufferInc;
N      if(wOffset >= L)
N        wOffset -= L;
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *writeOffset = wOffset;
N  }
N
N
N
N  /**
N   * @brief floating-point Circular Read function.
N   */
N  static __INLINE void arm_circularRead_f32(
X  static __inline void arm_circularRead_f32(
N  int32_t * circBuffer,
N  int32_t L,
N  int32_t * readOffset,
N  int32_t bufferInc,
N  int32_t * dst,
N  int32_t * dst_base,
N  int32_t dst_length,
N  int32_t dstInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0u;
N    int32_t rOffset, dst_end;
N
N    /* Copy the value of Index pointer that points
N     * to the current location from where the input samples to be read */
N    rOffset = *readOffset;
N    dst_end = (int32_t) (dst_base + dst_length);
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while(i > 0u)
N    {
N      /* copy the sample from the circular buffer to the destination buffer */
N      *dst = circBuffer[rOffset];
N
N      /* Update the input pointer */
N      dst += dstInc;
N
N      if(dst == (int32_t *) dst_end)
N      {
N        dst = dst_base;
N      }
N
N      /* Circularly update rOffset.  Watch out for positive and negative value  */
N      rOffset += bufferInc;
N
N      if(rOffset >= L)
N      {
N        rOffset -= L;
N      }
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *readOffset = rOffset;
N  }
N
N  /**
N   * @brief Q15 Circular write function.
N   */
N
N  static __INLINE void arm_circularWrite_q15(
X  static __inline void arm_circularWrite_q15(
N  q15_t * circBuffer,
N  int32_t L,
N  uint16_t * writeOffset,
N  int32_t bufferInc,
N  const q15_t * src,
N  int32_t srcInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0u;
N    int32_t wOffset;
N
N    /* Copy the value of Index pointer that points
N     * to the current location where the input samples to be copied */
N    wOffset = *writeOffset;
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while(i > 0u)
N    {
N      /* copy the input sample to the circular buffer */
N      circBuffer[wOffset] = *src;
N
N      /* Update the input pointer */
N      src += srcInc;
N
N      /* Circularly update wOffset.  Watch out for positive and negative value */
N      wOffset += bufferInc;
N      if(wOffset >= L)
N        wOffset -= L;
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *writeOffset = wOffset;
N  }
N
N
N
N  /**
N   * @brief Q15 Circular Read function.
N   */
N  static __INLINE void arm_circularRead_q15(
X  static __inline void arm_circularRead_q15(
N  q15_t * circBuffer,
N  int32_t L,
N  int32_t * readOffset,
N  int32_t bufferInc,
N  q15_t * dst,
N  q15_t * dst_base,
N  int32_t dst_length,
N  int32_t dstInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0;
N    int32_t rOffset, dst_end;
N
N    /* Copy the value of Index pointer that points
N     * to the current location from where the input samples to be read */
N    rOffset = *readOffset;
N
N    dst_end = (int32_t) (dst_base + dst_length);
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while(i > 0u)
N    {
N      /* copy the sample from the circular buffer to the destination buffer */
N      *dst = circBuffer[rOffset];
N
N      /* Update the input pointer */
N      dst += dstInc;
N
N      if(dst == (q15_t *) dst_end)
N      {
N        dst = dst_base;
N      }
N
N      /* Circularly update wOffset.  Watch out for positive and negative value */
N      rOffset += bufferInc;
N
N      if(rOffset >= L)
N      {
N        rOffset -= L;
N      }
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *readOffset = rOffset;
N  }
N
N
N  /**
N   * @brief Q7 Circular write function.
N   */
N
N  static __INLINE void arm_circularWrite_q7(
X  static __inline void arm_circularWrite_q7(
N  q7_t * circBuffer,
N  int32_t L,
N  uint16_t * writeOffset,
N  int32_t bufferInc,
N  const q7_t * src,
N  int32_t srcInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0u;
N    int32_t wOffset;
N
N    /* Copy the value of Index pointer that points
N     * to the current location where the input samples to be copied */
N    wOffset = *writeOffset;
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while(i > 0u)
N    {
N      /* copy the input sample to the circular buffer */
N      circBuffer[wOffset] = *src;
N
N      /* Update the input pointer */
N      src += srcInc;
N
N      /* Circularly update wOffset.  Watch out for positive and negative value */
N      wOffset += bufferInc;
N      if(wOffset >= L)
N        wOffset -= L;
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *writeOffset = wOffset;
N  }
N
N
N
N  /**
N   * @brief Q7 Circular Read function.
N   */
N  static __INLINE void arm_circularRead_q7(
X  static __inline void arm_circularRead_q7(
N  q7_t * circBuffer,
N  int32_t L,
N  int32_t * readOffset,
N  int32_t bufferInc,
N  q7_t * dst,
N  q7_t * dst_base,
N  int32_t dst_length,
N  int32_t dstInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0;
N    int32_t rOffset, dst_end;
N
N    /* Copy the value of Index pointer that points
N     * to the current location from where the input samples to be read */
N    rOffset = *readOffset;
N
N    dst_end = (int32_t) (dst_base + dst_length);
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while(i > 0u)
N    {
N      /* copy the sample from the circular buffer to the destination buffer */
N      *dst = circBuffer[rOffset];
N
N      /* Update the input pointer */
N      dst += dstInc;
N
N      if(dst == (q7_t *) dst_end)
N      {
N        dst = dst_base;
N      }
N
N      /* Circularly update rOffset.  Watch out for positive and negative value */
N      rOffset += bufferInc;
N
N      if(rOffset >= L)
N      {
N        rOffset -= L;
N      }
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *readOffset = rOffset;
N  }
N
N
N  /**
N   * @brief  Sum of the squares of the elements of a Q31 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_power_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q63_t * pResult);
N
N  /**
N   * @brief  Sum of the squares of the elements of a floating-point vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_power_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult);
N
N  /**
N   * @brief  Sum of the squares of the elements of a Q15 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_power_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q63_t * pResult);
N
N  /**
N   * @brief  Sum of the squares of the elements of a Q7 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_power_q7(
N  q7_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult);
N
N  /**
N   * @brief  Mean value of a Q7 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_mean_q7(
N  q7_t * pSrc,
N  uint32_t blockSize,
N  q7_t * pResult);
N
N  /**
N   * @brief  Mean value of a Q15 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N  void arm_mean_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult);
N
N  /**
N   * @brief  Mean value of a Q31 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N  void arm_mean_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult);
N
N  /**
N   * @brief  Mean value of a floating-point vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N  void arm_mean_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult);
N
N  /**
N   * @brief  Variance of the elements of a floating-point vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_var_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult);
N
N  /**
N   * @brief  Variance of the elements of a Q31 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_var_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult);
N
N  /**
N   * @brief  Variance of the elements of a Q15 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_var_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult);
N
N  /**
N   * @brief  Root Mean Square of the elements of a floating-point vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_rms_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult);
N
N  /**
N   * @brief  Root Mean Square of the elements of a Q31 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_rms_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult);
N
N  /**
N   * @brief  Root Mean Square of the elements of a Q15 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_rms_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult);
N
N  /**
N   * @brief  Standard deviation of the elements of a floating-point vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_std_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult);
N
N  /**
N   * @brief  Standard deviation of the elements of a Q31 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_std_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult);
N
N  /**
N   * @brief  Standard deviation of the elements of a Q15 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_std_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult);
N
N  /**
N   * @brief  Floating-point complex magnitude
N   * @param[in]  *pSrc points to the complex input vector
N   * @param[out]  *pDst points to the real output vector
N   * @param[in]  numSamples number of complex samples in the input vector
N   * @return none.
N   */
N
N  void arm_cmplx_mag_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Q31 complex magnitude
N   * @param[in]  *pSrc points to the complex input vector
N   * @param[out]  *pDst points to the real output vector
N   * @param[in]  numSamples number of complex samples in the input vector
N   * @return none.
N   */
N
N  void arm_cmplx_mag_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Q15 complex magnitude
N   * @param[in]  *pSrc points to the complex input vector
N   * @param[out]  *pDst points to the real output vector
N   * @param[in]  numSamples number of complex samples in the input vector
N   * @return none.
N   */
N
N  void arm_cmplx_mag_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Q15 complex dot product
N   * @param[in]  *pSrcA points to the first input vector
N   * @param[in]  *pSrcB points to the second input vector
N   * @param[in]  numSamples number of complex samples in each vector
N   * @param[out]  *realResult real part of the result returned here
N   * @param[out]  *imagResult imaginary part of the result returned here
N   * @return none.
N   */
N
N  void arm_cmplx_dot_prod_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  uint32_t numSamples,
N  q31_t * realResult,
N  q31_t * imagResult);
N
N  /**
N   * @brief  Q31 complex dot product
N   * @param[in]  *pSrcA points to the first input vector
N   * @param[in]  *pSrcB points to the second input vector
N   * @param[in]  numSamples number of complex samples in each vector
N   * @param[out]  *realResult real part of the result returned here
N   * @param[out]  *imagResult imaginary part of the result returned here
N   * @return none.
N   */
N
N  void arm_cmplx_dot_prod_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  uint32_t numSamples,
N  q63_t * realResult,
N  q63_t * imagResult);
N
N  /**
N   * @brief  Floating-point complex dot product
N   * @param[in]  *pSrcA points to the first input vector
N   * @param[in]  *pSrcB points to the second input vector
N   * @param[in]  numSamples number of complex samples in each vector
N   * @param[out]  *realResult real part of the result returned here
N   * @param[out]  *imagResult imaginary part of the result returned here
N   * @return none.
N   */
N
N  void arm_cmplx_dot_prod_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  uint32_t numSamples,
N  float32_t * realResult,
N  float32_t * imagResult);
N
N  /**
N   * @brief  Q15 complex-by-real multiplication
N   * @param[in]  *pSrcCmplx points to the complex input vector
N   * @param[in]  *pSrcReal points to the real input vector
N   * @param[out]  *pCmplxDst points to the complex output vector
N   * @param[in]  numSamples number of samples in each vector
N   * @return none.
N   */
N
N  void arm_cmplx_mult_real_q15(
N  q15_t * pSrcCmplx,
N  q15_t * pSrcReal,
N  q15_t * pCmplxDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Q31 complex-by-real multiplication
N   * @param[in]  *pSrcCmplx points to the complex input vector
N   * @param[in]  *pSrcReal points to the real input vector
N   * @param[out]  *pCmplxDst points to the complex output vector
N   * @param[in]  numSamples number of samples in each vector
N   * @return none.
N   */
N
N  void arm_cmplx_mult_real_q31(
N  q31_t * pSrcCmplx,
N  q31_t * pSrcReal,
N  q31_t * pCmplxDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Floating-point complex-by-real multiplication
N   * @param[in]  *pSrcCmplx points to the complex input vector
N   * @param[in]  *pSrcReal points to the real input vector
N   * @param[out]  *pCmplxDst points to the complex output vector
N   * @param[in]  numSamples number of samples in each vector
N   * @return none.
N   */
N
N  void arm_cmplx_mult_real_f32(
N  float32_t * pSrcCmplx,
N  float32_t * pSrcReal,
N  float32_t * pCmplxDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Minimum value of a Q7 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *result is output pointer
N   * @param[in]  index is the array index of the minimum value in the input buffer.
N   * @return none.
N   */
N
N  void arm_min_q7(
N  q7_t * pSrc,
N  uint32_t blockSize,
N  q7_t * result,
N  uint32_t * index);
N
N  /**
N   * @brief  Minimum value of a Q15 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output pointer
N   * @param[in]  *pIndex is the array index of the minimum value in the input buffer.
N   * @return none.
N   */
N
N  void arm_min_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult,
N  uint32_t * pIndex);
N
N  /**
N   * @brief  Minimum value of a Q31 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output pointer
N   * @param[out]  *pIndex is the array index of the minimum value in the input buffer.
N   * @return none.
N   */
N  void arm_min_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult,
N  uint32_t * pIndex);
N
N  /**
N   * @brief  Minimum value of a floating-point vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output pointer
N   * @param[out]  *pIndex is the array index of the minimum value in the input buffer.
N   * @return none.
N   */
N
N  void arm_min_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult,
N  uint32_t * pIndex);
N
N/**
N * @brief Maximum value of a Q7 vector.
N * @param[in]       *pSrc points to the input buffer
N * @param[in]       blockSize length of the input vector
N * @param[out]      *pResult maximum value returned here
N * @param[out]      *pIndex index of maximum value returned here
N * @return none.
N */
N
N  void arm_max_q7(
N  q7_t * pSrc,
N  uint32_t blockSize,
N  q7_t * pResult,
N  uint32_t * pIndex);
N
N/**
N * @brief Maximum value of a Q15 vector.
N * @param[in]       *pSrc points to the input buffer
N * @param[in]       blockSize length of the input vector
N * @param[out]      *pResult maximum value returned here
N * @param[out]      *pIndex index of maximum value returned here
N * @return none.
N */
N
N  void arm_max_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult,
N  uint32_t * pIndex);
N
N/**
N * @brief Maximum value of a Q31 vector.
N * @param[in]       *pSrc points to the input buffer
N * @param[in]       blockSize length of the input vector
N * @param[out]      *pResult maximum value returned here
N * @param[out]      *pIndex index of maximum value returned here
N * @return none.
N */
N
N  void arm_max_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult,
N  uint32_t * pIndex);
N
N/**
N * @brief Maximum value of a floating-point vector.
N * @param[in]       *pSrc points to the input buffer
N * @param[in]       blockSize length of the input vector
N * @param[out]      *pResult maximum value returned here
N * @param[out]      *pIndex index of maximum value returned here
N * @return none.
N */
N
N  void arm_max_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult,
N  uint32_t * pIndex);
N
N  /**
N   * @brief  Q15 complex-by-complex multiplication
N   * @param[in]  *pSrcA points to the first input vector
N   * @param[in]  *pSrcB points to the second input vector
N   * @param[out]  *pDst  points to the output vector
N   * @param[in]  numSamples number of complex samples in each vector
N   * @return none.
N   */
N
N  void arm_cmplx_mult_cmplx_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  q15_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Q31 complex-by-complex multiplication
N   * @param[in]  *pSrcA points to the first input vector
N   * @param[in]  *pSrcB points to the second input vector
N   * @param[out]  *pDst  points to the output vector
N   * @param[in]  numSamples number of complex samples in each vector
N   * @return none.
N   */
N
N  void arm_cmplx_mult_cmplx_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  q31_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Floating-point complex-by-complex multiplication
N   * @param[in]  *pSrcA points to the first input vector
N   * @param[in]  *pSrcB points to the second input vector
N   * @param[out]  *pDst  points to the output vector
N   * @param[in]  numSamples number of complex samples in each vector
N   * @return none.
N   */
N
N  void arm_cmplx_mult_cmplx_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  float32_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief Converts the elements of the floating-point vector to Q31 vector.
N   * @param[in]       *pSrc points to the floating-point input vector
N   * @param[out]      *pDst points to the Q31 output vector
N   * @param[in]       blockSize length of the input vector
N   * @return none.
N   */
N  void arm_float_to_q31(
N  float32_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Converts the elements of the floating-point vector to Q15 vector.
N   * @param[in]       *pSrc points to the floating-point input vector
N   * @param[out]      *pDst points to the Q15 output vector
N   * @param[in]       blockSize length of the input vector
N   * @return          none
N   */
N  void arm_float_to_q15(
N  float32_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Converts the elements of the floating-point vector to Q7 vector.
N   * @param[in]       *pSrc points to the floating-point input vector
N   * @param[out]      *pDst points to the Q7 output vector
N   * @param[in]       blockSize length of the input vector
N   * @return          none
N   */
N  void arm_float_to_q7(
N  float32_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Converts the elements of the Q31 vector to Q15 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[out]  *pDst is output pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @return none.
N   */
N  void arm_q31_to_q15(
N  q31_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Converts the elements of the Q31 vector to Q7 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[out]  *pDst is output pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @return none.
N   */
N  void arm_q31_to_q7(
N  q31_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Converts the elements of the Q15 vector to floating-point vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[out]  *pDst is output pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @return none.
N   */
N  void arm_q15_to_float(
N  q15_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Converts the elements of the Q15 vector to Q31 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[out]  *pDst is output pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @return none.
N   */
N  void arm_q15_to_q31(
N  q15_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Converts the elements of the Q15 vector to Q7 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[out]  *pDst is output pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @return none.
N   */
N  void arm_q15_to_q7(
N  q15_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @ingroup groupInterpolation
N   */
N
N  /**
N   * @defgroup BilinearInterpolate Bilinear Interpolation
N   *
N   * Bilinear interpolation is an extension of linear interpolation applied to a two dimensional grid.
N   * The underlying function <code>f(x, y)</code> is sampled on a regular grid and the interpolation process
N   * determines values between the grid points.
N   * Bilinear interpolation is equivalent to two step linear interpolation, first in the x-dimension and then in the y-dimension.
N   * Bilinear interpolation is often used in image processing to rescale images.
N   * The CMSIS DSP library provides bilinear interpolation functions for Q7, Q15, Q31, and floating-point data types.
N   *
N   * <b>Algorithm</b>
N   * \par
N   * The instance structure used by the bilinear interpolation functions describes a two dimensional data table.
N   * For floating-point, the instance structure is defined as:
N   * <pre>
N   *   typedef struct
N   *   {
N   *     uint16_t numRows;
N   *     uint16_t numCols;
N   *     float32_t *pData;
N   * } arm_bilinear_interp_instance_f32;
N   * </pre>
N   *
N   * \par
N   * where <code>numRows</code> specifies the number of rows in the table;
N   * <code>numCols</code> specifies the number of columns in the table;
N   * and <code>pData</code> points to an array of size <code>numRows*numCols</code> values.
N   * The data table <code>pTable</code> is organized in row order and the supplied data values fall on integer indexes.
N   * That is, table element (x,y) is located at <code>pTable[x + y*numCols]</code> where x and y are integers.
N   *
N   * \par
N   * Let <code>(x, y)</code> specify the desired interpolation point.  Then define:
N   * <pre>
N   *     XF = floor(x)
N   *     YF = floor(y)
N   * </pre>
N   * \par
N   * The interpolated output point is computed as:
N   * <pre>
N   *  f(x, y) = f(XF, YF) * (1-(x-XF)) * (1-(y-YF))
N   *           + f(XF+1, YF) * (x-XF)*(1-(y-YF))
N   *           + f(XF, YF+1) * (1-(x-XF))*(y-YF)
N   *           + f(XF+1, YF+1) * (x-XF)*(y-YF)
N   * </pre>
N   * Note that the coordinates (x, y) contain integer and fractional components.
N   * The integer components specify which portion of the table to use while the
N   * fractional components control the interpolation processor.
N   *
N   * \par
N   * if (x,y) are outside of the table boundary, Bilinear interpolation returns zero output.
N   */
N
N  /**
N   * @addtogroup BilinearInterpolate
N   * @{
N   */
N
N  /**
N  *
N  * @brief  Floating-point bilinear interpolation.
N  * @param[in,out] *S points to an instance of the interpolation structure.
N  * @param[in] X interpolation coordinate.
N  * @param[in] Y interpolation coordinate.
N  * @return out interpolated value.
N  */
N
N
N  static __INLINE float32_t arm_bilinear_interp_f32(
X  static __inline float32_t arm_bilinear_interp_f32(
N  const arm_bilinear_interp_instance_f32 * S,
N  float32_t X,
N  float32_t Y)
N  {
N    float32_t out;
N    float32_t f00, f01, f10, f11;
N    float32_t *pData = S->pData;
N    int32_t xIndex, yIndex, index;
N    float32_t xdiff, ydiff;
N    float32_t b1, b2, b3, b4;
N
N    xIndex = (int32_t) X;
N    yIndex = (int32_t) Y;
N
N    /* Care taken for table outside boundary */
N    /* Returns zero output when values are outside table boundary */
N    if(xIndex < 0 || xIndex > (S->numRows - 1) || yIndex < 0
N       || yIndex > (S->numCols - 1))
N    {
N      return (0);
N    }
N
N    /* Calculation of index for two nearest points in X-direction */
N    index = (xIndex - 1) + (yIndex - 1) * S->numCols;
N
N
N    /* Read two nearest points in X-direction */
N    f00 = pData[index];
N    f01 = pData[index + 1];
N
N    /* Calculation of index for two nearest points in Y-direction */
N    index = (xIndex - 1) + (yIndex) * S->numCols;
N
N
N    /* Read two nearest points in Y-direction */
N    f10 = pData[index];
N    f11 = pData[index + 1];
N
N    /* Calculation of intermediate values */
N    b1 = f00;
N    b2 = f01 - f00;
N    b3 = f10 - f00;
N    b4 = f00 - f01 - f10 + f11;
N
N    /* Calculation of fractional part in X */
N    xdiff = X - xIndex;
N
N    /* Calculation of fractional part in Y */
N    ydiff = Y - yIndex;
N
N    /* Calculation of bi-linear interpolated output */
N    out = b1 + b2 * xdiff + b3 * ydiff + b4 * xdiff * ydiff;
N
N    /* return to application */
N    return (out);
N
N  }
N
N  /**
N  *
N  * @brief  Q31 bilinear interpolation.
N  * @param[in,out] *S points to an instance of the interpolation structure.
N  * @param[in] X interpolation coordinate in 12.20 format.
N  * @param[in] Y interpolation coordinate in 12.20 format.
N  * @return out interpolated value.
N  */
N
N  static __INLINE q31_t arm_bilinear_interp_q31(
X  static __inline q31_t arm_bilinear_interp_q31(
N  arm_bilinear_interp_instance_q31 * S,
N  q31_t X,
N  q31_t Y)
N  {
N    q31_t out;                                   /* Temporary output */
N    q31_t acc = 0;                               /* output */
N    q31_t xfract, yfract;                        /* X, Y fractional parts */
N    q31_t x1, x2, y1, y2;                        /* Nearest output values */
N    int32_t rI, cI;                              /* Row and column indices */
N    q31_t *pYData = S->pData;                    /* pointer to output table values */
N    uint32_t nCols = S->numCols;                 /* num of rows */
N
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    rI = ((X & 0xFFF00000) >> 20u);
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    cI = ((Y & 0xFFF00000) >> 20u);
N
N    /* Care taken for table outside boundary */
N    /* Returns zero output when values are outside table boundary */
N    if(rI < 0 || rI > (S->numRows - 1) || cI < 0 || cI > (S->numCols - 1))
N    {
N      return (0);
N    }
N
N    /* 20 bits for the fractional part */
N    /* shift left xfract by 11 to keep 1.31 format */
N    xfract = (X & 0x000FFFFF) << 11u;
N
N    /* Read two nearest output values from the index */
N    x1 = pYData[(rI) + nCols * (cI)];
N    x2 = pYData[(rI) + nCols * (cI) + 1u];
N
N    /* 20 bits for the fractional part */
N    /* shift left yfract by 11 to keep 1.31 format */
N    yfract = (Y & 0x000FFFFF) << 11u;
N
N    /* Read two nearest output values from the index */
N    y1 = pYData[(rI) + nCols * (cI + 1)];
N    y2 = pYData[(rI) + nCols * (cI + 1) + 1u];
N
N    /* Calculation of x1 * (1-xfract ) * (1-yfract) and acc is in 3.29(q29) format */
N    out = ((q31_t) (((q63_t) x1 * (0x7FFFFFFF - xfract)) >> 32));
N    acc = ((q31_t) (((q63_t) out * (0x7FFFFFFF - yfract)) >> 32));
N
N    /* x2 * (xfract) * (1-yfract)  in 3.29(q29) and adding to acc */
N    out = ((q31_t) ((q63_t) x2 * (0x7FFFFFFF - yfract) >> 32));
N    acc += ((q31_t) ((q63_t) out * (xfract) >> 32));
N
N    /* y1 * (1 - xfract) * (yfract)  in 3.29(q29) and adding to acc */
N    out = ((q31_t) ((q63_t) y1 * (0x7FFFFFFF - xfract) >> 32));
N    acc += ((q31_t) ((q63_t) out * (yfract) >> 32));
N
N    /* y2 * (xfract) * (yfract)  in 3.29(q29) and adding to acc */
N    out = ((q31_t) ((q63_t) y2 * (xfract) >> 32));
N    acc += ((q31_t) ((q63_t) out * (yfract) >> 32));
N
N    /* Convert acc to 1.31(q31) format */
N    return (acc << 2u);
N
N  }
N
N  /**
N  * @brief  Q15 bilinear interpolation.
N  * @param[in,out] *S points to an instance of the interpolation structure.
N  * @param[in] X interpolation coordinate in 12.20 format.
N  * @param[in] Y interpolation coordinate in 12.20 format.
N  * @return out interpolated value.
N  */
N
N  static __INLINE q15_t arm_bilinear_interp_q15(
X  static __inline q15_t arm_bilinear_interp_q15(
N  arm_bilinear_interp_instance_q15 * S,
N  q31_t X,
N  q31_t Y)
N  {
N    q63_t acc = 0;                               /* output */
N    q31_t out;                                   /* Temporary output */
N    q15_t x1, x2, y1, y2;                        /* Nearest output values */
N    q31_t xfract, yfract;                        /* X, Y fractional parts */
N    int32_t rI, cI;                              /* Row and column indices */
N    q15_t *pYData = S->pData;                    /* pointer to output table values */
N    uint32_t nCols = S->numCols;                 /* num of rows */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    rI = ((X & 0xFFF00000) >> 20);
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    cI = ((Y & 0xFFF00000) >> 20);
N
N    /* Care taken for table outside boundary */
N    /* Returns zero output when values are outside table boundary */
N    if(rI < 0 || rI > (S->numRows - 1) || cI < 0 || cI > (S->numCols - 1))
N    {
N      return (0);
N    }
N
N    /* 20 bits for the fractional part */
N    /* xfract should be in 12.20 format */
N    xfract = (X & 0x000FFFFF);
N
N    /* Read two nearest output values from the index */
N    x1 = pYData[(rI) + nCols * (cI)];
N    x2 = pYData[(rI) + nCols * (cI) + 1u];
N
N
N    /* 20 bits for the fractional part */
N    /* yfract should be in 12.20 format */
N    yfract = (Y & 0x000FFFFF);
N
N    /* Read two nearest output values from the index */
N    y1 = pYData[(rI) + nCols * (cI + 1)];
N    y2 = pYData[(rI) + nCols * (cI + 1) + 1u];
N
N    /* Calculation of x1 * (1-xfract ) * (1-yfract) and acc is in 13.51 format */
N
N    /* x1 is in 1.15(q15), xfract in 12.20 format and out is in 13.35 format */
N    /* convert 13.35 to 13.31 by right shifting  and out is in 1.31 */
N    out = (q31_t) (((q63_t) x1 * (0xFFFFF - xfract)) >> 4u);
N    acc = ((q63_t) out * (0xFFFFF - yfract));
N
N    /* x2 * (xfract) * (1-yfract)  in 1.51 and adding to acc */
N    out = (q31_t) (((q63_t) x2 * (0xFFFFF - yfract)) >> 4u);
N    acc += ((q63_t) out * (xfract));
N
N    /* y1 * (1 - xfract) * (yfract)  in 1.51 and adding to acc */
N    out = (q31_t) (((q63_t) y1 * (0xFFFFF - xfract)) >> 4u);
N    acc += ((q63_t) out * (yfract));
N
N    /* y2 * (xfract) * (yfract)  in 1.51 and adding to acc */
N    out = (q31_t) (((q63_t) y2 * (xfract)) >> 4u);
N    acc += ((q63_t) out * (yfract));
N
N    /* acc is in 13.51 format and down shift acc by 36 times */
N    /* Convert out to 1.15 format */
N    return (acc >> 36);
N
N  }
N
N  /**
N  * @brief  Q7 bilinear interpolation.
N  * @param[in,out] *S points to an instance of the interpolation structure.
N  * @param[in] X interpolation coordinate in 12.20 format.
N  * @param[in] Y interpolation coordinate in 12.20 format.
N  * @return out interpolated value.
N  */
N
N  static __INLINE q7_t arm_bilinear_interp_q7(
X  static __inline q7_t arm_bilinear_interp_q7(
N  arm_bilinear_interp_instance_q7 * S,
N  q31_t X,
N  q31_t Y)
N  {
N    q63_t acc = 0;                               /* output */
N    q31_t out;                                   /* Temporary output */
N    q31_t xfract, yfract;                        /* X, Y fractional parts */
N    q7_t x1, x2, y1, y2;                         /* Nearest output values */
N    int32_t rI, cI;                              /* Row and column indices */
N    q7_t *pYData = S->pData;                     /* pointer to output table values */
N    uint32_t nCols = S->numCols;                 /* num of rows */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    rI = ((X & 0xFFF00000) >> 20);
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    cI = ((Y & 0xFFF00000) >> 20);
N
N    /* Care taken for table outside boundary */
N    /* Returns zero output when values are outside table boundary */
N    if(rI < 0 || rI > (S->numRows - 1) || cI < 0 || cI > (S->numCols - 1))
N    {
N      return (0);
N    }
N
N    /* 20 bits for the fractional part */
N    /* xfract should be in 12.20 format */
N    xfract = (X & 0x000FFFFF);
N
N    /* Read two nearest output values from the index */
N    x1 = pYData[(rI) + nCols * (cI)];
N    x2 = pYData[(rI) + nCols * (cI) + 1u];
N
N
N    /* 20 bits for the fractional part */
N    /* yfract should be in 12.20 format */
N    yfract = (Y & 0x000FFFFF);
N
N    /* Read two nearest output values from the index */
N    y1 = pYData[(rI) + nCols * (cI + 1)];
N    y2 = pYData[(rI) + nCols * (cI + 1) + 1u];
N
N    /* Calculation of x1 * (1-xfract ) * (1-yfract) and acc is in 16.47 format */
N    out = ((x1 * (0xFFFFF - xfract)));
N    acc = (((q63_t) out * (0xFFFFF - yfract)));
N
N    /* x2 * (xfract) * (1-yfract)  in 2.22 and adding to acc */
N    out = ((x2 * (0xFFFFF - yfract)));
N    acc += (((q63_t) out * (xfract)));
N
N    /* y1 * (1 - xfract) * (yfract)  in 2.22 and adding to acc */
N    out = ((y1 * (0xFFFFF - xfract)));
N    acc += (((q63_t) out * (yfract)));
N
N    /* y2 * (xfract) * (yfract)  in 2.22 and adding to acc */
N    out = ((y2 * (yfract)));
N    acc += (((q63_t) out * (xfract)));
N
N    /* acc in 16.47 format and down shift by 40 to convert to 1.7 format */
N    return (acc >> 40);
N
N  }
N
N  /**
N   * @} end of BilinearInterpolate group
N   */
N   
N
N//SMMLAR
N#define multAcc_32x32_keep32_R(a, x, y) \
N    a = (q31_t) (((((q63_t) a) << 32) + ((q63_t) x * y) + 0x80000000LL ) >> 32)
X#define multAcc_32x32_keep32_R(a, x, y)     a = (q31_t) (((((q63_t) a) << 32) + ((q63_t) x * y) + 0x80000000LL ) >> 32)
N
N//SMMLSR
N#define multSub_32x32_keep32_R(a, x, y) \
N    a = (q31_t) (((((q63_t) a) << 32) - ((q63_t) x * y) + 0x80000000LL ) >> 32)
X#define multSub_32x32_keep32_R(a, x, y)     a = (q31_t) (((((q63_t) a) << 32) - ((q63_t) x * y) + 0x80000000LL ) >> 32)
N
N//SMMULR
N#define mult_32x32_keep32_R(a, x, y) \
N    a = (q31_t) (((q63_t) x * y + 0x80000000LL ) >> 32)
X#define mult_32x32_keep32_R(a, x, y)     a = (q31_t) (((q63_t) x * y + 0x80000000LL ) >> 32)
N
N//SMMLA
N#define multAcc_32x32_keep32(a, x, y) \
N    a += (q31_t) (((q63_t) x * y) >> 32)
X#define multAcc_32x32_keep32(a, x, y)     a += (q31_t) (((q63_t) x * y) >> 32)
N
N//SMMLS
N#define multSub_32x32_keep32(a, x, y) \
N    a -= (q31_t) (((q63_t) x * y) >> 32)
X#define multSub_32x32_keep32(a, x, y)     a -= (q31_t) (((q63_t) x * y) >> 32)
N
N//SMMUL
N#define mult_32x32_keep32(a, x, y) \
N    a = (q31_t) (((q63_t) x * y ) >> 32)
X#define mult_32x32_keep32(a, x, y)     a = (q31_t) (((q63_t) x * y ) >> 32)
N
N
N#if defined ( __CC_ARM ) //Keil
X#if 1L 
N
N//Enter low optimization region - place directly above function definition
N    #ifdef ARM_MATH_CM4
N      #define LOW_OPTIMIZATION_ENTER \
N         _Pragma ("push")         \
N         _Pragma ("O1")
X      #define LOW_OPTIMIZATION_ENTER          _Pragma ("push")                  _Pragma ("O1")
N    #else
S      #define LOW_OPTIMIZATION_ENTER 
N    #endif
N
N//Exit low optimization region - place directly after end of function definition
N    #ifdef ARM_MATH_CM4
N      #define LOW_OPTIMIZATION_EXIT \
N         _Pragma ("pop")
X      #define LOW_OPTIMIZATION_EXIT          _Pragma ("pop")
N    #else
S      #define LOW_OPTIMIZATION_EXIT  
N    #endif
N
N//Enter low optimization region - place directly above function definition
N  #define IAR_ONLY_LOW_OPTIMIZATION_ENTER
N
N//Exit low optimization region - place directly after end of function definition
N  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
N
N#elif defined(__ICCARM__) //IAR
S
S//Enter low optimization region - place directly above function definition
S    #ifdef ARM_MATH_CM4
S      #define LOW_OPTIMIZATION_ENTER \
S         _Pragma ("optimize=low")
X      #define LOW_OPTIMIZATION_ENTER          _Pragma ("optimize=low")
S    #else
S      #define LOW_OPTIMIZATION_ENTER   
S    #endif
S
S//Exit low optimization region - place directly after end of function definition
S  #define LOW_OPTIMIZATION_EXIT
S
S//Enter low optimization region - place directly above function definition
S    #ifdef ARM_MATH_CM4
S      #define IAR_ONLY_LOW_OPTIMIZATION_ENTER \
S         _Pragma ("optimize=low")
X      #define IAR_ONLY_LOW_OPTIMIZATION_ENTER          _Pragma ("optimize=low")
S    #else
S      #define IAR_ONLY_LOW_OPTIMIZATION_ENTER   
S    #endif
S
S//Exit low optimization region - place directly after end of function definition
S  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
S
S#elif defined(__GNUC__)
S
S  #define LOW_OPTIMIZATION_ENTER __attribute__(( optimize("-O1") ))
S
S  #define LOW_OPTIMIZATION_EXIT
S
S  #define IAR_ONLY_LOW_OPTIMIZATION_ENTER
S
S  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
S
S#elif defined(__CSMC__)		// Cosmic
S
S#define LOW_OPTIMIZATION_ENTER
S#define LOW_OPTIMIZATION_EXIT
S#define IAR_ONLY_LOW_OPTIMIZATION_ENTER
S#define IAR_ONLY_LOW_OPTIMIZATION_EXIT
S
N#endif
N
Nextern void arm_bitreversal_32(
N    uint32_t * pSrc,
N    const uint16_t bitRevLen,
N    const uint16_t * pBitRevTable);
N
N
N#ifdef	__cplusplus
S}
N#endif
N
N
N
N
N#endif /* _ARM_MATH_H */
N
N/**
N *
N * End of file.
N */
L 25 "..\..\..\..\..\..\COMMON\SRC\TEST\CM_TEST.c" 2
N#include "stdlib.h"
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060019
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 26 "..\..\..\..\..\..\COMMON\SRC\TEST\CM_TEST.c" 2
N#include "arm_const_structs.h"
L 1 "..\..\..\..\..\..\COMMON\SRC\CMSIS_DSP_4_5\inc\arm_const_structs.h" 1
N/* ----------------------------------------------------------------------
N* Copyright (C) 2010-2014 ARM Limited. All rights reserved.
N*
N* $Date:        31. July 2014
N* $Revision: 	V1.4.4
N*
N* Project: 	    CMSIS DSP Library
N* Title:	    arm_const_structs.h
N*
N* Description:	This file has constant structs that are initialized for
N*              user convenience.  For example, some can be given as
N*              arguments to the arm_cfft_f32() function.
N*
N* Target Processor: Cortex-M4/Cortex-M3
N*
N* Redistribution and use in source and binary forms, with or without
N* modification, are permitted provided that the following conditions
N* are met:
N*   - Redistributions of source code must retain the above copyright
N*     notice, this list of conditions and the following disclaimer.
N*   - Redistributions in binary form must reproduce the above copyright
N*     notice, this list of conditions and the following disclaimer in
N*     the documentation and/or other materials provided with the
N*     distribution.
N*   - Neither the name of ARM LIMITED nor the names of its contributors
N*     may be used to endorse or promote products derived from this
N*     software without specific prior written permission.
N*
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
N* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
N* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
N* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
N* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
N* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
N* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
N* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N* POSSIBILITY OF SUCH DAMAGE.
N* -------------------------------------------------------------------- */
N
N#ifndef _ARM_CONST_STRUCTS_H
N#define _ARM_CONST_STRUCTS_H
N
N#include "arm_math.h"
N#include "arm_common_tables.h"
L 1 "..\..\..\..\..\..\COMMON\SRC\CMSIS_DSP_4_5\inc\arm_common_tables.h" 1
N/* ----------------------------------------------------------------------
N* Copyright (C) 2010-2014 ARM Limited. All rights reserved.
N*
N* $Date:        31. July 2014
N* $Revision: 	V1.4.4
N*
N* Project: 	    CMSIS DSP Library
N* Title:	    arm_common_tables.h
N*
N* Description:	This file has extern declaration for common tables like Bitreverse, reciprocal etc which are used across different functions
N*
N* Target Processor: Cortex-M4/Cortex-M3
N*
N* Redistribution and use in source and binary forms, with or without
N* modification, are permitted provided that the following conditions
N* are met:
N*   - Redistributions of source code must retain the above copyright
N*     notice, this list of conditions and the following disclaimer.
N*   - Redistributions in binary form must reproduce the above copyright
N*     notice, this list of conditions and the following disclaimer in
N*     the documentation and/or other materials provided with the
N*     distribution.
N*   - Neither the name of ARM LIMITED nor the names of its contributors
N*     may be used to endorse or promote products derived from this
N*     software without specific prior written permission.
N*
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
N* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
N* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
N* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
N* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
N* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
N* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
N* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N* POSSIBILITY OF SUCH DAMAGE.
N* -------------------------------------------------------------------- */
N
N#ifndef _ARM_COMMON_TABLES_H
N#define _ARM_COMMON_TABLES_H
N
N#include "arm_math.h"
N
Nextern const uint16_t armBitRevTable[1024];
Nextern const q15_t armRecipTableQ15[64];
Nextern const q31_t armRecipTableQ31[64];
N//extern const q31_t realCoefAQ31[1024];
N//extern const q31_t realCoefBQ31[1024];
Nextern const float32_t twiddleCoef_16[32];
Nextern const float32_t twiddleCoef_32[64];
Nextern const float32_t twiddleCoef_64[128];
Nextern const float32_t twiddleCoef_128[256];
Nextern const float32_t twiddleCoef_256[512];
Nextern const float32_t twiddleCoef_512[1024];
Nextern const float32_t twiddleCoef_1024[2048];
Nextern const float32_t twiddleCoef_2048[4096];
Nextern const float32_t twiddleCoef_4096[8192];
N#define twiddleCoef twiddleCoef_4096
Nextern const q31_t twiddleCoef_16_q31[24];
Nextern const q31_t twiddleCoef_32_q31[48];
Nextern const q31_t twiddleCoef_64_q31[96];
Nextern const q31_t twiddleCoef_128_q31[192];
Nextern const q31_t twiddleCoef_256_q31[384];
Nextern const q31_t twiddleCoef_512_q31[768];
Nextern const q31_t twiddleCoef_1024_q31[1536];
Nextern const q31_t twiddleCoef_2048_q31[3072];
Nextern const q31_t twiddleCoef_4096_q31[6144];
Nextern const q15_t twiddleCoef_16_q15[24];
Nextern const q15_t twiddleCoef_32_q15[48];
Nextern const q15_t twiddleCoef_64_q15[96];
Nextern const q15_t twiddleCoef_128_q15[192];
Nextern const q15_t twiddleCoef_256_q15[384];
Nextern const q15_t twiddleCoef_512_q15[768];
Nextern const q15_t twiddleCoef_1024_q15[1536];
Nextern const q15_t twiddleCoef_2048_q15[3072];
Nextern const q15_t twiddleCoef_4096_q15[6144];
Nextern const float32_t twiddleCoef_rfft_32[32];
Nextern const float32_t twiddleCoef_rfft_64[64];
Nextern const float32_t twiddleCoef_rfft_128[128];
Nextern const float32_t twiddleCoef_rfft_256[256];
Nextern const float32_t twiddleCoef_rfft_512[512];
Nextern const float32_t twiddleCoef_rfft_1024[1024];
Nextern const float32_t twiddleCoef_rfft_2048[2048];
Nextern const float32_t twiddleCoef_rfft_4096[4096];
N
N
N/* floating-point bit reversal tables */
N#define ARMBITREVINDEXTABLE__16_TABLE_LENGTH ((uint16_t)20  )
N#define ARMBITREVINDEXTABLE__32_TABLE_LENGTH ((uint16_t)48  )
N#define ARMBITREVINDEXTABLE__64_TABLE_LENGTH ((uint16_t)56  )
N#define ARMBITREVINDEXTABLE_128_TABLE_LENGTH ((uint16_t)208 )
N#define ARMBITREVINDEXTABLE_256_TABLE_LENGTH ((uint16_t)440 )
N#define ARMBITREVINDEXTABLE_512_TABLE_LENGTH ((uint16_t)448 )
N#define ARMBITREVINDEXTABLE1024_TABLE_LENGTH ((uint16_t)1800)
N#define ARMBITREVINDEXTABLE2048_TABLE_LENGTH ((uint16_t)3808)
N#define ARMBITREVINDEXTABLE4096_TABLE_LENGTH ((uint16_t)4032)
N
Nextern const uint16_t armBitRevIndexTable16[ARMBITREVINDEXTABLE__16_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable16[((uint16_t)20 )];
Nextern const uint16_t armBitRevIndexTable32[ARMBITREVINDEXTABLE__32_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable32[((uint16_t)48 )];
Nextern const uint16_t armBitRevIndexTable64[ARMBITREVINDEXTABLE__64_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable64[((uint16_t)56 )];
Nextern const uint16_t armBitRevIndexTable128[ARMBITREVINDEXTABLE_128_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable128[((uint16_t)208 )];
Nextern const uint16_t armBitRevIndexTable256[ARMBITREVINDEXTABLE_256_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable256[((uint16_t)440 )];
Nextern const uint16_t armBitRevIndexTable512[ARMBITREVINDEXTABLE_512_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable512[((uint16_t)448 )];
Nextern const uint16_t armBitRevIndexTable1024[ARMBITREVINDEXTABLE1024_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable1024[((uint16_t)1800)];
Nextern const uint16_t armBitRevIndexTable2048[ARMBITREVINDEXTABLE2048_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable2048[((uint16_t)3808)];
Nextern const uint16_t armBitRevIndexTable4096[ARMBITREVINDEXTABLE4096_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable4096[((uint16_t)4032)];
N
N/* fixed-point bit reversal tables */
N#define ARMBITREVINDEXTABLE_FIXED___16_TABLE_LENGTH ((uint16_t)12  )
N#define ARMBITREVINDEXTABLE_FIXED___32_TABLE_LENGTH ((uint16_t)24  )
N#define ARMBITREVINDEXTABLE_FIXED___64_TABLE_LENGTH ((uint16_t)56  )
N#define ARMBITREVINDEXTABLE_FIXED__128_TABLE_LENGTH ((uint16_t)112 )
N#define ARMBITREVINDEXTABLE_FIXED__256_TABLE_LENGTH ((uint16_t)240 )
N#define ARMBITREVINDEXTABLE_FIXED__512_TABLE_LENGTH ((uint16_t)480 )
N#define ARMBITREVINDEXTABLE_FIXED_1024_TABLE_LENGTH ((uint16_t)992 )
N#define ARMBITREVINDEXTABLE_FIXED_2048_TABLE_LENGTH ((uint16_t)1984)
N#define ARMBITREVINDEXTABLE_FIXED_4096_TABLE_LENGTH ((uint16_t)4032)
N
Nextern const uint16_t armBitRevIndexTable_fixed_16[ARMBITREVINDEXTABLE_FIXED___16_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable_fixed_16[((uint16_t)12 )];
Nextern const uint16_t armBitRevIndexTable_fixed_32[ARMBITREVINDEXTABLE_FIXED___32_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable_fixed_32[((uint16_t)24 )];
Nextern const uint16_t armBitRevIndexTable_fixed_64[ARMBITREVINDEXTABLE_FIXED___64_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable_fixed_64[((uint16_t)56 )];
Nextern const uint16_t armBitRevIndexTable_fixed_128[ARMBITREVINDEXTABLE_FIXED__128_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable_fixed_128[((uint16_t)112 )];
Nextern const uint16_t armBitRevIndexTable_fixed_256[ARMBITREVINDEXTABLE_FIXED__256_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable_fixed_256[((uint16_t)240 )];
Nextern const uint16_t armBitRevIndexTable_fixed_512[ARMBITREVINDEXTABLE_FIXED__512_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable_fixed_512[((uint16_t)480 )];
Nextern const uint16_t armBitRevIndexTable_fixed_1024[ARMBITREVINDEXTABLE_FIXED_1024_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable_fixed_1024[((uint16_t)992 )];
Nextern const uint16_t armBitRevIndexTable_fixed_2048[ARMBITREVINDEXTABLE_FIXED_2048_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable_fixed_2048[((uint16_t)1984)];
Nextern const uint16_t armBitRevIndexTable_fixed_4096[ARMBITREVINDEXTABLE_FIXED_4096_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable_fixed_4096[((uint16_t)4032)];
N
N/* Tables for Fast Math Sine and Cosine */
Nextern const float32_t sinTable_f32[FAST_MATH_TABLE_SIZE + 1];
Xextern const float32_t sinTable_f32[512 + 1];
Nextern const q31_t sinTable_q31[FAST_MATH_TABLE_SIZE + 1];
Xextern const q31_t sinTable_q31[512 + 1];
Nextern const q15_t sinTable_q15[FAST_MATH_TABLE_SIZE + 1];
Xextern const q15_t sinTable_q15[512 + 1];
N
N#endif /*  ARM_COMMON_TABLES_H */
L 48 "..\..\..\..\..\..\COMMON\SRC\CMSIS_DSP_4_5\inc\arm_const_structs.h" 2
N
N   extern const arm_cfft_instance_f32 arm_cfft_sR_f32_len16;
N   extern const arm_cfft_instance_f32 arm_cfft_sR_f32_len32;
N   extern const arm_cfft_instance_f32 arm_cfft_sR_f32_len64;
N   extern const arm_cfft_instance_f32 arm_cfft_sR_f32_len128;
N   extern const arm_cfft_instance_f32 arm_cfft_sR_f32_len256;
N   extern const arm_cfft_instance_f32 arm_cfft_sR_f32_len512;
N   extern const arm_cfft_instance_f32 arm_cfft_sR_f32_len1024;
N   extern const arm_cfft_instance_f32 arm_cfft_sR_f32_len2048;
N   extern const arm_cfft_instance_f32 arm_cfft_sR_f32_len4096;
N
N   extern const arm_cfft_instance_q31 arm_cfft_sR_q31_len16;
N   extern const arm_cfft_instance_q31 arm_cfft_sR_q31_len32;
N   extern const arm_cfft_instance_q31 arm_cfft_sR_q31_len64;
N   extern const arm_cfft_instance_q31 arm_cfft_sR_q31_len128;
N   extern const arm_cfft_instance_q31 arm_cfft_sR_q31_len256;
N   extern const arm_cfft_instance_q31 arm_cfft_sR_q31_len512;
N   extern const arm_cfft_instance_q31 arm_cfft_sR_q31_len1024;
N   extern const arm_cfft_instance_q31 arm_cfft_sR_q31_len2048;
N   extern const arm_cfft_instance_q31 arm_cfft_sR_q31_len4096;
N
N   extern const arm_cfft_instance_q15 arm_cfft_sR_q15_len16;
N   extern const arm_cfft_instance_q15 arm_cfft_sR_q15_len32;
N   extern const arm_cfft_instance_q15 arm_cfft_sR_q15_len64;
N   extern const arm_cfft_instance_q15 arm_cfft_sR_q15_len128;
N   extern const arm_cfft_instance_q15 arm_cfft_sR_q15_len256;
N   extern const arm_cfft_instance_q15 arm_cfft_sR_q15_len512;
N   extern const arm_cfft_instance_q15 arm_cfft_sR_q15_len1024;
N   extern const arm_cfft_instance_q15 arm_cfft_sR_q15_len2048;
N   extern const arm_cfft_instance_q15 arm_cfft_sR_q15_len4096;
N
N#endif
L 27 "..\..\..\..\..\..\COMMON\SRC\TEST\CM_TEST.c" 2
N#include "IIR.h"
L 1 "..\..\..\..\..\..\COMMON\SRC\TEST\IIR.h" 1
N/*
N * IIR.h
N *
N *  Created on: Mar 1, 2014
N *      Author: emh203
N */
N#include "CM_TEST_CONFIG.h"
N#include "arm_math.h"
N
N#ifndef IIR_H_
N#define IIR_H_
N
Ntypedef struct
N{
N    q31_t	b[3];   //Feedforward
N    q31_t	a[2];	//Feedback
N    int8_t PostShift;  //Post multiplication
N} q31_t_IIR_Coefficients;
N
Ntypedef struct
N{
N    float	b[3];   //Feedforward
N    float	a[2];	//Feedback
N
N} f32_IIR_Coefficients;
N
Ntypedef struct
N{
N    q31_t	Xn1;    //Previous Input
N    q31_t	Xn2;	//Previous Previous Input
N    q63_t	Yn1;    //Previous Output.  Note that we will store the output State in a very High precision form
N    q63_t	Yn2;	//Previous Previous Output. Note that we will store the output State in a very High precision form
N
N} q31_t_IIR_State;
N
Ntypedef struct
N{
N    float	Xn1;    //Previous Input
N    float	Xn2;	//Previous Previous Input
N    float	Yn1;    //Previous Output.  Note that we will store the output State in a very High precision form
N    float	Yn2;	//Previous Previous Output. Note that we will store the output State in a very High precision form
N
N} f32_IIR_State;
N
N
Ntypedef struct
N{
N    q31_t_IIR_Coefficients Coef;
N    q31_t_IIR_State		   State;
N
N    q31_t_IIR_Coefficients Shadow_Coef; //Note will will NOT use a pointer here.  This will ensure the faster implementation for copying (no need to deference more than we need!)
N
N    uint8_t	Update ; //This will be set high to flag the processing routine to safely copy in the new Coefficients
N
N} q31_t_IIR;
N
Ntypedef struct
N{
N    f32_IIR_Coefficients   Coef;
N    f32_IIR_State		   State;
N
N    f32_IIR_Coefficients Shadow_Coef; //Note will will NOT use a pointer here.  This will ensure the faster implementation for copying (no need to deference more than we need!)
N
N    uint8_t	Update ; //This will be set high to flag the processing routine to safely copy in the new Coefficients
N
N} f32_IIR;
N
N#endif /* IIR_H_ */
N
N
Nvoid Init_q31_t_IIR(q31_t_IIR *MyIIR);
N#ifdef KV5_TCM_TEST
S__attribute__((section (".itcm")))
N#endif
Nvoid Compute_q31_t_IIR(q31_t_IIR *MyIIR,q31_t Input,q31_t *Output);
N
Nvoid Init_f32_IIR(f32_IIR *MyIIR);
N#ifdef KV5_TCM_TEST
S__attribute__((section (".itcm")))
N#endif
Nvoid Compute_f32_IIR(f32_IIR *MyIIR,float Input,float *Output);
N
N
N#define BIQUAD_LOW_PASS_FILTER													0
N#define BIQUAD_HIGH_PASS_FILTER 												1
N#define BIQUAD_BAND_PASS_FILTER_CONSTANT_SKIRT_GAIN_PEAKGAIN_Q					2
N#define BIQUAD_BAND_PASS_FILTER_CONSTANT_0_DB_PEAK_GAIN							3
N#define BIQUAD_NOTCH_FILTER														4
N#define BIQUAD_ALL_PASS_FILTER													5
N#define BIQUAD_PEAKING_EQ														6
N#define BIQUAD_LOW_SHELF														7
N#define BIQUAD_HIGH_SHELF														8
N
Nvoid DesignAudioBiquadIIR_q31_t(q31_t_IIR_Coefficients *C,// Pointer to the IIR Structure
N                                uint8_t FilterType,
N                                float Fs, //System Sample Rate
N                                float f0, //("wherever it's happenin', man."  Center Frequency or
N                                //Corner Frequency, or shelf midpoint frequency, depending
N                                //on which filter type.  The "significant frequency".)*/
N                                float Q,//(the EE kind of definition, except for peakingEQ in which A*Q is
N                                // the classic EE Q.  That adjustment in definition was made so that
N                                // a boost of N dB followed by a cut of N dB for identical Q and
N                                // f0/Fs results in a precisely flat unity gain filter or "wire".)*/
N                                float dBgain// (used only for peaking and shelving filters)
N                               );
N
Nvoid DesignAudioBiquadIIR_f32(f32_IIR_Coefficients *C,// Pointer to the IIR Structure
N                                uint8_t FilterType,
N                                float Fs, //System Sample Rate
N                                float f0, //("wherever it's happenin', man."  Center Frequency or
N                                //Corner Frequency, or shelf midpoint frequency, depending
N                                //on which filter type.  The "significant frequency".)*/
N                                float Q,//(the EE kind of definition, except for peakingEQ in which A*Q is
N                                // the classic EE Q.  That adjustment in definition was made so that
N                                // a boost of N dB followed by a cut of N dB for identical Q and
N                                // f0/Fs results in a precisely flat unity gain filter or "wire".)*/
N                                float dBgain// (used only for peaking and shelving filters)
N                               );
L 28 "..\..\..\..\..\..\COMMON\SRC\TEST\CM_TEST.c" 2
N#include "Goertzel.h"
L 1 "..\..\..\..\..\..\COMMON\SRC\TEST\Goertzel.h" 1
N#ifndef GOERTZEL_H
N#define GOERTZEL_H
N
Ntypedef struct
N{
N	float Cos_w;
N	float Sin_w;
N	uint32_t BlockSize;
N	float SampleRate;
N
N} Goertzel_f32_t;
N
N#ifndef M_PI
N	#define M_PI 3.14159265358979323846f
N#endif
N
Nvoid InitGoertzel_f32(Goertzel_f32_t * G,float Frequency,float SampleRate, uint32_t BlockSize);
N
Nfloat ProcessGoertzel_f32_Power(Goertzel_f32_t * G, float *x);
N
N#endif
L 29 "..\..\..\..\..\..\COMMON\SRC\TEST\CM_TEST.c" 2
N
N#if BOARD == 0
X#if 2 == 0
S
S	#define CPU_NAME "LPC4337"
S
S#elif BOARD == 1
X#elif 2 == 1
S
S	#define CPU_NAME "LPC4370"
S
N#elif BOARD == 2
X#elif 2 == 2
N
N	#define CPU_NAME "LPC54114"
N
N#else
S
S	#define CPU_NAME "MKV58F24"
S
N#endif
N
N
N#define MAX_INPUT_SIZE	8192
N
N#define FIR_TAP_SIZE	32
N
N
N#if ( BOARD==3)
X#if ( 2==3)
S
S
S	#define INIT_CYCLE_TIMER			        SysTick->CTRL = 0;SysTick->LOAD = 0xFFFFFF;SysTick->VAL = 0;
S	#define START_CYCLE_TIMER					SysTick->VAL = 0;SysTick->CTRL |= 1;
S	#define STOP_AND_GRAB_CYCLE_TIMER(x)	    SysTick->CTRL &= ~1;	x++; x = SysTick->VAL; x = 0x1000000 - x;
S	#define REPORT_CYCLE_TIMER			   		SysTick->CTRL = 0;	 CycleTimer = SysTick->VAL; CycleTimer = 0x1000000 - CycleTimer;CM_PRINTF("%i",CycleTimer - CycleOffset)
S	#define COMMA													CM_PRINTF(",");
S
N#elif  (BOARD==2 || BOARD==0 || BOARD==1)
X#elif  (2==2 || 2==0 || 2==1)
N
N	#define INIT_CYCLE_TIMER			        SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk;SysTick->LOAD = 0xFFFFFF;SysTick->VAL = 0;
N	#define START_CYCLE_TIMER					SysTick->VAL = 0;SysTick->CTRL = SysTick_CTRL_ENABLE_Msk | SysTick_CTRL_CLKSOURCE_Msk;
N	#define STOP_AND_GRAB_CYCLE_TIMER(x)	    SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk;	x++; x = SysTick->VAL; x = 0x1000000 - x;
N	#define REPORT_CYCLE_TIMER			   		SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk;	 CycleTimer = SysTick->VAL; CycleTimer = 0x1000000 - CycleTimer;CM_PRINTF("%i",CycleTimer - CycleOffset)
N	#define COMMA								CM_PRINTF(",");
N
N#endif
N
N
N#if BUILD_CONFIG == 0
X#if 3 == 0
S
S#define OPT_LEVEL "-O0"
S
S#elif BUILD_CONFIG == 1
X#elif 3 == 1
S
S#define OPT_LEVEL "-O1"
S
S#elif BUILD_CONFIG == 2
X#elif 3 == 2
S
S	#define OPT_LEVEL "-O2"
S
N#elif BUILD_CONFIG == 3
X#elif 3 == 3
N
N	#define OPT_LEVEL "-O3"
N
N#elif BUILD_CONFIG == 4
S
S	#define OPT_LEVEL "-Og"
S
S#elif BUILD_CONFIG == 5
S
S	#define OPT_LEVEL "-Os"
S
S#else
S
S	#error "Unknown BUILD_CONFIG"
S
N#endif
N
N
N#if ABI == 0
X#if 1 == 0
S
S	#define ABI_TYPE "SoftABI"
S
N#else
N
N	#define ABI_TYPE "HardABI"
N
N#endif
N
N
N	#if BOARD == 0
X	#if 2 == 0
S		#ifdef DATA_IN_ALTERNATE_AHB_BANK
S			__BSS(RAM2)
S		#endif
N	#endif
N	#if BOARD == 1
X	#if 2 == 1
S		#ifdef DATA_IN_ALTERNATE_AHB_BANK
S			__BSS(RAM2)
S		#endif
N	#endif
N	#if BOARD == 2
X	#if 2 == 2
N		#ifdef DATA_IN_ALTERNATE_AHB_BANK
S			__BSS(RAM2)
N		#endif
N	#endif
N	union
N	{
N		 q15_t 		q15[MAX_INPUT_SIZE];
X		 q15_t 		q15[8192];
N		 q31_t 		q31[MAX_INPUT_SIZE];
X		 q31_t 		q31[8192];
N		 float32_t	f32[MAX_INPUT_SIZE];
X		 float32_t	f32[8192];
N	} InputData;
N
N	#if BOARD == 0
X	#if 2 == 0
S		#ifdef DATA_IN_ALTERNATE_AHB_BANK
S			__BSS(RAM2)
S		#endif
N	#endif
N	#if BOARD == 1
X	#if 2 == 1
S		#ifdef DATA_IN_ALTERNATE_AHB_BANK
S			__BSS(RAM2)
S		#endif
N	#endif
N	#if BOARD == 2
X	#if 2 == 2
N		#ifdef DATA_IN_ALTERNATE_AHB_BANK
S			__BSS(RAM2)
N		#endif
N	#endif
Nunion
N{
N	 q15_t 		q15[MAX_INPUT_SIZE];
X	 q15_t 		q15[8192];
N	 q31_t 		q31[MAX_INPUT_SIZE];
X	 q31_t 		q31[8192];
N	 float32_t	f32[MAX_INPUT_SIZE];
X	 float32_t	f32[8192];
N} OutputData;
N
N
N
Nunion
N{
N	arm_biquad_casd_df1_inst_f32 		 f32_df1;
N	arm_biquad_cascade_df2T_instance_f32 f32_df2T;
N	arm_biquad_casd_df1_inst_q15		 q15_df1;
N	arm_biquad_casd_df1_inst_q31		 q31_df1;
N	arm_biquad_cas_df1_32x64_ins_q31     q31_64_df1;
N} IIR_Inst;
N
N
N#ifdef _f32
S	float32_t IIR_Coef_f32 [5] = {0.1,0.2,0.3,-0.4,-0.4};
S	float32_t IIR_State_f32 [4] = {0,0,0,0};
N#endif
N
N#ifdef _q31
S	q31_t IIR_Coef_q31 [5] = {0.1*0x7FFFFFFF,0.2*0x7FFFFFFF,0.3*0x7FFFFFFF,-0.4*0x7FFFFFFF,-0.4*0x7FFFFFFF};
S	q31_t IIR_State_q31 [4] = {0,0,0,0};
S	q63_t IIR_State_q63 [4] = {0,0,0,0};
N#endif
N
N#ifdef _q15
N	q15_t IIR_Coef_q15 [5] = {0.1*0x7FFF,0.2*0x7FFF,0.3*0x7FFF,-0.4*0x7FFF,-0.4*0x7FFF};
N	q15_t IIR_State_q15 [4] = {0,0,0,0};
N#endif
N
N#define MAX_FIR_LENGTH 2048
N
N	#ifdef ENABLE_BLOCK_FIR
N		union
N		{
N			arm_fir_instance_f32			f32;
N			arm_fir_instance_q31			q31;
N			arm_fir_instance_q15			q15;
N		} FIR_Inst;
N
N		union
N		{
N			float32_t f32[MAX_FIR_LENGTH+FIR_TAP_SIZE+1];
X			float32_t f32[2048+32+1];
N			q31_t	  q31[MAX_FIR_LENGTH+FIR_TAP_SIZE+1];
X			q31_t	  q31[2048+32+1];
N			q15_t	  q15[MAX_FIR_LENGTH+FIR_TAP_SIZE+1];
X			q15_t	  q15[2048+32+1];
N		}FIR_State;
N
N		#ifdef _f32
S			float32_t	FIR_Coef_f32[FIR_TAP_SIZE];
N		#endif
N
N		#ifdef _q31
S			q31_t		FIR_Coef_q31[FIR_TAP_SIZE];
N		#endif
N
N		#ifdef _q15
N			q15_t   	FIR_Coef_q15[FIR_TAP_SIZE];
X			q15_t   	FIR_Coef_q15[32];
N		#endif
N
N	#endif
N
N
N#ifdef ENABLE_PER_SAMPLE
N
Nq31_t_IIR E_IIR;
N
Nf32_IIR E_IIRf;
N
Nunion
N{
N	arm_pid_instance_f32	f32;
N	arm_pid_instance_q31	q31;
N	arm_pid_instance_q15	q15;
N}PID_Inst;
N
N#endif
N
Nunion
N{
N	arm_rfft_fast_instance_f32 rfft_fast_f32;
N	arm_rfft_instance_q31 rfft_q31;
N	arm_rfft_instance_q15 rfft_q15;
N}FFT_Inst;
N
N
N#ifdef ENABLE_GOERTZEL
N
N	Goertzel_f32_t G;
N
N#endif
N
N
Nint main(void)
N{
Nint i = 0 ;
Nvolatile float r=1;
Nvolatile uint32_t CycleTimer = 0;
Nvolatile uint32_t CycleOffset = 0;
N
N#if(BOARD==0 || BOARD==1 || BOARD==2)
X#if(2==0 || 2==1 || 2==2)
N	SystemCoreClockUpdate();
N	 fpuInit();
N	Board_Init();
N#endif
N
N
N#if (BOARD==3)
X#if (2==3)
S  BOARD_InitPins();
S  BOARD_BootClockRUN();
S  BOARD_InitDebugConsole();
S  SystemCoreClockUpdate();
N#endif
N
N
NINIT_CYCLE_TIMER;
X((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD = 0xFFFFFF;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;;
N
N#ifdef ENABLE_BLOCK_PROCESSING
N
N	for(i=0;i<MAX_INPUT_SIZE;i++)
X	for(i=0;i<8192;i++)
N    {
N    	InputData.q31[i] = rand();
N    }
N
N	#ifdef ENABLE_BLOCK_FIR
N		for(i=0;i<32;i++)
N		{
N		#ifdef _f32
S			FIR_Coef_f32[i] = (float32_t)i/32;
N		#endif
N
N		#ifdef _q31
S			FIR_Coef_q31[i] = i<<26;
N		#endif
N
N		#ifdef _q15
N			 	 FIR_Coef_q15[i] = i<<10;
N		#endif
N		}
N	#endif
N
N#endif
N
N    CM_PRINTF("Cortex M4/7 Performance Test.\r\n");
X    printf("Cortex M4/7 Performance Test.\r\n");
N		
N		#ifdef __ARMCC_VERSION
N		
N			CM_PRINTF("ARMCC Version: %d\r\n",__ARMCC_VERSION);
X			printf("ARMCC Version: %d\r\n",5060422);
N			CM_PRINTF("%s %s %s\r\n",CPU_NAME,OPT_LEVEL,ABI_TYPE);
X			printf("%s %s %s\r\n","LPC54114","-O3","HardABI");
N			CM_PRINTF("NOTES: \r\n");
X			printf("NOTES: \r\n");
N		
N		#else
S		
S			CM_PRINTF("GCC Version: %d.%d.%d\r\n",__GNUC__,__GNUC_MINOR__,__GNUC_PATCHLEVEL__);
S			CM_PRINTF("%s %s %s\r\n",CPU_NAME,OPT_LEVEL,ABI_TYPE);
S			CM_PRINTF("NOTES: \r\n");
S	  
N		#endif
N
N   	START_CYCLE_TIMER;
X   	((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;
N   	STOP_AND_GRAB_CYCLE_TIMER(CycleOffset);
X   	((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleOffset++; CycleOffset = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleOffset = 0x1000000 - CycleOffset;;
N   	CM_PRINTF("Cycle Offset: %d\r\n",CycleOffset);
X   	printf("Cycle Offset: %d\r\n",CycleOffset);
N
N   	/***
N   	 *      ____  _      ____   _____ _  __  _____  _____   ____   _____ ______  _____ _____ _____ _   _  _____
N   	 *     |  _ \| |    / __ \ / ____| |/ / |  __ \|  __ \ / __ \ / ____|  ____|/ ____/ ____|_   _| \ | |/ ____|
N   	 *     | |_) | |   | |  | | |    | ' /  | |__) | |__) | |  | | |    | |__  | (___| (___   | | |  \| | |  __
N   	 *     |  _ <| |   | |  | | |    |  <   |  ___/|  _  /| |  | | |    |  __|  \___ \\___ \  | | | . ` | | |_ |
N   	 *     | |_) | |___| |__| | |____| . \  | |    | | \ \| |__| | |____| |____ ____) |___) |_| |_| |\  | |__| |
N   	 *     |____/|______\____/ \_____|_|\_\ |_|    |_|  \_\\____/ \_____|______|_____/_____/|_____|_| \_|\_____|
N   	 *
N   	 *
N   	 */
N
N#ifdef ENABLE_BLOCK_PROCESSING
N
N   	CM_PRINTF("\r\nBlock Processing Functions");
X   	printf("\r\nBlock Processing Functions");
N  	CM_PRINTF("\r\n---------------------------------------------------------------\r\n");
X  	printf("\r\n---------------------------------------------------------------\r\n");
N   	CM_PRINTF("\r\nLength,16,32,64,128,256,512,1024,2048,4096");
X   	printf("\r\nLength,16,32,64,128,256,512,1024,2048,4096");
N
N	   /***
N	    *       __ ____ ___
N	    *      / _|___ \__ \
N	    *     | |_  __) | ) |
X
N	    *     |  _||__ < / /
N	    *     | |  ___) / /_
N	    *     |_| |____/____|
N	    *
N	    *
N	    */
N
N	#ifdef _f32
S
S			#ifdef ENABLE_CFFT_BR
S					CM_PRINTF("\r\n");
S					CM_PRINTF("\r\nCFFT-f32-BitReverse,");
S					START_CYCLE_TIMER; arm_cfft_f32(&arm_cfft_sR_f32_len16,  &InputData.f32[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cfft_f32(&arm_cfft_sR_f32_len32,   &InputData.f32[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cfft_f32(&arm_cfft_sR_f32_len64,   &InputData.f32[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cfft_f32(&arm_cfft_sR_f32_len128,  &InputData.f32[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cfft_f32(&arm_cfft_sR_f32_len256,  &InputData.f32[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cfft_f32(&arm_cfft_sR_f32_len512,  &InputData.f32[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cfft_f32(&arm_cfft_sR_f32_len1024, &InputData.f32[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cfft_f32(&arm_cfft_sR_f32_len2048, &InputData.f32[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cfft_f32(&arm_cfft_sR_f32_len4096, &InputData.f32[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
S		    #endif
S
S			#ifdef ENABLE_CFFT_NBR
S					CM_PRINTF("\r\n");
S					CM_PRINTF("CFFT-f32-NoBitReverse,");
S					START_CYCLE_TIMER;arm_cfft_f32(&arm_cfft_sR_f32_len16,   &InputData.f32[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cfft_f32(&arm_cfft_sR_f32_len32,   &InputData.f32[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cfft_f32(&arm_cfft_sR_f32_len64,   &InputData.f32[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cfft_f32(&arm_cfft_sR_f32_len128,  &InputData.f32[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cfft_f32(&arm_cfft_sR_f32_len256,  &InputData.f32[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cfft_f32(&arm_cfft_sR_f32_len512,  &InputData.f32[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cfft_f32(&arm_cfft_sR_f32_len1024, &InputData.f32[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cfft_f32(&arm_cfft_sR_f32_len2048, &InputData.f32[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cfft_f32(&arm_cfft_sR_f32_len4096, &InputData.f32[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
S			#endif
S
S
S			#ifdef ENABLE_RFFT_NBR
S					CM_PRINTF("\r\n");
S					CM_PRINTF("RFFT-f32-NoBitReverse,");
S
S					CM_PRINTF("n/a");COMMA;
S					arm_rfft_fast_init_f32(&FFT_Inst.rfft_fast_f32,32);START_CYCLE_TIMER;arm_rfft_fast_f32(&FFT_Inst.rfft_fast_f32,&InputData.f32[0], &OutputData.f32[0], 0);REPORT_CYCLE_TIMER;COMMA;
S					arm_rfft_fast_init_f32(&FFT_Inst.rfft_fast_f32,64);START_CYCLE_TIMER;arm_rfft_fast_f32(&FFT_Inst.rfft_fast_f32,&InputData.f32[0], &OutputData.f32[0], 0);REPORT_CYCLE_TIMER;COMMA;
S					arm_rfft_fast_init_f32(&FFT_Inst.rfft_fast_f32,128);START_CYCLE_TIMER;arm_rfft_fast_f32(&FFT_Inst.rfft_fast_f32,&InputData.f32[0], &OutputData.f32[0], 0);REPORT_CYCLE_TIMER;COMMA;
S					arm_rfft_fast_init_f32(&FFT_Inst.rfft_fast_f32,256);START_CYCLE_TIMER;arm_rfft_fast_f32(&FFT_Inst.rfft_fast_f32,&InputData.f32[0], &OutputData.f32[0], 0);REPORT_CYCLE_TIMER;COMMA;
S					arm_rfft_fast_init_f32(&FFT_Inst.rfft_fast_f32,512);START_CYCLE_TIMER;arm_rfft_fast_f32(&FFT_Inst.rfft_fast_f32,&InputData.f32[0], &OutputData.f32[0], 0);REPORT_CYCLE_TIMER;COMMA;
S					arm_rfft_fast_init_f32(&FFT_Inst.rfft_fast_f32,1024);START_CYCLE_TIMER;arm_rfft_fast_f32(&FFT_Inst.rfft_fast_f32,&InputData.f32[0], &OutputData.f32[0], 0);REPORT_CYCLE_TIMER;COMMA;
S					arm_rfft_fast_init_f32(&FFT_Inst.rfft_fast_f32,2048);START_CYCLE_TIMER;arm_rfft_fast_f32(&FFT_Inst.rfft_fast_f32,&InputData.f32[0], &OutputData.f32[0], 0);REPORT_CYCLE_TIMER;COMMA;
S					arm_rfft_fast_init_f32(&FFT_Inst.rfft_fast_f32,4096);START_CYCLE_TIMER;arm_rfft_fast_f32(&FFT_Inst.rfft_fast_f32,&InputData.f32[0], &OutputData.f32[0], 0);REPORT_CYCLE_TIMER;COMMA;
S			#endif
S
S			#ifdef COMPLEX_MAG
S					CM_PRINTF("\r\n");
S					CM_PRINTF("ComplexMag-f32,");
S					START_CYCLE_TIMER;arm_cmplx_mag_f32(&InputData.f32[0],&OutputData.f32[0],16);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cmplx_mag_f32(&InputData.f32[0],&OutputData.f32[0],32);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cmplx_mag_f32(&InputData.f32[0],&OutputData.f32[0],64);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cmplx_mag_f32(&InputData.f32[0],&OutputData.f32[0],128);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cmplx_mag_f32(&InputData.f32[0],&OutputData.f32[0],256);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cmplx_mag_f32(&InputData.f32[0],&OutputData.f32[0],512);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cmplx_mag_f32(&InputData.f32[0],&OutputData.f32[0],1024);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cmplx_mag_f32(&InputData.f32[0],&OutputData.f32[0],2048);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cmplx_mag_f32(&InputData.f32[0],&OutputData.f32[0],4096);REPORT_CYCLE_TIMER;COMMA;
S			#endif
S
S			#ifdef COMPLEX_MAG_SQUARED
S					CM_PRINTF("\r\n");
S					CM_PRINTF("ComplexMagSquared-f32,");
S					START_CYCLE_TIMER;arm_cmplx_mag_squared_f32(&InputData.f32[0],&OutputData.f32[0],16);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cmplx_mag_squared_f32(&InputData.f32[0],&OutputData.f32[0],32);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cmplx_mag_squared_f32(&InputData.f32[0],&OutputData.f32[0],64);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cmplx_mag_squared_f32(&InputData.f32[0],&OutputData.f32[0],128);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cmplx_mag_squared_f32(&InputData.f32[0],&OutputData.f32[0],256);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cmplx_mag_squared_f32(&InputData.f32[0],&OutputData.f32[0],512);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cmplx_mag_squared_f32(&InputData.f32[0],&OutputData.f32[0],1024);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cmplx_mag_squared_f32(&InputData.f32[0],&OutputData.f32[0],2048);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_cmplx_mag_squared_f32(&InputData.f32[0],&OutputData.f32[0],4096);REPORT_CYCLE_TIMER;COMMA;
S			#endif
S
S			#ifdef ENABLE_GOERTZEL
S
S					CM_PRINTF("\r\n");
S					InitGoertzel_f32(&G,180000.0f,1000000.0f,32);
S					CM_PRINTF("Goertzel_f32,");
S
S					G.BlockSize = 16; START_CYCLE_TIMER;r=ProcessGoertzel_f32_Power(&G,&InputData.f32[0]);REPORT_CYCLE_TIMER;COMMA;r*=2;//To Get rid of the warning
S					G.BlockSize = 32; START_CYCLE_TIMER;r=ProcessGoertzel_f32_Power(&G,&InputData.f32[0]);REPORT_CYCLE_TIMER;COMMA;r*=2;//To Get rid of the warning
S					G.BlockSize = 64; START_CYCLE_TIMER;r=ProcessGoertzel_f32_Power(&G,&InputData.f32[0]);REPORT_CYCLE_TIMER;COMMA;r*=2;//To Get rid of the warning
S					G.BlockSize = 128; START_CYCLE_TIMER;r=ProcessGoertzel_f32_Power(&G,&InputData.f32[0]);REPORT_CYCLE_TIMER;COMMA;r*=2;//To Get rid of the warning
S					G.BlockSize = 256; START_CYCLE_TIMER;r=ProcessGoertzel_f32_Power(&G,&InputData.f32[0]);REPORT_CYCLE_TIMER;COMMA;r*=2;//To Get rid of the warning
S					G.BlockSize = 512; START_CYCLE_TIMER;r=ProcessGoertzel_f32_Power(&G,&InputData.f32[0]);REPORT_CYCLE_TIMER;COMMA;r*=2;//To Get rid of the warning
S					G.BlockSize = 1024; START_CYCLE_TIMER;r=ProcessGoertzel_f32_Power(&G,&InputData.f32[0]);REPORT_CYCLE_TIMER;COMMA;r*=2;//To Get rid of the warning
S					G.BlockSize = 2048; START_CYCLE_TIMER;r=ProcessGoertzel_f32_Power(&G,&InputData.f32[0]);REPORT_CYCLE_TIMER;COMMA;r*=2;//To Get rid of the warning
S					G.BlockSize = 4096; START_CYCLE_TIMER;r=ProcessGoertzel_f32_Power(&G,&InputData.f32[0]);REPORT_CYCLE_TIMER;COMMA;r*=2;//To Get rid of the warning
S			#endif
S
S			#ifdef ENABLE_BLOCK_IIR
S					CM_PRINTF("\r\n");
S					CM_PRINTF("IIR-f32_df1-1Stage,");
S
S					arm_biquad_cascade_df1_init_f32(&IIR_Inst.f32_df1,1,&IIR_Coef_f32[0],&IIR_State_f32[0]);
S
S					START_CYCLE_TIMER;arm_biquad_cascade_df1_f32(&IIR_Inst.f32_df1,&InputData.f32[0],&OutputData.f32[0],16);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_biquad_cascade_df1_f32(&IIR_Inst.f32_df1,&InputData.f32[0],&OutputData.f32[0],32);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_biquad_cascade_df1_f32(&IIR_Inst.f32_df1,&InputData.f32[0],&OutputData.f32[0],64);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_biquad_cascade_df1_f32(&IIR_Inst.f32_df1,&InputData.f32[0],&OutputData.f32[0],128);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_biquad_cascade_df1_f32(&IIR_Inst.f32_df1,&InputData.f32[0],&OutputData.f32[0],256);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_biquad_cascade_df1_f32(&IIR_Inst.f32_df1,&InputData.f32[0],&OutputData.f32[0],512);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_biquad_cascade_df1_f32(&IIR_Inst.f32_df1,&InputData.f32[0],&OutputData.f32[0],1024);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_biquad_cascade_df1_f32(&IIR_Inst.f32_df1,&InputData.f32[0],&OutputData.f32[0],2048);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_biquad_cascade_df1_f32(&IIR_Inst.f32_df1,&InputData.f32[0],&OutputData.f32[0],4096);REPORT_CYCLE_TIMER;COMMA;
S
S					CM_PRINTF("\r\n");
S					CM_PRINTF("IIR-f32_df2T-1Stage,");
S
S					arm_biquad_cascade_df2T_init_f32(&IIR_Inst.f32_df2T,1,&IIR_Coef_f32[0],&IIR_State_f32[0]);
S
S					START_CYCLE_TIMER;arm_biquad_cascade_df2T_f32(&IIR_Inst.f32_df2T,&InputData.f32[0],&OutputData.f32[0],16);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_biquad_cascade_df2T_f32(&IIR_Inst.f32_df2T,&InputData.f32[0],&OutputData.f32[0],32);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_biquad_cascade_df2T_f32(&IIR_Inst.f32_df2T,&InputData.f32[0],&OutputData.f32[0],64);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_biquad_cascade_df2T_f32(&IIR_Inst.f32_df2T,&InputData.f32[0],&OutputData.f32[0],128);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_biquad_cascade_df2T_f32(&IIR_Inst.f32_df2T,&InputData.f32[0],&OutputData.f32[0],256);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_biquad_cascade_df2T_f32(&IIR_Inst.f32_df2T,&InputData.f32[0],&OutputData.f32[0],512);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_biquad_cascade_df2T_f32(&IIR_Inst.f32_df2T,&InputData.f32[0],&OutputData.f32[0],1024);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_biquad_cascade_df2T_f32(&IIR_Inst.f32_df2T,&InputData.f32[0],&OutputData.f32[0],2048);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_biquad_cascade_df2T_f32(&IIR_Inst.f32_df2T,&InputData.f32[0],&OutputData.f32[0],4096);REPORT_CYCLE_TIMER;COMMA;
S				#endif
S
S				#ifdef ENABLE_BLOCK_FIR
S					CM_PRINTF("\r\n");
S					CM_PRINTF("FIR-f32_8tap,");
S					arm_fir_init_f32(&FIR_Inst.f32,8,&FIR_Coef_f32[0],&FIR_State.f32[0],2048);
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],16);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],32);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],64);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],128);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],256);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],512);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],1024);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],2048);REPORT_CYCLE_TIMER;COMMA;
S					CM_PRINTF("n/a"); // Not enough memory to do the 4096 case
S
S					CM_PRINTF("\r\n");
S					CM_PRINTF("FIR-f32_16tap,");
S
S					arm_fir_init_f32(&FIR_Inst.f32,16,&FIR_Coef_f32[0],&FIR_State.f32[0],2048);
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],16);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],32);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],64);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],128);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],256);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],512);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],1024);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],2048);REPORT_CYCLE_TIMER;COMMA;
S					CM_PRINTF("n/a"); // Not enough memory to do the 4096 case
S
S					CM_PRINTF("\r\n");
S					CM_PRINTF("FIR-f32_32tap,");
S
S					arm_fir_init_f32(&FIR_Inst.f32,32,&FIR_Coef_f32[0],&FIR_State.f32[0],2048);
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],16);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],32);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],64);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],128);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],256);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],512);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],1024);REPORT_CYCLE_TIMER;COMMA;
S					START_CYCLE_TIMER;arm_fir_f32(&FIR_Inst.f32,&InputData.f32[0],&OutputData.f32[0],2048);REPORT_CYCLE_TIMER;COMMA;
S					CM_PRINTF("n/a"); // Not enough memory to do the 4096 case
S				#endif
N	#endif
N
N    	/***
N    	 *            ____  __
N    	 *           |___ \/_ |
N    	 *       __ _  __) || |
N    	 *      / _` ||__ < | |
N    	 *     | (_| |___) || |
N    	 *      \__, |____/ |_|
N    	 *         | |
N    	 *         |_|
N    	 */
N
N
N
N		#ifdef _q31
S
S			#ifdef ENABLE_CFFT_BR
S				CM_PRINTF("\r\n");
S				CM_PRINTF("CFFT-q31-BitReverse,");
S				START_CYCLE_TIMER;arm_cfft_q31(&arm_cfft_sR_q31_len16,   &InputData.q31[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cfft_q31(&arm_cfft_sR_q31_len32,   &InputData.q31[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cfft_q31(&arm_cfft_sR_q31_len64,   &InputData.q31[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cfft_q31(&arm_cfft_sR_q31_len128,  &InputData.q31[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cfft_q31(&arm_cfft_sR_q31_len256,  &InputData.q31[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cfft_q31(&arm_cfft_sR_q31_len512,  &InputData.q31[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cfft_q31(&arm_cfft_sR_q31_len1024, &InputData.q31[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cfft_q31(&arm_cfft_sR_q31_len2048, &InputData.q31[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cfft_q31(&arm_cfft_sR_q31_len4096, &InputData.q31[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
S			#endif
S
S			#ifdef ENABLE_CFFT_NBR
S				CM_PRINTF("\r\n");
S				CM_PRINTF("CFFT-q31-NoBitReverse,");
S				START_CYCLE_TIMER;arm_cfft_q31(&arm_cfft_sR_q31_len16,   &InputData.q31[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cfft_q31(&arm_cfft_sR_q31_len32,   &InputData.q31[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cfft_q31(&arm_cfft_sR_q31_len64,   &InputData.q31[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cfft_q31(&arm_cfft_sR_q31_len128,  &InputData.q31[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cfft_q31(&arm_cfft_sR_q31_len256,  &InputData.q31[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cfft_q31(&arm_cfft_sR_q31_len512,  &InputData.q31[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cfft_q31(&arm_cfft_sR_q31_len1024, &InputData.q31[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cfft_q31(&arm_cfft_sR_q31_len2048, &InputData.q31[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cfft_q31(&arm_cfft_sR_q31_len4096, &InputData.q31[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
S			#endif
S
S			#ifdef ENABLE_RFFT_BR
S				CM_PRINTF("\r\nRFFT-Q31-BitReverse,");
S				CM_PRINTF("n/a");COMMA;
S				arm_rfft_init_q31(&FFT_Inst.rfft_q31,32,0,1);START_CYCLE_TIMER;arm_rfft_q31(&FFT_Inst.rfft_q31,&InputData.q31[0], &OutputData.q31[0]);REPORT_CYCLE_TIMER;COMMA;
S				arm_rfft_init_q31(&FFT_Inst.rfft_q31,64,0,1);START_CYCLE_TIMER;arm_rfft_q31(&FFT_Inst.rfft_q31,&InputData.q31[0], &OutputData.q31[0]);REPORT_CYCLE_TIMER;COMMA;
S				arm_rfft_init_q31(&FFT_Inst.rfft_q31,128,0,1);START_CYCLE_TIMER;arm_rfft_q31(&FFT_Inst.rfft_q31,&InputData.q31[0], &OutputData.q31[0]);REPORT_CYCLE_TIMER;COMMA;
S				arm_rfft_init_q31(&FFT_Inst.rfft_q31,256,0,1);START_CYCLE_TIMER;arm_rfft_q31(&FFT_Inst.rfft_q31,&InputData.q31[0], &OutputData.q31[0]);REPORT_CYCLE_TIMER;COMMA;
S				arm_rfft_init_q31(&FFT_Inst.rfft_q31,512,0,1);START_CYCLE_TIMER;arm_rfft_q31(&FFT_Inst.rfft_q31,&InputData.q31[0], &OutputData.q31[0]);REPORT_CYCLE_TIMER;COMMA;
S				arm_rfft_init_q31(&FFT_Inst.rfft_q31,1024,0,1);START_CYCLE_TIMER;arm_rfft_q31(&FFT_Inst.rfft_q31,&InputData.q31[0], &OutputData.q31[0]);REPORT_CYCLE_TIMER;COMMA;
S				arm_rfft_init_q31(&FFT_Inst.rfft_q31,2048,0,1);START_CYCLE_TIMER;arm_rfft_q31(&FFT_Inst.rfft_q31,&InputData.q31[0], &OutputData.q31[0]);REPORT_CYCLE_TIMER;COMMA;
S				arm_rfft_init_q31(&FFT_Inst.rfft_q31,4096,0,1);START_CYCLE_TIMER;arm_rfft_q31(&FFT_Inst.rfft_q31,&InputData.q31[0], &OutputData.q31[0]);REPORT_CYCLE_TIMER;COMMA;
S			#endif
S
S			#ifdef ENABLE_RFFT_NBR
S				CM_PRINTF("\r\nRFFT-Q31-NoBitReverse,");
S				CM_PRINTF("n/a");COMMA;
S				arm_rfft_init_q31(&FFT_Inst.rfft_q31,32,0,0);START_CYCLE_TIMER;arm_rfft_q31(&FFT_Inst.rfft_q31,&InputData.q31[0], &OutputData.q31[0]);REPORT_CYCLE_TIMER;COMMA;
S				arm_rfft_init_q31(&FFT_Inst.rfft_q31,64,0,0);START_CYCLE_TIMER;arm_rfft_q31(&FFT_Inst.rfft_q31,&InputData.q31[0], &OutputData.q31[0]);REPORT_CYCLE_TIMER;COMMA;
S				arm_rfft_init_q31(&FFT_Inst.rfft_q31,128,0,0);START_CYCLE_TIMER;arm_rfft_q31(&FFT_Inst.rfft_q31,&InputData.q31[0], &OutputData.q31[0]);REPORT_CYCLE_TIMER;COMMA;
S				arm_rfft_init_q31(&FFT_Inst.rfft_q31,256,0,0);START_CYCLE_TIMER;arm_rfft_q31(&FFT_Inst.rfft_q31,&InputData.q31[0], &OutputData.q31[0]);REPORT_CYCLE_TIMER;COMMA;
S				arm_rfft_init_q31(&FFT_Inst.rfft_q31,512,0,0);START_CYCLE_TIMER;arm_rfft_q31(&FFT_Inst.rfft_q31,&InputData.q31[0], &OutputData.q31[0]);REPORT_CYCLE_TIMER;COMMA;
S				arm_rfft_init_q31(&FFT_Inst.rfft_q31,1024,0,0);START_CYCLE_TIMER;arm_rfft_q31(&FFT_Inst.rfft_q31,&InputData.q31[0], &OutputData.q31[0]);REPORT_CYCLE_TIMER;COMMA;
S				arm_rfft_init_q31(&FFT_Inst.rfft_q31,2048,0,0);START_CYCLE_TIMER;arm_rfft_q31(&FFT_Inst.rfft_q31,&InputData.q31[0], &OutputData.q31[0]);REPORT_CYCLE_TIMER;COMMA;
S				arm_rfft_init_q31(&FFT_Inst.rfft_q31,4096,0,0);START_CYCLE_TIMER;arm_rfft_q31(&FFT_Inst.rfft_q31,&InputData.q31[0], &OutputData.q31[0]);REPORT_CYCLE_TIMER;COMMA;
S			#endif
S
S			#ifdef COMPLEX_MAG_SQUARED
S				CM_PRINTF("\r\n");
S				CM_PRINTF("ComplexMag-q31,");
S				START_CYCLE_TIMER;arm_cmplx_mag_q31(&InputData.q31[0],&OutputData.q31[0],16);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cmplx_mag_q31(&InputData.q31[0],&OutputData.q31[0],32);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cmplx_mag_q31(&InputData.q31[0],&OutputData.q31[0],64);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cmplx_mag_q31(&InputData.q31[0],&OutputData.q31[0],128);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cmplx_mag_q31(&InputData.q31[0],&OutputData.q31[0],256);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cmplx_mag_q31(&InputData.q31[0],&OutputData.q31[0],512);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cmplx_mag_q31(&InputData.q31[0],&OutputData.q31[0],1024);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cmplx_mag_q31(&InputData.q31[0],&OutputData.q31[0],2048);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cmplx_mag_q31(&InputData.q31[0],&OutputData.q31[0],4096);REPORT_CYCLE_TIMER;COMMA;
S			#endif
S
S			#ifdef COMPLEX_MAG_SQUARED
S				CM_PRINTF("\r\n");
S				CM_PRINTF("ComplexMagSquared-q31,");
S				START_CYCLE_TIMER;arm_cmplx_mag_squared_q31(&InputData.q31[0],&OutputData.q31[0],16);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cmplx_mag_squared_q31(&InputData.q31[0],&OutputData.q31[0],32);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cmplx_mag_squared_q31(&InputData.q31[0],&OutputData.q31[0],64);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cmplx_mag_squared_q31(&InputData.q31[0],&OutputData.q31[0],128);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cmplx_mag_squared_q31(&InputData.q31[0],&OutputData.q31[0],256);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cmplx_mag_squared_q31(&InputData.q31[0],&OutputData.q31[0],512);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cmplx_mag_squared_q31(&InputData.q31[0],&OutputData.q31[0],1024);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cmplx_mag_squared_q31(&InputData.q31[0],&OutputData.q31[0],2048);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_cmplx_mag_squared_q31(&InputData.q31[0],&OutputData.q31[0],4096);REPORT_CYCLE_TIMER;COMMA;
S            #endif
S
S			#ifdef ENABLE_BLOCK_IIR
S				CM_PRINTF("\r\n");
S				CM_PRINTF("IIR-q31_df1-1Stage,");
S
S				arm_biquad_cascade_df1_init_q31(&IIR_Inst.q31_df1,1,&IIR_Coef_q31[0],&IIR_State_q31[0],1);
S
S				START_CYCLE_TIMER;arm_biquad_cascade_df1_q31(&IIR_Inst.q31_df1,&InputData.q31[0],&OutputData.q31[0],16);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cascade_df1_q31(&IIR_Inst.q31_df1,&InputData.q31[0],&OutputData.q31[0],32);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cascade_df1_q31(&IIR_Inst.q31_df1,&InputData.q31[0],&OutputData.q31[0],64);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cascade_df1_q31(&IIR_Inst.q31_df1,&InputData.q31[0],&OutputData.q31[0],128);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cascade_df1_q31(&IIR_Inst.q31_df1,&InputData.q31[0],&OutputData.q31[0],256);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cascade_df1_q31(&IIR_Inst.q31_df1,&InputData.q31[0],&OutputData.q31[0],512);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cascade_df1_q31(&IIR_Inst.q31_df1,&InputData.q31[0],&OutputData.q31[0],1024);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cascade_df1_q31(&IIR_Inst.q31_df1,&InputData.q31[0],&OutputData.q31[0],2048);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cascade_df1_q31(&IIR_Inst.q31_df1,&InputData.q31[0],&OutputData.q31[0],4096);REPORT_CYCLE_TIMER;COMMA;
S
S				CM_PRINTF("\r\n");
S				CM_PRINTF("IIR-q31_df1-1Stage-fast,");
S
S				arm_biquad_cascade_df1_init_q31(&IIR_Inst.q31_df1,1,&IIR_Coef_q31[0],&IIR_State_q31[0],1);
S
S				START_CYCLE_TIMER;arm_biquad_cascade_df1_fast_q31(&IIR_Inst.q31_df1,&InputData.q31[0],&OutputData.q31[0],16);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cascade_df1_fast_q31(&IIR_Inst.q31_df1,&InputData.q31[0],&OutputData.q31[0],32);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cascade_df1_fast_q31(&IIR_Inst.q31_df1,&InputData.q31[0],&OutputData.q31[0],64);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cascade_df1_fast_q31(&IIR_Inst.q31_df1,&InputData.q31[0],&OutputData.q31[0],128);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cascade_df1_fast_q31(&IIR_Inst.q31_df1,&InputData.q31[0],&OutputData.q31[0],256);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cascade_df1_fast_q31(&IIR_Inst.q31_df1,&InputData.q31[0],&OutputData.q31[0],512);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cascade_df1_fast_q31(&IIR_Inst.q31_df1,&InputData.q31[0],&OutputData.q31[0],1024);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cascade_df1_fast_q31(&IIR_Inst.q31_df1,&InputData.q31[0],&OutputData.q31[0],2048);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cascade_df1_fast_q31(&IIR_Inst.q31_df1,&InputData.q31[0],&OutputData.q31[0],4096);REPORT_CYCLE_TIMER;COMMA;
S
S				CM_PRINTF("\r\n");
S				CM_PRINTF("IIR-q31_64_df1-1Staget,");
S				arm_biquad_cas_df1_32x64_init_q31(&IIR_Inst.q31_64_df1,1,&IIR_Coef_q31[0],&IIR_State_q63[0],1);
S				START_CYCLE_TIMER;arm_biquad_cas_df1_32x64_q31(&IIR_Inst.q31_64_df1,&InputData.q31[0],&OutputData.q31[0],16);REPORT_CYCLE_TIMER;COMMA;
S
S				START_CYCLE_TIMER;arm_biquad_cas_df1_32x64_q31(&IIR_Inst.q31_64_df1,&InputData.q31[0],&OutputData.q31[0],32);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cas_df1_32x64_q31(&IIR_Inst.q31_64_df1,&InputData.q31[0],&OutputData.q31[0],64);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cas_df1_32x64_q31(&IIR_Inst.q31_64_df1,&InputData.q31[0],&OutputData.q31[0],128);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cas_df1_32x64_q31(&IIR_Inst.q31_64_df1,&InputData.q31[0],&OutputData.q31[0],256);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cas_df1_32x64_q31(&IIR_Inst.q31_64_df1,&InputData.q31[0],&OutputData.q31[0],512);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cas_df1_32x64_q31(&IIR_Inst.q31_64_df1,&InputData.q31[0],&OutputData.q31[0],1024);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cas_df1_32x64_q31(&IIR_Inst.q31_64_df1,&InputData.q31[0],&OutputData.q31[0],2048);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_biquad_cas_df1_32x64_q31(&IIR_Inst.q31_64_df1,&InputData.q31[0],&OutputData.q31[0],4096);REPORT_CYCLE_TIMER;COMMA;
S	     	#endif
S
S			#ifdef ENABLE_BLOCK_FIR
S				CM_PRINTF("\r\n");
S				CM_PRINTF("FIR-q31_8tap,");
S				arm_fir_init_q31(&FIR_Inst.q31,8,&FIR_Coef_q31[0],&FIR_State.q31[0],2048);
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],16);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],32);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],64);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],128);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],256);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],512);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],1024);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],2048);REPORT_CYCLE_TIMER;COMMA;
S				CM_PRINTF("n/a"); // Not enough memory to do the 4096 case
S
S				CM_PRINTF("\r\n");
S				CM_PRINTF("FIR-q31_16tap,");
S
S				arm_fir_init_q31(&FIR_Inst.q31,16,&FIR_Coef_q31[0],&FIR_State.q31[0],2048);
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],16);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],32);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],64);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],128);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],256);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],512);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],1024);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],2048);REPORT_CYCLE_TIMER;COMMA;
S				CM_PRINTF("n/a"); // Not enough memory to do the 4096 case
S
S				CM_PRINTF("\r\n");
S				CM_PRINTF("FIR-q31_32tap,");
S
S				arm_fir_init_q31(&FIR_Inst.q31,32,&FIR_Coef_q31[0],&FIR_State.q31[0],2048);
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],16);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],32);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],64);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],128);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],256);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],512);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],1024);REPORT_CYCLE_TIMER;COMMA;
S				START_CYCLE_TIMER;arm_fir_q31(&FIR_Inst.q31,&InputData.q31[0],&OutputData.q31[0],2048);REPORT_CYCLE_TIMER;COMMA;
S				CM_PRINTF("n/a"); // Not enough memory to do the 4096 case
S			#endif
S
N	#endif
N
N    	/***
N    	 *           __ _____
N    	 *          /_ | ____|
N    	 *       __ _| | |__
N    	 *      / _` | |___ \
N    	 *     | (_| | |___) |
X
N    	 *      \__, |_|____/
N    	 *         | |
N    	 *         |_|
N    	 */
N
N		#ifdef _q15
N				#ifdef ENABLE_CFFT_BR
N
N				CM_PRINTF("\r\n");
X				printf("\r\n");
N				CM_PRINTF("CFFT-q15-BitReverse,");
X				printf("CFFT-q15-BitReverse,");
N				START_CYCLE_TIMER;arm_cfft_q15(&arm_cfft_sR_q15_len16,   &InputData.q15[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cfft_q15(&arm_cfft_sR_q15_len16,   &InputData.q15[0], 0, 1);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cfft_q15(&arm_cfft_sR_q15_len32,   &InputData.q15[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cfft_q15(&arm_cfft_sR_q15_len32,   &InputData.q15[0], 0, 1);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cfft_q15(&arm_cfft_sR_q15_len64,   &InputData.q15[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cfft_q15(&arm_cfft_sR_q15_len64,   &InputData.q15[0], 0, 1);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cfft_q15(&arm_cfft_sR_q15_len128,  &InputData.q15[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cfft_q15(&arm_cfft_sR_q15_len128,  &InputData.q15[0], 0, 1);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cfft_q15(&arm_cfft_sR_q15_len256,  &InputData.q15[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cfft_q15(&arm_cfft_sR_q15_len256,  &InputData.q15[0], 0, 1);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cfft_q15(&arm_cfft_sR_q15_len512,  &InputData.q15[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cfft_q15(&arm_cfft_sR_q15_len512,  &InputData.q15[0], 0, 1);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cfft_q15(&arm_cfft_sR_q15_len1024, &InputData.q15[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cfft_q15(&arm_cfft_sR_q15_len1024, &InputData.q15[0], 0, 1);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cfft_q15(&arm_cfft_sR_q15_len2048, &InputData.q15[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cfft_q15(&arm_cfft_sR_q15_len2048, &InputData.q15[0], 0, 1);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cfft_q31(&arm_cfft_sR_q31_len4096, &InputData.q31[0], 0, 1);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cfft_q31(&arm_cfft_sR_q31_len4096, &InputData.q31[0], 0, 1);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				#endif
N
N				#ifdef ENABLE_CFFT_NBR
N				CM_PRINTF("\r\n");
X				printf("\r\n");
N				CM_PRINTF("CFFT-q15-NoBitReverse,");
X				printf("CFFT-q15-NoBitReverse,");
N				START_CYCLE_TIMER;arm_cfft_q15(&arm_cfft_sR_q15_len16,   &InputData.q15[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cfft_q15(&arm_cfft_sR_q15_len16,   &InputData.q15[0], 0, 0);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cfft_q15(&arm_cfft_sR_q15_len32,   &InputData.q15[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cfft_q15(&arm_cfft_sR_q15_len32,   &InputData.q15[0], 0, 0);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cfft_q15(&arm_cfft_sR_q15_len64,   &InputData.q15[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cfft_q15(&arm_cfft_sR_q15_len64,   &InputData.q15[0], 0, 0);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cfft_q15(&arm_cfft_sR_q15_len128,  &InputData.q15[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cfft_q15(&arm_cfft_sR_q15_len128,  &InputData.q15[0], 0, 0);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cfft_q15(&arm_cfft_sR_q15_len256,  &InputData.q15[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cfft_q15(&arm_cfft_sR_q15_len256,  &InputData.q15[0], 0, 0);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cfft_q15(&arm_cfft_sR_q15_len512,  &InputData.q15[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cfft_q15(&arm_cfft_sR_q15_len512,  &InputData.q15[0], 0, 0);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cfft_q15(&arm_cfft_sR_q15_len1024, &InputData.q15[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cfft_q15(&arm_cfft_sR_q15_len1024, &InputData.q15[0], 0, 0);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cfft_q15(&arm_cfft_sR_q15_len2048, &InputData.q15[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cfft_q15(&arm_cfft_sR_q15_len2048, &InputData.q15[0], 0, 0);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cfft_q31(&arm_cfft_sR_q31_len4096, &InputData.q31[0], 0, 0);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cfft_q31(&arm_cfft_sR_q31_len4096, &InputData.q31[0], 0, 0);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				#endif
N
N				#ifdef ENABLE_RFFT_BR
N				CM_PRINTF("\r\nRFFT-Q15-BitReverse,");
X				printf("\r\nRFFT-Q15-BitReverse,");
N				CM_PRINTF("n/a");COMMA;
X				printf("n/a");printf(",");;
N				arm_rfft_init_q15(&FFT_Inst.rfft_q15,32,0,1);START_CYCLE_TIMER  ;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);REPORT_CYCLE_TIMER;COMMA;
X				arm_rfft_init_q15(&FFT_Inst.rfft_q15,32,0,1);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);  ;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				arm_rfft_init_q15(&FFT_Inst.rfft_q15,64,0,1);START_CYCLE_TIMER  ;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);REPORT_CYCLE_TIMER;COMMA;
X				arm_rfft_init_q15(&FFT_Inst.rfft_q15,64,0,1);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);  ;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				arm_rfft_init_q15(&FFT_Inst.rfft_q15,128,0,1);START_CYCLE_TIMER ;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);REPORT_CYCLE_TIMER;COMMA;
X				arm_rfft_init_q15(&FFT_Inst.rfft_q15,128,0,1);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2); ;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				arm_rfft_init_q15(&FFT_Inst.rfft_q15,256,0,1);START_CYCLE_TIMER ;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);REPORT_CYCLE_TIMER;COMMA;
X				arm_rfft_init_q15(&FFT_Inst.rfft_q15,256,0,1);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2); ;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				arm_rfft_init_q15(&FFT_Inst.rfft_q15,512,0,1);START_CYCLE_TIMER ;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);REPORT_CYCLE_TIMER;COMMA;
X				arm_rfft_init_q15(&FFT_Inst.rfft_q15,512,0,1);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2); ;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				arm_rfft_init_q15(&FFT_Inst.rfft_q15,1024,0,1);START_CYCLE_TIMER;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);REPORT_CYCLE_TIMER;COMMA;
X				arm_rfft_init_q15(&FFT_Inst.rfft_q15,1024,0,1);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				arm_rfft_init_q15(&FFT_Inst.rfft_q15,2048,0,1);START_CYCLE_TIMER;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);REPORT_CYCLE_TIMER;COMMA;
X				arm_rfft_init_q15(&FFT_Inst.rfft_q15,2048,0,1);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				arm_rfft_init_q15(&FFT_Inst.rfft_q15,4096,0,1);START_CYCLE_TIMER;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);REPORT_CYCLE_TIMER;COMMA;
X				arm_rfft_init_q15(&FFT_Inst.rfft_q15,4096,0,1);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				#endif
N
N				#ifdef ENABLE_RFFT_NBR
N				CM_PRINTF("\r\nRFFT-Q15-NoBitReverse,");
X				printf("\r\nRFFT-Q15-NoBitReverse,");
N				CM_PRINTF("n/a");COMMA;
X				printf("n/a");printf(",");;
N				arm_rfft_init_q15(&FFT_Inst.rfft_q15,32,0,0);START_CYCLE_TIMER  ;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);REPORT_CYCLE_TIMER;COMMA;
X				arm_rfft_init_q15(&FFT_Inst.rfft_q15,32,0,0);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);  ;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				arm_rfft_init_q15(&FFT_Inst.rfft_q15,64,0,0);START_CYCLE_TIMER  ;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);REPORT_CYCLE_TIMER;COMMA;
X				arm_rfft_init_q15(&FFT_Inst.rfft_q15,64,0,0);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);  ;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				arm_rfft_init_q15(&FFT_Inst.rfft_q15,128,0,0);START_CYCLE_TIMER ;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);REPORT_CYCLE_TIMER;COMMA;
X				arm_rfft_init_q15(&FFT_Inst.rfft_q15,128,0,0);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2); ;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				arm_rfft_init_q15(&FFT_Inst.rfft_q15,256,0,0);START_CYCLE_TIMER ;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);REPORT_CYCLE_TIMER;COMMA;
X				arm_rfft_init_q15(&FFT_Inst.rfft_q15,256,0,0);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2); ;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				arm_rfft_init_q15(&FFT_Inst.rfft_q15,512,0,0);START_CYCLE_TIMER ;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);REPORT_CYCLE_TIMER;COMMA;
X				arm_rfft_init_q15(&FFT_Inst.rfft_q15,512,0,0);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2); ;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				arm_rfft_init_q15(&FFT_Inst.rfft_q15,1024,0,0);START_CYCLE_TIMER;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);REPORT_CYCLE_TIMER;COMMA;
X				arm_rfft_init_q15(&FFT_Inst.rfft_q15,1024,0,0);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				arm_rfft_init_q15(&FFT_Inst.rfft_q15,2048,0,0);START_CYCLE_TIMER;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);REPORT_CYCLE_TIMER;COMMA;
X				arm_rfft_init_q15(&FFT_Inst.rfft_q15,2048,0,0);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				arm_rfft_init_q15(&FFT_Inst.rfft_q15,4096,0,0);START_CYCLE_TIMER;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);REPORT_CYCLE_TIMER;COMMA;
X				arm_rfft_init_q15(&FFT_Inst.rfft_q15,4096,0,0);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_rfft_q15(&FFT_Inst.rfft_q15,&InputData.q15[0], &OutputData.q15[0]);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				#endif
N
N				#ifdef COMPLEX_MAG
N				CM_PRINTF("\r\n");
X				printf("\r\n");
N				CM_PRINTF("ComplexMag-q15,");
X				printf("ComplexMag-q15,");
N				START_CYCLE_TIMER;arm_cmplx_mag_q15(&InputData.q15[0],&OutputData.q15[0],16);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cmplx_mag_q15(&InputData.q15[0],&OutputData.q15[0],16);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cmplx_mag_q15(&InputData.q15[0],&OutputData.q15[0],32);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cmplx_mag_q15(&InputData.q15[0],&OutputData.q15[0],32);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cmplx_mag_q15(&InputData.q15[0],&OutputData.q15[0],64);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cmplx_mag_q15(&InputData.q15[0],&OutputData.q15[0],64);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cmplx_mag_q15(&InputData.q15[0],&OutputData.q15[0],128);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cmplx_mag_q15(&InputData.q15[0],&OutputData.q15[0],128);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cmplx_mag_q15(&InputData.q15[0],&OutputData.q15[0],256);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cmplx_mag_q15(&InputData.q15[0],&OutputData.q15[0],256);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cmplx_mag_q15(&InputData.q15[0],&OutputData.q15[0],512);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cmplx_mag_q15(&InputData.q15[0],&OutputData.q15[0],512);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cmplx_mag_q15(&InputData.q15[0],&OutputData.q15[0],1024);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cmplx_mag_q15(&InputData.q15[0],&OutputData.q15[0],1024);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cmplx_mag_q15(&InputData.q15[0],&OutputData.q15[0],2048);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cmplx_mag_q15(&InputData.q15[0],&OutputData.q15[0],2048);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cmplx_mag_q15(&InputData.q15[0],&OutputData.q15[0],4096);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cmplx_mag_q15(&InputData.q15[0],&OutputData.q15[0],4096);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				#endif
N
N				#ifdef COMPLEX_MAG_SQUARED
N				CM_PRINTF("\r\n");
X				printf("\r\n");
N				CM_PRINTF("ComplexMagSquared-q15,");
X				printf("ComplexMagSquared-q15,");
N				START_CYCLE_TIMER;arm_cmplx_mag_squared_q15(&InputData.q15[0],&OutputData.q15[0],16);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cmplx_mag_squared_q15(&InputData.q15[0],&OutputData.q15[0],16);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cmplx_mag_squared_q15(&InputData.q15[0],&OutputData.q15[0],32);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cmplx_mag_squared_q15(&InputData.q15[0],&OutputData.q15[0],32);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cmplx_mag_squared_q15(&InputData.q15[0],&OutputData.q15[0],64);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cmplx_mag_squared_q15(&InputData.q15[0],&OutputData.q15[0],64);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cmplx_mag_squared_q15(&InputData.q15[0],&OutputData.q15[0],128);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cmplx_mag_squared_q15(&InputData.q15[0],&OutputData.q15[0],128);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cmplx_mag_squared_q15(&InputData.q15[0],&OutputData.q15[0],256);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cmplx_mag_squared_q15(&InputData.q15[0],&OutputData.q15[0],256);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cmplx_mag_squared_q15(&InputData.q15[0],&OutputData.q15[0],512);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cmplx_mag_squared_q15(&InputData.q15[0],&OutputData.q15[0],512);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cmplx_mag_squared_q15(&InputData.q15[0],&OutputData.q15[0],1024);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cmplx_mag_squared_q15(&InputData.q15[0],&OutputData.q15[0],1024);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cmplx_mag_squared_q15(&InputData.q15[0],&OutputData.q15[0],2048);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cmplx_mag_squared_q15(&InputData.q15[0],&OutputData.q15[0],2048);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_cmplx_mag_squared_q15(&InputData.q15[0],&OutputData.q15[0],4096);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_cmplx_mag_squared_q15(&InputData.q15[0],&OutputData.q15[0],4096);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				#endif
N
N			#ifdef ENABLE_BLOCK_IIR
N				CM_PRINTF("\r\n");
X				printf("\r\n");
N				CM_PRINTF("IIR-q15_df1-1Stage,");
X				printf("IIR-q15_df1-1Stage,");
N
N				arm_biquad_cascade_df1_init_q15(&IIR_Inst.q15_df1,1,&IIR_Coef_q15[0],&IIR_State_q15[0],1);
N
N				START_CYCLE_TIMER;arm_biquad_cascade_df1_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],16);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_biquad_cascade_df1_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],16);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_biquad_cascade_df1_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],32);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_biquad_cascade_df1_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],32);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_biquad_cascade_df1_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],64);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_biquad_cascade_df1_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],64);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_biquad_cascade_df1_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],128);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_biquad_cascade_df1_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],128);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_biquad_cascade_df1_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],256);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_biquad_cascade_df1_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],256);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_biquad_cascade_df1_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],512);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_biquad_cascade_df1_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],512);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_biquad_cascade_df1_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],1024);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_biquad_cascade_df1_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],1024);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_biquad_cascade_df1_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],2048);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_biquad_cascade_df1_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],2048);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_biquad_cascade_df1_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],4096);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_biquad_cascade_df1_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],4096);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N
N
N				CM_PRINTF("\r\n");
X				printf("\r\n");
N				CM_PRINTF("IIR-q15_df1-1Stage-fast,");
X				printf("IIR-q15_df1-1Stage-fast,");
N
N				arm_biquad_cascade_df1_init_q15(&IIR_Inst.q15_df1,1,&IIR_Coef_q15[0],&IIR_State_q15[0],1);
N
N				START_CYCLE_TIMER;arm_biquad_cascade_df1_fast_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],16);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_biquad_cascade_df1_fast_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],16);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_biquad_cascade_df1_fast_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],32);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_biquad_cascade_df1_fast_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],32);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_biquad_cascade_df1_fast_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],64);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_biquad_cascade_df1_fast_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],64);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_biquad_cascade_df1_fast_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],128);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_biquad_cascade_df1_fast_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],128);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_biquad_cascade_df1_fast_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],256);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_biquad_cascade_df1_fast_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],256);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_biquad_cascade_df1_fast_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],512);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_biquad_cascade_df1_fast_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],512);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_biquad_cascade_df1_fast_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],1024);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_biquad_cascade_df1_fast_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],1024);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_biquad_cascade_df1_fast_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],2048);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_biquad_cascade_df1_fast_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],2048);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_biquad_cascade_df1_fast_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],4096);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_biquad_cascade_df1_fast_q15(&IIR_Inst.q15_df1,&InputData.q15[0],&OutputData.q15[0],4096);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N
N			#endif
N
N			#ifdef ENABLE_BLOCK_FIR
N				CM_PRINTF("\r\n");
X				printf("\r\n");
N				CM_PRINTF("FIR-q15_8tap,");
X				printf("FIR-q15_8tap,");
N				arm_fir_init_q15(&FIR_Inst.q15,8,&FIR_Coef_q15[0],&FIR_State.q15[0],2048);
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],16);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],16);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],32);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],32);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],64);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],64);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],128);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],128);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],256);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],256);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],512);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],512);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],1024);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],1024);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],2048);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],2048);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				CM_PRINTF("n/a"); // Not enough memory to do the 4096 case
X				printf("n/a"); 
N
N				CM_PRINTF("\r\n");
X				printf("\r\n");
N				CM_PRINTF("FIR-q15_16tap,");
X				printf("FIR-q15_16tap,");
N
N				arm_fir_init_q15(&FIR_Inst.q15,16,&FIR_Coef_q15[0],&FIR_State.q15[0],2048);
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],16);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],16);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],32);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],32);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],64);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],64);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],128);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],128);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],256);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],256);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],512);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],512);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],1024);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],1024);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],2048);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],2048);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				CM_PRINTF("n/a"); // Not enough memory to do the 4096 case
X				printf("n/a"); 
N
N				CM_PRINTF("\r\n");
X				printf("\r\n");
N				CM_PRINTF("FIR-q15_32tap,");
X				printf("FIR-q15_32tap,");
N
N				arm_fir_init_q15(&FIR_Inst.q15,32,&FIR_Coef_q15[0],&FIR_State.q15[0],2048);
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],16);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],16);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],32);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],32);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],64);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],64);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],128);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],128);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],256);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],256);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],512);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],512);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],1024);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],1024);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				START_CYCLE_TIMER;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],2048);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;arm_fir_q15(&FIR_Inst.q15,&InputData.q15[0],&OutputData.q15[0],2048);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N				CM_PRINTF("n/a"); // Not enough memory to do the 4096 case
X				printf("n/a"); 
N		#endif
N
N	#endif
N
N#endif
N
N
N#ifdef  ENABLE_PER_SAMPLE
N
N        	/***
N        	 *      _____  ______ _____     _____         __  __ _____  _      ______
N        	 *     |  __ \|  ____|  __ \   / ____|  /\   |  \/  |  __ \| |    |  ____|
N        	 *     | |__) | |__  | |__) | | (___   /  \  | \  / | |__) | |    | |__
N        	 *     |  ___/|  __| |  _  /   \___ \ / /\ \ | |\/| |  ___/| |    |  __|
N        	 *     | |    | |____| | \ \   ____) / ____ \| |  | | |    | |____| |____
N        	 *     |_|    |______|_|  \_\ |_____/_/    \_\_|  |_|_|    |______|______|
N        	 *
N        	 *
N        	 */
N
N      	CM_PRINTF("\r\n\r\n\r\nSample by Sample Tests");
X      	printf("\r\n\r\n\r\nSample by Sample Tests");
N      	CM_PRINTF("\r\n---------------------------------------------------------------\r\n");
X      	printf("\r\n---------------------------------------------------------------\r\n");
N        CM_PRINTF("\r\nIteration,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15\r\n");
X        printf("\r\nIteration,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15\r\n");
N
N		#ifdef _f32
S
S			CM_PRINTF("\r\n");
S			CM_PRINTF("PID-f32,");
S
S			PID_Inst.f32.Kp = 0.5;
S			PID_Inst.f32.Ki = 0.1;
S			PID_Inst.f32.Kd = 0.05;
S			arm_pid_init_f32(&PID_Inst.f32,1);
S
S			for(i=0;i<16;i++)
S			{
S				START_CYCLE_TIMER;r=arm_pid_f32(&PID_Inst.f32,InputData.f32[i]);REPORT_CYCLE_TIMER;COMMA;
S			}
S
S			CM_PRINTF("\r\n");
S			CM_PRINTF("IIR-f31_64_df1-1Stage,");
S			arm_biquad_cascade_df1_init_f32(&IIR_Inst.f32_df1,1,(float_t *)&IIR_Coef_f32[0],(float_t *)&IIR_State_f32[0]);
S
S			for(i=0;i<15;i++)
S			{
S				START_CYCLE_TIMER;arm_biquad_cascade_df1_f32(&IIR_Inst.f32_df1,&InputData.f32[0],&OutputData.f32[0],1);REPORT_CYCLE_TIMER;COMMA;
S			}
S
S			CM_PRINTF("\r\nE-IIR-f32_df1-1Stage,");
S
S			E_IIRf.Coef.a[0] = -0.4;
S			E_IIRf.Coef.a[1] = -0.4;
S			E_IIRf.Coef.b[0] = -0.1;
S			E_IIRf.Coef.b[1] = -0.2;
S			E_IIRf.Coef.b[2] = -0.3;
S
S			Init_f32_IIR(&E_IIRf);
S
S			for(i=0;i<16;i++)
S			{
S				START_CYCLE_TIMER;Compute_f32_IIR(&E_IIRf,InputData.f32[0],&OutputData.f32[0]);REPORT_CYCLE_TIMER;COMMA;
S			}
S
N		#endif
N
N
N
N
N		#ifdef _q31
S
S			CM_PRINTF("\r\n");
S			CM_PRINTF("PID-q31,");
S
S			PID_Inst.q31.Kp = (q31_t)(0.5 * 0x7fffffff);
S			PID_Inst.q31.Ki = (q31_t)(0.1 * 0x7fffffff);
S			PID_Inst.q31.Kd = (q31_t)(0.05 * 0x7fffffff);
S			arm_pid_init_q31(&PID_Inst.q31,1);
S
S			for(i=0;i<15;i++)
S			{
S				START_CYCLE_TIMER;r=arm_pid_q31(&PID_Inst.q31,InputData.q31[i]);REPORT_CYCLE_TIMER;COMMA;
S				r*=2;//To Get rid of the warning
S			}
S
S			CM_PRINTF("\r\n");
S			CM_PRINTF("IIR-q32_64_df1-1Stage,");
S			arm_biquad_cas_df1_32x64_init_q31(&IIR_Inst.q31_64_df1,1,&IIR_Coef_q31[0],&IIR_State_q63[0],1);
S
S			for(i=0;i<15;i++)
S			{
S				START_CYCLE_TIMER;arm_biquad_cas_df1_32x64_q31(&IIR_Inst.q31_64_df1,&InputData.q31[0],&OutputData.q31[0],1);REPORT_CYCLE_TIMER;COMMA;
S			}
S
S			CM_PRINTF("\r\n");
S			CM_PRINTF("E-IIR-q31_64_df1-1Stage,");
S
S			E_IIR.Coef.PostShift = 1;
S			E_IIR.Coef.a[0] = -0.4;
S			E_IIR.Coef.a[1] = -0.4;
S			E_IIR.Coef.b[0] = -0.1;
S			E_IIR.Coef.b[1] = -0.2;
S			E_IIR.Coef.b[2] = -0.3;
S			Init_q31_t_IIR(&E_IIR);
S
S			for(i=0;i<15;i++)
S			{
S				START_CYCLE_TIMER;Compute_q31_t_IIR(&E_IIR,InputData.q31[0],&OutputData.q31[0]);REPORT_CYCLE_TIMER;COMMA;
S			}
S
N		#endif
N
N
N		#ifdef _q15
N
N			CM_PRINTF("\r\n");
X			printf("\r\n");
N			CM_PRINTF("PID-q15,");
X			printf("PID-q15,");
N
N			PID_Inst.q15.Kp = (q31_t)(0.5 * 0x7fff);
N			PID_Inst.q15.Ki = (q31_t)(0.1 * 0x7fff);
N			PID_Inst.q15.Kd = (q31_t)(0.05 * 0x7fff);
N			arm_pid_init_q15(&PID_Inst.q15,1);
N
N			for(i=0;i<15;i++)
N			{
N				START_CYCLE_TIMER;r=arm_pid_q15(&PID_Inst.q15,InputData.q15[i]);REPORT_CYCLE_TIMER;COMMA;
X				((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 0) | (1UL << 2);;r=arm_pid_q15(&PID_Inst.q15,InputData.q15[i]);((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2); CycleTimer = ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL; CycleTimer = 0x1000000 - CycleTimer;printf("%i",CycleTimer - CycleOffset);printf(",");;
N			}
N
N			#endif
N
N	CM_PRINTF("\r\n");
X	printf("\r\n");
N#endif
N
N
N    while(1)
N    {
N
N    }
N}
