; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_fir_f32.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_fir_f32.c]
                          THUMB

                          AREA ||i.arm_fir_f32||, CODE, READONLY, ALIGN=2

                  arm_fir_f32 PROC
;;;564    
;;;565    void arm_fir_f32(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;566    const arm_fir_instance_f32 * S,
;;;567    float32_t * pSrc,
;;;568    float32_t * pDst,
;;;569    uint32_t blockSize)
;;;570    {
000004  ed2d8b0a          VPUSH    {d8-d12}
;;;571       float32_t *pState = S->pState;                 /* State pointer */
000008  6844              LDR      r4,[r0,#4]
;;;572       float32_t *pCoeffs = S->pCoeffs;               /* Coefficient pointer */
00000a  f8d0a008          LDR      r10,[r0,#8]
;;;573       float32_t *pStateCurnt;                        /* Points to the current sample of the state */
;;;574       float32_t *px, *pb;                            /* Temporary pointers for state and coefficient buffers */
;;;575       float32_t acc0, acc1, acc2, acc3, acc4, acc5, acc6, acc7;     /* Accumulators */
;;;576       float32_t x0, x1, x2, x3, x4, x5, x6, x7, c0;  /* Temporary variables to hold state and coefficient values */
;;;577       uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
00000e  f8b08000          LDRH     r8,[r0,#0]
;;;578       uint32_t i, tapCnt, blkCnt;                    /* Loop counters */
;;;579       float32_t p0,p1,p2,p3,p4,p5,p6,p7;             /* Temporary product values */
;;;580    
;;;581       /* S->pState points to state array which contains previous frame (numTaps - 1) samples */
;;;582       /* pStateCurnt points to the location where the new input data should be written */
;;;583       pStateCurnt = &(S->pState[(numTaps - 1u)]);
000012  f1a80b01          SUB      r11,r8,#1
000016  eb04078b          ADD      r7,r4,r11,LSL #2
;;;584    
;;;585       /* Apply loop unrolling and compute 8 output values simultaneously.  
;;;586        * The variables acc0 ... acc7 hold output values that are being computed:  
;;;587        *  
;;;588        *    acc0 =  b[numTaps-1] * x[n-numTaps-1] + b[numTaps-2] * x[n-numTaps-2] + b[numTaps-3] * x[n-numTaps-3] +...+ b[0] * x[0]  
;;;589        *    acc1 =  b[numTaps-1] * x[n-numTaps] +   b[numTaps-2] * x[n-numTaps-1] + b[numTaps-3] * x[n-numTaps-2] +...+ b[0] * x[1]  
;;;590        *    acc2 =  b[numTaps-1] * x[n-numTaps+1] + b[numTaps-2] * x[n-numTaps] +   b[numTaps-3] * x[n-numTaps-1] +...+ b[0] * x[2]  
;;;591        *    acc3 =  b[numTaps-1] * x[n-numTaps+2] + b[numTaps-2] * x[n-numTaps+1] + b[numTaps-3] * x[n-numTaps]   +...+ b[0] * x[3]  
;;;592        */
;;;593       blkCnt = blockSize >> 3;
00001a  ea4f09d3          LSR      r9,r3,#3
;;;594    
;;;595       /* First part of the processing with loop unrolling.  Compute 8 outputs at a time.  
;;;596       ** a second loop below computes the remaining 1 to 7 samples. */
;;;597       while(blkCnt > 0u)
;;;598       {
;;;599          /* Copy four new input samples into the state buffer */
;;;600          *pStateCurnt++ = *pSrc++;
;;;601          *pStateCurnt++ = *pSrc++;
;;;602          *pStateCurnt++ = *pSrc++;
;;;603          *pStateCurnt++ = *pSrc++;
;;;604    
;;;605          /* Set all accumulators to zero */
;;;606          acc0 = 0.0f;
00001e  eddfaafa          VLDR     s21,|L1.1032|
000022  e1b5              B        |L1.912|
                  |L1.36|
000024  ecb10a01          VLDM     r1!,{s0}              ;600
000028  eca70a01          VSTM     r7!,{s0}              ;600
00002c  ecb10a01          VLDM     r1!,{s0}              ;601
000030  eca70a01          VSTM     r7!,{s0}              ;601
000034  ecb10a01          VLDM     r1!,{s0}              ;602
000038  eca70a01          VSTM     r7!,{s0}              ;602
00003c  ecb10a01          VLDM     r1!,{s0}              ;603
000040  eca70a01          VSTM     r7!,{s0}              ;603
000044  eef04a6a          VMOV.F32 s9,s21
;;;607          acc1 = 0.0f;
000048  eeb05a64          VMOV.F32 s10,s9
;;;608          acc2 = 0.0f;
00004c  eef05a64          VMOV.F32 s11,s9
;;;609          acc3 = 0.0f;
000050  eeb06a64          VMOV.F32 s12,s9
;;;610          acc4 = 0.0f;
000054  eef06a64          VMOV.F32 s13,s9
;;;611          acc5 = 0.0f;
000058  eeb07a64          VMOV.F32 s14,s9
;;;612          acc6 = 0.0f;
00005c  eef07a64          VMOV.F32 s15,s9
;;;613          acc7 = 0.0f;		
000060  eeb08a64          VMOV.F32 s16,s9
;;;614    
;;;615          /* Initialize state pointer */
;;;616          px = pState;
;;;617    
;;;618          /* Initialize coeff pointer */
;;;619          pb = (pCoeffs);		
000064  4656              MOV      r6,r10
;;;620       
;;;621          /* This is separated from the others to avoid 
;;;622           * a call to __aeabi_memmove which would be slower
;;;623           */
;;;624          *pStateCurnt++ = *pSrc++;
000066  ecb10a01          VLDM     r1!,{s0}
00006a  eca70a01          VSTM     r7!,{s0}
;;;625          *pStateCurnt++ = *pSrc++;
00006e  ecb10a01          VLDM     r1!,{s0}
000072  eca70a01          VSTM     r7!,{s0}
;;;626          *pStateCurnt++ = *pSrc++;
000076  ecb10a01          VLDM     r1!,{s0}
00007a  eca70a01          VSTM     r7!,{s0}
;;;627          *pStateCurnt++ = *pSrc++;
00007e  ecb10a01          VLDM     r1!,{s0}
000082  eca70a01          VSTM     r7!,{s0}
;;;628    
;;;629          /* Read the first seven samples from the state buffer:  x[n-numTaps], x[n-numTaps-1], x[n-numTaps-2] */
;;;630          x0 = *px++;
000086  ed943a00          VLDR     s6,[r4,#0]
00008a  1d25              ADDS     r5,r4,#4
;;;631          x1 = *px++;
00008c  ecf50a01          VLDM     r5!,{s1}
;;;632          x2 = *px++;
000090  ecb51a01          VLDM     r5!,{s2}
;;;633          x3 = *px++;
000094  ecf51a01          VLDM     r5!,{s3}
;;;634          x4 = *px++;
000098  ecb52a01          VLDM     r5!,{s4}
;;;635          x5 = *px++;
00009c  ecf52a01          VLDM     r5!,{s5}
;;;636          x6 = *px++;
0000a0  ecb50a01          VLDM     r5!,{s0}
;;;637    
;;;638          /* Loop unrolling.  Process 8 taps at a time. */
;;;639          tapCnt = numTaps >> 3u;
0000a4  ea4f0cd8          LSR      r12,r8,#3
;;;640          
;;;641          /* Loop over the number of taps.  Unroll by a factor of 8.  
;;;642           ** Repeat until we've computed numTaps-8 coefficients. */
;;;643          while(tapCnt > 0u)
0000a8  e121              B        |L1.750|
                  |L1.170|
;;;644          {
;;;645             /* Read the b[numTaps-1] coefficient */
;;;646             c0 = *(pb++);
0000aa  ecb64a01          VLDM     r6!,{s8}
;;;647    
;;;648             /* Read x[n-numTaps-3] sample */
;;;649             x7 = *(px++);
0000ae  ecf53a01          VLDM     r5!,{s7}
;;;650    
;;;651             /* acc0 +=  b[numTaps-1] * x[n-numTaps] */
;;;652             p0 = x0 * c0;
0000b2  ee63ca04          VMUL.F32 s25,s6,s8
;;;653    
;;;654             /* acc1 +=  b[numTaps-1] * x[n-numTaps-1] */
;;;655             p1 = x1 * c0;
0000b6  ee20ba84          VMUL.F32 s22,s1,s8
;;;656    
;;;657             /* acc2 +=  b[numTaps-1] * x[n-numTaps-2] */
;;;658             p2 = x2 * c0;
0000ba  ee21ca04          VMUL.F32 s24,s2,s8
;;;659    
;;;660             /* acc3 +=  b[numTaps-1] * x[n-numTaps-3] */
;;;661             p3 = x3 * c0;
0000be  ee61ba84          VMUL.F32 s23,s3,s8
;;;662    
;;;663             /* acc4 +=  b[numTaps-1] * x[n-numTaps-4] */
;;;664             p4 = x4 * c0;
0000c2  ee229a04          VMUL.F32 s18,s4,s8
;;;665    
;;;666             /* acc1 +=  b[numTaps-1] * x[n-numTaps-5] */
;;;667             p5 = x5 * c0;
0000c6  ee22aa84          VMUL.F32 s20,s5,s8
;;;668    
;;;669             /* acc2 +=  b[numTaps-1] * x[n-numTaps-6] */
;;;670             p6 = x6 * c0;
0000ca  ee608a04          VMUL.F32 s17,s0,s8
;;;671    
;;;672             /* acc3 +=  b[numTaps-1] * x[n-numTaps-7] */
;;;673             p7 = x7 * c0;
0000ce  ee639a84          VMUL.F32 s19,s7,s8
;;;674             
;;;675             /* Read the b[numTaps-2] coefficient */
;;;676             c0 = *(pb++);
0000d2  ecb64a01          VLDM     r6!,{s8}
;;;677    
;;;678             /* Read x[n-numTaps-4] sample */
;;;679             x0 = *(px++);
0000d6  ecb53a01          VLDM     r5!,{s6}
;;;680             
;;;681             acc0 += p0;
0000da  ee744aac          VADD.F32 s9,s9,s25
;;;682             acc1 += p1;
0000de  ee35ba0b          VADD.F32 s22,s10,s22
;;;683             acc2 += p2;
0000e2  ee755a8c          VADD.F32 s11,s11,s24
;;;684             acc3 += p3;
0000e6  ee365a2b          VADD.F32 s10,s12,s23
;;;685             acc4 += p4;
0000ea  ee366a89          VADD.F32 s12,s13,s18
;;;686             acc5 += p5;
0000ee  ee776a0a          VADD.F32 s13,s14,s20
;;;687             acc6 += p6;
0000f2  ee377aa8          VADD.F32 s14,s15,s17
;;;688             acc7 += p7;
0000f6  ee787a29          VADD.F32 s15,s16,s19
;;;689    
;;;690    
;;;691             /* Perform the multiply-accumulate */
;;;692             p0 = x1 * c0;
0000fa  ee60ca84          VMUL.F32 s25,s1,s8
;;;693             p1 = x2 * c0;   
0000fe  ee21ca04          VMUL.F32 s24,s2,s8
;;;694             p2 = x3 * c0;   
000102  ee21aa84          VMUL.F32 s20,s3,s8
;;;695             p3 = x4 * c0;   
000106  ee228a04          VMUL.F32 s16,s4,s8
;;;696             p4 = x5 * c0;   
00010a  ee628a84          VMUL.F32 s17,s5,s8
;;;697             p5 = x6 * c0;   
00010e  ee209a04          VMUL.F32 s18,s0,s8
;;;698             p6 = x7 * c0;   
000112  ee639a84          VMUL.F32 s19,s7,s8
;;;699             p7 = x0 * c0;   
000116  ee63ba04          VMUL.F32 s23,s6,s8
;;;700             
;;;701             /* Read the b[numTaps-3] coefficient */
;;;702             c0 = *(pb++);
00011a  ecb64a01          VLDM     r6!,{s8}
;;;703    
;;;704             /* Read x[n-numTaps-5] sample */
;;;705             x1 = *(px++);
00011e  ecf50a01          VLDM     r5!,{s1}
;;;706             
;;;707             acc0 += p0;
000122  ee744aac          VADD.F32 s9,s9,s25
;;;708             acc1 += p1;
000126  ee3bba0c          VADD.F32 s22,s22,s24
;;;709             acc2 += p2;
00012a  ee755a8a          VADD.F32 s11,s11,s20
;;;710             acc3 += p3;
00012e  ee355a08          VADD.F32 s10,s10,s16
;;;711             acc4 += p4;
000132  ee366a28          VADD.F32 s12,s12,s17
;;;712             acc5 += p5;
000136  ee766a89          VADD.F32 s13,s13,s18
;;;713             acc6 += p6;
00013a  ee377a29          VADD.F32 s14,s14,s19
;;;714             acc7 += p7;
00013e  ee777aab          VADD.F32 s15,s15,s23
;;;715    
;;;716             /* Perform the multiply-accumulates */      
;;;717             p0 = x2 * c0;
000142  ee61ca04          VMUL.F32 s25,s2,s8
;;;718             p1 = x3 * c0;   
000146  ee21ca84          VMUL.F32 s24,s3,s8
;;;719             p2 = x4 * c0;   
00014a  ee628a04          VMUL.F32 s17,s4,s8
;;;720             p3 = x5 * c0;   
00014e  ee229a84          VMUL.F32 s18,s5,s8
;;;721             p4 = x6 * c0;   
000152  ee208a04          VMUL.F32 s16,s0,s8
;;;722             p5 = x7 * c0;   
000156  ee639a84          VMUL.F32 s19,s7,s8
;;;723             p6 = x0 * c0;   
00015a  ee23aa04          VMUL.F32 s20,s6,s8
;;;724             p7 = x1 * c0;   
00015e  ee60ba84          VMUL.F32 s23,s1,s8
;;;725    
;;;726             /* Read the b[numTaps-4] coefficient */
;;;727             c0 = *(pb++);
000162  ecb64a01          VLDM     r6!,{s8}
;;;728    
;;;729             /* Read x[n-numTaps-6] sample */
;;;730             x2 = *(px++);
000166  ecb51a01          VLDM     r5!,{s2}
;;;731             
;;;732             acc0 += p0;
00016a  ee744aac          VADD.F32 s9,s9,s25
;;;733             acc1 += p1;
00016e  ee3bba0c          VADD.F32 s22,s22,s24
;;;734             acc2 += p2;
000172  ee755aa8          VADD.F32 s11,s11,s17
;;;735             acc3 += p3;
000176  ee355a09          VADD.F32 s10,s10,s18
;;;736             acc4 += p4;
00017a  ee366a08          VADD.F32 s12,s12,s16
;;;737             acc5 += p5;
00017e  ee766aa9          VADD.F32 s13,s13,s19
;;;738             acc6 += p6;
000182  ee377a0a          VADD.F32 s14,s14,s20
;;;739             acc7 += p7;
000186  ee777aab          VADD.F32 s15,s15,s23
;;;740    
;;;741             /* Perform the multiply-accumulates */      
;;;742             p0 = x3 * c0;
00018a  ee61ca84          VMUL.F32 s25,s3,s8
;;;743             p1 = x4 * c0;   
00018e  ee22ca04          VMUL.F32 s24,s4,s8
;;;744             p2 = x5 * c0;   
000192  ee628a84          VMUL.F32 s17,s5,s8
;;;745             p3 = x6 * c0;   
000196  ee208a04          VMUL.F32 s16,s0,s8
;;;746             p4 = x7 * c0;   
00019a  ee239a84          VMUL.F32 s18,s7,s8
;;;747             p5 = x0 * c0;   
00019e  ee639a04          VMUL.F32 s19,s6,s8
;;;748             p6 = x1 * c0;   
0001a2  ee20aa84          VMUL.F32 s20,s1,s8
;;;749             p7 = x2 * c0;   
0001a6  ee61ba04          VMUL.F32 s23,s2,s8
;;;750    
;;;751             /* Read the b[numTaps-4] coefficient */
;;;752             c0 = *(pb++);
0001aa  ecb64a01          VLDM     r6!,{s8}
;;;753    
;;;754             /* Read x[n-numTaps-6] sample */
;;;755             x3 = *(px++);
0001ae  ecf51a01          VLDM     r5!,{s3}
;;;756             
;;;757             acc0 += p0;
0001b2  ee744aac          VADD.F32 s9,s9,s25
;;;758             acc1 += p1;
0001b6  ee3bba0c          VADD.F32 s22,s22,s24
;;;759             acc2 += p2;
0001ba  ee755aa8          VADD.F32 s11,s11,s17
;;;760             acc3 += p3;
0001be  ee355a08          VADD.F32 s10,s10,s16
;;;761             acc4 += p4;
0001c2  ee366a09          VADD.F32 s12,s12,s18
;;;762             acc5 += p5;
0001c6  ee766aa9          VADD.F32 s13,s13,s19
;;;763             acc6 += p6;
0001ca  ee377a0a          VADD.F32 s14,s14,s20
;;;764             acc7 += p7;
0001ce  ee777aab          VADD.F32 s15,s15,s23
;;;765    
;;;766             /* Perform the multiply-accumulates */      
;;;767             p0 = x4 * c0;
0001d2  ee62ca04          VMUL.F32 s25,s4,s8
;;;768             p1 = x5 * c0;   
0001d6  ee22ca84          VMUL.F32 s24,s5,s8
;;;769             p2 = x6 * c0;   
0001da  ee209a04          VMUL.F32 s18,s0,s8
;;;770             p3 = x7 * c0;   
0001de  ee238a84          VMUL.F32 s16,s7,s8
;;;771             p4 = x0 * c0;   
0001e2  ee638a04          VMUL.F32 s17,s6,s8
;;;772             p5 = x1 * c0;   
0001e6  ee609a84          VMUL.F32 s19,s1,s8
;;;773             p6 = x2 * c0;   
0001ea  ee21aa04          VMUL.F32 s20,s2,s8
;;;774             p7 = x3 * c0;   
0001ee  ee61ba84          VMUL.F32 s23,s3,s8
;;;775    
;;;776             /* Read the b[numTaps-4] coefficient */
;;;777             c0 = *(pb++);
0001f2  ecb64a01          VLDM     r6!,{s8}
;;;778    
;;;779             /* Read x[n-numTaps-6] sample */
;;;780             x4 = *(px++);
0001f6  ecb52a01          VLDM     r5!,{s4}
;;;781             
;;;782             acc0 += p0;
0001fa  ee744aac          VADD.F32 s9,s9,s25
;;;783             acc1 += p1;
0001fe  ee3bba0c          VADD.F32 s22,s22,s24
;;;784             acc2 += p2;
000202  ee755a89          VADD.F32 s11,s11,s18
;;;785             acc3 += p3;
000206  ee355a08          VADD.F32 s10,s10,s16
;;;786             acc4 += p4;
00020a  ee366a28          VADD.F32 s12,s12,s17
;;;787             acc5 += p5;
00020e  ee766aa9          VADD.F32 s13,s13,s19
;;;788             acc6 += p6;
000212  ee377a0a          VADD.F32 s14,s14,s20
;;;789             acc7 += p7;
000216  ee777aab          VADD.F32 s15,s15,s23
;;;790    
;;;791             /* Perform the multiply-accumulates */      
;;;792             p0 = x5 * c0;
00021a  ee62ca84          VMUL.F32 s25,s5,s8
;;;793             p1 = x6 * c0;   
00021e  ee20ca04          VMUL.F32 s24,s0,s8
;;;794             p2 = x7 * c0;   
000222  ee239a84          VMUL.F32 s18,s7,s8
;;;795             p3 = x0 * c0;   
000226  ee639a04          VMUL.F32 s19,s6,s8
;;;796             p4 = x1 * c0;   
00022a  ee20aa84          VMUL.F32 s20,s1,s8
;;;797             p5 = x2 * c0;   
00022e  ee218a04          VMUL.F32 s16,s2,s8
;;;798             p6 = x3 * c0;   
000232  ee618a84          VMUL.F32 s17,s3,s8
;;;799             p7 = x4 * c0;   
000236  ee62ba04          VMUL.F32 s23,s4,s8
;;;800    
;;;801             /* Read the b[numTaps-4] coefficient */
;;;802             c0 = *(pb++);
00023a  ecb64a01          VLDM     r6!,{s8}
;;;803    
;;;804             /* Read x[n-numTaps-6] sample */
;;;805             x5 = *(px++);
00023e  ecf52a01          VLDM     r5!,{s5}
;;;806             
;;;807             acc0 += p0;
000242  ee744aac          VADD.F32 s9,s9,s25
;;;808             acc1 += p1;
000246  ee3bba0c          VADD.F32 s22,s22,s24
;;;809             acc2 += p2;
00024a  ee755a89          VADD.F32 s11,s11,s18
;;;810             acc3 += p3;
00024e  ee355a29          VADD.F32 s10,s10,s19
;;;811             acc4 += p4;
000252  ee366a0a          VADD.F32 s12,s12,s20
;;;812             acc5 += p5;
000256  ee766a88          VADD.F32 s13,s13,s16
;;;813             acc6 += p6;
00025a  ee377a28          VADD.F32 s14,s14,s17
;;;814             acc7 += p7;
00025e  ee777aab          VADD.F32 s15,s15,s23
;;;815    
;;;816             /* Perform the multiply-accumulates */      
;;;817             p0 = x6 * c0;
000262  ee60ca04          VMUL.F32 s25,s0,s8
;;;818             p1 = x7 * c0;   
000266  ee23ca84          VMUL.F32 s24,s7,s8
;;;819             p2 = x0 * c0;   
00026a  ee638a04          VMUL.F32 s17,s6,s8
;;;820             p3 = x1 * c0;   
00026e  ee208a84          VMUL.F32 s16,s1,s8
;;;821             p4 = x2 * c0;   
000272  ee219a04          VMUL.F32 s18,s2,s8
;;;822             p5 = x3 * c0;   
000276  ee619a84          VMUL.F32 s19,s3,s8
;;;823             p6 = x4 * c0;   
00027a  ee22aa04          VMUL.F32 s20,s4,s8
;;;824             p7 = x5 * c0;   
00027e  ee62ba84          VMUL.F32 s23,s5,s8
;;;825    
;;;826             /* Read the b[numTaps-4] coefficient */
;;;827             c0 = *(pb++);
000282  ecb64a01          VLDM     r6!,{s8}
;;;828    
;;;829             /* Read x[n-numTaps-6] sample */
;;;830             x6 = *(px++);
000286  ecb50a01          VLDM     r5!,{s0}
;;;831             
;;;832             acc0 += p0;
00028a  ee744aac          VADD.F32 s9,s9,s25
;;;833             acc1 += p1;
00028e  ee3bba0c          VADD.F32 s22,s22,s24
;;;834             acc2 += p2;
000292  ee755aa8          VADD.F32 s11,s11,s17
;;;835             acc3 += p3;
000296  ee358a08          VADD.F32 s16,s10,s16
;;;836             acc4 += p4;
00029a  ee768a09          VADD.F32 s17,s12,s18
;;;837             acc5 += p5;
00029e  ee369aa9          VADD.F32 s18,s13,s19
;;;838             acc6 += p6;
0002a2  ee37aa0a          VADD.F32 s20,s14,s20
;;;839             acc7 += p7;
0002a6  ee779aab          VADD.F32 s19,s15,s23
;;;840    
;;;841             /* Perform the multiply-accumulates */      
;;;842             p0 = x7 * c0;
0002aa  ee63ba84          VMUL.F32 s23,s7,s8
;;;843             p1 = x0 * c0;   
0002ae  ee235a04          VMUL.F32 s10,s6,s8
;;;844             p2 = x1 * c0;   
0002b2  ee607a84          VMUL.F32 s15,s1,s8
;;;845             p3 = x2 * c0;   
0002b6  ee216a04          VMUL.F32 s12,s2,s8
;;;846             p4 = x3 * c0;   
0002ba  ee616a84          VMUL.F32 s13,s3,s8
;;;847             p5 = x4 * c0;   
0002be  ee227a04          VMUL.F32 s14,s4,s8
;;;848             p6 = x5 * c0;   
0002c2  ee623a84          VMUL.F32 s7,s5,s8
;;;849             p7 = x6 * c0;   
0002c6  ee204a04          VMUL.F32 s8,s0,s8
;;;850    
;;;851             tapCnt--;
0002ca  f1ac0c01          SUB      r12,r12,#1
;;;852             
;;;853             acc0 += p0;
0002ce  ee744aab          VADD.F32 s9,s9,s23
;;;854             acc1 += p1;
0002d2  ee3b5a05          VADD.F32 s10,s22,s10
;;;855             acc2 += p2;
0002d6  ee755aa7          VADD.F32 s11,s11,s15
;;;856             acc3 += p3;
0002da  ee386a06          VADD.F32 s12,s16,s12
;;;857             acc4 += p4;
0002de  ee786aa6          VADD.F32 s13,s17,s13
;;;858             acc5 += p5;
0002e2  ee397a07          VADD.F32 s14,s18,s14
;;;859             acc6 += p6;
0002e6  ee7a7a23          VADD.F32 s15,s20,s7
;;;860             acc7 += p7;
0002ea  ee398a84          VADD.F32 s16,s19,s8
                  |L1.750|
0002ee  f1bc0f00          CMP      r12,#0                ;643
0002f2  f47faeda          BNE      |L1.170|
;;;861          }
;;;862    
;;;863          /* If the filter length is not a multiple of 8, compute the remaining filter taps */
;;;864          tapCnt = numTaps % 0x8u;
0002f6  f0080c07          AND      r12,r8,#7
;;;865    
;;;866          while(tapCnt > 0u)
0002fa  e033              B        |L1.868|
                  |L1.764|
;;;867          {
;;;868             /* Read coefficients */
;;;869             c0 = *(pb++);
0002fc  ecf63a01          VLDM     r6!,{s7}
;;;870    
;;;871             /* Fetch 1 state variable */
;;;872             x7 = *(px++);
000300  ecb54a01          VLDM     r5!,{s8}
;;;873    
;;;874             /* Perform the multiply-accumulates */      
;;;875             p0 = x0 * c0;
000304  ee638a23          VMUL.F32 s17,s6,s7
;;;876             p1 = x1 * c0;   
000308  ee209aa3          VMUL.F32 s18,s1,s7
;;;877             p2 = x2 * c0;   
00030c  ee619a23          VMUL.F32 s19,s2,s7
;;;878             p3 = x3 * c0;   
000310  ee21aaa3          VMUL.F32 s20,s3,s7
;;;879             p4 = x4 * c0;   
000314  ee22ba23          VMUL.F32 s22,s4,s7
;;;880             p5 = x5 * c0;   
000318  ee62baa3          VMUL.F32 s23,s5,s7
;;;881             p6 = x6 * c0;   
00031c  ee20ca23          VMUL.F32 s24,s0,s7
;;;882             p7 = x7 * c0;   
000320  ee643a23          VMUL.F32 s7,s8,s7
;;;883    
;;;884             /* Reuse the present sample states for next sample */
;;;885             x0 = x1;
000324  eeb03a60          VMOV.F32 s6,s1
;;;886             x1 = x2;
000328  eef00a41          VMOV.F32 s1,s2
;;;887             x2 = x3;
00032c  eeb01a61          VMOV.F32 s2,s3
;;;888             x3 = x4;
000330  eef01a42          VMOV.F32 s3,s4
;;;889             x4 = x5;
000334  eeb02a62          VMOV.F32 s4,s5
;;;890             x5 = x6;
000338  eef02a40          VMOV.F32 s5,s0
;;;891             x6 = x7;
00033c  eeb00a44          VMOV.F32 s0,s8
;;;892             
;;;893             acc0 += p0;
000340  ee744aa8          VADD.F32 s9,s9,s17
;;;894             acc1 += p1;
000344  ee355a09          VADD.F32 s10,s10,s18
;;;895             acc2 += p2;
000348  ee755aa9          VADD.F32 s11,s11,s19
;;;896             acc3 += p3;
00034c  ee366a0a          VADD.F32 s12,s12,s20
;;;897             acc4 += p4;
000350  ee766a8b          VADD.F32 s13,s13,s22
;;;898             acc5 += p5;
000354  ee377a2b          VADD.F32 s14,s14,s23
;;;899             acc6 += p6;
000358  ee777a8c          VADD.F32 s15,s15,s24
;;;900             acc7 += p7;
00035c  ee388a23          VADD.F32 s16,s16,s7
;;;901    
;;;902             /* Decrement the loop counter */
;;;903             tapCnt--;
000360  f1ac0c01          SUB      r12,r12,#1
                  |L1.868|
000364  f1bc0f00          CMP      r12,#0                ;866
000368  d1c8              BNE      |L1.764|
;;;904          }
;;;905    
;;;906          /* Advance the state pointer by 8 to process the next group of 8 samples */
;;;907          pState = pState + 8;
00036a  3420              ADDS     r4,r4,#0x20
;;;908    
;;;909          /* The results in the 8 accumulators, store in the destination buffer. */
;;;910          *pDst++ = acc0;
00036c  ece24a01          VSTM     r2!,{s9}
;;;911          *pDst++ = acc1;
000370  eca25a01          VSTM     r2!,{s10}
;;;912          *pDst++ = acc2;
000374  ece25a01          VSTM     r2!,{s11}
;;;913          *pDst++ = acc3;
000378  eca26a01          VSTM     r2!,{s12}
;;;914          *pDst++ = acc4;
00037c  ece26a01          VSTM     r2!,{s13}
;;;915          *pDst++ = acc5;
000380  eca27a01          VSTM     r2!,{s14}
;;;916          *pDst++ = acc6;
000384  ece27a01          VSTM     r2!,{s15}
;;;917          *pDst++ = acc7;
000388  eca28a01          VSTM     r2!,{s16}
;;;918    
;;;919          blkCnt--;
00038c  f1a90901          SUB      r9,r9,#1
                  |L1.912|
000390  f1b90f00          CMP      r9,#0                 ;597
000394  f47fae46          BNE      |L1.36|
;;;920       }
;;;921    
;;;922       /* If the blockSize is not a multiple of 8, compute any remaining output samples here.  
;;;923       ** No loop unrolling is used. */
;;;924       blkCnt = blockSize % 0x8u;
000398  f0030c07          AND      r12,r3,#7
;;;925    
;;;926       while(blkCnt > 0u)
00039c  e016              B        |L1.972|
                  |L1.926|
;;;927       {
;;;928          /* Copy one sample at a time into state buffer */
;;;929          *pStateCurnt++ = *pSrc++;
00039e  ecb10a01          VLDM     r1!,{s0}
0003a2  eca70a01          VSTM     r7!,{s0}
;;;930    
;;;931          /* Set the accumulator to zero */
;;;932          acc0 = 0.0f;
0003a6  eef08a6a          VMOV.F32 s17,s21
;;;933    
;;;934          /* Initialize state pointer */
;;;935          px = pState;
0003aa  4625              MOV      r5,r4
;;;936    
;;;937          /* Initialize Coefficient pointer */
;;;938          pb = (pCoeffs);
0003ac  4656              MOV      r6,r10
;;;939    
;;;940          i = numTaps;
0003ae  4643              MOV      r3,r8
                  |L1.944|
;;;941    
;;;942          /* Perform the multiply-accumulates */
;;;943          do
;;;944          {
;;;945             acc0 += *px++ * *pb++;
0003b0  ecb50a01          VLDM     r5!,{s0}
0003b4  ecf60a01          VLDM     r6!,{s1}
0003b8  ee408a20          VMLA.F32 s17,s0,s1
;;;946             i--;
0003bc  1e5b              SUBS     r3,r3,#1
;;;947    
;;;948          } while(i > 0u);
0003be  2b00              CMP      r3,#0
0003c0  d1f6              BNE      |L1.944|
;;;949    
;;;950          /* The result is store in the destination buffer. */
;;;951          *pDst++ = acc0;
0003c2  ece28a01          VSTM     r2!,{s17}
;;;952    
;;;953          /* Advance state pointer by 1 for the next sample */
;;;954          pState = pState + 1;
0003c6  1d24              ADDS     r4,r4,#4
;;;955    
;;;956          blkCnt--;
0003c8  f1ac0c01          SUB      r12,r12,#1
                  |L1.972|
0003cc  f1bc0f00          CMP      r12,#0                ;926
0003d0  d1e5              BNE      |L1.926|
;;;957       }
;;;958    
;;;959       /* Processing is complete.  
;;;960       ** Now copy the last numTaps - 1 samples to the start of the state buffer.  
;;;961       ** This prepares the state buffer for the next function call. */
;;;962    
;;;963       /* Points to the start of the state buffer */
;;;964       pStateCurnt = S->pState;
0003d2  6840              LDR      r0,[r0,#4]
;;;965    
;;;966       tapCnt = (numTaps - 1u) >> 2u;
0003d4  ea4f019b          LSR      r1,r11,#2
;;;967    
;;;968       /* copy data */
;;;969       while(tapCnt > 0u)
0003d8  e010              B        |L1.1020|
                  |L1.986|
;;;970       {
;;;971          *pStateCurnt++ = *pState++;
0003da  ecb40a01          VLDM     r4!,{s0}
0003de  eca00a01          VSTM     r0!,{s0}
;;;972          *pStateCurnt++ = *pState++;
0003e2  ecb40a01          VLDM     r4!,{s0}
0003e6  eca00a01          VSTM     r0!,{s0}
;;;973          *pStateCurnt++ = *pState++;
0003ea  ecb40a01          VLDM     r4!,{s0}
0003ee  eca00a01          VSTM     r0!,{s0}
;;;974          *pStateCurnt++ = *pState++;
0003f2  ecb40a01          VLDM     r4!,{s0}
0003f6  eca00a01          VSTM     r0!,{s0}
;;;975    
;;;976          /* Decrement the loop counter */
;;;977          tapCnt--;
0003fa  1e49              SUBS     r1,r1,#1
                  |L1.1020|
0003fc  2900              CMP      r1,#0                 ;969
0003fe  d1ec              BNE      |L1.986|
;;;978       }
;;;979    
;;;980       /* Calculate remaining number of copies */
;;;981       tapCnt = (numTaps - 1u) % 0x4u;
000400  f00b0103          AND      r1,r11,#3
;;;982    
;;;983       /* Copy the remaining q31_t data */
;;;984       while(tapCnt > 0u)
000404  e007              B        |L1.1046|
000406  0000              DCW      0x0000
                  |L1.1032|
000408  00000000          DCFS     0x00000000 ; 0
                  |L1.1036|
;;;985       {
;;;986          *pStateCurnt++ = *pState++;
00040c  ecb40a01          VLDM     r4!,{s0}
000410  eca00a01          VSTM     r0!,{s0}
;;;987    
;;;988          /* Decrement the loop counter */
;;;989          tapCnt--;
000414  1e49              SUBS     r1,r1,#1
                  |L1.1046|
000416  2900              CMP      r1,#0                 ;984
000418  d1f8              BNE      |L1.1036|
;;;990       }
;;;991    }
00041a  ecbd8b0a          VPOP     {d8-d12}
00041e  e8bd8ff0          POP      {r4-r11,pc}
;;;992    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_fir_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_fir_f32_c_8e4c221c____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___13_arm_fir_f32_c_8e4c221c____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_fir_f32_c_8e4c221c____REVSH|
#line 144
|__asm___13_arm_fir_f32_c_8e4c221c____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_fir_f32_c_8e4c221c____RRX|
#line 300
|__asm___13_arm_fir_f32_c_8e4c221c____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
