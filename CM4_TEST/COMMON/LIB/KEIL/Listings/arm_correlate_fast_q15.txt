; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_correlate_fast_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_correlate_fast_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_correlate_fast_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_correlate_fast_q15.c]
                          THUMB

                          AREA ||i.arm_correlate_fast_q15||, CODE, READONLY, ALIGN=1

                  arm_correlate_fast_q15 PROC
;;;76     
;;;77     void arm_correlate_fast_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;78       q15_t * pSrcA,
;;;79       uint32_t srcALen,
;;;80       q15_t * pSrcB,
;;;81       uint32_t srcBLen,
;;;82       q15_t * pDst)
;;;83     {
000004  b08a              SUB      sp,sp,#0x28
000006  9917              LDR      r1,[sp,#0x5c]
;;;84     #ifndef UNALIGNED_SUPPORT_DISABLE
;;;85     
;;;86       q15_t *pIn1;                                   /* inputA pointer               */
;;;87       q15_t *pIn2;                                   /* inputB pointer               */
;;;88       q15_t *pOut = pDst;                            /* output pointer               */
;;;89       q31_t sum, acc0, acc1, acc2, acc3;             /* Accumulators                  */
;;;90       q15_t *px;                                     /* Intermediate inputA pointer  */
;;;91       q15_t *py;                                     /* Intermediate inputB pointer  */
;;;92       q15_t *pSrc1;                                  /* Intermediate pointers        */
;;;93       q31_t x0, x1, x2, x3, c0;                      /* temporary variables for holding input and coefficient values */
;;;94       uint32_t j, k = 0u, count, blkCnt, outBlockSize, blockSize1, blockSize2, blockSize3;  /* loop counter                 */
;;;95       int32_t inc = 1;                               /* Destination address modifier */
000008  f04f0901          MOV      r9,#1
;;;96     
;;;97     
;;;98       /* The algorithm implementation is based on the lengths of the inputs. */
;;;99       /* srcB is always made to slide across srcA. */
;;;100      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;101      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;102      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;103      /* and the destination pointer modifier, inc is set to -1 */
;;;104      /* If srcALen > srcBLen, zero pad has to be done to srcB to make the two inputs of same length */
;;;105      /* But to improve the performance,   
;;;106       * we include zeroes in the output instead of zero padding either of the the inputs*/
;;;107      /* If srcALen > srcBLen,   
;;;108       * (srcALen - srcBLen) zeroes has to included in the starting of the output buffer */
;;;109      /* If srcALen < srcBLen,   
;;;110       * (srcALen - srcBLen) zeroes has to included in the ending of the output buffer */
;;;111      if(srcALen >= srcBLen)
00000c  9d0b              LDR      r5,[sp,#0x2c]
;;;112      {
;;;113        /* Initialization of inputA pointer */
;;;114        pIn1 = (pSrcA);
;;;115    
;;;116        /* Initialization of inputB pointer */
;;;117        pIn2 = (pSrcB);
;;;118    
;;;119        /* Number of output samples is calculated */
;;;120        outBlockSize = (2u * srcALen) - 1u;
00000e  f04f34ff          MOV      r4,#0xffffffff
000012  429d              CMP      r5,r3                 ;111
000014  d30b              BCC      |L1.46|
000016  9008              STR      r0,[sp,#0x20]         ;114
000018  9207              STR      r2,[sp,#0x1c]         ;117
00001a  980b              LDR      r0,[sp,#0x2c]
00001c  eb040040          ADD      r0,r4,r0,LSL #1
;;;121    
;;;122        /* When srcALen > srcBLen, zero padding is done to srcB   
;;;123         * to make their lengths equal.   
;;;124         * Instead, (outBlockSize - (srcALen + srcBLen - 1))   
;;;125         * number of output samples are made zero */
;;;126        j = outBlockSize - (srcALen + (srcBLen - 1u));
000020  9a0b              LDR      r2,[sp,#0x2c]
000022  441a              ADD      r2,r2,r3
000024  1a80              SUBS     r0,r0,r2
000026  1c40              ADDS     r0,r0,#1
;;;127    
;;;128        /* Updating the pointer position to non zero value */
;;;129        pOut += j;
000028  eb010240          ADD      r2,r1,r0,LSL #1
00002c  e00a              B        |L1.68|
                  |L1.46|
;;;130    
;;;131      }
;;;132      else
;;;133      {
;;;134        /* Initialization of inputA pointer */
;;;135        pIn1 = (pSrcB);
00002e  9208              STR      r2,[sp,#0x20]
;;;136    
;;;137        /* Initialization of inputB pointer */
;;;138        pIn2 = (pSrcA);
000030  9007              STR      r0,[sp,#0x1c]
;;;139    
;;;140        /* srcBLen is always considered as shorter or equal to srcALen */
;;;141        j = srcBLen;
000032  4618              MOV      r0,r3
;;;142        srcBLen = srcALen;
000034  9b0b              LDR      r3,[sp,#0x2c]
;;;143        srcALen = j;
000036  900b              STR      r0,[sp,#0x2c]
;;;144    
;;;145        /* CORR(x, y) = Reverse order(CORR(y, x)) */
;;;146        /* Hence set the destination pointer to point to the last output sample */
;;;147        pOut = pDst + ((srcALen + srcBLen) - 2u);
000038  980b              LDR      r0,[sp,#0x2c]
00003a  4418              ADD      r0,r0,r3
00003c  1e80              SUBS     r0,r0,#2
00003e  eb010240          ADD      r2,r1,r0,LSL #1
;;;148    
;;;149        /* Destination address modifier is set to -1 */
;;;150        inc = -1;
000042  46a1              MOV      r9,r4
                  |L1.68|
;;;151    
;;;152      }
;;;153    
;;;154      /* The function is internally   
;;;155       * divided into three parts according to the number of multiplications that has to be   
;;;156       * taken place between inputA samples and inputB samples. In the first part of the   
;;;157       * algorithm, the multiplications increase by one for every iteration.   
;;;158       * In the second part of the algorithm, srcBLen number of multiplications are done.   
;;;159       * In the third part of the algorithm, the multiplications decrease by one   
;;;160       * for every iteration.*/
;;;161      /* The algorithm is implemented in three stages.   
;;;162       * The loop counters of each stage is initiated here. */
;;;163      blockSize1 = srcBLen - 1u;
000044  1e5f              SUBS     r7,r3,#1
;;;164      blockSize2 = srcALen - (srcBLen - 1u);
000046  980b              LDR      r0,[sp,#0x2c]
000048  1ac0              SUBS     r0,r0,r3
00004a  1c40              ADDS     r0,r0,#1
00004c  9001              STR      r0,[sp,#4]
;;;165      blockSize3 = blockSize1;
00004e  9700              STR      r7,[sp,#0]
;;;166    
;;;167      /* --------------------------   
;;;168       * Initializations of stage1   
;;;169       * -------------------------*/
;;;170    
;;;171      /* sum = x[0] * y[srcBlen - 1]   
;;;172       * sum = x[0] * y[srcBlen - 2] + x[1] * y[srcBlen - 1]   
;;;173       * ....   
;;;174       * sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen - 1] * y[srcBLen - 1]   
;;;175       */
;;;176    
;;;177      /* In this stage the MAC operations are increased by 1 for every iteration.   
;;;178         The count variable holds the number of MAC operations performed */
;;;179      count = 1u;
000050  2501              MOVS     r5,#1
;;;180    
;;;181      /* Working pointer of inputA */
;;;182      px = pIn1;
000052  9908              LDR      r1,[sp,#0x20]
;;;183    
;;;184      /* Working pointer of inputB */
;;;185      pSrc1 = pIn2 + (srcBLen - 1u);
000054  1e58              SUBS     r0,r3,#1
000056  9c07              LDR      r4,[sp,#0x1c]
000058  9009              STR      r0,[sp,#0x24]
00005a  eb040c40          ADD      r12,r4,r0,LSL #1
;;;186      py = pSrc1;
00005e  4660              MOV      r0,r12
;;;187    
;;;188      /* ------------------------   
;;;189       * Stage1 process   
;;;190       * ----------------------*/
;;;191    
;;;192      /* The first loop starts here */
;;;193      while(blockSize1 > 0u)
000060  e026              B        |L1.176|
                  |L1.98|
;;;194      {
;;;195        /* Accumulator is made zero for every iteration */
;;;196        sum = 0;
000062  2400              MOVS     r4,#0
;;;197    
;;;198        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;199        k = count >> 2;
000064  08ae              LSRS     r6,r5,#2
;;;200    
;;;201        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;202         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;203        while(k > 0u)
000066  e00c              B        |L1.130|
                  |L1.104|
;;;204        {
;;;205          /* x[0] * y[srcBLen - 4] , x[1] * y[srcBLen - 3] */
;;;206          sum = __SMLAD(*__SIMD32(px)++, *__SIMD32(py)++, sum);
000068  f8518b04          LDR      r8,[r1],#4
00006c  f850ab04          LDR      r10,[r0],#4
000070  fb28440a          SMLAD    r4,r8,r10,r4
;;;207          /* x[3] * y[srcBLen - 1] , x[2] * y[srcBLen - 2] */
;;;208          sum = __SMLAD(*__SIMD32(px)++, *__SIMD32(py)++, sum);
000074  f8518b04          LDR      r8,[r1],#4
000078  f850ab04          LDR      r10,[r0],#4
00007c  fb28440a          SMLAD    r4,r8,r10,r4
;;;209    
;;;210          /* Decrement the loop counter */
;;;211          k--;
000080  1e76              SUBS     r6,r6,#1
                  |L1.130|
000082  2e00              CMP      r6,#0                 ;203
000084  d1f0              BNE      |L1.104|
;;;212        }
;;;213    
;;;214        /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;215         ** No loop unrolling is used. */
;;;216        k = count % 0x4u;
000086  f0050603          AND      r6,r5,#3
;;;217    
;;;218        while(k > 0u)
00008a  e006              B        |L1.154|
                  |L1.140|
;;;219        {
;;;220          /* Perform the multiply-accumulates */
;;;221          /* x[0] * y[srcBLen - 1] */
;;;222          sum = __SMLAD(*px++, *py++, sum);
00008c  f9318b02          LDRSH    r8,[r1],#2
000090  f930ab02          LDRSH    r10,[r0],#2
000094  fb28440a          SMLAD    r4,r8,r10,r4
;;;223    
;;;224          /* Decrement the loop counter */
;;;225          k--;
000098  1e76              SUBS     r6,r6,#1
                  |L1.154|
00009a  2e00              CMP      r6,#0                 ;218
00009c  d1f6              BNE      |L1.140|
;;;226        }
;;;227    
;;;228        /* Store the result in the accumulator in the destination buffer. */
;;;229        *pOut = (q15_t) (sum >> 15);
00009e  13e0              ASRS     r0,r4,#15
0000a0  8010              STRH     r0,[r2,#0]
;;;230        /* Destination pointer is updated according to the address modifier, inc */
;;;231        pOut += inc;
0000a2  eb020249          ADD      r2,r2,r9,LSL #1
;;;232    
;;;233        /* Update the inputA and inputB pointers for next MAC calculation */
;;;234        py = pSrc1 - count;
0000a6  ebac0045          SUB      r0,r12,r5,LSL #1
;;;235        px = pIn1;
0000aa  9908              LDR      r1,[sp,#0x20]
;;;236    
;;;237        /* Increment the MAC count */
;;;238        count++;
0000ac  1c6d              ADDS     r5,r5,#1
;;;239    
;;;240        /* Decrement the loop counter */
;;;241        blockSize1--;
0000ae  1e7f              SUBS     r7,r7,#1
                  |L1.176|
0000b0  2f00              CMP      r7,#0                 ;193
0000b2  d1d6              BNE      |L1.98|
;;;242      }
;;;243    
;;;244      /* --------------------------   
;;;245       * Initializations of stage2   
;;;246       * ------------------------*/
;;;247    
;;;248      /* sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen-1] * y[srcBLen-1]   
;;;249       * sum = x[1] * y[0] + x[2] * y[1] +...+ x[srcBLen] * y[srcBLen-1]   
;;;250       * ....   
;;;251       * sum = x[srcALen-srcBLen-2] * y[0] + x[srcALen-srcBLen-1] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]   
;;;252       */
;;;253    
;;;254      /* Working pointer of inputA */
;;;255      px = pIn1;
;;;256    
;;;257      /* Working pointer of inputB */
;;;258      py = pIn2;
0000b4  9807              LDR      r0,[sp,#0x1c]
;;;259    
;;;260      /* count is index by which the pointer pIn1 to be incremented */
;;;261      count = 0u;
0000b6  46b8              MOV      r8,r7
;;;262    
;;;263      /* -------------------   
;;;264       * Stage2 process   
;;;265       * ------------------*/
;;;266    
;;;267      /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.   
;;;268       * So, to loop unroll over blockSize2,   
;;;269       * srcBLen should be greater than or equal to 4, to loop unroll the srcBLen loop */
;;;270      if(srcBLen >= 4u)
0000b8  2b04              CMP      r3,#4
0000ba  d37d              BCC      |L1.440|
;;;271      {
;;;272        /* Loop unroll over blockSize2, by 4 */
;;;273        blkCnt = blockSize2 >> 2u;
0000bc  9c01              LDR      r4,[sp,#4]
0000be  08a4              LSRS     r4,r4,#2
0000c0  9402              STR      r4,[sp,#8]
;;;274    
;;;275        while(blkCnt > 0u)
0000c2  e097              B        |L1.500|
                  |L1.196|
;;;276        {
;;;277          /* Set all accumulators to zero */
;;;278          acc0 = 0;
0000c4  2400              MOVS     r4,#0
;;;279          acc1 = 0;
0000c6  2500              MOVS     r5,#0
;;;280          acc2 = 0;
0000c8  2600              MOVS     r6,#0
;;;281          acc3 = 0;
0000ca  2700              MOVS     r7,#0
;;;282    
;;;283          /* read x[0], x[1] samples */
;;;284          x0 = *__SIMD32(px);
0000cc  f8d1a000          LDR      r10,[r1,#0]
;;;285          /* read x[1], x[2] samples */
;;;286          x1 = _SIMD32_OFFSET(px + 1);
0000d0  f8d1c002          LDR      r12,[r1,#2]
;;;287    	  px += 2u;
0000d4  1d09              ADDS     r1,r1,#4
;;;288    
;;;289          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;290          k = srcBLen >> 2u;
0000d6  ea4f0e93          LSR      lr,r3,#2
                  |L1.218|
;;;291    
;;;292          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;293           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;294          do
;;;295          {
;;;296            /* Read the first two inputB samples using SIMD:   
;;;297             * y[0] and y[1] */
;;;298            c0 = *__SIMD32(py)++;
0000da  f8d0b000          LDR      r11,[r0,#0]
;;;299    
;;;300            /* acc0 +=  x[0] * y[0] + x[1] * y[1] */
;;;301            acc0 = __SMLAD(x0, c0, acc0);
0000de  fb2a4a0b          SMLAD    r10,r10,r11,r4
;;;302    
;;;303            /* acc1 +=  x[1] * y[0] + x[2] * y[1] */
;;;304            acc1 = __SMLAD(x1, c0, acc1);
0000e2  fb2c5c0b          SMLAD    r12,r12,r11,r5
;;;305    
;;;306            /* Read x[2], x[3] */
;;;307            x2 = *__SIMD32(px);
0000e6  680c              LDR      r4,[r1,#0]
;;;308    
;;;309            /* Read x[3], x[4] */
;;;310            x3 = _SIMD32_OFFSET(px + 1);
0000e8  f8d15002          LDR      r5,[r1,#2]
;;;311    
;;;312            /* acc2 +=  x[2] * y[0] + x[3] * y[1] */
;;;313            acc2 = __SMLAD(x2, c0, acc2);
0000ec  fb24660b          SMLAD    r6,r4,r11,r6
;;;314    
;;;315            /* acc3 +=  x[3] * y[0] + x[4] * y[1] */
;;;316            acc3 = __SMLAD(x3, c0, acc3);
0000f0  fb257b0b          SMLAD    r11,r5,r11,r7
;;;317    
;;;318            /* Read y[2] and y[3] */
;;;319            c0 = *__SIMD32(py)++;
0000f4  6847              LDR      r7,[r0,#4]
0000f6  3008              ADDS     r0,r0,#8
;;;320    
;;;321            /* acc0 +=  x[2] * y[2] + x[3] * y[3] */
;;;322            acc0 = __SMLAD(x2, c0, acc0);
0000f8  fb24a407          SMLAD    r4,r4,r7,r10
;;;323    
;;;324            /* acc1 +=  x[3] * y[2] + x[4] * y[3] */
;;;325            acc1 = __SMLAD(x3, c0, acc1);
0000fc  fb25c507          SMLAD    r5,r5,r7,r12
;;;326    
;;;327            /* Read x[4], x[5] */
;;;328            x0 = _SIMD32_OFFSET(px + 2);
000100  f8d1a004          LDR      r10,[r1,#4]
;;;329    
;;;330            /* Read x[5], x[6] */
;;;331            x1 = _SIMD32_OFFSET(px + 3);
000104  f8d1c006          LDR      r12,[r1,#6]
;;;332    		px += 4u;
000108  3108              ADDS     r1,r1,#8
;;;333    
;;;334            /* acc2 +=  x[4] * y[2] + x[5] * y[3] */
;;;335            acc2 = __SMLAD(x0, c0, acc2);
00010a  fb2a6607          SMLAD    r6,r10,r7,r6
;;;336    
;;;337            /* acc3 +=  x[5] * y[2] + x[6] * y[3] */
;;;338            acc3 = __SMLAD(x1, c0, acc3);
00010e  fb2cb707          SMLAD    r7,r12,r7,r11
;;;339    
;;;340          } while(--k);
000112  f1be0e01          SUBS     lr,lr,#1
000116  d1e0              BNE      |L1.218|
;;;341    
;;;342          /* For the next MAC operations, SIMD is not used   
;;;343           * So, the 16 bit pointer if inputB, py is updated */
;;;344    
;;;345          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;346           ** No loop unrolling is used. */
;;;347          k = srcBLen % 0x4u;
000118  f0030b03          AND      r11,r3,#3
00011c  f8cdb00c          STR      r11,[sp,#0xc]
;;;348    
;;;349          if(k == 1u)
000120  f8ddb00c          LDR      r11,[sp,#0xc]
000124  f1bb0f01          CMP      r11,#1
000128  d10e              BNE      |L1.328|
;;;350          {
;;;351            /* Read y[4] */
;;;352            c0 = *py;
00012a  f8b0b000          LDRH     r11,[r0,#0]
;;;353    #ifdef  ARM_MATH_BIG_ENDIAN
;;;354    
;;;355            c0 = c0 << 16u;
;;;356    
;;;357    #else
;;;358    
;;;359            c0 = c0 & 0x0000FFFF;
00012e  fa1ffb8b          UXTH     r11,r11
;;;360    
;;;361    #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;362    
;;;363            /* Read x[7] */
;;;364            x3 = *__SIMD32(px);
000132  f8d1e000          LDR      lr,[r1,#0]
;;;365    		px++;
000136  1c89              ADDS     r1,r1,#2
;;;366    
;;;367            /* Perform the multiply-accumulates */
;;;368            acc0 = __SMLAD(x0, c0, acc0);
000138  fb2a440b          SMLAD    r4,r10,r11,r4
;;;369            acc1 = __SMLAD(x1, c0, acc1);
00013c  fb2c550b          SMLAD    r5,r12,r11,r5
;;;370            acc2 = __SMLADX(x1, c0, acc2);
000140  fb2c661b          SMLADX   r6,r12,r11,r6
;;;371            acc3 = __SMLADX(x3, c0, acc3);
000144  fb2e771b          SMLADX   r7,lr,r11,r7
                  |L1.328|
;;;372          }
;;;373    
;;;374          if(k == 2u)
000148  f8ddb00c          LDR      r11,[sp,#0xc]
00014c  f1bb0f02          CMP      r11,#2
000150  d116              BNE      |L1.384|
;;;375          {
;;;376            /* Read y[4], y[5] */
;;;377            c0 = *__SIMD32(py);
000152  f8d0b000          LDR      r11,[r0,#0]
;;;378    
;;;379            /* Read x[7], x[8] */
;;;380            x3 = *__SIMD32(px);
000156  f8d1e000          LDR      lr,[r1,#0]
00015a  f8cde010          STR      lr,[sp,#0x10]
;;;381    
;;;382            /* Read x[9] */
;;;383            x2 = _SIMD32_OFFSET(px + 1);
00015e  f8d1e002          LDR      lr,[r1,#2]
000162  f8cde014          STR      lr,[sp,#0x14]
;;;384    		px += 2u;
000166  1d09              ADDS     r1,r1,#4
;;;385    
;;;386            /* Perform the multiply-accumulates */
;;;387            acc0 = __SMLAD(x0, c0, acc0);
000168  fb2a440b          SMLAD    r4,r10,r11,r4
;;;388            acc1 = __SMLAD(x1, c0, acc1);
00016c  fb2c550b          SMLAD    r5,r12,r11,r5
;;;389            acc2 = __SMLAD(x3, c0, acc2);
000170  f8dde010          LDR      lr,[sp,#0x10]
000174  fb2e660b          SMLAD    r6,lr,r11,r6
;;;390            acc3 = __SMLAD(x2, c0, acc3);
000178  f8dde014          LDR      lr,[sp,#0x14]
00017c  fb2e770b          SMLAD    r7,lr,r11,r7
                  |L1.384|
;;;391          }
;;;392    
;;;393          if(k == 3u)
000180  f8ddb00c          LDR      r11,[sp,#0xc]
000184  f1bb0f03          CMP      r11,#3
000188  d11b              BNE      |L1.450|
;;;394          {
;;;395            /* Read y[4], y[5] */
;;;396            c0 = *__SIMD32(py)++;
00018a  f850bb04          LDR      r11,[r0],#4
00018e  9006              STR      r0,[sp,#0x18]
;;;397    
;;;398            /* Read x[7], x[8] */
;;;399            x3 = *__SIMD32(px);
000190  6808              LDR      r0,[r1,#0]
;;;400    
;;;401            /* Read x[9] */
;;;402            x2 = _SIMD32_OFFSET(px + 1);
000192  f8d1e002          LDR      lr,[r1,#2]
;;;403    
;;;404            /* Perform the multiply-accumulates */
;;;405            acc0 = __SMLAD(x0, c0, acc0);
000196  fb2a440b          SMLAD    r4,r10,r11,r4
;;;406            acc1 = __SMLAD(x1, c0, acc1);
00019a  fb2c550b          SMLAD    r5,r12,r11,r5
;;;407            acc2 = __SMLAD(x3, c0, acc2);
00019e  fb20660b          SMLAD    r6,r0,r11,r6
;;;408            acc3 = __SMLAD(x2, c0, acc3);
0001a2  fb2e770b          SMLAD    r7,lr,r11,r7
;;;409    
;;;410            c0 = (*py);
0001a6  9806              LDR      r0,[sp,#0x18]
0001a8  8800              LDRH     r0,[r0,#0]
;;;411            /* Read y[6] */
;;;412    #ifdef  ARM_MATH_BIG_ENDIAN
;;;413    
;;;414            c0 = c0 << 16u;
;;;415    #else
;;;416    
;;;417            c0 = c0 & 0x0000FFFF;
0001aa  b280              UXTH     r0,r0
;;;418    #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;419    
;;;420            /* Read x[10] */
;;;421            x3 = _SIMD32_OFFSET(px + 2);
0001ac  6849              LDR      r1,[r1,#4]
;;;422    		px += 3u;
;;;423    
;;;424            /* Perform the multiply-accumulates */
;;;425            acc0 = __SMLADX(x1, c0, acc0);
0001ae  fb2c4410          SMLADX   r4,r12,r0,r4
;;;426            acc1 = __SMLAD(x2, c0, acc1);
0001b2  fb2e5500          SMLAD    r5,lr,r0,r5
;;;427            acc2 = __SMLADX(x2, c0, acc2);
0001b6  e000              B        |L1.442|
                  |L1.440|
0001b8  e059              B        |L1.622|
                  |L1.442|
0001ba  fb2e6610          SMLADX   r6,lr,r0,r6
;;;428            acc3 = __SMLADX(x3, c0, acc3);
0001be  fb217710          SMLADX   r7,r1,r0,r7
                  |L1.450|
;;;429          }
;;;430    
;;;431          /* Store the result in the accumulator in the destination buffer. */
;;;432          *pOut = (q15_t) (acc0 >> 15);
0001c2  13e0              ASRS     r0,r4,#15
0001c4  8010              STRH     r0,[r2,#0]
;;;433          /* Destination pointer is updated according to the address modifier, inc */
;;;434          pOut += inc;
0001c6  eb020049          ADD      r0,r2,r9,LSL #1
;;;435    
;;;436          *pOut = (q15_t) (acc1 >> 15);
0001ca  13e9              ASRS     r1,r5,#15
0001cc  8001              STRH     r1,[r0,#0]
;;;437          pOut += inc;
0001ce  eb000049          ADD      r0,r0,r9,LSL #1
;;;438    
;;;439          *pOut = (q15_t) (acc2 >> 15);
0001d2  13f1              ASRS     r1,r6,#15
0001d4  8001              STRH     r1,[r0,#0]
;;;440          pOut += inc;
0001d6  eb000049          ADD      r0,r0,r9,LSL #1
;;;441    
;;;442          *pOut = (q15_t) (acc3 >> 15);
0001da  13f9              ASRS     r1,r7,#15
0001dc  8001              STRH     r1,[r0,#0]
;;;443          pOut += inc;
0001de  eb000249          ADD      r2,r0,r9,LSL #1
;;;444    
;;;445          /* Increment the pointer pIn1 index, count by 1 */
;;;446          count += 4u;
0001e2  f1080804          ADD      r8,r8,#4
;;;447    
;;;448          /* Update the inputA and inputB pointers for next MAC calculation */
;;;449          px = pIn1 + count;
0001e6  9808              LDR      r0,[sp,#0x20]
0001e8  eb000148          ADD      r1,r0,r8,LSL #1
;;;450          py = pIn2;
0001ec  9807              LDR      r0,[sp,#0x1c]
;;;451    
;;;452    
;;;453          /* Decrement the loop counter */
;;;454          blkCnt--;
0001ee  9c02              LDR      r4,[sp,#8]
0001f0  1e64              SUBS     r4,r4,#1
0001f2  9402              STR      r4,[sp,#8]
                  |L1.500|
0001f4  9c02              LDR      r4,[sp,#8]            ;275
0001f6  2c00              CMP      r4,#0                 ;275
0001f8  f47faf64          BNE      |L1.196|
;;;455        }
;;;456    
;;;457        /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.   
;;;458         ** No loop unrolling is used. */
;;;459        blkCnt = blockSize2 % 0x4u;
0001fc  9c01              LDR      r4,[sp,#4]
0001fe  f0040603          AND      r6,r4,#3
;;;460    
;;;461        while(blkCnt > 0u)
000202  e031              B        |L1.616|
                  |L1.516|
;;;462        {
;;;463          /* Accumulator is made zero for every iteration */
;;;464          sum = 0;
000204  2400              MOVS     r4,#0
;;;465    
;;;466          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;467          k = srcBLen >> 2u;
000206  089d              LSRS     r5,r3,#2
;;;468    
;;;469          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;470           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;471          while(k > 0u)
000208  e015              B        |L1.566|
                  |L1.522|
;;;472          {
;;;473            /* Perform the multiply-accumulates */
;;;474            sum += ((q31_t) * px++ * *py++);
00020a  880f              LDRH     r7,[r1,#0]
00020c  f830cb02          LDRH     r12,[r0],#2
000210  fb17440c          SMLABB   r4,r7,r12,r4
;;;475            sum += ((q31_t) * px++ * *py++);
000214  884f              LDRH     r7,[r1,#2]
000216  f830cb02          LDRH     r12,[r0],#2
00021a  fb17440c          SMLABB   r4,r7,r12,r4
;;;476            sum += ((q31_t) * px++ * *py++);
00021e  888f              LDRH     r7,[r1,#4]
000220  f830cb02          LDRH     r12,[r0],#2
000224  fb17440c          SMLABB   r4,r7,r12,r4
;;;477            sum += ((q31_t) * px++ * *py++);
000228  88cf              LDRH     r7,[r1,#6]
00022a  f830cb02          LDRH     r12,[r0],#2
00022e  3108              ADDS     r1,r1,#8
000230  fb17440c          SMLABB   r4,r7,r12,r4
;;;478    
;;;479            /* Decrement the loop counter */
;;;480            k--;
000234  1e6d              SUBS     r5,r5,#1
                  |L1.566|
000236  2d00              CMP      r5,#0                 ;471
000238  d1e7              BNE      |L1.522|
;;;481          }
;;;482    
;;;483          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;484           ** No loop unrolling is used. */
;;;485          k = srcBLen % 0x4u;
00023a  f0030503          AND      r5,r3,#3
;;;486    
;;;487          while(k > 0u)
00023e  e006              B        |L1.590|
                  |L1.576|
;;;488          {
;;;489            /* Perform the multiply-accumulates */
;;;490            sum += ((q31_t) * px++ * *py++);
000240  f8317b02          LDRH     r7,[r1],#2
000244  f830cb02          LDRH     r12,[r0],#2
000248  fb17440c          SMLABB   r4,r7,r12,r4
;;;491    
;;;492            /* Decrement the loop counter */
;;;493            k--;
00024c  1e6d              SUBS     r5,r5,#1
                  |L1.590|
00024e  2d00              CMP      r5,#0                 ;487
000250  d1f6              BNE      |L1.576|
;;;494          }
;;;495    
;;;496          /* Store the result in the accumulator in the destination buffer. */
;;;497          *pOut = (q15_t) (sum >> 15);
000252  13e0              ASRS     r0,r4,#15
000254  8010              STRH     r0,[r2,#0]
;;;498          /* Destination pointer is updated according to the address modifier, inc */
;;;499          pOut += inc;
000256  eb020249          ADD      r2,r2,r9,LSL #1
;;;500    
;;;501          /* Increment the pointer pIn1 index, count by 1 */
;;;502          count++;
00025a  f1080801          ADD      r8,r8,#1
;;;503    
;;;504          /* Update the inputA and inputB pointers for next MAC calculation */
;;;505          px = pIn1 + count;
00025e  9808              LDR      r0,[sp,#0x20]
000260  eb000148          ADD      r1,r0,r8,LSL #1
;;;506          py = pIn2;
000264  9807              LDR      r0,[sp,#0x1c]
;;;507    
;;;508          /* Decrement the loop counter */
;;;509          blkCnt--;
000266  1e76              SUBS     r6,r6,#1
                  |L1.616|
000268  2e00              CMP      r6,#0                 ;461
00026a  d1cb              BNE      |L1.516|
00026c  e01a              B        |L1.676|
                  |L1.622|
;;;510        }
;;;511      }
;;;512      else
;;;513      {
;;;514        /* If the srcBLen is not a multiple of 4,   
;;;515         * the blockSize2 loop cannot be unrolled by 4 */
;;;516        blkCnt = blockSize2;
00026e  9e01              LDR      r6,[sp,#4]
;;;517    
;;;518        while(blkCnt > 0u)
000270  e016              B        |L1.672|
                  |L1.626|
;;;519        {
;;;520          /* Accumulator is made zero for every iteration */
;;;521          sum = 0;
000272  2500              MOVS     r5,#0
;;;522    
;;;523          /* Loop over srcBLen */
;;;524          k = srcBLen;
000274  461c              MOV      r4,r3
;;;525    
;;;526          while(k > 0u)
000276  e006              B        |L1.646|
                  |L1.632|
;;;527          {
;;;528            /* Perform the multiply-accumulate */
;;;529            sum += ((q31_t) * px++ * *py++);
000278  f8317b02          LDRH     r7,[r1],#2
00027c  f830cb02          LDRH     r12,[r0],#2
000280  fb17550c          SMLABB   r5,r7,r12,r5
;;;530    
;;;531            /* Decrement the loop counter */
;;;532            k--;
000284  1e64              SUBS     r4,r4,#1
                  |L1.646|
000286  2c00              CMP      r4,#0                 ;526
000288  d1f6              BNE      |L1.632|
;;;533          }
;;;534    
;;;535          /* Store the result in the accumulator in the destination buffer. */
;;;536          *pOut = (q15_t) (sum >> 15);
00028a  13e8              ASRS     r0,r5,#15
00028c  8010              STRH     r0,[r2,#0]
;;;537          /* Destination pointer is updated according to the address modifier, inc */
;;;538          pOut += inc;
00028e  eb020249          ADD      r2,r2,r9,LSL #1
;;;539    
;;;540          /* Increment the MAC count */
;;;541          count++;
000292  f1080801          ADD      r8,r8,#1
;;;542    
;;;543          /* Update the inputA and inputB pointers for next MAC calculation */
;;;544          px = pIn1 + count;
000296  9808              LDR      r0,[sp,#0x20]
000298  eb000148          ADD      r1,r0,r8,LSL #1
;;;545          py = pIn2;
00029c  9807              LDR      r0,[sp,#0x1c]
;;;546    
;;;547          /* Decrement the loop counter */
;;;548          blkCnt--;
00029e  1e76              SUBS     r6,r6,#1
                  |L1.672|
0002a0  2e00              CMP      r6,#0                 ;518
0002a2  d1e6              BNE      |L1.626|
                  |L1.676|
;;;549        }
;;;550      }
;;;551    
;;;552      /* --------------------------   
;;;553       * Initializations of stage3   
;;;554       * -------------------------*/
;;;555    
;;;556      /* sum += x[srcALen-srcBLen+1] * y[0] + x[srcALen-srcBLen+2] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]   
;;;557       * sum += x[srcALen-srcBLen+2] * y[0] + x[srcALen-srcBLen+3] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]   
;;;558       * ....   
;;;559       * sum +=  x[srcALen-2] * y[0] + x[srcALen-1] * y[1]   
;;;560       * sum +=  x[srcALen-1] * y[0]   
;;;561       */
;;;562    
;;;563      /* In this stage the MAC operations are decreased by 1 for every iteration.   
;;;564         The count variable holds the number of MAC operations performed */
;;;565      count = srcBLen - 1u;
0002a4  1e5b              SUBS     r3,r3,#1
;;;566    
;;;567      /* Working pointer of inputA */
;;;568      pSrc1 = (pIn1 + srcALen) - (srcBLen - 1u);
0002a6  9c0b              LDR      r4,[sp,#0x2c]
0002a8  9908              LDR      r1,[sp,#0x20]
0002aa  eb010444          ADD      r4,r1,r4,LSL #1
0002ae  9909              LDR      r1,[sp,#0x24]
0002b0  eba40641          SUB      r6,r4,r1,LSL #1
;;;569      px = pSrc1;
0002b4  4631              MOV      r1,r6
;;;570    
;;;571      /* Working pointer of inputB */
;;;572      py = pIn2;
;;;573    
;;;574      /* -------------------   
;;;575       * Stage3 process   
;;;576       * ------------------*/
;;;577    
;;;578      while(blockSize3 > 0u)
0002b6  e027              B        |L1.776|
                  |L1.696|
;;;579      {
;;;580        /* Accumulator is made zero for every iteration */
;;;581        sum = 0;
0002b8  2400              MOVS     r4,#0
;;;582    
;;;583        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;584        k = count >> 2u;
0002ba  089d              LSRS     r5,r3,#2
;;;585    
;;;586        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;587         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;588        while(k > 0u)
0002bc  e00b              B        |L1.726|
                  |L1.702|
;;;589        {
;;;590          /* Perform the multiply-accumulates */
;;;591          /* sum += x[srcALen - srcBLen + 4] * y[3] , sum += x[srcALen - srcBLen + 3] * y[2] */
;;;592          sum = __SMLAD(*__SIMD32(px)++, *__SIMD32(py)++, sum);
0002be  680f              LDR      r7,[r1,#0]
0002c0  f850cb04          LDR      r12,[r0],#4
0002c4  fb27440c          SMLAD    r4,r7,r12,r4
;;;593          /* sum += x[srcALen - srcBLen + 2] * y[1] , sum += x[srcALen - srcBLen + 1] * y[0] */
;;;594          sum = __SMLAD(*__SIMD32(px)++, *__SIMD32(py)++, sum);
0002c8  684f              LDR      r7,[r1,#4]
0002ca  f850cb04          LDR      r12,[r0],#4
0002ce  3108              ADDS     r1,r1,#8
0002d0  fb27440c          SMLAD    r4,r7,r12,r4
;;;595    
;;;596          /* Decrement the loop counter */
;;;597          k--;
0002d4  1e6d              SUBS     r5,r5,#1
                  |L1.726|
0002d6  2d00              CMP      r5,#0                 ;588
0002d8  d1f1              BNE      |L1.702|
;;;598        }
;;;599    
;;;600        /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;601         ** No loop unrolling is used. */
;;;602        k = count % 0x4u;
0002da  f0030503          AND      r5,r3,#3
;;;603    
;;;604        while(k > 0u)
0002de  e006              B        |L1.750|
                  |L1.736|
;;;605        {
;;;606          /* Perform the multiply-accumulates */
;;;607          sum = __SMLAD(*px++, *py++, sum);
0002e0  f9317b02          LDRSH    r7,[r1],#2
0002e4  f930cb02          LDRSH    r12,[r0],#2
0002e8  fb27440c          SMLAD    r4,r7,r12,r4
;;;608    
;;;609          /* Decrement the loop counter */
;;;610          k--;
0002ec  1e6d              SUBS     r5,r5,#1
                  |L1.750|
0002ee  2d00              CMP      r5,#0                 ;604
0002f0  d1f6              BNE      |L1.736|
;;;611        }
;;;612    
;;;613        /* Store the result in the accumulator in the destination buffer. */
;;;614        *pOut = (q15_t) (sum >> 15);
0002f2  13e0              ASRS     r0,r4,#15
0002f4  8010              STRH     r0,[r2,#0]
;;;615        /* Destination pointer is updated according to the address modifier, inc */
;;;616        pOut += inc;
0002f6  eb020249          ADD      r2,r2,r9,LSL #1
;;;617    
;;;618        /* Update the inputA and inputB pointers for next MAC calculation */
;;;619        px = ++pSrc1;
0002fa  1cb1              ADDS     r1,r6,#2
0002fc  460e              MOV      r6,r1
;;;620        py = pIn2;
0002fe  9807              LDR      r0,[sp,#0x1c]
;;;621    
;;;622        /* Decrement the MAC count */
;;;623        count--;
000300  1e5b              SUBS     r3,r3,#1
;;;624    
;;;625        /* Decrement the loop counter */
;;;626        blockSize3--;
000302  9c00              LDR      r4,[sp,#0]
000304  1e64              SUBS     r4,r4,#1
000306  9400              STR      r4,[sp,#0]
                  |L1.776|
000308  9c00              LDR      r4,[sp,#0]            ;578
00030a  2c00              CMP      r4,#0                 ;578
00030c  d1d4              BNE      |L1.696|
;;;627      }
;;;628    
;;;629    #else
;;;630    
;;;631      q15_t *pIn1;                                   /* inputA pointer               */
;;;632      q15_t *pIn2;                                   /* inputB pointer               */
;;;633      q15_t *pOut = pDst;                            /* output pointer               */
;;;634      q31_t sum, acc0, acc1, acc2, acc3;             /* Accumulators                  */
;;;635      q15_t *px;                                     /* Intermediate inputA pointer  */
;;;636      q15_t *py;                                     /* Intermediate inputB pointer  */
;;;637      q15_t *pSrc1;                                  /* Intermediate pointers        */
;;;638      q31_t x0, x1, x2, x3, c0;                      /* temporary variables for holding input and coefficient values */
;;;639      uint32_t j, k = 0u, count, blkCnt, outBlockSize, blockSize1, blockSize2, blockSize3;  /* loop counter                 */
;;;640      int32_t inc = 1;                               /* Destination address modifier */
;;;641      q15_t a, b;
;;;642    
;;;643    
;;;644      /* The algorithm implementation is based on the lengths of the inputs. */
;;;645      /* srcB is always made to slide across srcA. */
;;;646      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;647      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;648      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;649      /* and the destination pointer modifier, inc is set to -1 */
;;;650      /* If srcALen > srcBLen, zero pad has to be done to srcB to make the two inputs of same length */
;;;651      /* But to improve the performance,   
;;;652       * we include zeroes in the output instead of zero padding either of the the inputs*/
;;;653      /* If srcALen > srcBLen,   
;;;654       * (srcALen - srcBLen) zeroes has to included in the starting of the output buffer */
;;;655      /* If srcALen < srcBLen,   
;;;656       * (srcALen - srcBLen) zeroes has to included in the ending of the output buffer */
;;;657      if(srcALen >= srcBLen)
;;;658      {
;;;659        /* Initialization of inputA pointer */
;;;660        pIn1 = (pSrcA);
;;;661    
;;;662        /* Initialization of inputB pointer */
;;;663        pIn2 = (pSrcB);
;;;664    
;;;665        /* Number of output samples is calculated */
;;;666        outBlockSize = (2u * srcALen) - 1u;
;;;667    
;;;668        /* When srcALen > srcBLen, zero padding is done to srcB   
;;;669         * to make their lengths equal.   
;;;670         * Instead, (outBlockSize - (srcALen + srcBLen - 1))   
;;;671         * number of output samples are made zero */
;;;672        j = outBlockSize - (srcALen + (srcBLen - 1u));
;;;673    
;;;674        /* Updating the pointer position to non zero value */
;;;675        pOut += j;
;;;676    
;;;677      }
;;;678      else
;;;679      {
;;;680        /* Initialization of inputA pointer */
;;;681        pIn1 = (pSrcB);
;;;682    
;;;683        /* Initialization of inputB pointer */
;;;684        pIn2 = (pSrcA);
;;;685    
;;;686        /* srcBLen is always considered as shorter or equal to srcALen */
;;;687        j = srcBLen;
;;;688        srcBLen = srcALen;
;;;689        srcALen = j;
;;;690    
;;;691        /* CORR(x, y) = Reverse order(CORR(y, x)) */
;;;692        /* Hence set the destination pointer to point to the last output sample */
;;;693        pOut = pDst + ((srcALen + srcBLen) - 2u);
;;;694    
;;;695        /* Destination address modifier is set to -1 */
;;;696        inc = -1;
;;;697    
;;;698      }
;;;699    
;;;700      /* The function is internally   
;;;701       * divided into three parts according to the number of multiplications that has to be   
;;;702       * taken place between inputA samples and inputB samples. In the first part of the   
;;;703       * algorithm, the multiplications increase by one for every iteration.   
;;;704       * In the second part of the algorithm, srcBLen number of multiplications are done.   
;;;705       * In the third part of the algorithm, the multiplications decrease by one   
;;;706       * for every iteration.*/
;;;707      /* The algorithm is implemented in three stages.   
;;;708       * The loop counters of each stage is initiated here. */
;;;709      blockSize1 = srcBLen - 1u;
;;;710      blockSize2 = srcALen - (srcBLen - 1u);
;;;711      blockSize3 = blockSize1;
;;;712    
;;;713      /* --------------------------   
;;;714       * Initializations of stage1   
;;;715       * -------------------------*/
;;;716    
;;;717      /* sum = x[0] * y[srcBlen - 1]   
;;;718       * sum = x[0] * y[srcBlen - 2] + x[1] * y[srcBlen - 1]   
;;;719       * ....   
;;;720       * sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen - 1] * y[srcBLen - 1]   
;;;721       */
;;;722    
;;;723      /* In this stage the MAC operations are increased by 1 for every iteration.   
;;;724         The count variable holds the number of MAC operations performed */
;;;725      count = 1u;
;;;726    
;;;727      /* Working pointer of inputA */
;;;728      px = pIn1;
;;;729    
;;;730      /* Working pointer of inputB */
;;;731      pSrc1 = pIn2 + (srcBLen - 1u);
;;;732      py = pSrc1;
;;;733    
;;;734      /* ------------------------   
;;;735       * Stage1 process   
;;;736       * ----------------------*/
;;;737    
;;;738      /* The first loop starts here */
;;;739      while(blockSize1 > 0u)
;;;740      {
;;;741        /* Accumulator is made zero for every iteration */
;;;742        sum = 0;
;;;743    
;;;744        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;745        k = count >> 2;
;;;746    
;;;747        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;748         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;749        while(k > 0u)
;;;750        {
;;;751          /* x[0] * y[srcBLen - 4] , x[1] * y[srcBLen - 3] */
;;;752            sum += ((q31_t) * px++ * *py++);
;;;753            sum += ((q31_t) * px++ * *py++);
;;;754            sum += ((q31_t) * px++ * *py++);
;;;755            sum += ((q31_t) * px++ * *py++);
;;;756    
;;;757          /* Decrement the loop counter */
;;;758          k--;
;;;759        }
;;;760    
;;;761        /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;762         ** No loop unrolling is used. */
;;;763        k = count % 0x4u;
;;;764    
;;;765        while(k > 0u)
;;;766        {
;;;767          /* Perform the multiply-accumulates */
;;;768          /* x[0] * y[srcBLen - 1] */
;;;769            sum += ((q31_t) * px++ * *py++);
;;;770    
;;;771          /* Decrement the loop counter */
;;;772          k--;
;;;773        }
;;;774    
;;;775        /* Store the result in the accumulator in the destination buffer. */
;;;776        *pOut = (q15_t) (sum >> 15);
;;;777        /* Destination pointer is updated according to the address modifier, inc */
;;;778        pOut += inc;
;;;779    
;;;780        /* Update the inputA and inputB pointers for next MAC calculation */
;;;781        py = pSrc1 - count;
;;;782        px = pIn1;
;;;783    
;;;784        /* Increment the MAC count */
;;;785        count++;
;;;786    
;;;787        /* Decrement the loop counter */
;;;788        blockSize1--;
;;;789      }
;;;790    
;;;791      /* --------------------------   
;;;792       * Initializations of stage2   
;;;793       * ------------------------*/
;;;794    
;;;795      /* sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen-1] * y[srcBLen-1]   
;;;796       * sum = x[1] * y[0] + x[2] * y[1] +...+ x[srcBLen] * y[srcBLen-1]   
;;;797       * ....   
;;;798       * sum = x[srcALen-srcBLen-2] * y[0] + x[srcALen-srcBLen-1] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]   
;;;799       */
;;;800    
;;;801      /* Working pointer of inputA */
;;;802      px = pIn1;
;;;803    
;;;804      /* Working pointer of inputB */
;;;805      py = pIn2;
;;;806    
;;;807      /* count is index by which the pointer pIn1 to be incremented */
;;;808      count = 0u;
;;;809    
;;;810      /* -------------------   
;;;811       * Stage2 process   
;;;812       * ------------------*/
;;;813    
;;;814      /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.   
;;;815       * So, to loop unroll over blockSize2,   
;;;816       * srcBLen should be greater than or equal to 4, to loop unroll the srcBLen loop */
;;;817      if(srcBLen >= 4u)
;;;818      {
;;;819        /* Loop unroll over blockSize2, by 4 */
;;;820        blkCnt = blockSize2 >> 2u;
;;;821    
;;;822        while(blkCnt > 0u)
;;;823        {
;;;824          /* Set all accumulators to zero */
;;;825          acc0 = 0;
;;;826          acc1 = 0;
;;;827          acc2 = 0;
;;;828          acc3 = 0;
;;;829    
;;;830          /* read x[0], x[1], x[2] samples */
;;;831    	  a = *px;
;;;832    	  b = *(px + 1);
;;;833    
;;;834    #ifndef ARM_MATH_BIG_ENDIAN
;;;835    
;;;836    	  x0 = __PKHBT(a, b, 16);
;;;837    	  a = *(px + 2);
;;;838    	  x1 = __PKHBT(b, a, 16);
;;;839    
;;;840    #else
;;;841    
;;;842    	  x0 = __PKHBT(b, a, 16);
;;;843    	  a = *(px + 2);
;;;844    	  x1 = __PKHBT(a, b, 16);
;;;845    
;;;846    #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;847    
;;;848    	  px += 2u;
;;;849    
;;;850          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;851          k = srcBLen >> 2u;
;;;852    
;;;853          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;854           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;855          do
;;;856          {
;;;857            /* Read the first two inputB samples using SIMD:   
;;;858             * y[0] and y[1] */
;;;859    		  a = *py;
;;;860    		  b = *(py + 1);
;;;861    	
;;;862    #ifndef ARM_MATH_BIG_ENDIAN
;;;863    	
;;;864    		  c0 = __PKHBT(a, b, 16);
;;;865    	
;;;866    #else
;;;867    	
;;;868    		  c0 = __PKHBT(b, a, 16);
;;;869    	
;;;870    #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;871    
;;;872            /* acc0 +=  x[0] * y[0] + x[1] * y[1] */
;;;873            acc0 = __SMLAD(x0, c0, acc0);
;;;874    
;;;875            /* acc1 +=  x[1] * y[0] + x[2] * y[1] */
;;;876            acc1 = __SMLAD(x1, c0, acc1);
;;;877    
;;;878            /* Read x[2], x[3], x[4] */
;;;879    	  	a = *px;
;;;880    	  	b = *(px + 1);
;;;881    
;;;882    #ifndef ARM_MATH_BIG_ENDIAN
;;;883    
;;;884    	  	x2 = __PKHBT(a, b, 16);
;;;885    	  	a = *(px + 2);
;;;886    	  	x3 = __PKHBT(b, a, 16);
;;;887    
;;;888    #else
;;;889    
;;;890    	  	x2 = __PKHBT(b, a, 16);
;;;891    	  	a = *(px + 2);
;;;892    	  	x3 = __PKHBT(a, b, 16);
;;;893    
;;;894    #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;895    
;;;896            /* acc2 +=  x[2] * y[0] + x[3] * y[1] */
;;;897            acc2 = __SMLAD(x2, c0, acc2);
;;;898    
;;;899            /* acc3 +=  x[3] * y[0] + x[4] * y[1] */
;;;900            acc3 = __SMLAD(x3, c0, acc3);
;;;901    
;;;902            /* Read y[2] and y[3] */
;;;903    		  a = *(py + 2);
;;;904    		  b = *(py + 3);
;;;905    
;;;906    		  py += 4u;
;;;907    	
;;;908    #ifndef ARM_MATH_BIG_ENDIAN
;;;909    	
;;;910    		  c0 = __PKHBT(a, b, 16);
;;;911    	
;;;912    #else
;;;913    	
;;;914    		  c0 = __PKHBT(b, a, 16);
;;;915    	
;;;916    #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;917    
;;;918            /* acc0 +=  x[2] * y[2] + x[3] * y[3] */
;;;919            acc0 = __SMLAD(x2, c0, acc0);
;;;920    
;;;921            /* acc1 +=  x[3] * y[2] + x[4] * y[3] */
;;;922            acc1 = __SMLAD(x3, c0, acc1);
;;;923    
;;;924            /* Read x[4], x[5], x[6] */
;;;925    	  	a = *(px + 2);
;;;926    	  	b = *(px + 3);
;;;927    
;;;928    #ifndef ARM_MATH_BIG_ENDIAN
;;;929    
;;;930    	  	x0 = __PKHBT(a, b, 16);
;;;931    	  	a = *(px + 4);
;;;932    	  	x1 = __PKHBT(b, a, 16);
;;;933    
;;;934    #else
;;;935    
;;;936    	  	x0 = __PKHBT(b, a, 16);
;;;937    	  	a = *(px + 4);
;;;938    	  	x1 = __PKHBT(a, b, 16);
;;;939    
;;;940    #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;941    
;;;942    		px += 4u;
;;;943    
;;;944            /* acc2 +=  x[4] * y[2] + x[5] * y[3] */
;;;945            acc2 = __SMLAD(x0, c0, acc2);
;;;946    
;;;947            /* acc3 +=  x[5] * y[2] + x[6] * y[3] */
;;;948            acc3 = __SMLAD(x1, c0, acc3);
;;;949    
;;;950          } while(--k);
;;;951    
;;;952          /* For the next MAC operations, SIMD is not used   
;;;953           * So, the 16 bit pointer if inputB, py is updated */
;;;954    
;;;955          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;956           ** No loop unrolling is used. */
;;;957          k = srcBLen % 0x4u;
;;;958    
;;;959          if(k == 1u)
;;;960          {
;;;961            /* Read y[4] */
;;;962            c0 = *py;
;;;963    #ifdef  ARM_MATH_BIG_ENDIAN
;;;964    
;;;965            c0 = c0 << 16u;
;;;966    
;;;967    #else
;;;968    
;;;969            c0 = c0 & 0x0000FFFF;
;;;970    
;;;971    #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;972    
;;;973            /* Read x[7] */
;;;974    		a = *px;
;;;975    		b = *(px + 1);
;;;976    
;;;977    		px++;;
;;;978    	
;;;979    #ifndef ARM_MATH_BIG_ENDIAN
;;;980    	
;;;981    		x3 = __PKHBT(a, b, 16);
;;;982    	
;;;983    #else
;;;984    	
;;;985    		x3 = __PKHBT(b, a, 16);
;;;986    	
;;;987    #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;988    
;;;989    		px++;
;;;990    
;;;991            /* Perform the multiply-accumulates */
;;;992            acc0 = __SMLAD(x0, c0, acc0);
;;;993            acc1 = __SMLAD(x1, c0, acc1);
;;;994            acc2 = __SMLADX(x1, c0, acc2);
;;;995            acc3 = __SMLADX(x3, c0, acc3);
;;;996          }
;;;997    
;;;998          if(k == 2u)
;;;999          {
;;;1000           /* Read y[4], y[5] */
;;;1001   		  a = *py;
;;;1002   		  b = *(py + 1);
;;;1003   	
;;;1004   #ifndef ARM_MATH_BIG_ENDIAN
;;;1005   	
;;;1006   		  c0 = __PKHBT(a, b, 16);
;;;1007   	
;;;1008   #else
;;;1009   	
;;;1010   		  c0 = __PKHBT(b, a, 16);
;;;1011   	
;;;1012   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;1013   
;;;1014           /* Read x[7], x[8], x[9] */
;;;1015   	  	a = *px;
;;;1016   	  	b = *(px + 1);
;;;1017   
;;;1018   #ifndef ARM_MATH_BIG_ENDIAN
;;;1019   
;;;1020   	  	x3 = __PKHBT(a, b, 16);
;;;1021   	  	a = *(px + 2);
;;;1022   	  	x2 = __PKHBT(b, a, 16);
;;;1023   
;;;1024   #else
;;;1025   
;;;1026   	  	x3 = __PKHBT(b, a, 16);
;;;1027   	  	a = *(px + 2);
;;;1028   	  	x2 = __PKHBT(a, b, 16);
;;;1029   
;;;1030   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;1031   
;;;1032   		px += 2u;
;;;1033   
;;;1034           /* Perform the multiply-accumulates */
;;;1035           acc0 = __SMLAD(x0, c0, acc0);
;;;1036           acc1 = __SMLAD(x1, c0, acc1);
;;;1037           acc2 = __SMLAD(x3, c0, acc2);
;;;1038           acc3 = __SMLAD(x2, c0, acc3);
;;;1039         }
;;;1040   
;;;1041         if(k == 3u)
;;;1042         {
;;;1043           /* Read y[4], y[5] */
;;;1044   		  a = *py;
;;;1045   		  b = *(py + 1);
;;;1046   	
;;;1047   #ifndef ARM_MATH_BIG_ENDIAN
;;;1048   	
;;;1049   		  c0 = __PKHBT(a, b, 16);
;;;1050   	
;;;1051   #else
;;;1052   	
;;;1053   		  c0 = __PKHBT(b, a, 16);
;;;1054   	
;;;1055   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;1056   
;;;1057   		py += 2u;
;;;1058   
;;;1059           /* Read x[7], x[8], x[9] */
;;;1060   	  	a = *px;
;;;1061   	  	b = *(px + 1);
;;;1062   
;;;1063   #ifndef ARM_MATH_BIG_ENDIAN
;;;1064   
;;;1065   	  	x3 = __PKHBT(a, b, 16);
;;;1066   	  	a = *(px + 2);
;;;1067   	  	x2 = __PKHBT(b, a, 16);
;;;1068   
;;;1069   #else
;;;1070   
;;;1071   	  	x3 = __PKHBT(b, a, 16);
;;;1072   	  	a = *(px + 2);
;;;1073   	  	x2 = __PKHBT(a, b, 16);
;;;1074   
;;;1075   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;1076   
;;;1077           /* Perform the multiply-accumulates */
;;;1078           acc0 = __SMLAD(x0, c0, acc0);
;;;1079           acc1 = __SMLAD(x1, c0, acc1);
;;;1080           acc2 = __SMLAD(x3, c0, acc2);
;;;1081           acc3 = __SMLAD(x2, c0, acc3);
;;;1082   
;;;1083           c0 = (*py);
;;;1084           /* Read y[6] */
;;;1085   #ifdef  ARM_MATH_BIG_ENDIAN
;;;1086   
;;;1087           c0 = c0 << 16u;
;;;1088   #else
;;;1089   
;;;1090           c0 = c0 & 0x0000FFFF;
;;;1091   #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;1092   
;;;1093           /* Read x[10] */
;;;1094   		b = *(px + 3);
;;;1095   	
;;;1096   #ifndef ARM_MATH_BIG_ENDIAN
;;;1097   	
;;;1098   		x3 = __PKHBT(a, b, 16);
;;;1099   	
;;;1100   #else
;;;1101   	
;;;1102   		x3 = __PKHBT(b, a, 16);
;;;1103   	
;;;1104   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;1105   
;;;1106   		px += 3u;
;;;1107   
;;;1108           /* Perform the multiply-accumulates */
;;;1109           acc0 = __SMLADX(x1, c0, acc0);
;;;1110           acc1 = __SMLAD(x2, c0, acc1);
;;;1111           acc2 = __SMLADX(x2, c0, acc2);
;;;1112           acc3 = __SMLADX(x3, c0, acc3);
;;;1113         }
;;;1114   
;;;1115         /* Store the result in the accumulator in the destination buffer. */
;;;1116         *pOut = (q15_t) (acc0 >> 15);
;;;1117         /* Destination pointer is updated according to the address modifier, inc */
;;;1118         pOut += inc;
;;;1119   
;;;1120         *pOut = (q15_t) (acc1 >> 15);
;;;1121         pOut += inc;
;;;1122   
;;;1123         *pOut = (q15_t) (acc2 >> 15);
;;;1124         pOut += inc;
;;;1125   
;;;1126         *pOut = (q15_t) (acc3 >> 15);
;;;1127         pOut += inc;
;;;1128   
;;;1129         /* Increment the pointer pIn1 index, count by 1 */
;;;1130         count += 4u;
;;;1131   
;;;1132         /* Update the inputA and inputB pointers for next MAC calculation */
;;;1133         px = pIn1 + count;
;;;1134         py = pIn2;
;;;1135   
;;;1136   
;;;1137         /* Decrement the loop counter */
;;;1138         blkCnt--;
;;;1139       }
;;;1140   
;;;1141       /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.   
;;;1142        ** No loop unrolling is used. */
;;;1143       blkCnt = blockSize2 % 0x4u;
;;;1144   
;;;1145       while(blkCnt > 0u)
;;;1146       {
;;;1147         /* Accumulator is made zero for every iteration */
;;;1148         sum = 0;
;;;1149   
;;;1150         /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;1151         k = srcBLen >> 2u;
;;;1152   
;;;1153         /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;1154          ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;1155         while(k > 0u)
;;;1156         {
;;;1157           /* Perform the multiply-accumulates */
;;;1158           sum += ((q31_t) * px++ * *py++);
;;;1159           sum += ((q31_t) * px++ * *py++);
;;;1160           sum += ((q31_t) * px++ * *py++);
;;;1161           sum += ((q31_t) * px++ * *py++);
;;;1162   
;;;1163           /* Decrement the loop counter */
;;;1164           k--;
;;;1165         }
;;;1166   
;;;1167         /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;1168          ** No loop unrolling is used. */
;;;1169         k = srcBLen % 0x4u;
;;;1170   
;;;1171         while(k > 0u)
;;;1172         {
;;;1173           /* Perform the multiply-accumulates */
;;;1174           sum += ((q31_t) * px++ * *py++);
;;;1175   
;;;1176           /* Decrement the loop counter */
;;;1177           k--;
;;;1178         }
;;;1179   
;;;1180         /* Store the result in the accumulator in the destination buffer. */
;;;1181         *pOut = (q15_t) (sum >> 15);
;;;1182         /* Destination pointer is updated according to the address modifier, inc */
;;;1183         pOut += inc;
;;;1184   
;;;1185         /* Increment the pointer pIn1 index, count by 1 */
;;;1186         count++;
;;;1187   
;;;1188         /* Update the inputA and inputB pointers for next MAC calculation */
;;;1189         px = pIn1 + count;
;;;1190         py = pIn2;
;;;1191   
;;;1192         /* Decrement the loop counter */
;;;1193         blkCnt--;
;;;1194       }
;;;1195     }
;;;1196     else
;;;1197     {
;;;1198       /* If the srcBLen is not a multiple of 4,   
;;;1199        * the blockSize2 loop cannot be unrolled by 4 */
;;;1200       blkCnt = blockSize2;
;;;1201   
;;;1202       while(blkCnt > 0u)
;;;1203       {
;;;1204         /* Accumulator is made zero for every iteration */
;;;1205         sum = 0;
;;;1206   
;;;1207         /* Loop over srcBLen */
;;;1208         k = srcBLen;
;;;1209   
;;;1210         while(k > 0u)
;;;1211         {
;;;1212           /* Perform the multiply-accumulate */
;;;1213           sum += ((q31_t) * px++ * *py++);
;;;1214   
;;;1215           /* Decrement the loop counter */
;;;1216           k--;
;;;1217         }
;;;1218   
;;;1219         /* Store the result in the accumulator in the destination buffer. */
;;;1220         *pOut = (q15_t) (sum >> 15);
;;;1221         /* Destination pointer is updated according to the address modifier, inc */
;;;1222         pOut += inc;
;;;1223   
;;;1224         /* Increment the MAC count */
;;;1225         count++;
;;;1226   
;;;1227         /* Update the inputA and inputB pointers for next MAC calculation */
;;;1228         px = pIn1 + count;
;;;1229         py = pIn2;
;;;1230   
;;;1231         /* Decrement the loop counter */
;;;1232         blkCnt--;
;;;1233       }
;;;1234     }
;;;1235   
;;;1236     /* --------------------------   
;;;1237      * Initializations of stage3   
;;;1238      * -------------------------*/
;;;1239   
;;;1240     /* sum += x[srcALen-srcBLen+1] * y[0] + x[srcALen-srcBLen+2] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]   
;;;1241      * sum += x[srcALen-srcBLen+2] * y[0] + x[srcALen-srcBLen+3] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]   
;;;1242      * ....   
;;;1243      * sum +=  x[srcALen-2] * y[0] + x[srcALen-1] * y[1]   
;;;1244      * sum +=  x[srcALen-1] * y[0]   
;;;1245      */
;;;1246   
;;;1247     /* In this stage the MAC operations are decreased by 1 for every iteration.   
;;;1248        The count variable holds the number of MAC operations performed */
;;;1249     count = srcBLen - 1u;
;;;1250   
;;;1251     /* Working pointer of inputA */
;;;1252     pSrc1 = (pIn1 + srcALen) - (srcBLen - 1u);
;;;1253     px = pSrc1;
;;;1254   
;;;1255     /* Working pointer of inputB */
;;;1256     py = pIn2;
;;;1257   
;;;1258     /* -------------------   
;;;1259      * Stage3 process   
;;;1260      * ------------------*/
;;;1261   
;;;1262     while(blockSize3 > 0u)
;;;1263     {
;;;1264       /* Accumulator is made zero for every iteration */
;;;1265       sum = 0;
;;;1266   
;;;1267       /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;1268       k = count >> 2u;
;;;1269   
;;;1270       /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;1271        ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;1272       while(k > 0u)
;;;1273       {
;;;1274         /* Perform the multiply-accumulates */
;;;1275           sum += ((q31_t) * px++ * *py++);
;;;1276           sum += ((q31_t) * px++ * *py++);
;;;1277           sum += ((q31_t) * px++ * *py++);
;;;1278           sum += ((q31_t) * px++ * *py++);
;;;1279   
;;;1280         /* Decrement the loop counter */
;;;1281         k--;
;;;1282       }
;;;1283   
;;;1284       /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;1285        ** No loop unrolling is used. */
;;;1286       k = count % 0x4u;
;;;1287   
;;;1288       while(k > 0u)
;;;1289       {
;;;1290         /* Perform the multiply-accumulates */
;;;1291           sum += ((q31_t) * px++ * *py++);
;;;1292   
;;;1293         /* Decrement the loop counter */
;;;1294         k--;
;;;1295       }
;;;1296   
;;;1297       /* Store the result in the accumulator in the destination buffer. */
;;;1298       *pOut = (q15_t) (sum >> 15);
;;;1299       /* Destination pointer is updated according to the address modifier, inc */
;;;1300       pOut += inc;
;;;1301   
;;;1302       /* Update the inputA and inputB pointers for next MAC calculation */
;;;1303       px = ++pSrc1;
;;;1304       py = pIn2;
;;;1305   
;;;1306       /* Decrement the MAC count */
;;;1307       count--;
;;;1308   
;;;1309       /* Decrement the loop counter */
;;;1310       blockSize3--;
;;;1311     }
;;;1312   
;;;1313   #endif /*   #ifndef UNALIGNED_SUPPORT_DISABLE */
;;;1314   
;;;1315   }
00030e  b00e              ADD      sp,sp,#0x38
000310  e8bd8ff0          POP      {r4-r11,pc}
;;;1316   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_correlate_fast_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_correlate_fast_q15_c_ec63ef05____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___24_arm_correlate_fast_q15_c_ec63ef05____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_correlate_fast_q15_c_ec63ef05____REVSH|
#line 144
|__asm___24_arm_correlate_fast_q15_c_ec63ef05____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_correlate_fast_q15_c_ec63ef05____RRX|
#line 300
|__asm___24_arm_correlate_fast_q15_c_ec63ef05____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
