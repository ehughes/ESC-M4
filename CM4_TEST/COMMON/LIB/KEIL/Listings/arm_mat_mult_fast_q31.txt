; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_mult_fast_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_mult_fast_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_mat_mult_fast_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\MatrixFunctions\arm_mat_mult_fast_q31.c]
                          THUMB

                          AREA ||i.arm_mat_mult_fast_q31||, CODE, READONLY, ALIGN=1

                  arm_mat_mult_fast_q31 PROC
;;;82     
;;;83     arm_status arm_mat_mult_fast_q31(
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;84       const arm_matrix_instance_q31 * pSrcA,
;;;85       const arm_matrix_instance_q31 * pSrcB,
;;;86       arm_matrix_instance_q31 * pDst)
;;;87     {
000004  b085              SUB      sp,sp,#0x14
;;;88       q31_t *pIn1 = pSrcA->pData;                    /* input data matrix pointer A */
000006  f8d0c004          LDR      r12,[r0,#4]
;;;89       q31_t *pIn2 = pSrcB->pData;                    /* input data matrix pointer B */
;;;90       q31_t *pInA = pSrcA->pData;                    /* input data matrix pointer A */
;;;91     //  q31_t *pSrcB = pSrcB->pData;                    /* input data matrix pointer B */    
;;;92       q31_t *pOut = pDst->pData;                     /* output data matrix pointer */
00000a  6851              LDR      r1,[r2,#4]
00000c  9103              STR      r1,[sp,#0xc]
;;;93       q31_t *px;                                     /* Temporary output data matrix pointer */
;;;94       q31_t sum;                                     /* Accumulator */
;;;95       uint16_t numRowsA = pSrcA->numRows;            /* number of rows of input matrix A    */
00000e  8801              LDRH     r1,[r0,#0]
;;;96       uint16_t numColsB = pSrcB->numCols;            /* number of columns of input matrix B */
000010  9a06              LDR      r2,[sp,#0x18]
000012  8852              LDRH     r2,[r2,#2]
;;;97       uint16_t numColsA = pSrcA->numCols;            /* number of columns of input matrix A */
000014  8840              LDRH     r0,[r0,#2]
000016  9002              STR      r0,[sp,#8]
;;;98       uint16_t col, i = 0u, j, row = numRowsA, colCnt;      /* loop counters */
000018  2000              MOVS     r0,#0
00001a  9001              STR      r0,[sp,#4]
00001c  9100              STR      r1,[sp,#0]
;;;99       arm_status status;                             /* status of matrix multiplication */
;;;100      q31_t inA1, inA2, inA3, inA4, inB1, inB2, inB3, inB4;
;;;101    
;;;102    #ifdef ARM_MATH_MATRIX_CHECK
;;;103    
;;;104    
;;;105      /* Check for matrix mismatch condition */
;;;106      if((pSrcA->numCols != pSrcB->numRows) ||
;;;107         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;108      {
;;;109        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;110        status = ARM_MATH_SIZE_MISMATCH;
;;;111      }
;;;112      else
;;;113    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;114    
;;;115      {
;;;116        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;117        /* row loop */
;;;118        do
;;;119        {
;;;120          /* Output pointer is set to starting address of the row being processed */
;;;121          px = pOut + i;
;;;122    
;;;123          /* For every row wise process, the column loop counter is to be initiated */
;;;124          col = numColsB;
;;;125    
;;;126          /* For every row wise process, the pIn2 pointer is set    
;;;127           ** to the starting address of the pSrcB data */
;;;128          pIn2 = pSrcB->pData;
;;;129    
;;;130          j = 0u;
;;;131    
;;;132          /* column loop */
;;;133          do
;;;134          {
;;;135            /* Set the variable sum, that acts as accumulator, to zero */
;;;136            sum = 0;
;;;137    
;;;138            /* Initiate the pointer pIn1 to point to the starting address of pInA */
;;;139            pIn1 = pInA;
;;;140    
;;;141            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;142            colCnt = numColsA >> 2;
00001e  9802              LDR      r0,[sp,#8]
000020  0880              LSRS     r0,r0,#2
000022  9004              STR      r0,[sp,#0x10]
                  |L1.36|
000024  9901              LDR      r1,[sp,#4]            ;121
000026  9803              LDR      r0,[sp,#0xc]          ;121
000028  eb000781          ADD      r7,r0,r1,LSL #2       ;121
00002c  4615              MOV      r5,r2                 ;124
00002e  9806              LDR      r0,[sp,#0x18]         ;128
000030  6840              LDR      r0,[r0,#4]            ;128
000032  2600              MOVS     r6,#0                 ;130
                  |L1.52|
000034  2300              MOVS     r3,#0                 ;136
000036  4661              MOV      r1,r12                ;139
000038  9c04              LDR      r4,[sp,#0x10]
;;;143    
;;;144    
;;;145            /* matrix multiplication */
;;;146            while(colCnt > 0u)
00003a  e021              B        |L1.128|
                  |L1.60|
;;;147            {
;;;148              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;149              /* Perform the multiply-accumulates */
;;;150              inB1 = *pIn2;
00003c  f8d08000          LDR      r8,[r0,#0]
;;;151              pIn2 += numColsB;
000040  eb000082          ADD      r0,r0,r2,LSL #2
;;;152    
;;;153              inA1 = pIn1[0];
000044  f8d1a000          LDR      r10,[r1,#0]
;;;154              inA2 = pIn1[1];
000048  f8d1b004          LDR      r11,[r1,#4]
;;;155    
;;;156              inB2 = *pIn2;
00004c  f8d0e000          LDR      lr,[r0,#0]
;;;157              pIn2 += numColsB;
000050  eb000082          ADD      r0,r0,r2,LSL #2
;;;158    
;;;159              inB3 = *pIn2;
000054  f8d09000          LDR      r9,[r0,#0]
;;;160              pIn2 += numColsB;
000058  eb000082          ADD      r0,r0,r2,LSL #2
;;;161    
;;;162              sum = (q31_t) ((((q63_t) sum << 32) + ((q63_t) inA1 * inB1)) >> 32);
00005c  fb5a3308          SMMLA    r3,r10,r8,r3
;;;163              sum = (q31_t) ((((q63_t) sum << 32) + ((q63_t) inA2 * inB2)) >> 32);
000060  fb5b3b0e          SMMLA    r11,r11,lr,r3
;;;164    
;;;165              inA3 = pIn1[2];
000064  688b              LDR      r3,[r1,#8]
;;;166              inA4 = pIn1[3];
000066  f8d1800c          LDR      r8,[r1,#0xc]
;;;167    
;;;168              inB4 = *pIn2;
00006a  f8d0a000          LDR      r10,[r0,#0]
;;;169              pIn2 += numColsB;
00006e  eb000082          ADD      r0,r0,r2,LSL #2
;;;170    
;;;171              sum = (q31_t) ((((q63_t) sum << 32) + ((q63_t) inA3 * inB3)) >> 32);
000072  fb53b309          SMMLA    r3,r3,r9,r11
;;;172              sum = (q31_t) ((((q63_t) sum << 32) + ((q63_t) inA4 * inB4)) >> 32);
000076  fb58330a          SMMLA    r3,r8,r10,r3
;;;173    
;;;174              pIn1 += 4u;
00007a  3110              ADDS     r1,r1,#0x10
;;;175    
;;;176              /* Decrement the loop counter */
;;;177              colCnt--;
00007c  1e64              SUBS     r4,r4,#1
00007e  b2a4              UXTH     r4,r4
                  |L1.128|
000080  2c00              CMP      r4,#0                 ;146
000082  d1db              BNE      |L1.60|
;;;178            }
;;;179    
;;;180            /* If the columns of pSrcA is not a multiple of 4, compute any remaining output samples here.    
;;;181             ** No loop unrolling is used. */
;;;182            colCnt = numColsA % 0x4u;
000084  9c02              LDR      r4,[sp,#8]
000086  f0040403          AND      r4,r4,#3
;;;183    
;;;184            while(colCnt > 0u)
00008a  e009              B        |L1.160|
                  |L1.140|
;;;185            {
;;;186              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;187              /* Perform the multiply-accumulates */
;;;188              sum = (q31_t) ((((q63_t) sum << 32) +
00008c  f8518b04          LDR      r8,[r1],#4
000090  f8d09000          LDR      r9,[r0,#0]
000094  fb583309          SMMLA    r3,r8,r9,r3
;;;189                              ((q63_t) * pIn1++ * (*pIn2))) >> 32);
;;;190              pIn2 += numColsB;
000098  eb000082          ADD      r0,r0,r2,LSL #2
;;;191    
;;;192              /* Decrement the loop counter */
;;;193              colCnt--;
00009c  1e64              SUBS     r4,r4,#1
00009e  b2a4              UXTH     r4,r4
                  |L1.160|
0000a0  2c00              CMP      r4,#0                 ;184
0000a2  d1f3              BNE      |L1.140|
;;;194            }
;;;195    
;;;196            /* Convert the result from 2.30 to 1.31 format and store in destination buffer */
;;;197            *px++ = sum << 1;
0000a4  0058              LSLS     r0,r3,#1
0000a6  c701              STM      r7!,{r0}
;;;198    
;;;199            /* Update the pointer pIn2 to point to the  starting address of the next column */
;;;200            j++;
0000a8  1c76              ADDS     r6,r6,#1
0000aa  b2b6              UXTH     r6,r6
;;;201            pIn2 = pSrcB->pData + j;
0000ac  9806              LDR      r0,[sp,#0x18]
0000ae  6840              LDR      r0,[r0,#4]
0000b0  eb000086          ADD      r0,r0,r6,LSL #2
;;;202    
;;;203            /* Decrement the column loop counter */
;;;204            col--;
0000b4  1e6d              SUBS     r5,r5,#1
0000b6  b2ad              UXTH     r5,r5
;;;205    
;;;206          } while(col > 0u);
0000b8  2d00              CMP      r5,#0
0000ba  d1bb              BNE      |L1.52|
;;;207    
;;;208          /* Update the pointer pInA to point to the  starting address of the next row */
;;;209          i = i + numColsB;
0000bc  9801              LDR      r0,[sp,#4]
0000be  4410              ADD      r0,r0,r2
0000c0  b280              UXTH     r0,r0
0000c2  9001              STR      r0,[sp,#4]
;;;210          pInA = pInA + numColsA;
0000c4  9802              LDR      r0,[sp,#8]
0000c6  eb0c0c80          ADD      r12,r12,r0,LSL #2
;;;211    
;;;212          /* Decrement the row loop counter */
;;;213          row--;
0000ca  9800              LDR      r0,[sp,#0]
0000cc  1e40              SUBS     r0,r0,#1
0000ce  b280              UXTH     r0,r0
0000d0  9000              STR      r0,[sp,#0]
;;;214    
;;;215        } while(row > 0u);
0000d2  9800              LDR      r0,[sp,#0]
0000d4  2800              CMP      r0,#0
0000d6  d1a5              BNE      |L1.36|
;;;216    
;;;217        /* set status as ARM_MATH_SUCCESS */
;;;218        status = ARM_MATH_SUCCESS;
;;;219      }
;;;220      /* Return to application */
;;;221      return (status);
;;;222    }
0000d8  b008              ADD      sp,sp,#0x20
0000da  e8bd8ff0          POP      {r4-r11,pc}
;;;223    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\MatrixFunctions\\arm_mat_mult_fast_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_mat_mult_fast_q31_c_a938e5df____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___23_arm_mat_mult_fast_q31_c_a938e5df____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_mat_mult_fast_q31_c_a938e5df____REVSH|
#line 144
|__asm___23_arm_mat_mult_fast_q31_c_a938e5df____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_mat_mult_fast_q31_c_a938e5df____RRX|
#line 300
|__asm___23_arm_mat_mult_fast_q31_c_a938e5df____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
