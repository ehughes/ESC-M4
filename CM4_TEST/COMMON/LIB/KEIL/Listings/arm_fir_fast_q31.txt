; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_fast_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_fast_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_fir_fast_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_fir_fast_q31.c]
                          THUMB

                          AREA ||i.arm_fir_fast_q31||, CODE, READONLY, ALIGN=1

                  arm_fir_fast_q31 PROC
;;;74     IAR_ONLY_LOW_OPTIMIZATION_ENTER
;;;75     void arm_fir_fast_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;76       const arm_fir_instance_q31 * S,
;;;77       q31_t * pSrc,
;;;78       q31_t * pDst,
;;;79       uint32_t blockSize)
;;;80     {
000004  b087              SUB      sp,sp,#0x1c
;;;81       q31_t *pState = S->pState;                     /* State pointer */
000006  9807              LDR      r0,[sp,#0x1c]
000008  6844              LDR      r4,[r0,#4]
;;;82       q31_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
00000a  9807              LDR      r0,[sp,#0x1c]
00000c  6880              LDR      r0,[r0,#8]
00000e  9006              STR      r0,[sp,#0x18]
;;;83       q31_t *pStateCurnt;                            /* Points to the current sample of the state */
;;;84       q31_t x0, x1, x2, x3;                          /* Temporary variables to hold state */
;;;85       q31_t c0;                                      /* Temporary variable to hold coefficient value */
;;;86       q31_t *px;                                     /* Temporary pointer for state */
;;;87       q31_t *pb;                                     /* Temporary pointer for coefficient buffer */
;;;88       q31_t acc0, acc1, acc2, acc3;                  /* Accumulators */
;;;89       uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
000010  9807              LDR      r0,[sp,#0x1c]
000012  8800              LDRH     r0,[r0,#0]
000014  9002              STR      r0,[sp,#8]
;;;90       uint32_t i, tapCnt, blkCnt;                    /* Loop counters */
;;;91     
;;;92       /* S->pState points to buffer which contains previous frame (numTaps - 1) samples */
;;;93       /* pStateCurnt points to the location where the new input data should be written */
;;;94       pStateCurnt = &(S->pState[(numTaps - 1u)]);
000016  9802              LDR      r0,[sp,#8]
000018  1e40              SUBS     r0,r0,#1
00001a  eb040a80          ADD      r10,r4,r0,LSL #2
;;;95     
;;;96       /* Apply loop unrolling and compute 4 output values simultaneously.    
;;;97        * The variables acc0 ... acc3 hold output values that are being computed:    
;;;98        *    
;;;99        *    acc0 =  b[numTaps-1] * x[n-numTaps-1] + b[numTaps-2] * x[n-numTaps-2] + b[numTaps-3] * x[n-numTaps-3] +...+ b[0] * x[0]    
;;;100       *    acc1 =  b[numTaps-1] * x[n-numTaps] +   b[numTaps-2] * x[n-numTaps-1] + b[numTaps-3] * x[n-numTaps-2] +...+ b[0] * x[1]    
;;;101       *    acc2 =  b[numTaps-1] * x[n-numTaps+1] + b[numTaps-2] * x[n-numTaps] +   b[numTaps-3] * x[n-numTaps-1] +...+ b[0] * x[2]    
;;;102       *    acc3 =  b[numTaps-1] * x[n-numTaps+2] + b[numTaps-2] * x[n-numTaps+1] + b[numTaps-3] * x[n-numTaps]   +...+ b[0] * x[3]    
;;;103       */
;;;104      blkCnt = blockSize >> 2;
00001e  980a              LDR      r0,[sp,#0x28]
000020  0880              LSRS     r0,r0,#2
000022  9000              STR      r0,[sp,#0]
000024  e09a              B        |L1.348|
                  |L1.38|
;;;105    
;;;106      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;107       ** a second loop below computes the remaining 1 to 3 samples. */
;;;108      while(blkCnt > 0u)
;;;109      {
;;;110        /* Copy four new input samples into the state buffer */
;;;111        *pStateCurnt++ = *pSrc++;
000026  9808              LDR      r0,[sp,#0x20]
000028  6800              LDR      r0,[r0,#0]
00002a  f84a0b04          STR      r0,[r10],#4
00002e  9808              LDR      r0,[sp,#0x20]
;;;112        *pStateCurnt++ = *pSrc++;
000030  6841              LDR      r1,[r0,#4]
000032  f84a1b04          STR      r1,[r10],#4
;;;113        *pStateCurnt++ = *pSrc++;
000036  6881              LDR      r1,[r0,#8]
000038  f84a1b04          STR      r1,[r10],#4
;;;114        *pStateCurnt++ = *pSrc++;
00003c  68c1              LDR      r1,[r0,#0xc]
00003e  3010              ADDS     r0,r0,#0x10
000040  f84a1b04          STR      r1,[r10],#4
000044  9008              STR      r0,[sp,#0x20]
;;;115    
;;;116        /* Set all accumulators to zero */
;;;117        acc0 = 0;
000046  2500              MOVS     r5,#0
;;;118        acc1 = 0;
000048  2600              MOVS     r6,#0
;;;119        acc2 = 0;
00004a  2700              MOVS     r7,#0
;;;120        acc3 = 0;
00004c  46ac              MOV      r12,r5
;;;121    
;;;122        /* Initialize state pointer */
;;;123        px = pState;
00004e  4620              MOV      r0,r4
;;;124    
;;;125        /* Initialize coefficient pointer */
;;;126        pb = pCoeffs;
000050  9906              LDR      r1,[sp,#0x18]
;;;127    
;;;128        /* Read the first three samples from the state buffer:    
;;;129         *  x[n-numTaps], x[n-numTaps-1], x[n-numTaps-2] */
;;;130        x0 = *(px++);
000052  f8d0b000          LDR      r11,[r0,#0]
;;;131        x1 = *(px++);
000056  6842              LDR      r2,[r0,#4]
;;;132        x2 = *(px++);
000058  6883              LDR      r3,[r0,#8]
00005a  300c              ADDS     r0,r0,#0xc
;;;133    
;;;134        /* Loop unrolling.  Process 4 taps at a time. */
;;;135        tapCnt = numTaps >> 2;
00005c  f8dd8008          LDR      r8,[sp,#8]
000060  ea4f0e98          LSR      lr,r8,#2
000064  f8cde004          STR      lr,[sp,#4]
;;;136        i = tapCnt;
000068  f8dde004          LDR      lr,[sp,#4]
;;;137    
;;;138        while(i > 0u)
00006c  e045              B        |L1.250|
                  |L1.110|
;;;139        {
;;;140          /* Read the b[numTaps] coefficient */
;;;141          c0 = *pb;
00006e  f8d19000          LDR      r9,[r1,#0]
;;;142    
;;;143          /* Read x[n-numTaps-3] sample */
;;;144          x3 = *px;
000072  f8d08000          LDR      r8,[r0,#0]
;;;145    
;;;146          /* acc0 +=  b[numTaps] * x[n-numTaps] */
;;;147          multAcc_32x32_keep32_R(acc0, x0, c0);
000076  fb5b5519          SMMLAR   r5,r11,r9,r5
;;;148    
;;;149          /* acc1 +=  b[numTaps] * x[n-numTaps-1] */
;;;150          multAcc_32x32_keep32_R(acc1, x1, c0);
00007a  fb526619          SMMLAR   r6,r2,r9,r6
;;;151    
;;;152          /* acc2 +=  b[numTaps] * x[n-numTaps-2] */
;;;153          multAcc_32x32_keep32_R(acc2, x2, c0);
00007e  fb537719          SMMLAR   r7,r3,r9,r7
000082  9704              STR      r7,[sp,#0x10]
;;;154    
;;;155          /* acc3 +=  b[numTaps] * x[n-numTaps-3] */
;;;156          multAcc_32x32_keep32_R(acc3, x3, c0);
000084  fb58c919          SMMLAR   r9,r8,r9,r12
000088  f8cd900c          STR      r9,[sp,#0xc]
;;;157    
;;;158          /* Read the b[numTaps-1] coefficient */
;;;159          c0 = *(pb + 1u);
00008c  684f              LDR      r7,[r1,#4]
;;;160    
;;;161          /* Read x[n-numTaps-4] sample */
;;;162          x0 = *(px + 1u);
00008e  f8d0b004          LDR      r11,[r0,#4]
;;;163    
;;;164          /* Perform the multiply-accumulates */      
;;;165          multAcc_32x32_keep32_R(acc0, x1, c0);
000092  fb525c17          SMMLAR   r12,r2,r7,r5
;;;166          multAcc_32x32_keep32_R(acc1, x2, c0);
000096  fb536617          SMMLAR   r6,r3,r7,r6
;;;167          multAcc_32x32_keep32_R(acc2, x3, c0);
00009a  9a04              LDR      r2,[sp,#0x10]
00009c  fb582917          SMMLAR   r9,r8,r7,r2
0000a0  f8cd9010          STR      r9,[sp,#0x10]
;;;168          multAcc_32x32_keep32_R(acc3, x0, c0);
0000a4  f8dd900c          LDR      r9,[sp,#0xc]
0000a8  fb5b9917          SMMLAR   r9,r11,r7,r9
0000ac  f8cd900c          STR      r9,[sp,#0xc]
;;;169    
;;;170          /* Read the b[numTaps-2] coefficient */
;;;171          c0 = *(pb + 2u);
0000b0  688d              LDR      r5,[r1,#8]
;;;172    
;;;173          /* Read x[n-numTaps-5] sample */
;;;174          x1 = *(px + 2u);
0000b2  6882              LDR      r2,[r0,#8]
;;;175    
;;;176          /* Perform the multiply-accumulates */      
;;;177          multAcc_32x32_keep32_R(acc0, x2, c0);
0000b4  fb53c915          SMMLAR   r9,r3,r5,r12
0000b8  f8cd9014          STR      r9,[sp,#0x14]
;;;178          multAcc_32x32_keep32_R(acc1, x3, c0);
0000bc  fb586615          SMMLAR   r6,r8,r5,r6
;;;179          multAcc_32x32_keep32_R(acc2, x0, c0);
0000c0  f8dd9010          LDR      r9,[sp,#0x10]
0000c4  fb5b9715          SMMLAR   r7,r11,r5,r9
;;;180          multAcc_32x32_keep32_R(acc3, x1, c0);
0000c8  f8dd900c          LDR      r9,[sp,#0xc]
0000cc  fb529915          SMMLAR   r9,r2,r5,r9
0000d0  f8cd900c          STR      r9,[sp,#0xc]
;;;181    
;;;182          /* Read the b[numTaps-3] coefficients */
;;;183          c0 = *(pb + 3u);
0000d4  f8d1c00c          LDR      r12,[r1,#0xc]
;;;184    
;;;185          /* Read x[n-numTaps-6] sample */
;;;186          x2 = *(px + 3u);
0000d8  68c3              LDR      r3,[r0,#0xc]
;;;187    
;;;188          /* Perform the multiply-accumulates */      
;;;189          multAcc_32x32_keep32_R(acc0, x3, c0);
0000da  f8dd9014          LDR      r9,[sp,#0x14]
0000de  fb58951c          SMMLAR   r5,r8,r12,r9
;;;190          multAcc_32x32_keep32_R(acc1, x0, c0);
0000e2  fb5b661c          SMMLAR   r6,r11,r12,r6
;;;191          multAcc_32x32_keep32_R(acc2, x1, c0);
0000e6  fb52771c          SMMLAR   r7,r2,r12,r7
;;;192          multAcc_32x32_keep32_R(acc3, x2, c0);
0000ea  f8dd900c          LDR      r9,[sp,#0xc]
0000ee  fb539c1c          SMMLAR   r12,r3,r12,r9
;;;193    
;;;194          /* update coefficient pointer */
;;;195          pb += 4u;
0000f2  3110              ADDS     r1,r1,#0x10
;;;196          px += 4u;
0000f4  3010              ADDS     r0,r0,#0x10
;;;197          
;;;198          /* Decrement the loop counter */
;;;199          i--;
0000f6  f1ae0e01          SUB      lr,lr,#1
                  |L1.250|
0000fa  f1be0f00          CMP      lr,#0                 ;138
0000fe  d1b6              BNE      |L1.110|
;;;200        }
;;;201    
;;;202        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;203    
;;;204        i = numTaps - (tapCnt * 4u);
000100  f8dd8004          LDR      r8,[sp,#4]
000104  f1c80900          RSB      r9,r8,#0
000108  f8dd8008          LDR      r8,[sp,#8]
00010c  eb080989          ADD      r9,r8,r9,LSL #2
;;;205        while(i > 0u)
000110  e010              B        |L1.308|
                  |L1.274|
;;;206        {
;;;207          /* Read coefficients */
;;;208          c0 = *(pb++);
000112  f8518b04          LDR      r8,[r1],#4
;;;209    
;;;210          /* Fetch 1 state variable */
;;;211          x3 = *(px++);
000116  f850eb04          LDR      lr,[r0],#4
;;;212    
;;;213          /* Perform the multiply-accumulates */      
;;;214          multAcc_32x32_keep32_R(acc0, x0, c0);
00011a  fb5b5518          SMMLAR   r5,r11,r8,r5
;;;215          multAcc_32x32_keep32_R(acc1, x1, c0);
00011e  fb526618          SMMLAR   r6,r2,r8,r6
;;;216          multAcc_32x32_keep32_R(acc2, x2, c0);
000122  fb537718          SMMLAR   r7,r3,r8,r7
;;;217          multAcc_32x32_keep32_R(acc3, x3, c0);
000126  fb5ecc18          SMMLAR   r12,lr,r8,r12
;;;218    
;;;219          /* Reuse the present sample states for next sample */
;;;220          x0 = x1;
00012a  4693              MOV      r11,r2
;;;221          x1 = x2;
00012c  461a              MOV      r2,r3
;;;222          x2 = x3;
00012e  4673              MOV      r3,lr
;;;223    
;;;224          /* Decrement the loop counter */
;;;225          i--;
000130  f1a90901          SUB      r9,r9,#1
                  |L1.308|
000134  f1b90f00          CMP      r9,#0                 ;205
000138  d1eb              BNE      |L1.274|
;;;226        }
;;;227    
;;;228        /* Advance the state pointer by 4 to process the next group of 4 samples */
;;;229        pState = pState + 4;
00013a  3410              ADDS     r4,r4,#0x10
;;;230    
;;;231        /* The results in the 4 accumulators are in 2.30 format.  Convert to 1.31    
;;;232         ** Then store the 4 outputs in the destination buffer. */
;;;233        *pDst++ = (q31_t) (acc0 << 1);
00013c  9809              LDR      r0,[sp,#0x24]
00013e  0069              LSLS     r1,r5,#1
000140  6001              STR      r1,[r0,#0]
000142  9809              LDR      r0,[sp,#0x24]
;;;234        *pDst++ = (q31_t) (acc1 << 1);
000144  0071              LSLS     r1,r6,#1
000146  6041              STR      r1,[r0,#4]
;;;235        *pDst++ = (q31_t) (acc2 << 1);
000148  0079              LSLS     r1,r7,#1
00014a  6081              STR      r1,[r0,#8]
;;;236        *pDst++ = (q31_t) (acc3 << 1);
00014c  ea4f014c          LSL      r1,r12,#1
000150  60c1              STR      r1,[r0,#0xc]
000152  3010              ADDS     r0,r0,#0x10
000154  9009              STR      r0,[sp,#0x24]
;;;237    
;;;238        /* Decrement the samples loop counter */
;;;239        blkCnt--;
000156  9800              LDR      r0,[sp,#0]
000158  1e40              SUBS     r0,r0,#1
00015a  9000              STR      r0,[sp,#0]
                  |L1.348|
00015c  9800              LDR      r0,[sp,#0]            ;108
00015e  2800              CMP      r0,#0                 ;108
000160  f47faf61          BNE      |L1.38|
;;;240      }
;;;241    
;;;242    
;;;243      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;244       ** No loop unrolling is used. */
;;;245      blkCnt = blockSize % 4u;
000164  980a              LDR      r0,[sp,#0x28]
000166  f0000503          AND      r5,r0,#3
;;;246    
;;;247      while(blkCnt > 0u)
00016a  e019              B        |L1.416|
                  |L1.364|
;;;248      {
;;;249        /* Copy one sample at a time into state buffer */
;;;250        *pStateCurnt++ = *pSrc++;
00016c  9808              LDR      r0,[sp,#0x20]
00016e  6800              LDR      r0,[r0,#0]
000170  f84a0b04          STR      r0,[r10],#4
000174  9808              LDR      r0,[sp,#0x20]
000176  1d00              ADDS     r0,r0,#4
000178  9008              STR      r0,[sp,#0x20]
;;;251    
;;;252        /* Set the accumulator to zero */
;;;253        acc0 = 0;
00017a  2300              MOVS     r3,#0
;;;254    
;;;255        /* Initialize state pointer */
;;;256        px = pState;
00017c  4620              MOV      r0,r4
;;;257    
;;;258        /* Initialize Coefficient pointer */
;;;259        pb = (pCoeffs);
00017e  9906              LDR      r1,[sp,#0x18]
;;;260    
;;;261        i = numTaps;
000180  9a02              LDR      r2,[sp,#8]
                  |L1.386|
;;;262    
;;;263        /* Perform the multiply-accumulates */
;;;264        do
;;;265        {
;;;266          multAcc_32x32_keep32_R(acc0, (*px++), (*(pb++)));
000182  c840              LDM      r0!,{r6}
000184  c980              LDM      r1!,{r7}
000186  fb563317          SMMLAR   r3,r6,r7,r3
;;;267          i--;
00018a  1e52              SUBS     r2,r2,#1
;;;268        } while(i > 0u);
00018c  2a00              CMP      r2,#0
00018e  d1f8              BNE      |L1.386|
;;;269    
;;;270        /* The result is in 2.30 format.  Convert to 1.31    
;;;271         ** Then store the output in the destination buffer. */
;;;272        *pDst++ = (q31_t) (acc0 << 1);
000190  9809              LDR      r0,[sp,#0x24]
000192  0059              LSLS     r1,r3,#1
000194  6001              STR      r1,[r0,#0]
000196  9809              LDR      r0,[sp,#0x24]
000198  1d00              ADDS     r0,r0,#4
00019a  9009              STR      r0,[sp,#0x24]
;;;273    
;;;274        /* Advance state pointer by 1 for the next sample */
;;;275        pState = pState + 1;
00019c  1d24              ADDS     r4,r4,#4
;;;276    
;;;277        /* Decrement the samples loop counter */
;;;278        blkCnt--;
00019e  1e6d              SUBS     r5,r5,#1
                  |L1.416|
0001a0  2d00              CMP      r5,#0                 ;247
0001a2  d1e3              BNE      |L1.364|
;;;279      }
;;;280    
;;;281      /* Processing is complete.    
;;;282       ** Now copy the last numTaps - 1 samples to the start of the state buffer.    
;;;283       ** This prepares the state buffer for the next function call. */
;;;284    
;;;285      /* Points to the start of the state buffer */
;;;286      pStateCurnt = S->pState;
0001a4  9807              LDR      r0,[sp,#0x1c]
0001a6  6841              LDR      r1,[r0,#4]
;;;287    
;;;288      /* Calculate remaining number of copies */
;;;289      tapCnt = (numTaps - 1u);
0001a8  9802              LDR      r0,[sp,#8]
0001aa  1e40              SUBS     r0,r0,#1
;;;290    
;;;291      /* Copy the remaining q31_t data */
;;;292      while(tapCnt > 0u)
0001ac  e002              B        |L1.436|
                  |L1.430|
;;;293      {
;;;294        *pStateCurnt++ = *pState++;
0001ae  cc04              LDM      r4!,{r2}
0001b0  c104              STM      r1!,{r2}
;;;295    
;;;296        /* Decrement the loop counter */
;;;297        tapCnt--;
0001b2  1e40              SUBS     r0,r0,#1
                  |L1.436|
0001b4  2800              CMP      r0,#0                 ;292
0001b6  d1fa              BNE      |L1.430|
;;;298      }
;;;299    
;;;300    
;;;301    }
0001b8  b00b              ADD      sp,sp,#0x2c
0001ba  e8bd8ff0          POP      {r4-r11,pc}
;;;302    IAR_ONLY_LOW_OPTIMIZATION_EXIT
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_fir_fast_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_fir_fast_q31_c_aa7d348b____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___18_arm_fir_fast_q31_c_aa7d348b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_fir_fast_q31_c_aa7d348b____REVSH|
#line 144
|__asm___18_arm_fir_fast_q31_c_aa7d348b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_fir_fast_q31_c_aa7d348b____RRX|
#line 300
|__asm___18_arm_fir_fast_q31_c_aa7d348b____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
