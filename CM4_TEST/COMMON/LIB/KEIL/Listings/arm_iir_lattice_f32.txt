; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_iir_lattice_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_iir_lattice_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_iir_lattice_f32.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_iir_lattice_f32.c]
                          THUMB

                          AREA ||i.arm_iir_lattice_f32||, CODE, READONLY, ALIGN=2

                  arm_iir_lattice_f32 PROC
;;;133    
;;;134    void arm_iir_lattice_f32(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;135      const arm_iir_lattice_instance_f32 * S,
;;;136      float32_t * pSrc,
;;;137      float32_t * pDst,
;;;138      uint32_t blockSize)
;;;139    {
;;;140      float32_t fnext1, gcurr1, gnext;               /* Temporary variables for lattice stages */
;;;141      float32_t acc;                                 /* Accumlator */
;;;142      uint32_t blkCnt, tapCnt;                       /* temporary variables for counts */
;;;143      float32_t *px1, *px2, *pk, *pv;                /* temporary pointers for state and coef */
;;;144      uint32_t numStages = S->numStages;             /* number of stages */
000004  f8b09000          LDRH     r9,[r0,#0]
;;;145      float32_t *pState;                             /* State pointer */
;;;146      float32_t *pStateCurnt;                        /* State current pointer */
;;;147      float32_t k1, k2;
;;;148      float32_t v1, v2, v3, v4;
;;;149      float32_t gcurr2;
;;;150      float32_t fnext2;
;;;151    
;;;152      /* initialise loop count */
;;;153      blkCnt = blockSize;
000008  469e              MOV      lr,r3
;;;154    
;;;155      /* initialise state pointer */
;;;156      pState = &S->pState[0];
00000a  f8d0b004          LDR      r11,[r0,#4]
;;;157    
;;;158      /* Sample processing */
;;;159      while(blkCnt > 0u)
;;;160      {
;;;161        /* Read Sample from input buffer */
;;;162        /* fN(n) = x(n) */
;;;163        fnext2 = *pSrc++;
;;;164    
;;;165        /* Initialize Ladder coeff pointer */
;;;166        pv = &S->pvCoeffs[0];
;;;167        /* Initialize Reflection coeff pointer */
;;;168        pk = &S->pkCoeffs[0];
;;;169    
;;;170        /* Initialize state read pointer */
;;;171        px1 = pState;
;;;172        /* Initialize state write pointer */
;;;173        px2 = pState;
;;;174    
;;;175        /* Set accumulator to zero */
;;;176        acc = 0.0;
;;;177    
;;;178        /* Loop unrolling.  Process 4 taps at a time. */
;;;179        tapCnt = (numStages) >> 2;
00000e  ea4f0a99          LSR      r10,r9,#2
000012  e072              B        |L1.250|
                  |L1.20|
000014  ecb10a01          VLDM     r1!,{s0}              ;163
000018  68c4              LDR      r4,[r0,#0xc]          ;166
00001a  6886              LDR      r6,[r0,#8]            ;168
00001c  465d              MOV      r5,r11                ;173
00001e  462f              MOV      r7,r5                 ;173
000020  eddf0a4a          VLDR     s1,|L1.332|
000024  46d4              MOV      r12,r10
;;;180    
;;;181        while(tapCnt > 0u)
000026  e042              B        |L1.174|
                  |L1.40|
;;;182        {
;;;183          /* Read gN-1(n-1) from state buffer */
;;;184          gcurr1 = *px1;
000028  ed951a00          VLDR     s2,[r5,#0]
;;;185    
;;;186          /* read reflection coefficient kN */
;;;187          k1 = *pk;
00002c  ed962a00          VLDR     s4,[r6,#0]
;;;188    
;;;189          /* fN-1(n) = fN(n) - kN * gN-1(n-1) */
;;;190          fnext1 = fnext2 - (k1 * gcurr1);
000030  ee020a41          VMLS.F32 s0,s4,s2
;;;191    
;;;192          /* read ladder coefficient vN */
;;;193          v1 = *pv;
000034  edd44a00          VLDR     s9,[r4,#0]
;;;194    
;;;195          /* read next reflection coefficient kN-1 */
;;;196          k2 = *(pk + 1u);
000038  edd63a01          VLDR     s7,[r6,#4]
;;;197    
;;;198          /* Read gN-2(n-1) from state buffer */
;;;199          gcurr2 = *(px1 + 1u);
00003c  edd52a01          VLDR     s5,[r5,#4]
;;;200    
;;;201          /* read next ladder coefficient vN-1 */
;;;202          v2 = *(pv + 1u);
000040  ed944a01          VLDR     s8,[r4,#4]
;;;203    
;;;204          /* fN-2(n) = fN-1(n) - kN-1 * gN-2(n-1) */
;;;205          fnext2 = fnext1 - (k2 * gcurr2);
000044  eef01a40          VMOV.F32 s3,s0
000048  ee431ae2          VMLS.F32 s3,s7,s5
;;;206    
;;;207          /* gN(n)   = kN * fN-1(n) + gN-1(n-1) */
;;;208          gnext = gcurr1 + (k1 * fnext1);
00004c  ee021a00          VMLA.F32 s2,s4,s0
;;;209    
;;;210          /* read reflection coefficient kN-2 */
;;;211          k1 = *(pk + 2u);
000050  ed963a02          VLDR     s6,[r6,#8]
;;;212    
;;;213          /* write gN(n) into state for next sample processing */
;;;214          *px2++ = gnext;
000054  eca71a01          VSTM     r7!,{s2}
;;;215    
;;;216          /* Read gN-3(n-1) from state buffer */
;;;217          gcurr1 = *(px1 + 2u);
000058  ed952a02          VLDR     s4,[r5,#8]
;;;218    
;;;219          /* y(n) += gN(n) * vN  */
;;;220          acc += (gnext * v1);
00005c  ee410a24          VMLA.F32 s1,s2,s9
;;;221    
;;;222          /* fN-3(n) = fN-2(n) - kN-2 * gN-3(n-1) */
;;;223          fnext1 = fnext2 - (k1 * gcurr1);
000060  eeb01a61          VMOV.F32 s2,s3
000064  ee031a42          VMLS.F32 s2,s6,s4
;;;224    
;;;225          /* gN-1(n)   = kN-1 * fN-2(n) + gN-2(n-1) */
;;;226          gnext = gcurr2 + (k2 * fnext2);
000068  ee432aa1          VMLA.F32 s5,s7,s3
;;;227    
;;;228          /* Read gN-4(n-1) from state buffer */
;;;229          gcurr2 = *(px1 + 3u);
00006c  edd51a03          VLDR     s3,[r5,#0xc]
;;;230    
;;;231          /* y(n) += gN-1(n) * vN-1  */
;;;232          acc += (gnext * v2);
000070  ee420a84          VMLA.F32 s1,s5,s8
;;;233    
;;;234          /* read reflection coefficient kN-3 */
;;;235          k2 = *(pk + 3u);
000074  edd63a03          VLDR     s7,[r6,#0xc]
;;;236    
;;;237          /* write gN-1(n) into state for next sample processing */
;;;238          *px2++ = gnext;
000078  ece72a01          VSTM     r7!,{s5}
;;;239    
;;;240          /* fN-4(n) = fN-3(n) - kN-3 * gN-4(n-1) */
;;;241          fnext2 = fnext1 - (k2 * gcurr2);
00007c  eeb00a41          VMOV.F32 s0,s2
000080  ee030ae1          VMLS.F32 s0,s7,s3
;;;242    
;;;243          /* gN-2(n) = kN-2 * fN-3(n) + gN-3(n-1) */
;;;244          gnext = gcurr1 + (k1 * fnext1);
000084  ee032a01          VMLA.F32 s4,s6,s2
;;;245    
;;;246          /* read ladder coefficient vN-2 */
;;;247          v3 = *(pv + 2u);
000088  ed941a02          VLDR     s2,[r4,#8]
;;;248    
;;;249          /* y(n) += gN-2(n) * vN-2  */
;;;250          acc += (gnext * v3);
00008c  ee420a01          VMLA.F32 s1,s4,s2
;;;251    
;;;252          /* write gN-2(n) into state for next sample processing */
;;;253          *px2++ = gnext;
000090  eca72a01          VSTM     r7!,{s4}
;;;254    
;;;255          /* update pointer */
;;;256          pk += 4u;
000094  3610              ADDS     r6,r6,#0x10
;;;257    
;;;258          /* gN-3(n) = kN-3 * fN-4(n) + gN-4(n-1) */
;;;259          gnext = (fnext2 * k2) + gcurr2;
000096  ee401a23          VMLA.F32 s3,s0,s7
;;;260    
;;;261          /* read next ladder coefficient vN-3 */
;;;262          v4 = *(pv + 3u);
00009a  ed941a03          VLDR     s2,[r4,#0xc]
;;;263    
;;;264          /* y(n) += gN-4(n) * vN-4  */
;;;265          acc += (gnext * v4);
00009e  ee410a81          VMLA.F32 s1,s3,s2
;;;266    
;;;267          /* write gN-3(n) into state for next sample processing */
;;;268          *px2++ = gnext;
0000a2  ece71a01          VSTM     r7!,{s3}
;;;269    
;;;270          /* update pointers */
;;;271          px1 += 4u;
0000a6  3510              ADDS     r5,r5,#0x10
;;;272          pv += 4u;
0000a8  3410              ADDS     r4,r4,#0x10
;;;273    
;;;274          tapCnt--;
0000aa  f1ac0c01          SUB      r12,r12,#1
                  |L1.174|
0000ae  f1bc0f00          CMP      r12,#0                ;181
0000b2  d1b9              BNE      |L1.40|
;;;275    
;;;276        }
;;;277    
;;;278        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;279        tapCnt = (numStages) % 0x4u;
0000b4  f0090803          AND      r8,r9,#3
;;;280    
;;;281        while(tapCnt > 0u)
0000b8  e010              B        |L1.220|
                  |L1.186|
;;;282        {
;;;283          gcurr1 = *px1++;
0000ba  ecb51a01          VLDM     r5!,{s2}
;;;284          /* Process sample for last taps */
;;;285          fnext1 = fnext2 - ((*pk) * gcurr1);
0000be  edd61a00          VLDR     s3,[r6,#0]
0000c2  ee010ac1          VMLS.F32 s0,s3,s2
;;;286          gnext = (fnext1 * (*pk++)) + gcurr1;
0000c6  1d36              ADDS     r6,r6,#4
0000c8  ee001a21          VMLA.F32 s2,s0,s3
;;;287          /* Output samples for last taps */
;;;288          acc += (gnext * (*pv++));
0000cc  ecf41a01          VLDM     r4!,{s3}
0000d0  ee410a21          VMLA.F32 s1,s2,s3
;;;289          *px2++ = gnext;
0000d4  eca71a01          VSTM     r7!,{s2}
;;;290          fnext2 = fnext1;
;;;291    
;;;292          tapCnt--;
0000d8  f1a80801          SUB      r8,r8,#1
                  |L1.220|
0000dc  f1b80f00          CMP      r8,#0                 ;281
0000e0  d1eb              BNE      |L1.186|
;;;293    
;;;294        }
;;;295    
;;;296        /* y(n) += g0(n) * v0 */
;;;297        acc += (fnext2 * (*pv));
0000e2  ed941a00          VLDR     s2,[r4,#0]
0000e6  ee400a01          VMLA.F32 s1,s0,s2
;;;298    
;;;299        *px2++ = fnext2;
0000ea  ed870a00          VSTR     s0,[r7,#0]
;;;300    
;;;301        /* write out into pDst */
;;;302        *pDst++ = acc;
0000ee  ece20a01          VSTM     r2!,{s1}
;;;303    
;;;304        /* Advance the state pointer by 4 to process the next group of 4 samples */
;;;305        pState = pState + 1u;
0000f2  f10b0b04          ADD      r11,r11,#4
;;;306    
;;;307        blkCnt--;
0000f6  f1ae0e01          SUB      lr,lr,#1
                  |L1.250|
0000fa  f1be0f00          CMP      lr,#0                 ;159
0000fe  d189              BNE      |L1.20|
;;;308    
;;;309      }
;;;310    
;;;311      /* Processing is complete. Now copy last S->numStages samples to start of the buffer        
;;;312         for the preperation of next frame process */
;;;313    
;;;314      /* Points to the start of the state buffer */
;;;315      pStateCurnt = &S->pState[0];
000100  6840              LDR      r0,[r0,#4]
;;;316      pState = &S->pState[blockSize];
000102  eb000183          ADD      r1,r0,r3,LSL #2
;;;317    
;;;318      tapCnt = numStages >> 2u;
;;;319    
;;;320      /* copy data */
;;;321      while(tapCnt > 0u)
000106  e011              B        |L1.300|
                  |L1.264|
;;;322      {
;;;323        *pStateCurnt++ = *pState++;
000108  ecb10a01          VLDM     r1!,{s0}
00010c  eca00a01          VSTM     r0!,{s0}
;;;324        *pStateCurnt++ = *pState++;
000110  ecb10a01          VLDM     r1!,{s0}
000114  eca00a01          VSTM     r0!,{s0}
;;;325        *pStateCurnt++ = *pState++;
000118  ecb10a01          VLDM     r1!,{s0}
00011c  eca00a01          VSTM     r0!,{s0}
;;;326        *pStateCurnt++ = *pState++;
000120  ecb10a01          VLDM     r1!,{s0}
000124  eca00a01          VSTM     r0!,{s0}
;;;327    
;;;328        /* Decrement the loop counter */
;;;329        tapCnt--;
000128  f1aa0a01          SUB      r10,r10,#1
                  |L1.300|
00012c  f1ba0f00          CMP      r10,#0                ;321
000130  d1ea              BNE      |L1.264|
;;;330    
;;;331      }
;;;332    
;;;333      /* Calculate remaining number of copies */
;;;334      tapCnt = (numStages) % 0x4u;
000132  f0090203          AND      r2,r9,#3
;;;335    
;;;336      /* Copy the remaining q31_t data */
;;;337      while(tapCnt > 0u)
000136  e004              B        |L1.322|
                  |L1.312|
;;;338      {
;;;339        *pStateCurnt++ = *pState++;
000138  ecb10a01          VLDM     r1!,{s0}
00013c  eca00a01          VSTM     r0!,{s0}
;;;340    
;;;341        /* Decrement the loop counter */
;;;342        tapCnt--;
000140  1e52              SUBS     r2,r2,#1
                  |L1.322|
000142  2a00              CMP      r2,#0                 ;337
000144  d1f8              BNE      |L1.312|
;;;343      }
;;;344    }
000146  e8bd8ff0          POP      {r4-r11,pc}
;;;345    
                          ENDP

00014a  0000              DCW      0x0000
                  |L1.332|
00014c  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_iir_lattice_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_iir_lattice_f32_c_cc182ffe____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___21_arm_iir_lattice_f32_c_cc182ffe____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_iir_lattice_f32_c_cc182ffe____REVSH|
#line 144
|__asm___21_arm_iir_lattice_f32_c_cc182ffe____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_iir_lattice_f32_c_cc182ffe____RRX|
#line 300
|__asm___21_arm_iir_lattice_f32_c_cc182ffe____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
