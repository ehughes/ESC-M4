; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_fast_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_fast_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_conv_fast_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_fast_q31.c]
                          THUMB

                          AREA ||i.arm_conv_fast_q31||, CODE, READONLY, ALIGN=1

                  arm_conv_fast_q31 PROC
;;;78     
;;;79     void arm_conv_fast_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;80       q31_t * pSrcA,
;;;81       uint32_t srcALen,
;;;82       q31_t * pSrcB,
;;;83       uint32_t srcBLen,
;;;84       q31_t * pDst)
;;;85     {
000004  b08b              SUB      sp,sp,#0x2c
000006  9918              LDR      r1,[sp,#0x60]
;;;86       q31_t *pIn1;                                   /* inputA pointer */
;;;87       q31_t *pIn2;                                   /* inputB pointer */
;;;88       q31_t *pOut = pDst;                            /* output pointer */
;;;89       q31_t *px;                                     /* Intermediate inputA pointer  */
;;;90       q31_t *py;                                     /* Intermediate inputB pointer  */
;;;91       q31_t *pSrc1, *pSrc2;                          /* Intermediate pointers */
;;;92       q31_t sum, acc0, acc1, acc2, acc3;             /* Accumulator */
;;;93       q31_t x0, x1, x2, x3, c0;                      /* Temporary variables to hold state and coefficient values */
;;;94       uint32_t j, k, count, blkCnt, blockSize1, blockSize2, blockSize3;     /* loop counter */
;;;95     
;;;96       /* The algorithm implementation is based on the lengths of the inputs. */
;;;97       /* srcB is always made to slide across srcA. */
;;;98       /* So srcBLen is always considered as shorter or equal to srcALen */
;;;99       if(srcALen >= srcBLen)
000008  9c0c              LDR      r4,[sp,#0x30]
00000a  429c              CMP      r4,r3
00000c  d302              BCC      |L1.20|
;;;100      {
;;;101        /* Initialization of inputA pointer */
;;;102        pIn1 = pSrcA;
00000e  9008              STR      r0,[sp,#0x20]
;;;103    
;;;104        /* Initialization of inputB pointer */
;;;105        pIn2 = pSrcB;
000010  4610              MOV      r0,r2
000012  e003              B        |L1.28|
                  |L1.20|
;;;106      }
;;;107      else
;;;108      {
;;;109        /* Initialization of inputA pointer */
;;;110        pIn1 = pSrcB;
000014  9208              STR      r2,[sp,#0x20]
;;;111    
;;;112        /* Initialization of inputB pointer */
;;;113        pIn2 = pSrcA;
;;;114    
;;;115        /* srcBLen is always considered as shorter or equal to srcALen */
;;;116        j = srcBLen;
000016  461a              MOV      r2,r3
;;;117        srcBLen = srcALen;
000018  9b0c              LDR      r3,[sp,#0x30]
;;;118        srcALen = j;
00001a  920c              STR      r2,[sp,#0x30]
                  |L1.28|
;;;119      }
;;;120    
;;;121      /* conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1] */
;;;122      /* The function is internally    
;;;123       * divided into three stages according to the number of multiplications that has to be    
;;;124       * taken place between inputA samples and inputB samples. In the first stage of the    
;;;125       * algorithm, the multiplications increase by one for every iteration.    
;;;126       * In the second stage of the algorithm, srcBLen number of multiplications are done.    
;;;127       * In the third stage of the algorithm, the multiplications decrease by one    
;;;128       * for every iteration. */
;;;129    
;;;130      /* The algorithm is implemented in three stages.    
;;;131         The loop counters of each stage is initiated here. */
;;;132      blockSize1 = srcBLen - 1u;
00001c  f1a30801          SUB      r8,r3,#1
;;;133      blockSize2 = srcALen - (srcBLen - 1u);
000020  9a0c              LDR      r2,[sp,#0x30]
000022  1ad2              SUBS     r2,r2,r3
000024  1c52              ADDS     r2,r2,#1
000026  9201              STR      r2,[sp,#4]
;;;134      blockSize3 = blockSize1;
000028  f8cd8000          STR      r8,[sp,#0]
;;;135    
;;;136      /* --------------------------    
;;;137       * Initializations of stage1    
;;;138       * -------------------------*/
;;;139    
;;;140      /* sum = x[0] * y[0]    
;;;141       * sum = x[0] * y[1] + x[1] * y[0]    
;;;142       * ....    
;;;143       * sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]    
;;;144       */
;;;145    
;;;146      /* In this stage the MAC operations are increased by 1 for every iteration.    
;;;147         The count variable holds the number of MAC operations performed */
;;;148      count = 1u;
00002c  2701              MOVS     r7,#1
;;;149    
;;;150      /* Working pointer of inputA */
;;;151      px = pIn1;
00002e  9d08              LDR      r5,[sp,#0x20]
;;;152    
;;;153      /* Working pointer of inputB */
;;;154      py = pIn2;
000030  4604              MOV      r4,r0
;;;155    
;;;156    
;;;157      /* ------------------------    
;;;158       * Stage1 process    
;;;159       * ----------------------*/
;;;160    
;;;161      /* The first stage starts here */
;;;162      while(blockSize1 > 0u)
000032  e032              B        |L1.154|
                  |L1.52|
;;;163      {
;;;164        /* Accumulator is made zero for every iteration */
;;;165        sum = 0;
000034  2600              MOVS     r6,#0
;;;166    
;;;167        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;168        k = count >> 2u;
000036  ea4f0c97          LSR      r12,r7,#2
;;;169    
;;;170        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;171         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;172        while(k > 0u)
00003a  e016              B        |L1.106|
                  |L1.60|
;;;173        {
;;;174          /* x[0] * y[srcBLen - 1] */
;;;175          sum = (q31_t) ((((q63_t) sum << 32) +
00003c  682a              LDR      r2,[r5,#0]
00003e  f8549904          LDR      r9,[r4],#-4
000042  fb526209          SMMLA    r2,r2,r9,r6
;;;176                          ((q63_t) * px++ * (*py--))) >> 32);
;;;177    
;;;178          /* x[1] * y[srcBLen - 2] */
;;;179          sum = (q31_t) ((((q63_t) sum << 32) +
000046  686e              LDR      r6,[r5,#4]
000048  f8549904          LDR      r9,[r4],#-4
00004c  fb562209          SMMLA    r2,r6,r9,r2
;;;180                          ((q63_t) * px++ * (*py--))) >> 32);
;;;181    
;;;182          /* x[2] * y[srcBLen - 3] */
;;;183          sum = (q31_t) ((((q63_t) sum << 32) +
000050  68ae              LDR      r6,[r5,#8]
000052  f8549904          LDR      r9,[r4],#-4
000056  fb562209          SMMLA    r2,r6,r9,r2
;;;184                          ((q63_t) * px++ * (*py--))) >> 32);
;;;185    
;;;186          /* x[3] * y[srcBLen - 4] */
;;;187          sum = (q31_t) ((((q63_t) sum << 32) +
00005a  68ee              LDR      r6,[r5,#0xc]
00005c  f8549904          LDR      r9,[r4],#-4
000060  3510              ADDS     r5,r5,#0x10
000062  fb562609          SMMLA    r6,r6,r9,r2
;;;188                          ((q63_t) * px++ * (*py--))) >> 32);
;;;189    
;;;190          /* Decrement the loop counter */
;;;191          k--;
000066  f1ac0c01          SUB      r12,r12,#1
                  |L1.106|
00006a  f1bc0f00          CMP      r12,#0                ;172
00006e  d1e5              BNE      |L1.60|
;;;192        }
;;;193    
;;;194        /* If the count is not a multiple of 4, compute any remaining MACs here.    
;;;195         ** No loop unrolling is used. */
;;;196        k = count % 0x4u;
000070  f0070c03          AND      r12,r7,#3
;;;197    
;;;198        while(k > 0u)
000074  e006              B        |L1.132|
                  |L1.118|
;;;199        {
;;;200          /* Perform the multiply-accumulate */
;;;201          sum = (q31_t) ((((q63_t) sum << 32) +
000076  cd04              LDM      r5!,{r2}
000078  f8549904          LDR      r9,[r4],#-4
00007c  fb526609          SMMLA    r6,r2,r9,r6
;;;202                          ((q63_t) * px++ * (*py--))) >> 32);
;;;203    
;;;204          /* Decrement the loop counter */
;;;205          k--;
000080  f1ac0c01          SUB      r12,r12,#1
                  |L1.132|
000084  f1bc0f00          CMP      r12,#0                ;198
000088  d1f5              BNE      |L1.118|
;;;206        }
;;;207    
;;;208        /* Store the result in the accumulator in the destination buffer. */
;;;209        *pOut++ = sum << 1;
00008a  0072              LSLS     r2,r6,#1
00008c  c104              STM      r1!,{r2}
;;;210    
;;;211        /* Update the inputA and inputB pointers for next MAC calculation */
;;;212        py = pIn2 + count;
00008e  eb000487          ADD      r4,r0,r7,LSL #2
;;;213        px = pIn1;
000092  9d08              LDR      r5,[sp,#0x20]
;;;214    
;;;215        /* Increment the MAC count */
;;;216        count++;
000094  1c7f              ADDS     r7,r7,#1
;;;217    
;;;218        /* Decrement the loop counter */
;;;219        blockSize1--;
000096  f1a80801          SUB      r8,r8,#1
                  |L1.154|
00009a  f1b80f00          CMP      r8,#0                 ;162
00009e  d1c9              BNE      |L1.52|
;;;220      }
;;;221    
;;;222      /* --------------------------    
;;;223       * Initializations of stage2    
;;;224       * ------------------------*/
;;;225    
;;;226      /* sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0]    
;;;227       * sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0]    
;;;228       * ....    
;;;229       * sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]    
;;;230       */
;;;231    
;;;232      /* Working pointer of inputA */
;;;233      px = pIn1;
;;;234    
;;;235      /* Working pointer of inputB */
;;;236      pSrc2 = pIn2 + (srcBLen - 1u);
0000a0  1e5a              SUBS     r2,r3,#1
0000a2  eb000082          ADD      r0,r0,r2,LSL #2
0000a6  e9cd0209          STRD     r0,r2,[sp,#0x24]
0000aa  9007              STR      r0,[sp,#0x1c]
;;;237      py = pSrc2;
0000ac  9807              LDR      r0,[sp,#0x1c]
;;;238    
;;;239      /* count is index by which the pointer pIn1 to be incremented */
;;;240      count = 0u;
0000ae  2600              MOVS     r6,#0
;;;241    
;;;242      /* -------------------    
;;;243       * Stage2 process    
;;;244       * ------------------*/
;;;245    
;;;246      /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.    
;;;247       * So, to loop unroll over blockSize2,    
;;;248       * srcBLen should be greater than or equal to 4 */
;;;249      if(srcBLen >= 4u)
0000b0  2b04              CMP      r3,#4
0000b2  d37c              BCC      |L1.430|
;;;250      {
;;;251        /* Loop unroll over blockSize2, by 4 */
;;;252        blkCnt = blockSize2 >> 2u;
0000b4  9a01              LDR      r2,[sp,#4]
0000b6  0892              LSRS     r2,r2,#2
0000b8  9202              STR      r2,[sp,#8]
;;;253    
;;;254        while(blkCnt > 0u)
0000ba  e088              B        |L1.462|
                  |L1.188|
;;;255        {
;;;256          /* Set all accumulators to zero */
;;;257          acc0 = 0;
0000bc  2700              MOVS     r7,#0
;;;258          acc1 = 0;
0000be  46bc              MOV      r12,r7
;;;259          acc2 = 0;
0000c0  46b8              MOV      r8,r7
;;;260          acc3 = 0;
0000c2  46b9              MOV      r9,r7
;;;261    
;;;262          /* read x[0], x[1], x[2] samples */
;;;263          x0 = *(px++);
0000c4  f8d5b000          LDR      r11,[r5,#0]
;;;264          x1 = *(px++);
0000c8  686a              LDR      r2,[r5,#4]
;;;265          x2 = *(px++);
0000ca  68ac              LDR      r4,[r5,#8]
0000cc  350c              ADDS     r5,r5,#0xc
;;;266    
;;;267          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;268          k = srcBLen >> 2u;
0000ce  ea4f0a93          LSR      r10,r3,#2
0000d2  f8cda00c          STR      r10,[sp,#0xc]
                  |L1.214|
;;;269    
;;;270          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;271           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;272          do
;;;273          {
;;;274            /* Read y[srcBLen - 1] sample */
;;;275            c0 = *(py--);
0000d6  f850e904          LDR      lr,[r0],#-4
;;;276    
;;;277            /* Read x[3] sample */
;;;278            x3 = *(px++);
0000da  f8d5a000          LDR      r10,[r5,#0]
;;;279    
;;;280            /* Perform the multiply-accumulates */
;;;281            /* acc0 +=  x[0] * y[srcBLen - 1] */
;;;282            acc0 = (q31_t) ((((q63_t) acc0 << 32) + ((q63_t) x0 * c0)) >> 32);
0000de  fb5b770e          SMMLA    r7,r11,lr,r7
;;;283    
;;;284            /* acc1 +=  x[1] * y[srcBLen - 1] */
;;;285            acc1 = (q31_t) ((((q63_t) acc1 << 32) + ((q63_t) x1 * c0)) >> 32);
0000e2  fb52cc0e          SMMLA    r12,r2,lr,r12
0000e6  f8cdc018          STR      r12,[sp,#0x18]
;;;286    
;;;287            /* acc2 +=  x[2] * y[srcBLen - 1] */
;;;288            acc2 = (q31_t) ((((q63_t) acc2 << 32) + ((q63_t) x2 * c0)) >> 32);
0000ea  fb548c0e          SMMLA    r12,r4,lr,r8
0000ee  f8cdc014          STR      r12,[sp,#0x14]
;;;289    
;;;290            /* acc3 +=  x[3] * y[srcBLen - 1] */
;;;291            acc3 = (q31_t) ((((q63_t) acc3 << 32) + ((q63_t) x3 * c0)) >> 32);
0000f2  fb5a980e          SMMLA    r8,r10,lr,r9
;;;292    
;;;293            /* Read y[srcBLen - 2] sample */
;;;294            c0 = *(py--);
0000f6  f850c904          LDR      r12,[r0],#-4
;;;295    
;;;296            /* Read x[4] sample */
;;;297            x0 = *(px++);
0000fa  f8d5b004          LDR      r11,[r5,#4]
;;;298    
;;;299            /* Perform the multiply-accumulate */
;;;300            /* acc0 +=  x[1] * y[srcBLen - 2] */
;;;301            acc0 = (q31_t) ((((q63_t) acc0 << 32) + ((q63_t) x1 * c0)) >> 32);
0000fe  fb52770c          SMMLA    r7,r2,r12,r7
;;;302            /* acc1 +=  x[2] * y[srcBLen - 2] */
;;;303            acc1 = (q31_t) ((((q63_t) acc1 << 32) + ((q63_t) x2 * c0)) >> 32);
000102  9a06              LDR      r2,[sp,#0x18]
000104  fb54290c          SMMLA    r9,r4,r12,r2
;;;304            /* acc2 +=  x[3] * y[srcBLen - 2] */
;;;305            acc2 = (q31_t) ((((q63_t) acc2 << 32) + ((q63_t) x3 * c0)) >> 32);
000108  9a05              LDR      r2,[sp,#0x14]
00010a  fb5a2e0c          SMMLA    lr,r10,r12,r2
00010e  f8cde014          STR      lr,[sp,#0x14]
;;;306            /* acc3 +=  x[4] * y[srcBLen - 2] */
;;;307            acc3 = (q31_t) ((((q63_t) acc3 << 32) + ((q63_t) x0 * c0)) >> 32);
000112  fb5b8e0c          SMMLA    lr,r11,r12,r8
000116  f8cde010          STR      lr,[sp,#0x10]
;;;308    
;;;309            /* Read y[srcBLen - 3] sample */
;;;310            c0 = *(py--);
00011a  f850c904          LDR      r12,[r0],#-4
;;;311    
;;;312            /* Read x[5] sample */
;;;313            x1 = *(px++);
00011e  68aa              LDR      r2,[r5,#8]
;;;314    
;;;315            /* Perform the multiply-accumulates */
;;;316            /* acc0 +=  x[2] * y[srcBLen - 3] */
;;;317            acc0 = (q31_t) ((((q63_t) acc0 << 32) + ((q63_t) x2 * c0)) >> 32);
000120  fb54770c          SMMLA    r7,r4,r12,r7
;;;318            /* acc1 +=  x[3] * y[srcBLen - 3] */
;;;319            acc1 = (q31_t) ((((q63_t) acc1 << 32) + ((q63_t) x3 * c0)) >> 32);
000124  fb5a980c          SMMLA    r8,r10,r12,r9
;;;320            /* acc2 +=  x[4] * y[srcBLen - 3] */
;;;321            acc2 = (q31_t) ((((q63_t) acc2 << 32) + ((q63_t) x0 * c0)) >> 32);
000128  f8dde014          LDR      lr,[sp,#0x14]
00012c  fb5be40c          SMMLA    r4,r11,r12,lr
000130  9405              STR      r4,[sp,#0x14]
;;;322            /* acc3 +=  x[5] * y[srcBLen - 3] */
;;;323            acc3 = (q31_t) ((((q63_t) acc3 << 32) + ((q63_t) x1 * c0)) >> 32);
000132  f8dde010          LDR      lr,[sp,#0x10]
000136  fb52ee0c          SMMLA    lr,r2,r12,lr
;;;324    
;;;325            /* Read y[srcBLen - 4] sample */
;;;326            c0 = *(py--);
00013a  f8509904          LDR      r9,[r0],#-4
;;;327    
;;;328            /* Read x[6] sample */
;;;329            x2 = *(px++);
00013e  68ec              LDR      r4,[r5,#0xc]
000140  3510              ADDS     r5,r5,#0x10
;;;330    
;;;331            /* Perform the multiply-accumulates */
;;;332            /* acc0 +=  x[3] * y[srcBLen - 4] */
;;;333            acc0 = (q31_t) ((((q63_t) acc0 << 32) + ((q63_t) x3 * c0)) >> 32);
000142  fb5a7709          SMMLA    r7,r10,r9,r7
;;;334            /* acc1 +=  x[4] * y[srcBLen - 4] */
;;;335            acc1 = (q31_t) ((((q63_t) acc1 << 32) + ((q63_t) x0 * c0)) >> 32);
000146  fb5b8c09          SMMLA    r12,r11,r9,r8
;;;336            /* acc2 +=  x[5] * y[srcBLen - 4] */
;;;337            acc2 = (q31_t) ((((q63_t) acc2 << 32) + ((q63_t) x1 * c0)) >> 32);
00014a  f8dd8014          LDR      r8,[sp,#0x14]
00014e  fb528809          SMMLA    r8,r2,r9,r8
;;;338            /* acc3 +=  x[6] * y[srcBLen - 4] */
;;;339            acc3 = (q31_t) ((((q63_t) acc3 << 32) + ((q63_t) x2 * c0)) >> 32);
000152  fb54e909          SMMLA    r9,r4,r9,lr
;;;340    
;;;341    
;;;342          } while(--k);
000156  f8dda00c          LDR      r10,[sp,#0xc]
00015a  f1ba0a01          SUBS     r10,r10,#1
00015e  f8cda00c          STR      r10,[sp,#0xc]
000162  d1b8              BNE      |L1.214|
;;;343    
;;;344          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.    
;;;345           ** No loop unrolling is used. */
;;;346          k = srcBLen % 0x4u;
000164  f0030a03          AND      r10,r3,#3
000168  f8cda00c          STR      r10,[sp,#0xc]
;;;347    
;;;348          while(k > 0u)
00016c  e014              B        |L1.408|
                  |L1.366|
;;;349          {
;;;350            /* Read y[srcBLen - 5] sample */
;;;351            c0 = *(py--);
00016e  f850a904          LDR      r10,[r0],#-4
;;;352    
;;;353            /* Read x[7] sample */
;;;354            x3 = *(px++);
000172  f855eb04          LDR      lr,[r5],#4
;;;355    
;;;356            /* Perform the multiply-accumulates */
;;;357            /* acc0 +=  x[4] * y[srcBLen - 5] */
;;;358            acc0 = (q31_t) ((((q63_t) acc0 << 32) + ((q63_t) x0 * c0)) >> 32);
000176  fb5b770a          SMMLA    r7,r11,r10,r7
;;;359            /* acc1 +=  x[5] * y[srcBLen - 5] */
;;;360            acc1 = (q31_t) ((((q63_t) acc1 << 32) + ((q63_t) x1 * c0)) >> 32);
00017a  fb52cc0a          SMMLA    r12,r2,r10,r12
;;;361            /* acc2 +=  x[6] * y[srcBLen - 5] */
;;;362            acc2 = (q31_t) ((((q63_t) acc2 << 32) + ((q63_t) x2 * c0)) >> 32);
00017e  fb54880a          SMMLA    r8,r4,r10,r8
;;;363            /* acc3 +=  x[7] * y[srcBLen - 5] */
;;;364            acc3 = (q31_t) ((((q63_t) acc3 << 32) + ((q63_t) x3 * c0)) >> 32);
000182  fb5e990a          SMMLA    r9,lr,r10,r9
;;;365    
;;;366            /* Reuse the present samples for the next MAC */
;;;367            x0 = x1;
000186  4693              MOV      r11,r2
;;;368            x1 = x2;
000188  4622              MOV      r2,r4
;;;369            x2 = x3;
00018a  4674              MOV      r4,lr
;;;370    
;;;371            /* Decrement the loop counter */
;;;372            k--;
00018c  f8dda00c          LDR      r10,[sp,#0xc]
000190  f1aa0a01          SUB      r10,r10,#1
000194  f8cda00c          STR      r10,[sp,#0xc]
                  |L1.408|
000198  f8dda00c          LDR      r10,[sp,#0xc]         ;348
00019c  f1ba0f00          CMP      r10,#0                ;348
0001a0  d1e5              BNE      |L1.366|
;;;373          }
;;;374    
;;;375          /* Store the results in the accumulators in the destination buffer. */
;;;376          *pOut++ = (q31_t) (acc0 << 1);
0001a2  0078              LSLS     r0,r7,#1
0001a4  6008              STR      r0,[r1,#0]
;;;377          *pOut++ = (q31_t) (acc1 << 1);
0001a6  ea4f004c          LSL      r0,r12,#1
0001aa  6048              STR      r0,[r1,#4]
;;;378          *pOut++ = (q31_t) (acc2 << 1);
0001ac  e000              B        |L1.432|
                  |L1.430|
0001ae  e04b              B        |L1.584|
                  |L1.432|
0001b0  ea4f0048          LSL      r0,r8,#1
0001b4  6088              STR      r0,[r1,#8]
;;;379          *pOut++ = (q31_t) (acc3 << 1);
0001b6  ea4f0049          LSL      r0,r9,#1
0001ba  60c8              STR      r0,[r1,#0xc]
0001bc  3110              ADDS     r1,r1,#0x10
;;;380    
;;;381          /* Increment the pointer pIn1 index, count by 4 */
;;;382          count += 4u;
0001be  1d36              ADDS     r6,r6,#4
;;;383    
;;;384          /* Update the inputA and inputB pointers for next MAC calculation */
;;;385          px = pIn1 + count;
0001c0  9808              LDR      r0,[sp,#0x20]
0001c2  eb000586          ADD      r5,r0,r6,LSL #2
;;;386          py = pSrc2;
0001c6  9807              LDR      r0,[sp,#0x1c]
;;;387    
;;;388          /* Decrement the loop counter */
;;;389          blkCnt--;
0001c8  9a02              LDR      r2,[sp,#8]
0001ca  1e52              SUBS     r2,r2,#1
0001cc  9202              STR      r2,[sp,#8]
                  |L1.462|
0001ce  9a02              LDR      r2,[sp,#8]            ;254
0001d0  2a00              CMP      r2,#0                 ;254
0001d2  f47faf73          BNE      |L1.188|
;;;390        }
;;;391    
;;;392        /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.    
;;;393         ** No loop unrolling is used. */
;;;394        blkCnt = blockSize2 % 0x4u;
0001d6  9a01              LDR      r2,[sp,#4]
0001d8  f0020703          AND      r7,r2,#3
;;;395    
;;;396        while(blkCnt > 0u)
0001dc  e031              B        |L1.578|
                  |L1.478|
;;;397        {
;;;398          /* Accumulator is made zero for every iteration */
;;;399          sum = 0;
0001de  2200              MOVS     r2,#0
;;;400    
;;;401          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;402          k = srcBLen >> 2u;
0001e0  089c              LSRS     r4,r3,#2
;;;403    
;;;404          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;405           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;406          while(k > 0u)
0001e2  e018              B        |L1.534|
                  |L1.484|
;;;407          {
;;;408            /* Perform the multiply-accumulates */
;;;409            sum = (q31_t) ((((q63_t) sum << 32) +
0001e4  f855cb04          LDR      r12,[r5],#4
0001e8  f8508904          LDR      r8,[r0],#-4
0001ec  fb5c2208          SMMLA    r2,r12,r8,r2
;;;410                            ((q63_t) * px++ * (*py--))) >> 32);
;;;411            sum = (q31_t) ((((q63_t) sum << 32) +
0001f0  f855cb04          LDR      r12,[r5],#4
0001f4  f8508904          LDR      r8,[r0],#-4
0001f8  fb5c2208          SMMLA    r2,r12,r8,r2
;;;412                            ((q63_t) * px++ * (*py--))) >> 32);
;;;413            sum = (q31_t) ((((q63_t) sum << 32) +
0001fc  f855cb04          LDR      r12,[r5],#4
000200  f8508904          LDR      r8,[r0],#-4
000204  fb5c2208          SMMLA    r2,r12,r8,r2
;;;414                            ((q63_t) * px++ * (*py--))) >> 32);
;;;415            sum = (q31_t) ((((q63_t) sum << 32) +
000208  f855cb04          LDR      r12,[r5],#4
00020c  f8508904          LDR      r8,[r0],#-4
000210  fb5c2208          SMMLA    r2,r12,r8,r2
;;;416                            ((q63_t) * px++ * (*py--))) >> 32);
;;;417    
;;;418            /* Decrement the loop counter */
;;;419            k--;
000214  1e64              SUBS     r4,r4,#1
                  |L1.534|
000216  2c00              CMP      r4,#0                 ;406
000218  d1e4              BNE      |L1.484|
;;;420          }
;;;421    
;;;422          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.    
;;;423           ** No loop unrolling is used. */
;;;424          k = srcBLen % 0x4u;
00021a  f0030403          AND      r4,r3,#3
;;;425    
;;;426          while(k > 0u)
00021e  e006              B        |L1.558|
                  |L1.544|
;;;427          {
;;;428            /* Perform the multiply-accumulate */
;;;429            sum = (q31_t) ((((q63_t) sum << 32) +
000220  f855cb04          LDR      r12,[r5],#4
000224  f8508904          LDR      r8,[r0],#-4
000228  fb5c2208          SMMLA    r2,r12,r8,r2
;;;430                            ((q63_t) * px++ * (*py--))) >> 32);
;;;431    
;;;432            /* Decrement the loop counter */
;;;433            k--;
00022c  1e64              SUBS     r4,r4,#1
                  |L1.558|
00022e  2c00              CMP      r4,#0                 ;426
000230  d1f6              BNE      |L1.544|
;;;434          }
;;;435    
;;;436          /* Store the result in the accumulator in the destination buffer. */
;;;437          *pOut++ = sum << 1;
000232  0050              LSLS     r0,r2,#1
000234  c101              STM      r1!,{r0}
;;;438    
;;;439          /* Increment the MAC count */
;;;440          count++;
000236  1c76              ADDS     r6,r6,#1
;;;441    
;;;442          /* Update the inputA and inputB pointers for next MAC calculation */
;;;443          px = pIn1 + count;
000238  9808              LDR      r0,[sp,#0x20]
00023a  eb000586          ADD      r5,r0,r6,LSL #2
;;;444          py = pSrc2;
00023e  9807              LDR      r0,[sp,#0x1c]
;;;445    
;;;446          /* Decrement the loop counter */
;;;447          blkCnt--;
000240  1e7f              SUBS     r7,r7,#1
                  |L1.578|
000242  2f00              CMP      r7,#0                 ;396
000244  d1cb              BNE      |L1.478|
000246  e017              B        |L1.632|
                  |L1.584|
;;;448        }
;;;449      }
;;;450      else
;;;451      {
;;;452        /* If the srcBLen is not a multiple of 4,    
;;;453         * the blockSize2 loop cannot be unrolled by 4 */
;;;454        blkCnt = blockSize2;
000248  9f01              LDR      r7,[sp,#4]
;;;455    
;;;456        while(blkCnt > 0u)
00024a  e013              B        |L1.628|
                  |L1.588|
;;;457        {
;;;458          /* Accumulator is made zero for every iteration */
;;;459          sum = 0;
00024c  2400              MOVS     r4,#0
;;;460    
;;;461          /* srcBLen number of MACS should be performed */
;;;462          k = srcBLen;
00024e  461a              MOV      r2,r3
;;;463    
;;;464          while(k > 0u)
000250  e006              B        |L1.608|
                  |L1.594|
;;;465          {
;;;466            /* Perform the multiply-accumulate */
;;;467            sum = (q31_t) ((((q63_t) sum << 32) +
000252  f855cb04          LDR      r12,[r5],#4
000256  f8508904          LDR      r8,[r0],#-4
00025a  fb5c4408          SMMLA    r4,r12,r8,r4
;;;468                            ((q63_t) * px++ * (*py--))) >> 32);
;;;469    
;;;470            /* Decrement the loop counter */
;;;471            k--;
00025e  1e52              SUBS     r2,r2,#1
                  |L1.608|
000260  2a00              CMP      r2,#0                 ;464
000262  d1f6              BNE      |L1.594|
;;;472          }
;;;473    
;;;474          /* Store the result in the accumulator in the destination buffer. */
;;;475          *pOut++ = sum << 1;
000264  0060              LSLS     r0,r4,#1
000266  c101              STM      r1!,{r0}
;;;476    
;;;477          /* Increment the MAC count */
;;;478          count++;
000268  1c76              ADDS     r6,r6,#1
;;;479    
;;;480          /* Update the inputA and inputB pointers for next MAC calculation */
;;;481          px = pIn1 + count;
00026a  9808              LDR      r0,[sp,#0x20]
00026c  eb000586          ADD      r5,r0,r6,LSL #2
;;;482          py = pSrc2;
000270  9807              LDR      r0,[sp,#0x1c]
;;;483    
;;;484          /* Decrement the loop counter */
;;;485          blkCnt--;
000272  1e7f              SUBS     r7,r7,#1
                  |L1.628|
000274  2f00              CMP      r7,#0                 ;456
000276  d1e9              BNE      |L1.588|
                  |L1.632|
;;;486        }
;;;487      }
;;;488    
;;;489    
;;;490      /* --------------------------    
;;;491       * Initializations of stage3    
;;;492       * -------------------------*/
;;;493    
;;;494      /* sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1]    
;;;495       * sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2]    
;;;496       * ....    
;;;497       * sum +=  x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2]    
;;;498       * sum +=  x[srcALen-1] * y[srcBLen-1]    
;;;499       */
;;;500    
;;;501      /* In this stage the MAC operations are decreased by 1 for every iteration.    
;;;502         The blockSize3 variable holds the number of MAC operations performed */
;;;503    
;;;504      /* Working pointer of inputA */
;;;505      pSrc1 = (pIn1 + srcALen) - (srcBLen - 1u);
000278  9a0c              LDR      r2,[sp,#0x30]
00027a  9808              LDR      r0,[sp,#0x20]
00027c  eb000282          ADD      r2,r0,r2,LSL #2
000280  980a              LDR      r0,[sp,#0x28]
000282  eba20580          SUB      r5,r2,r0,LSL #2
;;;506      px = pSrc1;
000286  4628              MOV      r0,r5
;;;507    
;;;508      /* Working pointer of inputB */
;;;509      pSrc2 = pIn2 + (srcBLen - 1u);
000288  9e09              LDR      r6,[sp,#0x24]
;;;510      py = pSrc2;
00028a  4632              MOV      r2,r6
;;;511    
;;;512      /* -------------------    
;;;513       * Stage3 process    
;;;514       * ------------------*/
;;;515    
;;;516      while(blockSize3 > 0u)
00028c  e02f              B        |L1.750|
                  |L1.654|
;;;517      {
;;;518        /* Accumulator is made zero for every iteration */
;;;519        sum = 0;
00028e  2300              MOVS     r3,#0
;;;520    
;;;521        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;522        k = blockSize3 >> 2u;
000290  9c00              LDR      r4,[sp,#0]
000292  08a4              LSRS     r4,r4,#2
;;;523    
;;;524        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;525         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;526        while(k > 0u)
000294  e015              B        |L1.706|
                  |L1.662|
;;;527        {
;;;528          /* sum += x[srcALen - srcBLen + 1] * y[srcBLen - 1] */
;;;529          sum = (q31_t) ((((q63_t) sum << 32) +
000296  6807              LDR      r7,[r0,#0]
000298  f852c904          LDR      r12,[r2],#-4
00029c  fb57330c          SMMLA    r3,r7,r12,r3
;;;530                          ((q63_t) * px++ * (*py--))) >> 32);
;;;531    
;;;532          /* sum += x[srcALen - srcBLen + 2] * y[srcBLen - 2] */
;;;533          sum = (q31_t) ((((q63_t) sum << 32) +
0002a0  6847              LDR      r7,[r0,#4]
0002a2  f852c904          LDR      r12,[r2],#-4
0002a6  fb57330c          SMMLA    r3,r7,r12,r3
;;;534                          ((q63_t) * px++ * (*py--))) >> 32);
;;;535    
;;;536          /* sum += x[srcALen - srcBLen + 3] * y[srcBLen - 3] */
;;;537          sum = (q31_t) ((((q63_t) sum << 32) +
0002aa  6887              LDR      r7,[r0,#8]
0002ac  f852c904          LDR      r12,[r2],#-4
0002b0  fb57330c          SMMLA    r3,r7,r12,r3
;;;538                          ((q63_t) * px++ * (*py--))) >> 32);
;;;539    
;;;540          /* sum += x[srcALen - srcBLen + 4] * y[srcBLen - 4] */
;;;541          sum = (q31_t) ((((q63_t) sum << 32) +
0002b4  68c7              LDR      r7,[r0,#0xc]
0002b6  f852c904          LDR      r12,[r2],#-4
0002ba  3010              ADDS     r0,r0,#0x10
0002bc  fb57330c          SMMLA    r3,r7,r12,r3
;;;542                          ((q63_t) * px++ * (*py--))) >> 32);
;;;543    
;;;544          /* Decrement the loop counter */
;;;545          k--;
0002c0  1e64              SUBS     r4,r4,#1
                  |L1.706|
0002c2  2c00              CMP      r4,#0                 ;526
0002c4  d1e7              BNE      |L1.662|
;;;546        }
;;;547    
;;;548        /* If the blockSize3 is not a multiple of 4, compute any remaining MACs here.    
;;;549         ** No loop unrolling is used. */
;;;550        k = blockSize3 % 0x4u;
0002c6  9c00              LDR      r4,[sp,#0]
0002c8  f0040403          AND      r4,r4,#3
;;;551    
;;;552        while(k > 0u)
0002cc  e005              B        |L1.730|
                  |L1.718|
;;;553        {
;;;554          /* Perform the multiply-accumulate */
;;;555          sum = (q31_t) ((((q63_t) sum << 32) +
0002ce  c880              LDM      r0!,{r7}
0002d0  f852c904          LDR      r12,[r2],#-4
0002d4  fb57330c          SMMLA    r3,r7,r12,r3
;;;556                          ((q63_t) * px++ * (*py--))) >> 32);
;;;557    
;;;558          /* Decrement the loop counter */
;;;559          k--;
0002d8  1e64              SUBS     r4,r4,#1
                  |L1.730|
0002da  2c00              CMP      r4,#0                 ;552
0002dc  d1f7              BNE      |L1.718|
;;;560        }
;;;561    
;;;562        /* Store the result in the accumulator in the destination buffer. */
;;;563        *pOut++ = sum << 1;
0002de  0058              LSLS     r0,r3,#1
0002e0  c101              STM      r1!,{r0}
;;;564    
;;;565        /* Update the inputA and inputB pointers for next MAC calculation */
;;;566        px = ++pSrc1;
0002e2  1d28              ADDS     r0,r5,#4
0002e4  4605              MOV      r5,r0
;;;567        py = pSrc2;
0002e6  4632              MOV      r2,r6
;;;568    
;;;569        /* Decrement the loop counter */
;;;570        blockSize3--;
0002e8  9b00              LDR      r3,[sp,#0]
0002ea  1e5b              SUBS     r3,r3,#1
0002ec  9300              STR      r3,[sp,#0]
                  |L1.750|
0002ee  9b00              LDR      r3,[sp,#0]            ;516
0002f0  2b00              CMP      r3,#0                 ;516
0002f2  d1cc              BNE      |L1.654|
;;;571      }
;;;572    
;;;573    }
0002f4  b00f              ADD      sp,sp,#0x3c
0002f6  e8bd8ff0          POP      {r4-r11,pc}
;;;574    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_fast_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_conv_fast_q31_c_ce6d9f35____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___19_arm_conv_fast_q31_c_ce6d9f35____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_conv_fast_q31_c_ce6d9f35____REVSH|
#line 144
|__asm___19_arm_conv_fast_q31_c_ce6d9f35____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_conv_fast_q31_c_ce6d9f35____RRX|
#line 300
|__asm___19_arm_conv_fast_q31_c_ce6d9f35____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
