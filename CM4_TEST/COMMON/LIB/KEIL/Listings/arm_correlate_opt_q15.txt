; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_correlate_opt_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_correlate_opt_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_correlate_opt_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_correlate_opt_q15.c]
                          THUMB

                          AREA ||i.arm_correlate_opt_q15||, CODE, READONLY, ALIGN=1

                  arm_correlate_opt_q15 PROC
;;;82     
;;;83     void arm_correlate_opt_q15(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;84       q15_t * pSrcA,
;;;85       uint32_t srcALen,
;;;86       q15_t * pSrcB,
;;;87       uint32_t srcBLen,
;;;88       q15_t * pDst,
;;;89       q15_t * pScratch)
;;;90     {
000004  b08b              SUB      sp,sp,#0x2c
000006  460c              MOV      r4,r1
000008  9914              LDR      r1,[sp,#0x50]
00000a  4699              MOV      r9,r3
;;;91       q15_t *pIn1;                                   /* inputA pointer               */
;;;92       q15_t *pIn2;                                   /* inputB pointer               */
;;;93       q63_t acc0, acc1, acc2, acc3;                  /* Accumulators                  */
;;;94       q15_t *py;                                     /* Intermediate inputB pointer  */
;;;95       q31_t x1, x2, x3;                              /* temporary variables for holding input1 and input2 values */
;;;96       uint32_t j, blkCnt, outBlockSize;              /* loop counter                 */
;;;97       int32_t inc = 1;                               /* output pointer increment     */
00000c  2301              MOVS     r3,#1
00000e  9305              STR      r3,[sp,#0x14]
;;;98       uint32_t tapCnt;
;;;99       q31_t y1, y2;
;;;100      q15_t *pScr;                                   /* Intermediate pointers        */
;;;101      q15_t *pOut = pDst;                            /* output pointer               */
;;;102    #ifdef UNALIGNED_SUPPORT_DISABLE
;;;103    
;;;104      q15_t a, b;
;;;105    
;;;106    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;107    
;;;108      /* The algorithm implementation is based on the lengths of the inputs. */
;;;109      /* srcB is always made to slide across srcA. */
;;;110      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;111      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;112      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;113      /* and the destination pointer modifier, inc is set to -1 */
;;;114      /* If srcALen > srcBLen, zero pad has to be done to srcB to make the two inputs of same length */
;;;115      /* But to improve the performance,        
;;;116       * we include zeroes in the output instead of zero padding either of the the inputs*/
;;;117      /* If srcALen > srcBLen,        
;;;118       * (srcALen - srcBLen) zeroes has to included in the starting of the output buffer */
;;;119      /* If srcALen < srcBLen,        
;;;120       * (srcALen - srcBLen) zeroes has to included in the ending of the output buffer */
;;;121      if(srcALen >= srcBLen)
;;;122      {
;;;123        /* Initialization of inputA pointer */
;;;124        pIn1 = (pSrcA);
;;;125    
;;;126        /* Initialization of inputB pointer */
;;;127        pIn2 = (pSrcB);
;;;128    
;;;129        /* Number of output samples is calculated */
;;;130        outBlockSize = (2u * srcALen) - 1u;
000010  1e9b              SUBS     r3,r3,#2
000012  454c              CMP      r4,r9                 ;121
000014  d30b              BCC      |L1.46|
000016  4605              MOV      r5,r0                 ;124
000018  4690              MOV      r8,r2                 ;127
00001a  eb030044          ADD      r0,r3,r4,LSL #1
;;;131    
;;;132        /* When srcALen > srcBLen, zero padding is done to srcB        
;;;133         * to make their lengths equal.        
;;;134         * Instead, (outBlockSize - (srcALen + srcBLen - 1))        
;;;135         * number of output samples are made zero */
;;;136        j = outBlockSize - (srcALen + (srcBLen - 1u));
00001e  eb040209          ADD      r2,r4,r9
000022  1a80              SUBS     r0,r0,r2
000024  1c40              ADDS     r0,r0,#1
;;;137    
;;;138        /* Updating the pointer position to non zero value */
;;;139        pOut += j;
000026  eb010040          ADD      r0,r1,r0,LSL #1
00002a  9002              STR      r0,[sp,#8]
00002c  e00b              B        |L1.70|
                  |L1.46|
;;;140    
;;;141      }
;;;142      else
;;;143      {
;;;144        /* Initialization of inputA pointer */
;;;145        pIn1 = (pSrcB);
00002e  4615              MOV      r5,r2
;;;146    
;;;147        /* Initialization of inputB pointer */
;;;148        pIn2 = (pSrcA);
000030  4680              MOV      r8,r0
;;;149    
;;;150        /* srcBLen is always considered as shorter or equal to srcALen */
;;;151        j = srcBLen;
000032  4648              MOV      r0,r9
;;;152        srcBLen = srcALen;
000034  46a1              MOV      r9,r4
;;;153        srcALen = j;
000036  4604              MOV      r4,r0
;;;154    
;;;155        /* CORR(x, y) = Reverse order(CORR(y, x)) */
;;;156        /* Hence set the destination pointer to point to the last output sample */
;;;157        pOut = pDst + ((srcALen + srcBLen) - 2u);
000038  eb040009          ADD      r0,r4,r9
00003c  1e80              SUBS     r0,r0,#2
00003e  eb010040          ADD      r0,r1,r0,LSL #1
000042  9002              STR      r0,[sp,#8]
;;;158    
;;;159        /* Destination address modifier is set to -1 */
;;;160        inc = -1;
000044  9305              STR      r3,[sp,#0x14]
                  |L1.70|
;;;161    
;;;162      }
;;;163    
;;;164      pScr = pScratch;
000046  9e15              LDR      r6,[sp,#0x54]
;;;165    
;;;166      /* Fill (srcBLen - 1u) zeros in scratch buffer */
;;;167      arm_fill_q15(0, pScr, (srcBLen - 1u));
000048  f1a90201          SUB      r2,r9,#1
00004c  4631              MOV      r1,r6
00004e  2000              MOVS     r0,#0
000050  f7fffffe          BL       arm_fill_q15
;;;168    
;;;169      /* Update temporary scratch pointer */
;;;170      pScr += (srcBLen - 1u);
000054  f1a90001          SUB      r0,r9,#1
000058  eb060640          ADD      r6,r6,r0,LSL #1
;;;171    
;;;172    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;173    
;;;174      /* Copy (srcALen) samples in scratch buffer */
;;;175      arm_copy_q15(pIn1, pScr, srcALen);
00005c  4622              MOV      r2,r4
00005e  4631              MOV      r1,r6
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       arm_copy_q15
;;;176    
;;;177      /* Update pointers */
;;;178      //pIn1 += srcALen;    
;;;179      pScr += srcALen;
000066  eb060144          ADD      r1,r6,r4,LSL #1
;;;180    
;;;181    #else
;;;182    
;;;183      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;184      j = srcALen >> 2u;
;;;185    
;;;186      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;187       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;188      while(j > 0u)
;;;189      {
;;;190        /* copy second buffer in reversal manner */
;;;191        *pScr++ = *pIn1++;
;;;192        *pScr++ = *pIn1++;
;;;193        *pScr++ = *pIn1++;
;;;194        *pScr++ = *pIn1++;
;;;195    
;;;196        /* Decrement the loop counter */
;;;197        j--;
;;;198      }
;;;199    
;;;200      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;201       ** No loop unrolling is used. */
;;;202      j = srcALen % 0x4u;
;;;203    
;;;204      while(j > 0u)
;;;205      {
;;;206        /* copy second buffer in reversal manner for remaining samples */
;;;207        *pScr++ = *pIn1++;
;;;208    
;;;209        /* Decrement the loop counter */
;;;210        j--;
;;;211      }
;;;212    
;;;213    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;214    
;;;215    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;216    
;;;217      /* Fill (srcBLen - 1u) zeros at end of scratch buffer */
;;;218      arm_fill_q15(0, pScr, (srcBLen - 1u));
00006a  f1a90201          SUB      r2,r9,#1
00006e  2000              MOVS     r0,#0
000070  f7fffffe          BL       arm_fill_q15
;;;219    
;;;220      /* Update pointer */
;;;221      pScr += (srcBLen - 1u);
;;;222    
;;;223    #else
;;;224    
;;;225    /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;226      j = (srcBLen - 1u) >> 2u;
;;;227    
;;;228      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;229       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;230      while(j > 0u)
;;;231      {
;;;232        /* copy second buffer in reversal manner */
;;;233        *pScr++ = 0;
;;;234        *pScr++ = 0;
;;;235        *pScr++ = 0;
;;;236        *pScr++ = 0;
;;;237    
;;;238        /* Decrement the loop counter */
;;;239        j--;
;;;240      }
;;;241    
;;;242      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;243       ** No loop unrolling is used. */
;;;244      j = (srcBLen - 1u) % 0x4u;
;;;245    
;;;246      while(j > 0u)
;;;247      {
;;;248        /* copy second buffer in reversal manner for remaining samples */
;;;249        *pScr++ = 0;
;;;250    
;;;251        /* Decrement the loop counter */
;;;252        j--;
;;;253      }
;;;254    
;;;255    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;256    
;;;257      /* Temporary pointer for scratch2 */
;;;258      py = pIn2;
000074  f8cd801c          STR      r8,[sp,#0x1c]
;;;259    
;;;260    
;;;261      /* Actual correlation process starts here */
;;;262      blkCnt = (srcALen + srcBLen - 1u) >> 2;
000078  eb040009          ADD      r0,r4,r9
00007c  1e40              SUBS     r0,r0,#1
00007e  900a              STR      r0,[sp,#0x28]
000080  0880              LSRS     r0,r0,#2
000082  9006              STR      r0,[sp,#0x18]
;;;263    
;;;264      while(blkCnt > 0)
000084  e0c3              B        |L1.526|
                  |L1.134|
;;;265      {
;;;266        /* Initialze temporary scratch pointer as scratch1 */
;;;267        pScr = pScratch;
000086  f8ddb054          LDR      r11,[sp,#0x54]
;;;268    
;;;269        /* Clear Accumlators */
;;;270        acc0 = 0;
00008a  2000              MOVS     r0,#0
00008c  4601              MOV      r1,r0
;;;271        acc1 = 0;
00008e  2200              MOVS     r2,#0
000090  4613              MOV      r3,r2
;;;272        acc2 = 0;
000092  2400              MOVS     r4,#0
000094  4625              MOV      r5,r4
;;;273        acc3 = 0;
000096  2600              MOVS     r6,#0
000098  4637              MOV      r7,r6
;;;274    
;;;275        /* Read four samples from scratch1 buffer */
;;;276        x1 = *__SIMD32(pScr)++;
00009a  f85bab04          LDR      r10,[r11],#4
;;;277    
;;;278        /* Read next four samples from scratch1 buffer */
;;;279        x2 = *__SIMD32(pScr)++;
00009e  f85bcb04          LDR      r12,[r11],#4
0000a2  f8cdb00c          STR      r11,[sp,#0xc]
;;;280    
;;;281        tapCnt = (srcBLen) >> 2u;
0000a6  ea4f0b99          LSR      r11,r9,#2
0000aa  f8cdb010          STR      r11,[sp,#0x10]
;;;282    
;;;283        while(tapCnt > 0u)
0000ae  e03b              B        |L1.296|
                  |L1.176|
;;;284        {
;;;285    
;;;286    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;287    
;;;288          /* Read four samples from smaller buffer */
;;;289          y1 = _SIMD32_OFFSET(pIn2);
0000b0  f8d8b000          LDR      r11,[r8,#0]
;;;290          y2 = _SIMD32_OFFSET(pIn2 + 2u);
0000b4  f8d8e004          LDR      lr,[r8,#4]
0000b8  f8cde024          STR      lr,[sp,#0x24]
;;;291    
;;;292          acc0 = __SMLALD(x1, y1, acc0);
0000bc  fbca01cb          SMLALD   r0,r1,r10,r11
;;;293    
;;;294          acc2 = __SMLALD(x2, y1, acc2);
0000c0  fbcc45cb          SMLALD   r4,r5,r12,r11
;;;295    
;;;296    #ifndef ARM_MATH_BIG_ENDIAN
;;;297          x3 = __PKHBT(x2, x1, 0);
0000c4  eacc0a0a          PKHBT    r10,r12,r10
;;;298    #else
;;;299          x3 = __PKHBT(x1, x2, 0);
;;;300    #endif
;;;301    
;;;302          acc1 = __SMLALDX(x3, y1, acc1);
0000c8  fbca23db          SMLALDX  r2,r3,r10,r11
;;;303    
;;;304          x1 = _SIMD32_OFFSET(pScr);
0000cc  f8dda00c          LDR      r10,[sp,#0xc]
0000d0  f8daa000          LDR      r10,[r10,#0]
0000d4  f8cda020          STR      r10,[sp,#0x20]
;;;305    
;;;306          acc0 = __SMLALD(x2, y2, acc0);
0000d8  f8dde024          LDR      lr,[sp,#0x24]
0000dc  fbcc01ce          SMLALD   r0,r1,r12,lr
;;;307    
;;;308          acc2 = __SMLALD(x1, y2, acc2);
0000e0  e9ddae08          LDRD     r10,lr,[sp,#0x20]
0000e4  fbca45ce          SMLALD   r4,r5,r10,lr
;;;309    
;;;310    #ifndef ARM_MATH_BIG_ENDIAN
;;;311          x3 = __PKHBT(x1, x2, 0);
0000e8  eaca0c0c          PKHBT    r12,r10,r12
;;;312    #else
;;;313          x3 = __PKHBT(x2, x1, 0);
;;;314    #endif
;;;315    
;;;316          acc3 = __SMLALDX(x3, y1, acc3);
0000ec  fbcc67db          SMLALDX  r6,r7,r12,r11
;;;317    
;;;318          acc1 = __SMLALDX(x3, y2, acc1);
0000f0  f8dde024          LDR      lr,[sp,#0x24]
0000f4  fbcc23de          SMLALDX  r2,r3,r12,lr
;;;319    
;;;320          x2 = _SIMD32_OFFSET(pScr + 2u);
0000f8  f8ddc00c          LDR      r12,[sp,#0xc]
0000fc  f8dcc004          LDR      r12,[r12,#4]
;;;321    
;;;322    #ifndef ARM_MATH_BIG_ENDIAN
;;;323          x3 = __PKHBT(x2, x1, 0);
000100  eacc0b0a          PKHBT    r11,r12,r10
;;;324    #else
;;;325          x3 = __PKHBT(x1, x2, 0);
;;;326    #endif
;;;327    
;;;328          acc3 = __SMLALDX(x3, y2, acc3);
000104  f8dde024          LDR      lr,[sp,#0x24]
000108  fbcb67de          SMLALDX  r6,r7,r11,lr
;;;329    
;;;330    #else	 
;;;331    
;;;332          /* Read four samples from smaller buffer */
;;;333    	  a = *pIn2;
;;;334    	  b = *(pIn2 + 1);
;;;335    
;;;336    #ifndef ARM_MATH_BIG_ENDIAN
;;;337          y1 = __PKHBT(a, b, 16);
;;;338    #else
;;;339          y1 = __PKHBT(b, a, 16);
;;;340    #endif
;;;341    	  
;;;342    	  a = *(pIn2 + 2);
;;;343    	  b = *(pIn2 + 3);
;;;344    #ifndef ARM_MATH_BIG_ENDIAN
;;;345          y2 = __PKHBT(a, b, 16);
;;;346    #else
;;;347          y2 = __PKHBT(b, a, 16);
;;;348    #endif				
;;;349    
;;;350          acc0 = __SMLALD(x1, y1, acc0);
;;;351    
;;;352          acc2 = __SMLALD(x2, y1, acc2);
;;;353    
;;;354    #ifndef ARM_MATH_BIG_ENDIAN
;;;355          x3 = __PKHBT(x2, x1, 0);
;;;356    #else
;;;357          x3 = __PKHBT(x1, x2, 0);
;;;358    #endif
;;;359    
;;;360          acc1 = __SMLALDX(x3, y1, acc1);
;;;361    
;;;362    	  a = *pScr;
;;;363    	  b = *(pScr + 1);
;;;364    
;;;365    #ifndef ARM_MATH_BIG_ENDIAN
;;;366          x1 = __PKHBT(a, b, 16);
;;;367    #else
;;;368          x1 = __PKHBT(b, a, 16);
;;;369    #endif
;;;370    
;;;371          acc0 = __SMLALD(x2, y2, acc0);
;;;372    
;;;373          acc2 = __SMLALD(x1, y2, acc2);
;;;374    
;;;375    #ifndef ARM_MATH_BIG_ENDIAN
;;;376          x3 = __PKHBT(x1, x2, 0);
;;;377    #else
;;;378          x3 = __PKHBT(x2, x1, 0);
;;;379    #endif
;;;380    
;;;381          acc3 = __SMLALDX(x3, y1, acc3);
;;;382    
;;;383          acc1 = __SMLALDX(x3, y2, acc1);
;;;384    
;;;385    	  a = *(pScr + 2);
;;;386    	  b = *(pScr + 3);
;;;387    
;;;388    #ifndef ARM_MATH_BIG_ENDIAN
;;;389          x2 = __PKHBT(a, b, 16);
;;;390    #else
;;;391          x2 = __PKHBT(b, a, 16);
;;;392    #endif
;;;393    
;;;394    #ifndef ARM_MATH_BIG_ENDIAN
;;;395          x3 = __PKHBT(x2, x1, 0);
;;;396    #else
;;;397          x3 = __PKHBT(x1, x2, 0);
;;;398    #endif
;;;399    
;;;400          acc3 = __SMLALDX(x3, y2, acc3);
;;;401    
;;;402    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;403    
;;;404          pIn2 += 4u;
00010c  f1080808          ADD      r8,r8,#8
;;;405    
;;;406          pScr += 4u;
000110  f8ddb00c          LDR      r11,[sp,#0xc]
000114  f10b0b08          ADD      r11,r11,#8
000118  f8cdb00c          STR      r11,[sp,#0xc]
;;;407    
;;;408    
;;;409          /* Decrement the loop counter */
;;;410          tapCnt--;
00011c  f8ddb010          LDR      r11,[sp,#0x10]
000120  f1ab0b01          SUB      r11,r11,#1
000124  f8cdb010          STR      r11,[sp,#0x10]
                  |L1.296|
000128  f8ddb010          LDR      r11,[sp,#0x10]        ;283
00012c  f1bb0f00          CMP      r11,#0                ;283
000130  d1be              BNE      |L1.176|
;;;411        }
;;;412    
;;;413    
;;;414    
;;;415        /* Update scratch pointer for remaining samples of smaller length sequence */
;;;416        pScr -= 4u;
000132  f8dda00c          LDR      r10,[sp,#0xc]
000136  f1aa0a08          SUB      r10,r10,#8
;;;417    
;;;418    
;;;419        /* apply same above for remaining samples of smaller length sequence */
;;;420        tapCnt = (srcBLen) & 3u;
00013a  f0090b03          AND      r11,r9,#3
;;;421    
;;;422        while(tapCnt > 0u)
00013e  e031              B        |L1.420|
                  |L1.320|
;;;423        {
;;;424    
;;;425          /* accumlate the results */
;;;426          acc0 += (*pScr++ * *pIn2);
000140  f93aeb02          LDRSH    lr,[r10],#2
000144  f8cde004          STR      lr,[sp,#4]
000148  f9b8c000          LDRSH    r12,[r8,#0]
00014c  fbce018c          SMLALBB  r0,r1,lr,r12
;;;427          acc1 += (*pScr++ * *pIn2);
000150  9301              STR      r3,[sp,#4]
000152  f93a3b02          LDRSH    r3,[r10],#2
000156  f8cda00c          STR      r10,[sp,#0xc]
00015a  f8dda004          LDR      r10,[sp,#4]
00015e  fbc32a8c          SMLALBB  r2,r10,r3,r12
000162  4653              MOV      r3,r10
;;;428          acc2 += (*pScr++ * *pIn2);
000164  f8dda00c          LDR      r10,[sp,#0xc]
000168  9501              STR      r5,[sp,#4]
00016a  f93a5b02          LDRSH    r5,[r10],#2
00016e  f8cda00c          STR      r10,[sp,#0xc]
000172  f8dda004          LDR      r10,[sp,#4]
000176  fbc54a8c          SMLALBB  r4,r10,r5,r12
00017a  4655              MOV      r5,r10
;;;429          acc3 += (*pScr++ * *pIn2++);
00017c  f8dda00c          LDR      r10,[sp,#0xc]
000180  9701              STR      r7,[sp,#4]
000182  f1080802          ADD      r8,r8,#2
000186  f93a7b02          LDRSH    r7,[r10],#2
00018a  f8cda00c          STR      r10,[sp,#0xc]
00018e  f8dda004          LDR      r10,[sp,#4]
000192  fbc76a8c          SMLALBB  r6,r10,r7,r12
000196  4657              MOV      r7,r10
;;;430    
;;;431          pScr -= 3u;
000198  f8dda00c          LDR      r10,[sp,#0xc]
00019c  f1aa0a06          SUB      r10,r10,#6
;;;432    
;;;433          /* Decrement the loop counter */
;;;434          tapCnt--;
0001a0  f1ab0b01          SUB      r11,r11,#1
                  |L1.420|
0001a4  f1bb0f00          CMP      r11,#0                ;422
0001a8  d1ca              BNE      |L1.320|
;;;435        }
;;;436    
;;;437        blkCnt--;
0001aa  f8ddc018          LDR      r12,[sp,#0x18]
0001ae  f1ac0c01          SUB      r12,r12,#1
0001b2  f8cdc018          STR      r12,[sp,#0x18]
;;;438    
;;;439    
;;;440        /* Store the results in the accumulators in the destination buffer. */
;;;441        *pOut = (__SSAT(acc0 >> 15u, 16));
0001b6  0bc0              LSRS     r0,r0,#15
0001b8  ea404041          ORR      r0,r0,r1,LSL #17
0001bc  f300010f          SSAT     r1,#16,r0
0001c0  9802              LDR      r0,[sp,#8]
0001c2  8001              STRH     r1,[r0,#0]
;;;442        pOut += inc;
0001c4  9905              LDR      r1,[sp,#0x14]
0001c6  9802              LDR      r0,[sp,#8]
0001c8  eb000041          ADD      r0,r0,r1,LSL #1
;;;443        *pOut = (__SSAT(acc1 >> 15u, 16));
0001cc  0bd1              LSRS     r1,r2,#15
0001ce  ea414143          ORR      r1,r1,r3,LSL #17
0001d2  f301010f          SSAT     r1,#16,r1
0001d6  8001              STRH     r1,[r0,#0]
;;;444        pOut += inc;
0001d8  9905              LDR      r1,[sp,#0x14]
0001da  eb000041          ADD      r0,r0,r1,LSL #1
;;;445        *pOut = (__SSAT(acc2 >> 15u, 16));
0001de  0be1              LSRS     r1,r4,#15
0001e0  ea414145          ORR      r1,r1,r5,LSL #17
0001e4  f301010f          SSAT     r1,#16,r1
0001e8  8001              STRH     r1,[r0,#0]
;;;446        pOut += inc;
0001ea  9905              LDR      r1,[sp,#0x14]
0001ec  eb000041          ADD      r0,r0,r1,LSL #1
;;;447        *pOut = (__SSAT(acc3 >> 15u, 16));
0001f0  0bf1              LSRS     r1,r6,#15
0001f2  ea414147          ORR      r1,r1,r7,LSL #17
0001f6  f301010f          SSAT     r1,#16,r1
0001fa  8001              STRH     r1,[r0,#0]
;;;448        pOut += inc;
0001fc  9905              LDR      r1,[sp,#0x14]
0001fe  eb000041          ADD      r0,r0,r1,LSL #1
000202  9002              STR      r0,[sp,#8]
;;;449    
;;;450        /* Initialization of inputB pointer */
;;;451        pIn2 = py;
000204  f8dd801c          LDR      r8,[sp,#0x1c]
;;;452    
;;;453        pScratch += 4u;
000208  9815              LDR      r0,[sp,#0x54]
00020a  3008              ADDS     r0,r0,#8
00020c  9015              STR      r0,[sp,#0x54]
                  |L1.526|
00020e  9806              LDR      r0,[sp,#0x18]         ;264
000210  2800              CMP      r0,#0                 ;264
000212  f47faf38          BNE      |L1.134|
;;;454    
;;;455      }
;;;456    
;;;457    
;;;458      blkCnt = (srcALen + srcBLen - 1u) & 0x3;
000216  980a              LDR      r0,[sp,#0x28]
000218  f0000403          AND      r4,r0,#3
;;;459    
;;;460      /* Calculate correlation for remaining samples of Bigger length sequence */
;;;461      while(blkCnt > 0)
00021c  e033              B        |L1.646|
                  |L1.542|
;;;462      {
;;;463        /* Initialze temporary scratch pointer as scratch1 */
;;;464        pScr = pScratch;
00021e  9a15              LDR      r2,[sp,#0x54]
;;;465    
;;;466        /* Clear Accumlators */
;;;467        acc0 = 0;
000220  2000              MOVS     r0,#0
000222  4601              MOV      r1,r0
;;;468    
;;;469        tapCnt = (srcBLen) >> 1u;
000224  ea4f0359          LSR      r3,r9,#1
;;;470    
;;;471        while(tapCnt > 0u)
000228  e00d              B        |L1.582|
                  |L1.554|
;;;472        {
;;;473    
;;;474          acc0 += (*pScr++ * *pIn2++);
00022a  f9b25000          LDRSH    r5,[r2,#0]
00022e  f9386b02          LDRSH    r6,[r8],#2
000232  fbc50186          SMLALBB  r0,r1,r5,r6
;;;475          acc0 += (*pScr++ * *pIn2++);
000236  f9b25002          LDRSH    r5,[r2,#2]
00023a  f9386b02          LDRSH    r6,[r8],#2
00023e  1d12              ADDS     r2,r2,#4
000240  fbc50186          SMLALBB  r0,r1,r5,r6
;;;476    
;;;477          /* Decrement the loop counter */
;;;478          tapCnt--;
000244  1e5b              SUBS     r3,r3,#1
                  |L1.582|
000246  2b00              CMP      r3,#0                 ;471
000248  d1ef              BNE      |L1.554|
;;;479        }
;;;480    
;;;481        tapCnt = (srcBLen) & 1u;
00024a  f0090301          AND      r3,r9,#1
;;;482    
;;;483        /* apply same above for remaining samples of smaller length sequence */
;;;484        while(tapCnt > 0u)
00024e  e006              B        |L1.606|
                  |L1.592|
;;;485        {
;;;486    
;;;487          /* accumlate the results */
;;;488          acc0 += (*pScr++ * *pIn2++);
000250  f9327b02          LDRSH    r7,[r2],#2
000254  f9386b02          LDRSH    r6,[r8],#2
000258  fbc70186          SMLALBB  r0,r1,r7,r6
;;;489    
;;;490          /* Decrement the loop counter */
;;;491          tapCnt--;
00025c  1e5b              SUBS     r3,r3,#1
                  |L1.606|
00025e  2b00              CMP      r3,#0                 ;484
000260  d1f6              BNE      |L1.592|
;;;492        }
;;;493    
;;;494        blkCnt--;
000262  1e64              SUBS     r4,r4,#1
;;;495    
;;;496        /* Store the result in the accumulator in the destination buffer. */
;;;497        *pOut = (q15_t) (__SSAT((acc0 >> 15), 16));
000264  0bc0              LSRS     r0,r0,#15
000266  ea404041          ORR      r0,r0,r1,LSL #17
00026a  f300010f          SSAT     r1,#16,r0
00026e  9802              LDR      r0,[sp,#8]
000270  8001              STRH     r1,[r0,#0]
;;;498    
;;;499        pOut += inc;
000272  9905              LDR      r1,[sp,#0x14]
000274  9802              LDR      r0,[sp,#8]
000276  eb000041          ADD      r0,r0,r1,LSL #1
00027a  9002              STR      r0,[sp,#8]
;;;500    
;;;501        /* Initialization of inputB pointer */
;;;502        pIn2 = py;
00027c  f8dd801c          LDR      r8,[sp,#0x1c]
;;;503    
;;;504        pScratch += 1u;
000280  9815              LDR      r0,[sp,#0x54]
000282  1c80              ADDS     r0,r0,#2
000284  9015              STR      r0,[sp,#0x54]
                  |L1.646|
000286  2c00              CMP      r4,#0                 ;461
000288  d1c9              BNE      |L1.542|
;;;505    
;;;506      }
;;;507    
;;;508    
;;;509    }
00028a  b00b              ADD      sp,sp,#0x2c
00028c  e8bd8ff0          POP      {r4-r11,pc}
;;;510    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_correlate_opt_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_correlate_opt_q15_c_52b1d3e6____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___23_arm_correlate_opt_q15_c_52b1d3e6____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_correlate_opt_q15_c_52b1d3e6____REVSH|
#line 144
|__asm___23_arm_correlate_opt_q15_c_52b1d3e6____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_correlate_opt_q15_c_52b1d3e6____RRX|
#line 300
|__asm___23_arm_correlate_opt_q15_c_52b1d3e6____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
