; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_mult_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_mult_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_mat_mult_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\MatrixFunctions\arm_mat_mult_q15.c]
                          THUMB

                          AREA ||i.arm_mat_mult_q15||, CODE, READONLY, ALIGN=1

                  arm_mat_mult_q15 PROC
;;;78     
;;;79     arm_status arm_mat_mult_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;80       const arm_matrix_instance_q15 * pSrcA,
;;;81       const arm_matrix_instance_q15 * pSrcB,
;;;82       arm_matrix_instance_q15 * pDst,
;;;83       q15_t * pState CMSIS_UNUSED)
;;;84     {
000004  b083              SUB      sp,sp,#0xc
;;;85       q63_t sum;                                     /* accumulator */
;;;86     
;;;87     #ifndef ARM_MATH_CM0_FAMILY
;;;88     
;;;89       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;90     
;;;91       q15_t *pSrcBT = pState;                        /* input data matrix pointer for transpose */
000006  9301              STR      r3,[sp,#4]
;;;92       q15_t *pInA = pSrcA->pData;                    /* input data matrix pointer A of Q15 type */
;;;93       q15_t *pInB = pSrcB->pData;                    /* input data matrix pointer B of Q15 type */
000008  684b              LDR      r3,[r1,#4]
;;;94       q15_t *px;                                     /* Temporary output data matrix pointer */
;;;95       uint16_t numRowsA = pSrcA->numRows;            /* number of rows of input matrix A    */
00000a  9803              LDR      r0,[sp,#0xc]
00000c  f8b0b000          LDRH     r11,[r0,#0]
;;;96       uint16_t numColsB = pSrcB->numCols;            /* number of columns of input matrix B */
000010  8848              LDRH     r0,[r1,#2]
000012  9000              STR      r0,[sp,#0]
;;;97       uint16_t numColsA = pSrcA->numCols;            /* number of columns of input matrix A */
000014  9803              LDR      r0,[sp,#0xc]
000016  f8b0e002          LDRH     lr,[r0,#2]
;;;98       uint16_t numRowsB = pSrcB->numRows;            /* number of rows of input matrix A    */
00001a  8809              LDRH     r1,[r1,#0]
;;;99       uint16_t col, i = 0u, row = numRowsB, colCnt;  /* loop counters */
00001c  2700              MOVS     r7,#0
00001e  460e              MOV      r6,r1
;;;100      arm_status status;                             /* status of matrix multiplication */
;;;101    
;;;102    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;103    
;;;104      q31_t in;                                      /* Temporary variable to hold the input value */
;;;105      q31_t pSourceA1, pSourceB1, pSourceA2, pSourceB2;
;;;106    
;;;107    #else
;;;108    
;;;109      q15_t in;                                      /* Temporary variable to hold the input value */
;;;110      q15_t inA1, inB1, inA2, inB2;
;;;111    
;;;112    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;113    
;;;114    #ifdef ARM_MATH_MATRIX_CHECK
;;;115      /* Check for matrix mismatch condition */
;;;116      if((pSrcA->numCols != pSrcB->numRows) ||
;;;117         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;118      {
;;;119        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;120        status = ARM_MATH_SIZE_MISMATCH;
;;;121      }
;;;122      else
;;;123    #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;124      {
;;;125        /* Matrix transpose */
;;;126        do
;;;127        {
;;;128          /* Apply loop unrolling and exchange the columns with row elements */
;;;129          col = numColsB >> 2;
000020  9800              LDR      r0,[sp,#0]
000022  ea4f0c90          LSR      r12,r0,#2
                  |L1.38|
000026  4664              MOV      r4,r12
;;;130    
;;;131          /* The pointer px is set to starting address of the column being processed */
;;;132          px = pSrcBT + i;
000028  9801              LDR      r0,[sp,#4]
00002a  eb000047          ADD      r0,r0,r7,LSL #1
;;;133    
;;;134          /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.        
;;;135           ** a second loop below computes the remaining 1 to 3 samples. */
;;;136          while(col > 0u)
00002e  e012              B        |L1.86|
                  |L1.48|
;;;137          {
;;;138    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;139    
;;;140            /* Read two elements from the row */
;;;141            in = *__SIMD32(pInB)++;
000030  681d              LDR      r5,[r3,#0]
;;;142    
;;;143            /* Unpack and store one element in the destination */
;;;144    #ifndef ARM_MATH_BIG_ENDIAN
;;;145    
;;;146            *px = (q15_t) in;
000032  8005              STRH     r5,[r0,#0]
;;;147    
;;;148    #else
;;;149    
;;;150            *px = (q15_t) ((in & (q31_t) 0xffff0000) >> 16);
;;;151    
;;;152    #endif /*    #ifndef ARM_MATH_BIG_ENDIAN    */
;;;153    
;;;154            /* Update the pointer px to point to the next row of the transposed matrix */
;;;155            px += numRowsB;
000034  eb000041          ADD      r0,r0,r1,LSL #1
;;;156    
;;;157            /* Unpack and store the second element in the destination */
;;;158    #ifndef ARM_MATH_BIG_ENDIAN
;;;159    
;;;160            *px = (q15_t) ((in & (q31_t) 0xffff0000) >> 16);
000038  142d              ASRS     r5,r5,#16
00003a  8005              STRH     r5,[r0,#0]
;;;161    
;;;162    #else
;;;163    
;;;164            *px = (q15_t) in;
;;;165    
;;;166    #endif /*    #ifndef ARM_MATH_BIG_ENDIAN    */
;;;167    
;;;168            /* Update the pointer px to point to the next row of the transposed matrix */
;;;169            px += numRowsB;
00003c  eb000541          ADD      r5,r0,r1,LSL #1
;;;170    
;;;171            /* Read two elements from the row */
;;;172            in = *__SIMD32(pInB)++;
000040  6858              LDR      r0,[r3,#4]
000042  3308              ADDS     r3,r3,#8
;;;173    
;;;174            /* Unpack and store one element in the destination */
;;;175    #ifndef ARM_MATH_BIG_ENDIAN
;;;176    
;;;177            *px = (q15_t) in;
000044  8028              STRH     r0,[r5,#0]
;;;178    
;;;179    #else
;;;180    
;;;181            *px = (q15_t) ((in & (q31_t) 0xffff0000) >> 16);
;;;182    
;;;183    #endif /*    #ifndef ARM_MATH_BIG_ENDIAN    */
;;;184    
;;;185            /* Update the pointer px to point to the next row of the transposed matrix */
;;;186            px += numRowsB;
000046  eb050541          ADD      r5,r5,r1,LSL #1
;;;187    
;;;188            /* Unpack and store the second element in the destination */
;;;189    
;;;190    #ifndef ARM_MATH_BIG_ENDIAN
;;;191    
;;;192            *px = (q15_t) ((in & (q31_t) 0xffff0000) >> 16);
00004a  1400              ASRS     r0,r0,#16
00004c  8028              STRH     r0,[r5,#0]
;;;193    
;;;194    #else
;;;195    
;;;196            *px = (q15_t) in;
;;;197    
;;;198    #endif /*    #ifndef ARM_MATH_BIG_ENDIAN    */
;;;199    
;;;200            /* Update the pointer px to point to the next row of the transposed matrix */
;;;201            px += numRowsB;
00004e  eb050041          ADD      r0,r5,r1,LSL #1
;;;202    
;;;203    #else
;;;204    
;;;205            /* Read one element from the row */
;;;206            in = *pInB++;
;;;207    
;;;208            /* Store one element in the destination */
;;;209            *px = in;
;;;210     
;;;211            /* Update the pointer px to point to the next row of the transposed matrix */
;;;212            px += numRowsB;
;;;213    
;;;214            /* Read one element from the row */
;;;215            in = *pInB++;
;;;216    
;;;217            /* Store one element in the destination */
;;;218            *px = in;
;;;219     
;;;220            /* Update the pointer px to point to the next row of the transposed matrix */
;;;221            px += numRowsB;
;;;222    
;;;223            /* Read one element from the row */
;;;224            in = *pInB++;
;;;225    
;;;226            /* Store one element in the destination */
;;;227            *px = in;
;;;228     
;;;229            /* Update the pointer px to point to the next row of the transposed matrix */
;;;230            px += numRowsB;
;;;231    
;;;232            /* Read one element from the row */
;;;233            in = *pInB++;
;;;234    
;;;235            /* Store one element in the destination */
;;;236            *px = in;
;;;237     
;;;238            /* Update the pointer px to point to the next row of the transposed matrix */
;;;239            px += numRowsB;
;;;240    
;;;241    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;242    
;;;243           /* Decrement the column loop counter */
;;;244            col--;
000052  1e64              SUBS     r4,r4,#1
000054  b2a4              UXTH     r4,r4
                  |L1.86|
000056  2c00              CMP      r4,#0                 ;136
000058  d1ea              BNE      |L1.48|
;;;245          }
;;;246    
;;;247          /* If the columns of pSrcB is not a multiple of 4, compute any remaining output samples here.        
;;;248           ** No loop unrolling is used. */
;;;249          col = numColsB % 0x4u;
00005a  9c00              LDR      r4,[sp,#0]
00005c  f0040503          AND      r5,r4,#3
;;;250    
;;;251          while(col > 0u)
000060  e006              B        |L1.112|
                  |L1.98|
;;;252          {
;;;253            /* Read and store the input element in the destination */
;;;254            *px = *pInB++;
000062  f8334b02          LDRH     r4,[r3],#2
000066  8004              STRH     r4,[r0,#0]
;;;255    
;;;256            /* Update the pointer px to point to the next row of the transposed matrix */
;;;257            px += numRowsB;
000068  eb000041          ADD      r0,r0,r1,LSL #1
;;;258    
;;;259            /* Decrement the column loop counter */
;;;260            col--;
00006c  1e6d              SUBS     r5,r5,#1
00006e  b2ad              UXTH     r5,r5
                  |L1.112|
000070  2d00              CMP      r5,#0                 ;251
000072  d1f6              BNE      |L1.98|
;;;261          }
;;;262    
;;;263          i++;
000074  1c7f              ADDS     r7,r7,#1
000076  b2bf              UXTH     r7,r7
;;;264    
;;;265          /* Decrement the row loop counter */
;;;266          row--;
000078  1e76              SUBS     r6,r6,#1
00007a  b2b6              UXTH     r6,r6
;;;267    
;;;268        } while(row > 0u);
00007c  2e00              CMP      r6,#0
00007e  d1d2              BNE      |L1.38|
;;;269    
;;;270        /* Reset the variables for the usage in the following multiplication process */
;;;271        row = numRowsA;
;;;272        i = 0u;
;;;273        px = pDst->pData;
000080  6857              LDR      r7,[r2,#4]
;;;274    
;;;275        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;276        /* row loop */
;;;277        do
;;;278        {
;;;279          /* For every row wise process, the column loop counter is to be initiated */
;;;280          col = numColsB;
;;;281    
;;;282          /* For every row wise process, the pIn2 pointer is set        
;;;283           ** to the starting address of the transposed pSrcB data */
;;;284          pInB = pSrcBT;
;;;285    
;;;286          /* column loop */
;;;287          do
;;;288          {
;;;289            /* Set the variable sum, that acts as accumulator, to zero */
;;;290            sum = 0;
;;;291    
;;;292            /* Apply loop unrolling and compute 2 MACs simultaneously. */
;;;293            colCnt = numColsA >> 2;
000082  ea4f009e          LSR      r0,lr,#2
000086  9002              STR      r0,[sp,#8]
                  |L1.136|
000088  9d00              LDR      r5,[sp,#0]            ;280
00008a  9b01              LDR      r3,[sp,#4]            ;284
                  |L1.140|
00008c  2000              MOVS     r0,#0                 ;290
00008e  4601              MOV      r1,r0                 ;290
000090  9c02              LDR      r4,[sp,#8]
;;;294    
;;;295            /* Initiate the pointer pIn1 to point to the starting address of the column being processed */
;;;296            pInA = pSrcA->pData + i;
000092  9a03              LDR      r2,[sp,#0xc]
000094  6852              LDR      r2,[r2,#4]
000096  eb020246          ADD      r2,r2,r6,LSL #1
;;;297    
;;;298    
;;;299            /* matrix multiplication */
;;;300            while(colCnt > 0u)
00009a  e00d              B        |L1.184|
                  |L1.156|
;;;301            {
;;;302              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;303    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;304    
;;;305              /* read real and imag values from pSrcA and pSrcB buffer */
;;;306              pSourceA1 = *__SIMD32(pInA)++;
00009c  f8529b04          LDR      r9,[r2],#4
;;;307              pSourceB1 = *__SIMD32(pInB)++;
0000a0  f853ab04          LDR      r10,[r3],#4
;;;308    
;;;309              pSourceA2 = *__SIMD32(pInA)++;
0000a4  f852cb04          LDR      r12,[r2],#4
;;;310              pSourceB2 = *__SIMD32(pInB)++;
0000a8  f8538b04          LDR      r8,[r3],#4
;;;311    
;;;312              /* Multiply and Accumlates */
;;;313              sum = __SMLALD(pSourceA1, pSourceB1, sum);
0000ac  fbc901ca          SMLALD   r0,r1,r9,r10
;;;314              sum = __SMLALD(pSourceA2, pSourceB2, sum);
0000b0  fbcc01c8          SMLALD   r0,r1,r12,r8
;;;315    
;;;316    #else
;;;317              /* read real and imag values from pSrcA and pSrcB buffer */
;;;318              inA1 = *pInA++;
;;;319              inB1 = *pInB++;
;;;320              inA2 = *pInA++;
;;;321              /* Multiply and Accumlates */
;;;322              sum += inA1 * inB1;
;;;323              inB2 = *pInB++;
;;;324    
;;;325              inA1 = *pInA++;
;;;326              inB1 = *pInB++;
;;;327              /* Multiply and Accumlates */
;;;328              sum += inA2 * inB2;
;;;329              inA2 = *pInA++;
;;;330              inB2 = *pInB++;
;;;331    
;;;332              /* Multiply and Accumlates */
;;;333              sum += inA1 * inB1;
;;;334              sum += inA2 * inB2;
;;;335    
;;;336    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;337    
;;;338              /* Decrement the loop counter */
;;;339              colCnt--;
0000b4  1e64              SUBS     r4,r4,#1
0000b6  b2a4              UXTH     r4,r4
                  |L1.184|
0000b8  2c00              CMP      r4,#0                 ;300
0000ba  d1ef              BNE      |L1.156|
;;;340            }
;;;341    
;;;342            /* process remaining column samples */
;;;343            colCnt = numColsA & 3u;
0000bc  f00e0403          AND      r4,lr,#3
;;;344    
;;;345            while(colCnt > 0u)
0000c0  e007              B        |L1.210|
                  |L1.194|
;;;346            {
;;;347              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;348              sum += *pInA++ * *pInB++;
0000c2  f9328b02          LDRSH    r8,[r2],#2
0000c6  f933cb02          LDRSH    r12,[r3],#2
0000ca  fbc8018c          SMLALBB  r0,r1,r8,r12
;;;349    
;;;350              /* Decrement the loop counter */
;;;351              colCnt--;
0000ce  1e64              SUBS     r4,r4,#1
0000d0  b2a4              UXTH     r4,r4
                  |L1.210|
0000d2  2c00              CMP      r4,#0                 ;345
0000d4  d1f5              BNE      |L1.194|
;;;352            }
;;;353    
;;;354            /* Saturate and store the result in the destination buffer */
;;;355            *px = (q15_t) (__SSAT((sum >> 15), 16));
0000d6  0bc0              LSRS     r0,r0,#15
0000d8  ea404041          ORR      r0,r0,r1,LSL #17
0000dc  f300000f          SSAT     r0,#16,r0
0000e0  f8270b02          STRH     r0,[r7],#2
;;;356            px++;
;;;357    
;;;358            /* Decrement the column loop counter */
;;;359            col--;
0000e4  1e6d              SUBS     r5,r5,#1
0000e6  b2ad              UXTH     r5,r5
;;;360    
;;;361          } while(col > 0u);
0000e8  2d00              CMP      r5,#0
0000ea  d1cf              BNE      |L1.140|
;;;362    
;;;363          i = i + numColsA;
0000ec  eb06000e          ADD      r0,r6,lr
0000f0  b286              UXTH     r6,r0
;;;364    
;;;365          /* Decrement the row loop counter */
;;;366          row--;
0000f2  f1ab0b01          SUB      r11,r11,#1
0000f6  fa1ffb8b          UXTH     r11,r11
;;;367    
;;;368        } while(row > 0u);
0000fa  f1bb0f00          CMP      r11,#0
0000fe  d1c3              BNE      |L1.136|
;;;369    
;;;370    #else
;;;371    
;;;372      /* Run the below code for Cortex-M0 */
;;;373    
;;;374      q15_t *pIn1 = pSrcA->pData;                    /* input data matrix pointer A */
;;;375      q15_t *pIn2 = pSrcB->pData;                    /* input data matrix pointer B */
;;;376      q15_t *pInA = pSrcA->pData;                    /* input data matrix pointer A of Q15 type */
;;;377      q15_t *pInB = pSrcB->pData;                    /* input data matrix pointer B of Q15 type */
;;;378      q15_t *pOut = pDst->pData;                     /* output data matrix pointer */
;;;379      q15_t *px;                                     /* Temporary output data matrix pointer */
;;;380      uint16_t numColsB = pSrcB->numCols;            /* number of columns of input matrix B */
;;;381      uint16_t numColsA = pSrcA->numCols;            /* number of columns of input matrix A */
;;;382      uint16_t numRowsA = pSrcA->numRows;            /* number of rows of input matrix A    */
;;;383      uint16_t col, i = 0u, row = numRowsA, colCnt;  /* loop counters */
;;;384      arm_status status;                             /* status of matrix multiplication */
;;;385    
;;;386    #ifdef ARM_MATH_MATRIX_CHECK
;;;387    
;;;388      /* Check for matrix mismatch condition */
;;;389      if((pSrcA->numCols != pSrcB->numRows) ||
;;;390         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;391      {
;;;392        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;393        status = ARM_MATH_SIZE_MISMATCH;
;;;394      }
;;;395      else
;;;396    #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;397    
;;;398      {
;;;399        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;400        /* row loop */
;;;401        do
;;;402        {
;;;403          /* Output pointer is set to starting address of the row being processed */
;;;404          px = pOut + i;
;;;405    
;;;406          /* For every row wise process, the column loop counter is to be initiated */
;;;407          col = numColsB;
;;;408    
;;;409          /* For every row wise process, the pIn2 pointer is set          
;;;410           ** to the starting address of the pSrcB data */
;;;411          pIn2 = pSrcB->pData;
;;;412    
;;;413          /* column loop */
;;;414          do
;;;415          {
;;;416            /* Set the variable sum, that acts as accumulator, to zero */
;;;417            sum = 0;
;;;418    
;;;419            /* Initiate the pointer pIn1 to point to the starting address of pSrcA */
;;;420            pIn1 = pInA;
;;;421    
;;;422            /* Matrix A columns number of MAC operations are to be performed */
;;;423            colCnt = numColsA;
;;;424    
;;;425            /* matrix multiplication */
;;;426            while(colCnt > 0u)
;;;427            {
;;;428              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;429              /* Perform the multiply-accumulates */
;;;430              sum += (q31_t) * pIn1++ * *pIn2;
;;;431              pIn2 += numColsB;
;;;432    
;;;433              /* Decrement the loop counter */
;;;434              colCnt--;
;;;435            }
;;;436    
;;;437            /* Convert the result from 34.30 to 1.15 format and store the saturated value in destination buffer */
;;;438            /* Saturate and store the result in the destination buffer */
;;;439            *px++ = (q15_t) __SSAT((sum >> 15), 16);
;;;440    
;;;441            /* Decrement the column loop counter */
;;;442            col--;
;;;443    
;;;444            /* Update the pointer pIn2 to point to the  starting address of the next column */
;;;445            pIn2 = pInB + (numColsB - col);
;;;446    
;;;447          } while(col > 0u);
;;;448    
;;;449          /* Update the pointer pSrcA to point to the  starting address of the next row */
;;;450          i = i + numColsB;
;;;451          pInA = pInA + numColsA;
;;;452    
;;;453          /* Decrement the row loop counter */
;;;454          row--;
;;;455    
;;;456        } while(row > 0u);
;;;457    
;;;458    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;459        /* set status as ARM_MATH_SUCCESS */
;;;460        status = ARM_MATH_SUCCESS;
000100  2000              MOVS     r0,#0
;;;461      }
;;;462    
;;;463      /* Return to application */
;;;464      return (status);
;;;465    }
000102  b007              ADD      sp,sp,#0x1c
000104  e8bd8ff0          POP      {r4-r11,pc}
;;;466    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\MatrixFunctions\\arm_mat_mult_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_mat_mult_q15_c_6512b3d9____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___18_arm_mat_mult_q15_c_6512b3d9____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_mat_mult_q15_c_6512b3d9____REVSH|
#line 144
|__asm___18_arm_mat_mult_q15_c_6512b3d9____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_mat_mult_q15_c_6512b3d9____RRX|
#line 300
|__asm___18_arm_mat_mult_q15_c_6512b3d9____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
