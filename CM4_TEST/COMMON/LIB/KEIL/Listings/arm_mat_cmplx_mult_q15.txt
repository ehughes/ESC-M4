; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_cmplx_mult_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_cmplx_mult_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_mat_cmplx_mult_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\MatrixFunctions\arm_mat_cmplx_mult_q15.c]
                          THUMB

                          AREA ||i.arm_mat_cmplx_mult_q15||, CODE, READONLY, ALIGN=1

                  arm_mat_cmplx_mult_q15 PROC
;;;87     
;;;88     arm_status arm_mat_cmplx_mult_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;89       const arm_matrix_instance_q15 * pSrcA,
;;;90       const arm_matrix_instance_q15 * pSrcB,
;;;91       arm_matrix_instance_q15 * pDst,
;;;92       q15_t * pScratch)
;;;93     {
000004  b084              SUB      sp,sp,#0x10
;;;94       /* accumulator */
;;;95       q15_t *pSrcBT = pScratch;                      /* input data matrix pointer for transpose */
000006  9302              STR      r3,[sp,#8]
;;;96       q15_t *pInA = pSrcA->pData;                    /* input data matrix pointer A of Q15 type */
;;;97       q15_t *pInB = pSrcB->pData;                    /* input data matrix pointer B of Q15 type */
000008  684b              LDR      r3,[r1,#4]
;;;98       q15_t *px;                                     /* Temporary output data matrix pointer */
;;;99       uint16_t numRowsA = pSrcA->numRows;            /* number of rows of input matrix A    */
00000a  9804              LDR      r0,[sp,#0x10]
00000c  f8b08000          LDRH     r8,[r0,#0]
;;;100      uint16_t numColsB = pSrcB->numCols;            /* number of columns of input matrix B */
000010  8848              LDRH     r0,[r1,#2]
000012  9001              STR      r0,[sp,#4]
;;;101      uint16_t numColsA = pSrcA->numCols;            /* number of columns of input matrix A */
000014  9804              LDR      r0,[sp,#0x10]
000016  8840              LDRH     r0,[r0,#2]
000018  9000              STR      r0,[sp,#0]
;;;102      uint16_t numRowsB = pSrcB->numRows;            /* number of rows of input matrix A    */
00001a  8809              LDRH     r1,[r1,#0]
;;;103      uint16_t col, i = 0u, row = numRowsB, colCnt;  /* loop counters */
00001c  2700              MOVS     r7,#0
00001e  460e              MOV      r6,r1
;;;104      arm_status status;                             /* status of matrix multiplication */
;;;105      q63_t sumReal, sumImag;
;;;106    
;;;107    #ifdef UNALIGNED_SUPPORT_DISABLE
;;;108      q15_t in;                                      /* Temporary variable to hold the input value */
;;;109      q15_t a, b, c, d;
;;;110    #else
;;;111      q31_t in;                                      /* Temporary variable to hold the input value */
;;;112      q31_t prod1, prod2;
;;;113      q31_t pSourceA, pSourceB;
;;;114    #endif
;;;115    
;;;116    #ifdef ARM_MATH_MATRIX_CHECK
;;;117      /* Check for matrix mismatch condition */
;;;118      if((pSrcA->numCols != pSrcB->numRows) ||
;;;119         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;120      {
;;;121        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;122        status = ARM_MATH_SIZE_MISMATCH;
;;;123      }
;;;124      else
;;;125    #endif
;;;126      {
;;;127        /* Matrix transpose */
;;;128        do
;;;129        {
;;;130          /* Apply loop unrolling and exchange the columns with row elements */
;;;131          col = numColsB >> 2;
000020  9801              LDR      r0,[sp,#4]
000022  ea4f0c90          LSR      r12,r0,#2
                  |L1.38|
000026  4664              MOV      r4,r12
;;;132    
;;;133          /* The pointer px is set to starting address of the column being processed */
;;;134          px = pSrcBT + i;
000028  9802              LDR      r0,[sp,#8]
00002a  eb000047          ADD      r0,r0,r7,LSL #1
;;;135    
;;;136          /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.      
;;;137           ** a second loop below computes the remaining 1 to 3 samples. */
;;;138          while(col > 0u)
00002e  e012              B        |L1.86|
                  |L1.48|
;;;139          {
;;;140    #ifdef UNALIGNED_SUPPORT_DISABLE
;;;141            /* Read two elements from the row */
;;;142            in = *pInB++;
;;;143            *px = in;
;;;144            in = *pInB++;
;;;145            px[1] = in;
;;;146    
;;;147            /* Update the pointer px to point to the next row of the transposed matrix */
;;;148            px += numRowsB * 2;
;;;149    
;;;150            /* Read two elements from the row */
;;;151            in = *pInB++;
;;;152            *px = in;
;;;153            in = *pInB++;
;;;154            px[1] = in;
;;;155    
;;;156            /* Update the pointer px to point to the next row of the transposed matrix */
;;;157            px += numRowsB * 2;
;;;158    
;;;159            /* Read two elements from the row */
;;;160            in = *pInB++;
;;;161            *px = in;
;;;162            in = *pInB++;
;;;163            px[1] = in;
;;;164    
;;;165            /* Update the pointer px to point to the next row of the transposed matrix */
;;;166            px += numRowsB * 2;
;;;167    
;;;168            /* Read two elements from the row */
;;;169            in = *pInB++;
;;;170            *px = in;
;;;171            in = *pInB++;
;;;172            px[1] = in;
;;;173    
;;;174            /* Update the pointer px to point to the next row of the transposed matrix */
;;;175            px += numRowsB * 2;
;;;176    
;;;177            /* Decrement the column loop counter */
;;;178            col--;
;;;179          }
;;;180    
;;;181          /* If the columns of pSrcB is not a multiple of 4, compute any remaining output samples here.      
;;;182           ** No loop unrolling is used. */
;;;183          col = numColsB % 0x4u;
;;;184    
;;;185          while(col > 0u)
;;;186          {
;;;187            /* Read two elements from the row */
;;;188            in = *pInB++;
;;;189            *px = in;
;;;190            in = *pInB++;
;;;191            px[1] = in;
;;;192    #else
;;;193    
;;;194            /* Read two elements from the row */
;;;195            in = *__SIMD32(pInB)++;
000030  681d              LDR      r5,[r3,#0]
;;;196    
;;;197            *__SIMD32(px) = in;
000032  6005              STR      r5,[r0,#0]
;;;198    
;;;199            /* Update the pointer px to point to the next row of the transposed matrix */
;;;200            px += numRowsB * 2;
000034  eb000081          ADD      r0,r0,r1,LSL #2
;;;201    
;;;202    
;;;203            /* Read two elements from the row */
;;;204            in = *__SIMD32(pInB)++;
000038  685d              LDR      r5,[r3,#4]
;;;205    
;;;206            *__SIMD32(px) = in;
00003a  6005              STR      r5,[r0,#0]
;;;207    
;;;208            /* Update the pointer px to point to the next row of the transposed matrix */
;;;209            px += numRowsB * 2;
00003c  eb000081          ADD      r0,r0,r1,LSL #2
;;;210    
;;;211            /* Read two elements from the row */
;;;212            in = *__SIMD32(pInB)++;
000040  689d              LDR      r5,[r3,#8]
;;;213    
;;;214            *__SIMD32(px) = in;
000042  6005              STR      r5,[r0,#0]
;;;215    
;;;216            /* Update the pointer px to point to the next row of the transposed matrix */
;;;217            px += numRowsB * 2;
000044  eb000081          ADD      r0,r0,r1,LSL #2
;;;218    
;;;219            /* Read two elements from the row */
;;;220            in = *__SIMD32(pInB)++;
000048  68dd              LDR      r5,[r3,#0xc]
00004a  3310              ADDS     r3,r3,#0x10
;;;221    
;;;222            *__SIMD32(px) = in;
00004c  6005              STR      r5,[r0,#0]
;;;223    
;;;224            /* Update the pointer px to point to the next row of the transposed matrix */
;;;225            px += numRowsB * 2;
00004e  eb000081          ADD      r0,r0,r1,LSL #2
;;;226    
;;;227            /* Decrement the column loop counter */
;;;228            col--;
000052  1e64              SUBS     r4,r4,#1
000054  b2a4              UXTH     r4,r4
                  |L1.86|
000056  2c00              CMP      r4,#0                 ;138
000058  d1ea              BNE      |L1.48|
;;;229          }
;;;230    
;;;231          /* If the columns of pSrcB is not a multiple of 4, compute any remaining output samples here.      
;;;232           ** No loop unrolling is used. */
;;;233          col = numColsB % 0x4u;
00005a  9c01              LDR      r4,[sp,#4]
00005c  f0040503          AND      r5,r4,#3
;;;234    
;;;235          while(col > 0u)
000060  e006              B        |L1.112|
                  |L1.98|
;;;236          {
;;;237            /* Read two elements from the row */
;;;238            in = *__SIMD32(pInB)++;
000062  f8534b04          LDR      r4,[r3],#4
;;;239    
;;;240            *__SIMD32(px) = in;
000066  6004              STR      r4,[r0,#0]
;;;241    #endif
;;;242    
;;;243            /* Update the pointer px to point to the next row of the transposed matrix */
;;;244            px += numRowsB * 2;
000068  eb000081          ADD      r0,r0,r1,LSL #2
;;;245    
;;;246            /* Decrement the column loop counter */
;;;247            col--;
00006c  1e6d              SUBS     r5,r5,#1
00006e  b2ad              UXTH     r5,r5
                  |L1.112|
000070  2d00              CMP      r5,#0                 ;235
000072  d1f6              BNE      |L1.98|
;;;248          }
;;;249    
;;;250          i = i + 2u;
000074  1cbf              ADDS     r7,r7,#2
000076  b2bf              UXTH     r7,r7
;;;251    
;;;252          /* Decrement the row loop counter */
;;;253          row--;
000078  1e76              SUBS     r6,r6,#1
00007a  b2b6              UXTH     r6,r6
;;;254    
;;;255        } while(row > 0u);
00007c  2e00              CMP      r6,#0
00007e  d1d2              BNE      |L1.38|
;;;256    
;;;257        /* Reset the variables for the usage in the following multiplication process */
;;;258        row = numRowsA;
;;;259        i = 0u;
000080  46a9              MOV      r9,r5
;;;260        px = pDst->pData;
000082  f8d2a004          LDR      r10,[r2,#4]
;;;261    
;;;262        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;263        /* row loop */
;;;264        do
;;;265        {
;;;266          /* For every row wise process, the column loop counter is to be initiated */
;;;267          col = numColsB;
;;;268    
;;;269          /* For every row wise process, the pIn2 pointer is set      
;;;270           ** to the starting address of the transposed pSrcB data */
;;;271          pInB = pSrcBT;
;;;272    
;;;273          /* column loop */
;;;274          do
;;;275          {
;;;276            /* Set the variable sum, that acts as accumulator, to zero */
;;;277            sumReal = 0;
;;;278            sumImag = 0;
;;;279    
;;;280            /* Apply loop unrolling and compute 2 MACs simultaneously. */
;;;281            colCnt = numColsA >> 1;
000086  9800              LDR      r0,[sp,#0]
000088  0840              LSRS     r0,r0,#1
00008a  9003              STR      r0,[sp,#0xc]
                  |L1.140|
00008c  f8ddc004          LDR      r12,[sp,#4]           ;267
000090  9c02              LDR      r4,[sp,#8]            ;271
                  |L1.146|
000092  2000              MOVS     r0,#0                 ;277
000094  4601              MOV      r1,r0                 ;277
000096  2200              MOVS     r2,#0                 ;278
000098  4613              MOV      r3,r2                 ;278
00009a  9e03              LDR      r6,[sp,#0xc]
;;;282    
;;;283            /* Initiate the pointer pIn1 to point to the starting address of the column being processed */
;;;284            pInA = pSrcA->pData + i * 2;
00009c  9d04              LDR      r5,[sp,#0x10]
00009e  686d              LDR      r5,[r5,#4]
0000a0  eb050589          ADD      r5,r5,r9,LSL #2
;;;285    
;;;286    
;;;287            /* matrix multiplication */
;;;288            while(colCnt > 0u)
0000a4  e020              B        |L1.232|
                  |L1.166|
;;;289            {
;;;290              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;291    
;;;292    #ifdef UNALIGNED_SUPPORT_DISABLE
;;;293    
;;;294              /* read real and imag values from pSrcA buffer */
;;;295              a = *pInA;
;;;296              b = *(pInA + 1u);
;;;297              /* read real and imag values from pSrcB buffer */
;;;298              c = *pInB;
;;;299              d = *(pInB + 1u);
;;;300    
;;;301              /* Multiply and Accumlates */
;;;302              sumReal += (q31_t) a *c;
;;;303              sumImag += (q31_t) a *d;
;;;304              sumReal -= (q31_t) b *d;
;;;305              sumImag += (q31_t) b *c;
;;;306    
;;;307              /* read next real and imag values from pSrcA buffer */
;;;308              a = *(pInA + 2u);
;;;309              b = *(pInA + 3u);
;;;310              /* read next real and imag values from pSrcB buffer */
;;;311              c = *(pInB + 2u);
;;;312              d = *(pInB + 3u);
;;;313    
;;;314              /* update pointer */
;;;315              pInA += 4u;
;;;316    
;;;317              /* Multiply and Accumlates */
;;;318              sumReal += (q31_t) a *c;
;;;319              sumImag += (q31_t) a *d;
;;;320              sumReal -= (q31_t) b *d;
;;;321              sumImag += (q31_t) b *c;
;;;322              /* update pointer */
;;;323              pInB += 4u;
;;;324    #else
;;;325              /* read real and imag values from pSrcA and pSrcB buffer */
;;;326              pSourceA = *__SIMD32(pInA)++;
0000a6  682f              LDR      r7,[r5,#0]
;;;327              pSourceB = *__SIMD32(pInB)++;
0000a8  f854bb04          LDR      r11,[r4],#4
;;;328    
;;;329              /* Multiply and Accumlates */
;;;330    #ifdef ARM_MATH_BIG_ENDIAN
;;;331              prod1 = -__SMUSD(pSourceA, pSourceB);
;;;332    #else
;;;333              prod1 = __SMUSD(pSourceA, pSourceB);
0000ac  fb47fe0b          SMUSD    lr,r7,r11
;;;334    #endif
;;;335              prod2 = __SMUADX(pSourceA, pSourceB);
0000b0  fb27f71b          SMUADX   r7,r7,r11
;;;336              sumReal += (q63_t) prod1;
0000b4  eb10000e          ADDS     r0,r0,lr
0000b8  eb4171ee          ADC      r1,r1,lr,ASR #31
;;;337              sumImag += (q63_t) prod2;
0000bc  19d2              ADDS     r2,r2,r7
0000be  eb4373e7          ADC      r3,r3,r7,ASR #31
;;;338    
;;;339              /* read real and imag values from pSrcA and pSrcB buffer */
;;;340              pSourceA = *__SIMD32(pInA)++;
0000c2  686f              LDR      r7,[r5,#4]
0000c4  f1050508          ADD      r5,r5,#8
;;;341              pSourceB = *__SIMD32(pInB)++;
0000c8  f854bb04          LDR      r11,[r4],#4
;;;342    
;;;343              /* Multiply and Accumlates */
;;;344    #ifdef ARM_MATH_BIG_ENDIAN
;;;345              prod1 = -__SMUSD(pSourceA, pSourceB);
;;;346    #else
;;;347              prod1 = __SMUSD(pSourceA, pSourceB);
0000cc  fb47fe0b          SMUSD    lr,r7,r11
;;;348    #endif
;;;349              prod2 = __SMUADX(pSourceA, pSourceB);
0000d0  fb27f71b          SMUADX   r7,r7,r11
;;;350              sumReal += (q63_t) prod1;
0000d4  eb10000e          ADDS     r0,r0,lr
0000d8  eb4171ee          ADC      r1,r1,lr,ASR #31
;;;351              sumImag += (q63_t) prod2;
0000dc  19d2              ADDS     r2,r2,r7
0000de  eb4373e7          ADC      r3,r3,r7,ASR #31
;;;352    
;;;353    #endif /*      #ifdef UNALIGNED_SUPPORT_DISABLE */
;;;354    
;;;355              /* Decrement the loop counter */
;;;356              colCnt--;
0000e2  f1a60601          SUB      r6,r6,#1
0000e6  b2b6              UXTH     r6,r6
                  |L1.232|
0000e8  2e00              CMP      r6,#0                 ;288
0000ea  d1dc              BNE      |L1.166|
;;;357            }
;;;358    
;;;359            /* process odd column samples */
;;;360            if((numColsA & 0x1u) > 0u)
0000ec  9e00              LDR      r6,[sp,#0]
0000ee  07f6              LSLS     r6,r6,#31
0000f0  d00c              BEQ      |L1.268|
;;;361            {
;;;362              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;363    
;;;364    #ifdef UNALIGNED_SUPPORT_DISABLE
;;;365    
;;;366              /* read real and imag values from pSrcA and pSrcB buffer */
;;;367              a = *pInA++;
;;;368              b = *pInA++;
;;;369              c = *pInB++;
;;;370              d = *pInB++;
;;;371    
;;;372              /* Multiply and Accumlates */
;;;373              sumReal += (q31_t) a *c;
;;;374              sumImag += (q31_t) a *d;
;;;375              sumReal -= (q31_t) b *d;
;;;376              sumImag += (q31_t) b *c;
;;;377    
;;;378    #else
;;;379              /* read real and imag values from pSrcA and pSrcB buffer */
;;;380              pSourceA = *__SIMD32(pInA)++;
0000f2  682d              LDR      r5,[r5,#0]
;;;381              pSourceB = *__SIMD32(pInB)++;
0000f4  f8546b04          LDR      r6,[r4],#4
;;;382    
;;;383              /* Multiply and Accumlates */
;;;384    #ifdef ARM_MATH_BIG_ENDIAN
;;;385              prod1 = -__SMUSD(pSourceA, pSourceB);
;;;386    #else
;;;387              prod1 = __SMUSD(pSourceA, pSourceB);
0000f8  fb45f706          SMUSD    r7,r5,r6
;;;388    #endif
;;;389              prod2 = __SMUADX(pSourceA, pSourceB);
0000fc  fb25f516          SMUADX   r5,r5,r6
;;;390              sumReal += (q63_t) prod1;
000100  19c0              ADDS     r0,r0,r7
000102  eb4171e7          ADC      r1,r1,r7,ASR #31
;;;391              sumImag += (q63_t) prod2;
000106  1952              ADDS     r2,r2,r5
000108  eb4373e5          ADC      r3,r3,r5,ASR #31
                  |L1.268|
;;;392    
;;;393    #endif /*      #ifdef UNALIGNED_SUPPORT_DISABLE */
;;;394    
;;;395            }
;;;396    
;;;397            /* Saturate and store the result in the destination buffer */
;;;398    
;;;399            *px++ = (q15_t) (__SSAT(sumReal >> 15, 16));
00010c  ea4f30d0          LSR      r0,r0,#15
000110  ea404041          ORR      r0,r0,r1,LSL #17
000114  f300000f          SSAT     r0,#16,r0
000118  f82a0b02          STRH     r0,[r10],#2
;;;400            *px++ = (q15_t) (__SSAT(sumImag >> 15, 16));
00011c  ea4f30d2          LSR      r0,r2,#15
000120  ea404043          ORR      r0,r0,r3,LSL #17
000124  f300000f          SSAT     r0,#16,r0
000128  f82a0b02          STRH     r0,[r10],#2
;;;401    
;;;402            /* Decrement the column loop counter */
;;;403            col--;
00012c  f1ac0c01          SUB      r12,r12,#1
000130  fa1ffc8c          UXTH     r12,r12
;;;404    
;;;405          } while(col > 0u);
000134  f1bc0f00          CMP      r12,#0
000138  d1ab              BNE      |L1.146|
;;;406    
;;;407          i = i + numColsA;
00013a  9800              LDR      r0,[sp,#0]
00013c  4448              ADD      r0,r0,r9
00013e  fa1ff980          UXTH     r9,r0
;;;408    
;;;409          /* Decrement the row loop counter */
;;;410          row--;
000142  f1a80801          SUB      r8,r8,#1
000146  fa1ff888          UXTH     r8,r8
;;;411    
;;;412        } while(row > 0u);
00014a  f1b80f00          CMP      r8,#0
00014e  d19d              BNE      |L1.140|
;;;413    
;;;414        /* set status as ARM_MATH_SUCCESS */
;;;415        status = ARM_MATH_SUCCESS;
000150  2000              MOVS     r0,#0
;;;416      }
;;;417    
;;;418      /* Return to application */
;;;419      return (status);
;;;420    }
000152  b008              ADD      sp,sp,#0x20
000154  e8bd8ff0          POP      {r4-r11,pc}
;;;421    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\MatrixFunctions\\arm_mat_cmplx_mult_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_mat_cmplx_mult_q15_c_dbc728df____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___24_arm_mat_cmplx_mult_q15_c_dbc728df____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_mat_cmplx_mult_q15_c_dbc728df____REVSH|
#line 144
|__asm___24_arm_mat_cmplx_mult_q15_c_dbc728df____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_mat_cmplx_mult_q15_c_dbc728df____RRX|
#line 300
|__asm___24_arm_mat_cmplx_mult_q15_c_dbc728df____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
