; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_sparse_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_sparse_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_fir_sparse_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_fir_sparse_q31.c]
                          THUMB

                          AREA ||i.arm_circularRead_f32||, CODE, READONLY, ALIGN=1

                  arm_circularRead_f32 PROC
;;;6193      */
;;;6194     static __INLINE void arm_circularRead_f32(
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;6195     int32_t * circBuffer,
;;;6196     int32_t L,
;;;6197     int32_t * readOffset,
;;;6198     int32_t bufferInc,
;;;6199     int32_t * dst,
;;;6200     int32_t * dst_base,
;;;6201     int32_t dst_length,
;;;6202     int32_t dstInc,
;;;6203     uint32_t blockSize)
;;;6204     {
000004  e9dd7c09          LDRD     r7,r12,[sp,#0x24]
000008  e9dd5807          LDRD     r5,r8,[sp,#0x1c]
00000c  9e0b              LDR      r6,[sp,#0x2c]
;;;6205       uint32_t i = 0u;
;;;6206       int32_t rOffset, dst_end;
;;;6207   
;;;6208       /* Copy the value of Index pointer that points
;;;6209        * to the current location from where the input samples to be read */
;;;6210       rOffset = *readOffset;
00000e  6814              LDR      r4,[r2,#0]
;;;6211       dst_end = (int32_t) (dst_base + dst_length);
000010  eb080787          ADD      r7,r8,r7,LSL #2
000014  e00d              B        |L1.50|
                  |L1.22|
;;;6212   
;;;6213       /* Loop over the blockSize */
;;;6214       i = blockSize;
;;;6215   
;;;6216       while(i > 0u)
;;;6217       {
;;;6218         /* copy the sample from the circular buffer to the destination buffer */
;;;6219         *dst = circBuffer[rOffset];
000016  f8509024          LDR      r9,[r0,r4,LSL #2]
00001a  f8c59000          STR      r9,[r5,#0]
;;;6220   
;;;6221         /* Update the input pointer */
;;;6222         dst += dstInc;
00001e  eb05058c          ADD      r5,r5,r12,LSL #2
;;;6223   
;;;6224         if(dst == (int32_t *) dst_end)
000022  42bd              CMP      r5,r7
000024  d100              BNE      |L1.40|
;;;6225         {
;;;6226           dst = dst_base;
000026  4645              MOV      r5,r8
                  |L1.40|
;;;6227         }
;;;6228   
;;;6229         /* Circularly update rOffset.  Watch out for positive and negative value  */
;;;6230         rOffset += bufferInc;
000028  441c              ADD      r4,r4,r3
;;;6231   
;;;6232         if(rOffset >= L)
00002a  428c              CMP      r4,r1
00002c  db00              BLT      |L1.48|
;;;6233         {
;;;6234           rOffset -= L;
00002e  1a64              SUBS     r4,r4,r1
                  |L1.48|
;;;6235         }
;;;6236   
;;;6237         /* Decrement the loop counter */
;;;6238         i--;
000030  1e76              SUBS     r6,r6,#1
                  |L1.50|
000032  2e00              CMP      r6,#0                 ;6216
000034  d1ef              BNE      |L1.22|
;;;6239       }
;;;6240   
;;;6241       /* Update the index pointer */
;;;6242       *readOffset = rOffset;
000036  6014              STR      r4,[r2,#0]
;;;6243     }
000038  e8bd83f0          POP      {r4-r9,pc}
;;;6244   
                          ENDP


                          AREA ||i.arm_fir_sparse_q31||, CODE, READONLY, ALIGN=1

                  arm_fir_sparse_q31 PROC
;;;65     
;;;66     void arm_fir_sparse_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;67       arm_fir_sparse_instance_q31 * S,
;;;68       q31_t * pSrc,
;;;69       q31_t * pDst,
;;;70       q31_t * pScratchIn,
;;;71       uint32_t blockSize)
;;;72     {
000004  b08b              SUB      sp,sp,#0x2c
000006  4607              MOV      r7,r0
000008  9d18              LDR      r5,[sp,#0x60]
00000a  461e              MOV      r6,r3
;;;73     
;;;74       q31_t *pState = S->pState;                     /* State pointer */
00000c  687a              LDR      r2,[r7,#4]
00000e  9208              STR      r2,[sp,#0x20]
;;;75       q31_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
000010  f8d78008          LDR      r8,[r7,#8]
;;;76       q31_t *px;                                     /* Scratch buffer pointer */
;;;77       q31_t *py = pState;                            /* Temporary pointers for state buffer */
000014  9a08              LDR      r2,[sp,#0x20]
;;;78       q31_t *pb = pScratchIn;                        /* Temporary pointers for scratch buffer */
;;;79       q31_t *pOut;                                   /* Destination pointer */
;;;80       q63_t out;                                     /* Temporary output variable */
;;;81       int32_t *pTapDelay = S->pTapDelay;             /* Pointer to the array containing offset of the non-zero tap values. */
000016  f8d79010          LDR      r9,[r7,#0x10]
;;;82       uint32_t delaySize = S->maxDelay + blockSize;  /* state length */
00001a  89b8              LDRH     r0,[r7,#0xc]
00001c  eb000b05          ADD      r11,r0,r5
;;;83       uint16_t numTaps = S->numTaps;                 /* Filter order */
000020  8838              LDRH     r0,[r7,#0]
000022  9007              STR      r0,[sp,#0x1c]
;;;84       int32_t readIndex;                             /* Read index of the state buffer */
;;;85       uint32_t tapCnt, blkCnt;                       /* loop counters */
;;;86       q31_t coeff = *pCoeffs++;                      /* Read the first coefficient value */
000024  f8584b04          LDR      r4,[r8],#4
;;;87       q31_t in;
;;;88     
;;;89     
;;;90       /* BlockSize of Input samples are copied into the state buffer */
;;;91       /* StateIndex points to the starting position to write in the state buffer */
;;;92       arm_circularWrite_f32((int32_t *) py, delaySize, &S->stateIndex, 1,
000028  2001              MOVS     r0,#1
00002a  468c              MOV      r12,r1
00002c  f1070a02          ADD      r10,r7,#2
000030  4686              MOV      lr,r0
000032  4629              MOV      r1,r5
000034  9005              STR      r0,[sp,#0x14]
000036  f8ba0000          LDRH     r0,[r10,#0]
00003a  e00c              B        |L2.86|
                  |L2.60|
00003c  f8dc3000          LDR      r3,[r12,#0]           ;72
000040  f8423020          STR      r3,[r2,r0,LSL #2]     ;72
000044  eb0c0c8e          ADD      r12,r12,lr,LSL #2     ;72
000048  9b05              LDR      r3,[sp,#0x14]         ;72
00004a  4418              ADD      r0,r0,r3              ;72
00004c  4558              CMP      r0,r11                ;72
00004e  db01              BLT      |L2.84|
000050  eba0000b          SUB      r0,r0,r11             ;72
                  |L2.84|
000054  1e49              SUBS     r1,r1,#1              ;72
                  |L2.86|
000056  2900              CMP      r1,#0                 ;72
000058  d1f0              BNE      |L2.60|
00005a  f8aa0000          STRH     r0,[r10,#0]           ;72
;;;93                             (int32_t *) pSrc, 1, blockSize);
;;;94     
;;;95       /* Read Index, from where the state buffer should be read, is calculated. */
;;;96       readIndex = (int32_t) (S->stateIndex - blockSize) - *pTapDelay++;
00005e  8879              LDRH     r1,[r7,#2]
000060  f8590b04          LDR      r0,[r9],#4
000064  1b49              SUBS     r1,r1,r5
000066  1a08              SUBS     r0,r1,r0
000068  9006              STR      r0,[sp,#0x18]
;;;97     
;;;98       /* Wraparound of readIndex */
;;;99       if(readIndex < 0)
00006a  2800              CMP      r0,#0
00006c  da01              BGE      |L2.114|
;;;100      {
;;;101        readIndex += (int32_t) delaySize;
00006e  4458              ADD      r0,r0,r11
000070  9006              STR      r0,[sp,#0x18]
                  |L2.114|
;;;102      }
;;;103    
;;;104      /* Working pointer for state buffer is updated */
;;;105      py = pState;
000072  9808              LDR      r0,[sp,#0x20]
;;;106    
;;;107      /* blockSize samples are read from the state buffer */
;;;108      arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
000074  e9cd6501          STRD     r6,r5,[sp,#4]
000078  2101              MOVS     r1,#1
00007a  9600              STR      r6,[sp,#0]
00007c  e9cd1503          STRD     r1,r5,[sp,#0xc]
000080  460b              MOV      r3,r1
000082  aa06              ADD      r2,sp,#0x18
000084  4659              MOV      r1,r11
000086  f7fffffe          BL       arm_circularRead_f32
;;;109                           (int32_t *) pb, (int32_t *) pb, blockSize, 1,
;;;110                           blockSize);
;;;111    
;;;112      /* Working pointer for the scratch buffer of state values */
;;;113      px = pb;
00008a  4630              MOV      r0,r6
;;;114    
;;;115      /* Working pointer for scratch buffer of output values */
;;;116      pOut = pDst;
00008c  990d              LDR      r1,[sp,#0x34]
;;;117    
;;;118    
;;;119    #ifndef ARM_MATH_CM0_FAMILY
;;;120    
;;;121      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;122    
;;;123      /* Loop over the blockSize. Unroll by a factor of 4.    
;;;124       * Compute 4 Multiplications at a time. */
;;;125      blkCnt = blockSize >> 2;
00008e  08aa              LSRS     r2,r5,#2
000090  920a              STR      r2,[sp,#0x28]
;;;126    
;;;127      while(blkCnt > 0u)
000092  e012              B        |L2.186|
                  |L2.148|
;;;128      {
;;;129        /* Perform Multiplications and store in the destination buffer */
;;;130        *pOut++ = (q31_t) (((q63_t) * px++ * coeff) >> 32);
000094  6803              LDR      r3,[r0,#0]
000096  fb53f304          SMMUL    r3,r3,r4
00009a  600b              STR      r3,[r1,#0]
;;;131        *pOut++ = (q31_t) (((q63_t) * px++ * coeff) >> 32);
00009c  6843              LDR      r3,[r0,#4]
00009e  fb53f304          SMMUL    r3,r3,r4
0000a2  604b              STR      r3,[r1,#4]
;;;132        *pOut++ = (q31_t) (((q63_t) * px++ * coeff) >> 32);
0000a4  6883              LDR      r3,[r0,#8]
0000a6  fb53f304          SMMUL    r3,r3,r4
0000aa  608b              STR      r3,[r1,#8]
;;;133        *pOut++ = (q31_t) (((q63_t) * px++ * coeff) >> 32);
0000ac  68c3              LDR      r3,[r0,#0xc]
0000ae  3010              ADDS     r0,r0,#0x10
0000b0  fb53f304          SMMUL    r3,r3,r4
0000b4  60cb              STR      r3,[r1,#0xc]
0000b6  3110              ADDS     r1,r1,#0x10
;;;134    
;;;135        /* Decrement the loop counter */
;;;136        blkCnt--;
0000b8  1e52              SUBS     r2,r2,#1
                  |L2.186|
0000ba  2a00              CMP      r2,#0                 ;127
0000bc  d1ea              BNE      |L2.148|
;;;137      }
;;;138    
;;;139      /* If the blockSize is not a multiple of 4,    
;;;140       * compute the remaining samples */
;;;141      blkCnt = blockSize % 0x4u;
0000be  f0050203          AND      r2,r5,#3
0000c2  9209              STR      r2,[sp,#0x24]
;;;142    
;;;143      while(blkCnt > 0u)
0000c4  e004              B        |L2.208|
                  |L2.198|
;;;144      {
;;;145        /* Perform Multiplications and store in the destination buffer */
;;;146        *pOut++ = (q31_t) (((q63_t) * px++ * coeff) >> 32);
0000c6  c808              LDM      r0!,{r3}
0000c8  fb53f304          SMMUL    r3,r3,r4
0000cc  c108              STM      r1!,{r3}
;;;147    
;;;148        /* Decrement the loop counter */
;;;149        blkCnt--;
0000ce  1e52              SUBS     r2,r2,#1
                  |L2.208|
0000d0  2a00              CMP      r2,#0                 ;143
0000d2  d1f8              BNE      |L2.198|
;;;150      }
;;;151    
;;;152      /* Load the coefficient value and    
;;;153       * increment the coefficient buffer for the next set of state values */
;;;154      coeff = *pCoeffs++;
0000d4  f8584b04          LDR      r4,[r8],#4
;;;155    
;;;156      /* Read Index, from where the state buffer should be read, is calculated. */
;;;157      readIndex = (int32_t) (S->stateIndex - blockSize) - *pTapDelay++;
0000d8  8879              LDRH     r1,[r7,#2]
0000da  f8590b04          LDR      r0,[r9],#4
0000de  1b49              SUBS     r1,r1,r5
0000e0  1a08              SUBS     r0,r1,r0
0000e2  9006              STR      r0,[sp,#0x18]
;;;158    
;;;159      /* Wraparound of readIndex */
;;;160      if(readIndex < 0)
0000e4  2800              CMP      r0,#0
0000e6  da01              BGE      |L2.236|
;;;161      {
;;;162        readIndex += (int32_t) delaySize;
0000e8  4458              ADD      r0,r0,r11
0000ea  9006              STR      r0,[sp,#0x18]
                  |L2.236|
;;;163      }
;;;164    
;;;165      /* Loop over the number of taps. */
;;;166      tapCnt = (uint32_t) numTaps - 2u;
0000ec  f8dda01c          LDR      r10,[sp,#0x1c]
0000f0  f1aa0a02          SUB      r10,r10,#2
;;;167    
;;;168      while(tapCnt > 0u)
0000f4  e053              B        |L2.414|
                  |L2.246|
;;;169      {
;;;170        /* Working pointer for state buffer is updated */
;;;171        py = pState;
0000f6  9808              LDR      r0,[sp,#0x20]
;;;172    
;;;173        /* blockSize samples are read from the state buffer */
;;;174        arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
0000f8  e9cd6501          STRD     r6,r5,[sp,#4]
0000fc  2101              MOVS     r1,#1
0000fe  9600              STR      r6,[sp,#0]
000100  e9cd1503          STRD     r1,r5,[sp,#0xc]
000104  460b              MOV      r3,r1
000106  aa06              ADD      r2,sp,#0x18
000108  4659              MOV      r1,r11
00010a  f7fffffe          BL       arm_circularRead_f32
;;;175                             (int32_t *) pb, (int32_t *) pb, blockSize, 1,
;;;176                             blockSize);
;;;177    
;;;178        /* Working pointer for the scratch buffer of state values */
;;;179        px = pb;
00010e  4633              MOV      r3,r6
;;;180    
;;;181        /* Working pointer for scratch buffer of output values */
;;;182        pOut = pDst;
000110  980d              LDR      r0,[sp,#0x34]
;;;183    
;;;184        /* Loop over the blockSize. Unroll by a factor of 4.    
;;;185         * Compute 4 MACS at a time. */
;;;186        blkCnt = blockSize >> 2;
000112  990a              LDR      r1,[sp,#0x28]
;;;187    
;;;188        while(blkCnt > 0u)
000114  e023              B        |L2.350|
                  |L2.278|
;;;189        {
;;;190          out = *pOut;
000116  6802              LDR      r2,[r0,#0]
;;;191          out += ((q63_t) * px++ * coeff) >> 32;
000118  f853cb04          LDR      r12,[r3],#4
00011c  fb8cec04          SMULL    lr,r12,r12,r4
000120  eb1c0202          ADDS     r2,r12,r2
;;;192          *pOut++ = (q31_t) (out);
000124  6002              STR      r2,[r0,#0]
;;;193    
;;;194          out = *pOut;
000126  6842              LDR      r2,[r0,#4]
;;;195          out += ((q63_t) * px++ * coeff) >> 32;
000128  f853cb04          LDR      r12,[r3],#4
00012c  fb8cec04          SMULL    lr,r12,r12,r4
000130  eb1c0202          ADDS     r2,r12,r2
;;;196          *pOut++ = (q31_t) (out);
000134  6042              STR      r2,[r0,#4]
;;;197    
;;;198          out = *pOut;
000136  6882              LDR      r2,[r0,#8]
;;;199          out += ((q63_t) * px++ * coeff) >> 32;
000138  f853cb04          LDR      r12,[r3],#4
00013c  fb8cec04          SMULL    lr,r12,r12,r4
000140  eb1c0202          ADDS     r2,r12,r2
;;;200          *pOut++ = (q31_t) (out);
000144  6082              STR      r2,[r0,#8]
;;;201    
;;;202          out = *pOut;
000146  68c2              LDR      r2,[r0,#0xc]
;;;203          out += ((q63_t) * px++ * coeff) >> 32;
000148  f853cb04          LDR      r12,[r3],#4
00014c  fb8cec04          SMULL    lr,r12,r12,r4
000150  eb1c0202          ADDS     r2,r12,r2
;;;204          *pOut++ = (q31_t) (out);
000154  60c2              STR      r2,[r0,#0xc]
000156  f1000010          ADD      r0,r0,#0x10
;;;205    
;;;206          /* Decrement the loop counter */
;;;207          blkCnt--;
00015a  f1a10101          SUB      r1,r1,#1
                  |L2.350|
00015e  2900              CMP      r1,#0                 ;188
000160  d1d9              BNE      |L2.278|
;;;208        }
;;;209    
;;;210        /* If the blockSize is not a multiple of 4,    
;;;211         * compute the remaining samples */
;;;212        blkCnt = blockSize % 0x4u;
000162  9909              LDR      r1,[sp,#0x24]
;;;213    
;;;214        while(blkCnt > 0u)
000164  e009              B        |L2.378|
                  |L2.358|
;;;215        {
;;;216          /* Perform Multiply-Accumulate */
;;;217          out = *pOut;
000166  6802              LDR      r2,[r0,#0]
;;;218          out += ((q63_t) * px++ * coeff) >> 32;
000168  f853cb04          LDR      r12,[r3],#4
00016c  fb8cec04          SMULL    lr,r12,r12,r4
000170  eb1c0202          ADDS     r2,r12,r2
;;;219          *pOut++ = (q31_t) (out);
000174  c004              STM      r0!,{r2}
;;;220    
;;;221          /* Decrement the loop counter */
;;;222          blkCnt--;
000176  f1a10101          SUB      r1,r1,#1
                  |L2.378|
00017a  2900              CMP      r1,#0                 ;214
00017c  d1f3              BNE      |L2.358|
;;;223        }
;;;224    
;;;225        /* Load the coefficient value and    
;;;226         * increment the coefficient buffer for the next set of state values */
;;;227        coeff = *pCoeffs++;
00017e  f8584b04          LDR      r4,[r8],#4
;;;228    
;;;229        /* Read Index, from where the state buffer should be read, is calculated. */
;;;230        readIndex = (int32_t) (S->stateIndex - blockSize) - *pTapDelay++;
000182  8879              LDRH     r1,[r7,#2]
000184  f8590b04          LDR      r0,[r9],#4
000188  eba10105          SUB      r1,r1,r5
00018c  eba10000          SUB      r0,r1,r0
000190  9006              STR      r0,[sp,#0x18]
;;;231    
;;;232        /* Wraparound of readIndex */
;;;233        if(readIndex < 0)
000192  2800              CMP      r0,#0
000194  da01              BGE      |L2.410|
;;;234        {
;;;235          readIndex += (int32_t) delaySize;
000196  4458              ADD      r0,r0,r11
000198  9006              STR      r0,[sp,#0x18]
                  |L2.410|
;;;236        }
;;;237    
;;;238        /* Decrement the tap loop counter */
;;;239        tapCnt--;
00019a  f1aa0a01          SUB      r10,r10,#1
                  |L2.414|
00019e  f1ba0f00          CMP      r10,#0                ;168
0001a2  d1a8              BNE      |L2.246|
;;;240      }
;;;241    	
;;;242    	/* Compute last tap without the final read of pTapDelay */
;;;243    	
;;;244    	/* Working pointer for state buffer is updated */
;;;245    	py = pState;
0001a4  9808              LDR      r0,[sp,#0x20]
;;;246    
;;;247    	/* blockSize samples are read from the state buffer */
;;;248    	arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
0001a6  e9cd6501          STRD     r6,r5,[sp,#4]
0001aa  2101              MOVS     r1,#1
0001ac  9600              STR      r6,[sp,#0]
0001ae  e9cd1503          STRD     r1,r5,[sp,#0xc]
0001b2  460b              MOV      r3,r1
0001b4  aa06              ADD      r2,sp,#0x18
0001b6  4659              MOV      r1,r11
0001b8  f7fffffe          BL       arm_circularRead_f32
;;;249    											 (int32_t *) pb, (int32_t *) pb, blockSize, 1,
;;;250    											 blockSize);
;;;251    
;;;252    	/* Working pointer for the scratch buffer of state values */
;;;253    	px = pb;
;;;254    
;;;255    	/* Working pointer for scratch buffer of output values */
;;;256    	pOut = pDst;
0001bc  980d              LDR      r0,[sp,#0x34]
;;;257    
;;;258    	/* Loop over the blockSize. Unroll by a factor of 4.    
;;;259    	 * Compute 4 MACS at a time. */
;;;260    	blkCnt = blockSize >> 2;
0001be  990a              LDR      r1,[sp,#0x28]
;;;261    
;;;262    	while(blkCnt > 0u)
0001c0  e01d              B        |L2.510|
                  |L2.450|
;;;263    	{
;;;264    		out = *pOut;
0001c2  6802              LDR      r2,[r0,#0]
;;;265    		out += ((q63_t) * px++ * coeff) >> 32;
0001c4  6833              LDR      r3,[r6,#0]
0001c6  fb835304          SMULL    r5,r3,r3,r4
0001ca  189a              ADDS     r2,r3,r2
;;;266    		*pOut++ = (q31_t) (out);
0001cc  6002              STR      r2,[r0,#0]
;;;267    
;;;268    		out = *pOut;
0001ce  6842              LDR      r2,[r0,#4]
;;;269    		out += ((q63_t) * px++ * coeff) >> 32;
0001d0  6873              LDR      r3,[r6,#4]
0001d2  fb835304          SMULL    r5,r3,r3,r4
0001d6  189a              ADDS     r2,r3,r2
;;;270    		*pOut++ = (q31_t) (out);
0001d8  6042              STR      r2,[r0,#4]
;;;271    
;;;272    		out = *pOut;
0001da  6882              LDR      r2,[r0,#8]
;;;273    		out += ((q63_t) * px++ * coeff) >> 32;
0001dc  68b3              LDR      r3,[r6,#8]
0001de  fb835304          SMULL    r5,r3,r3,r4
0001e2  189a              ADDS     r2,r3,r2
;;;274    		*pOut++ = (q31_t) (out);
0001e4  6082              STR      r2,[r0,#8]
;;;275    
;;;276    		out = *pOut;
0001e6  68c2              LDR      r2,[r0,#0xc]
;;;277    		out += ((q63_t) * px++ * coeff) >> 32;
0001e8  68f3              LDR      r3,[r6,#0xc]
0001ea  f1060610          ADD      r6,r6,#0x10
0001ee  fb835304          SMULL    r5,r3,r3,r4
0001f2  189a              ADDS     r2,r3,r2
;;;278    		*pOut++ = (q31_t) (out);
0001f4  60c2              STR      r2,[r0,#0xc]
0001f6  f1000010          ADD      r0,r0,#0x10
;;;279    
;;;280    		/* Decrement the loop counter */
;;;281    		blkCnt--;
0001fa  f1a10101          SUB      r1,r1,#1
                  |L2.510|
0001fe  2900              CMP      r1,#0                 ;262
000200  d1df              BNE      |L2.450|
;;;282    	}
;;;283    
;;;284    	/* If the blockSize is not a multiple of 4,    
;;;285    	 * compute the remaining samples */
;;;286    	blkCnt = blockSize % 0x4u;
000202  9909              LDR      r1,[sp,#0x24]
;;;287    
;;;288    	while(blkCnt > 0u)
000204  e007              B        |L2.534|
                  |L2.518|
;;;289    	{
;;;290    		/* Perform Multiply-Accumulate */
;;;291    		out = *pOut;
000206  6802              LDR      r2,[r0,#0]
;;;292    		out += ((q63_t) * px++ * coeff) >> 32;
000208  ce08              LDM      r6!,{r3}
00020a  fb835304          SMULL    r5,r3,r3,r4
00020e  189a              ADDS     r2,r3,r2
;;;293    		*pOut++ = (q31_t) (out);
000210  c004              STM      r0!,{r2}
;;;294    
;;;295    		/* Decrement the loop counter */
;;;296    		blkCnt--;
000212  f1a10101          SUB      r1,r1,#1
                  |L2.534|
000216  2900              CMP      r1,#0                 ;288
000218  d1f5              BNE      |L2.518|
;;;297    	}	
;;;298    
;;;299      /* Working output pointer is updated */
;;;300      pOut = pDst;
00021a  980d              LDR      r0,[sp,#0x34]
;;;301    
;;;302      /* Output is converted into 1.31 format. */
;;;303      /* Loop over the blockSize. Unroll by a factor of 4.    
;;;304       * process 4 output samples at a time. */
;;;305      blkCnt = blockSize >> 2;
00021c  990a              LDR      r1,[sp,#0x28]
;;;306    
;;;307      while(blkCnt > 0u)
00021e  e00d              B        |L2.572|
                  |L2.544|
;;;308      {
;;;309        in = *pOut << 1;
000220  6802              LDR      r2,[r0,#0]
000222  0052              LSLS     r2,r2,#1
;;;310        *pOut++ = in;
000224  6002              STR      r2,[r0,#0]
;;;311        in = *pOut << 1;
000226  6842              LDR      r2,[r0,#4]
000228  0052              LSLS     r2,r2,#1
;;;312        *pOut++ = in;
00022a  6042              STR      r2,[r0,#4]
;;;313        in = *pOut << 1;
00022c  6882              LDR      r2,[r0,#8]
00022e  0052              LSLS     r2,r2,#1
;;;314        *pOut++ = in;
000230  6082              STR      r2,[r0,#8]
;;;315        in = *pOut << 1;
000232  68c2              LDR      r2,[r0,#0xc]
000234  0052              LSLS     r2,r2,#1
;;;316        *pOut++ = in;
000236  60c2              STR      r2,[r0,#0xc]
000238  3010              ADDS     r0,r0,#0x10
;;;317    
;;;318        /* Decrement the loop counter */
;;;319        blkCnt--;
00023a  1e49              SUBS     r1,r1,#1
                  |L2.572|
00023c  2900              CMP      r1,#0                 ;307
00023e  d1ef              BNE      |L2.544|
;;;320      }
;;;321    
;;;322      /* If the blockSize is not a multiple of 4,    
;;;323       * process the remaining output samples */
;;;324      blkCnt = blockSize % 0x4u;
000240  9909              LDR      r1,[sp,#0x24]
;;;325    
;;;326      while(blkCnt > 0u)
000242  e003              B        |L2.588|
                  |L2.580|
;;;327      {
;;;328        in = *pOut << 1;
000244  6802              LDR      r2,[r0,#0]
000246  0052              LSLS     r2,r2,#1
;;;329        *pOut++ = in;
000248  c004              STM      r0!,{r2}
;;;330    
;;;331        /* Decrement the loop counter */
;;;332        blkCnt--;
00024a  1e49              SUBS     r1,r1,#1
                  |L2.588|
00024c  2900              CMP      r1,#0                 ;326
00024e  d1f9              BNE      |L2.580|
;;;333      }
;;;334    
;;;335    #else
;;;336    
;;;337      /* Run the below code for Cortex-M0 */
;;;338      blkCnt = blockSize;
;;;339    
;;;340      while(blkCnt > 0u)
;;;341      {
;;;342        /* Perform Multiplications and store in the destination buffer */
;;;343        *pOut++ = (q31_t) (((q63_t) * px++ * coeff) >> 32);
;;;344    
;;;345        /* Decrement the loop counter */
;;;346        blkCnt--;
;;;347      }
;;;348    
;;;349      /* Load the coefficient value and           
;;;350       * increment the coefficient buffer for the next set of state values */
;;;351      coeff = *pCoeffs++;
;;;352    
;;;353      /* Read Index, from where the state buffer should be read, is calculated. */
;;;354      readIndex = (int32_t) (S->stateIndex - blockSize) - *pTapDelay++;
;;;355    
;;;356      /* Wraparound of readIndex */
;;;357      if(readIndex < 0)
;;;358      {
;;;359        readIndex += (int32_t) delaySize;
;;;360      }
;;;361    
;;;362      /* Loop over the number of taps. */
;;;363      tapCnt = (uint32_t) numTaps - 2u;
;;;364    
;;;365      while(tapCnt > 0u)
;;;366      {
;;;367        /* Working pointer for state buffer is updated */
;;;368        py = pState;
;;;369    
;;;370        /* blockSize samples are read from the state buffer */
;;;371        arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
;;;372                             (int32_t *) pb, (int32_t *) pb, blockSize, 1,
;;;373                             blockSize);
;;;374    
;;;375        /* Working pointer for the scratch buffer of state values */
;;;376        px = pb;
;;;377    
;;;378        /* Working pointer for scratch buffer of output values */
;;;379        pOut = pDst;
;;;380    
;;;381        blkCnt = blockSize;
;;;382    
;;;383        while(blkCnt > 0u)
;;;384        {
;;;385          /* Perform Multiply-Accumulate */
;;;386          out = *pOut;
;;;387          out += ((q63_t) * px++ * coeff) >> 32;
;;;388          *pOut++ = (q31_t) (out);
;;;389    
;;;390          /* Decrement the loop counter */
;;;391          blkCnt--;
;;;392        }
;;;393    
;;;394        /* Load the coefficient value and           
;;;395         * increment the coefficient buffer for the next set of state values */
;;;396        coeff = *pCoeffs++;
;;;397    
;;;398        /* Read Index, from where the state buffer should be read, is calculated. */
;;;399        readIndex = (int32_t) (S->stateIndex - blockSize) - *pTapDelay++;
;;;400    
;;;401        /* Wraparound of readIndex */
;;;402        if(readIndex < 0)
;;;403        {
;;;404          readIndex += (int32_t) delaySize;
;;;405        }
;;;406    
;;;407        /* Decrement the tap loop counter */
;;;408        tapCnt--;
;;;409      }
;;;410    	
;;;411    	/* Compute last tap without the final read of pTapDelay */	
;;;412    	
;;;413    	/* Working pointer for state buffer is updated */
;;;414    	py = pState;
;;;415    
;;;416    	/* blockSize samples are read from the state buffer */
;;;417    	arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
;;;418    											 (int32_t *) pb, (int32_t *) pb, blockSize, 1,
;;;419    											 blockSize);
;;;420    
;;;421    	/* Working pointer for the scratch buffer of state values */
;;;422    	px = pb;
;;;423    
;;;424    	/* Working pointer for scratch buffer of output values */
;;;425    	pOut = pDst;
;;;426    
;;;427    	blkCnt = blockSize;
;;;428    
;;;429    	while(blkCnt > 0u)
;;;430    	{
;;;431    		/* Perform Multiply-Accumulate */
;;;432    		out = *pOut;
;;;433    		out += ((q63_t) * px++ * coeff) >> 32;
;;;434    		*pOut++ = (q31_t) (out);
;;;435    
;;;436    		/* Decrement the loop counter */
;;;437    		blkCnt--;
;;;438    	}
;;;439    
;;;440      /* Working output pointer is updated */
;;;441      pOut = pDst;
;;;442    
;;;443      /* Output is converted into 1.31 format. */
;;;444      blkCnt = blockSize;
;;;445    
;;;446      while(blkCnt > 0u)
;;;447      {
;;;448        in = *pOut << 1;
;;;449        *pOut++ = in;
;;;450    
;;;451        /* Decrement the loop counter */
;;;452        blkCnt--;
;;;453      }
;;;454    
;;;455    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;456    
;;;457    }
000250  b00f              ADD      sp,sp,#0x3c
000252  e8bd8ff0          POP      {r4-r11,pc}
;;;458    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_fir_sparse_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_arm_fir_sparse_q31_c_deb9463b____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___20_arm_fir_sparse_q31_c_deb9463b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_arm_fir_sparse_q31_c_deb9463b____REVSH|
#line 144
|__asm___20_arm_fir_sparse_q31_c_deb9463b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_arm_fir_sparse_q31_c_deb9463b____RRX|
#line 300
|__asm___20_arm_fir_sparse_q31_c_deb9463b____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
