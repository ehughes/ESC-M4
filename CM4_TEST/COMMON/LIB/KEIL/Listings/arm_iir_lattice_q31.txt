; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_iir_lattice_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_iir_lattice_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_iir_lattice_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_iir_lattice_q31.c]
                          THUMB

                          AREA ||i.arm_iir_lattice_q31||, CODE, READONLY, ALIGN=1

                  arm_iir_lattice_q31 PROC
;;;69     
;;;70     void arm_iir_lattice_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;71       const arm_iir_lattice_instance_q31 * S,
;;;72       q31_t * pSrc,
;;;73       q31_t * pDst,
;;;74       uint32_t blockSize)
;;;75     {
000004  b087              SUB      sp,sp,#0x1c
;;;76       q31_t fcurr, fnext = 0, gcurr = 0, gnext;      /* Temporary variables for lattice stages */
;;;77       q63_t acc;                                     /* Accumlator */
;;;78       uint32_t blkCnt, tapCnt;                       /* Temporary variables for counts */
;;;79       q31_t *px1, *px2, *pk, *pv;                    /* Temporary pointers for state and coef */
;;;80       uint32_t numStages = S->numStages;             /* number of stages */
000006  8801              LDRH     r1,[r0,#0]
000008  9100              STR      r1,[sp,#0]
;;;81       q31_t *pState;                                 /* State pointer */
;;;82       q31_t *pStateCurnt;                            /* State current pointer */
;;;83     
;;;84       blkCnt = blockSize;
00000a  f8dda028          LDR      r10,[sp,#0x28]
;;;85     
;;;86       pState = &S->pState[0];
00000e  f8d08004          LDR      r8,[r0,#4]
000012  e0f6              B        |L1.514|
                  |L1.20|
;;;87     
;;;88     
;;;89     #ifndef ARM_MATH_CM0_FAMILY
;;;90     
;;;91       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;92     
;;;93       /* Sample processing */
;;;94       while(blkCnt > 0u)
;;;95       {
;;;96         /* Read Sample from input buffer */
;;;97         /* fN(n) = x(n) */
;;;98         fcurr = *pSrc++;
000014  9908              LDR      r1,[sp,#0x20]
000016  c980              LDM      r1!,{r7}
000018  9108              STR      r1,[sp,#0x20]
;;;99     
;;;100        /* Initialize state read pointer */
;;;101        px1 = pState;
;;;102        /* Initialize state write pointer */
;;;103        px2 = pState;
00001a  4643              MOV      r3,r8
;;;104        /* Set accumulator to zero */
;;;105        acc = 0;
;;;106        /* Initialize Ladder coeff pointer */
;;;107        pv = &S->pvCoeffs[0];
00001c  68c4              LDR      r4,[r0,#0xc]
;;;108        /* Initialize Reflection coeff pointer */
;;;109        pk = &S->pkCoeffs[0];
00001e  6886              LDR      r6,[r0,#8]
;;;110    
;;;111    
;;;112        /* Process sample for first tap */
;;;113        gcurr = *px1++;
000020  6819              LDR      r1,[r3,#0]
000022  1d1d              ADDS     r5,r3,#4
;;;114        /* fN-1(n) = fN(n) - kN * gN-1(n-1) */
;;;115        fnext = __QSUB(fcurr, (q31_t) (((q63_t) gcurr * (*pk)) >> 31));
000024  ce04              LDM      r6!,{r2}
000026  fb819c02          SMULL    r9,r12,r1,r2
00002a  ea4f0b4c          LSL      r11,r12,#1
00002e  ea4b7cd9          ORR      r12,r11,r9,LSR #31
000032  fa8cf7a7          QSUB     r7,r7,r12
;;;116        /* gN(n) = kN * fN-1(n) + gN-1(n-1) */
;;;117        gnext = __QADD(gcurr, (q31_t) (((q63_t) fnext * (*pk++)) >> 31));
000036  fb872c02          SMULL    r2,r12,r7,r2
00003a  0fd2              LSRS     r2,r2,#31
00003c  ea42024c          ORR      r2,r2,r12,LSL #1
000040  fa82f181          QADD     r1,r1,r2
;;;118        /* write gN-1(n-1) into state for next sample processing */
;;;119        *px2++ = gnext;
000044  c302              STM      r3!,{r1}
;;;120        /* y(n) += gN(n) * vN  */
;;;121        acc += ((q63_t) gnext * *pv++);
000046  cc04              LDM      r4!,{r2}
000048  fb811202          SMULL    r1,r2,r1,r2
;;;122    
;;;123        /* Update f values for next coefficient processing */
;;;124        fcurr = fnext;
;;;125    
;;;126        /* Loop unrolling.  Process 4 taps at a time. */
;;;127        tapCnt = (numStages - 1u) >> 2;
00004c  f8ddc000          LDR      r12,[sp,#0]
000050  f1ac0c01          SUB      r12,r12,#1
000054  f8cdc018          STR      r12,[sp,#0x18]
000058  ea4f0c9c          LSR      r12,r12,#2
;;;128    
;;;129        while(tapCnt > 0u)
00005c  e08d              B        |L1.378|
                  |L1.94|
;;;130        {
;;;131    
;;;132          /* Process sample for 2nd, 6th .. taps */
;;;133          /* Read gN-2(n-1) from state buffer */
;;;134          gcurr = *px1++;
00005e  f8559b04          LDR      r9,[r5],#4
;;;135          /* fN-2(n) = fN-1(n) - kN-1 * gN-2(n-1) */
;;;136          fnext = __QSUB(fcurr, (q31_t) (((q63_t) gcurr * (*pk)) >> 31));
000062  f8d6b000          LDR      r11,[r6,#0]
000066  f8cdb014          STR      r11,[sp,#0x14]
00006a  fb89be0b          SMULL    r11,lr,r9,r11
00006e  ea4f7bdb          LSR      r11,r11,#31
000072  ea4b0b4e          ORR      r11,r11,lr,LSL #1
000076  fa8bf7a7          QSUB     r7,r7,r11
;;;137          /* gN-1(n) = kN-1 * fN-2(n) + gN-2(n-1) */
;;;138          gnext = __QADD(gcurr, (q31_t) (((q63_t) fnext * (*pk++)) >> 31));
00007a  f8ddb014          LDR      r11,[sp,#0x14]
00007e  1d36              ADDS     r6,r6,#4
000080  fb87be0b          SMULL    r11,lr,r7,r11
000084  ea4f7bdb          LSR      r11,r11,#31
000088  ea4b0b4e          ORR      r11,r11,lr,LSL #1
00008c  fa8bf989          QADD     r9,r9,r11
;;;139          /* y(n) += gN-1(n) * vN-1  */
;;;140          /* process for gN-5(n) * vN-5, gN-9(n) * vN-9 ... */
;;;141          acc += ((q63_t) gnext * *pv++);
000090  f854bb04          LDR      r11,[r4],#4
000094  fb89eb0b          SMULL    lr,r11,r9,r11
000098  eb1e0101          ADDS     r1,lr,r1
00009c  eb4b0202          ADC      r2,r11,r2
;;;142          /* write gN-1(n) into state for next sample processing */
;;;143          *px2++ = gnext;
0000a0  f8439b04          STR      r9,[r3],#4
;;;144    
;;;145          /* Process sample for 3nd, 7th ...taps */
;;;146          /* Read gN-3(n-1) from state buffer */
;;;147          gcurr = *px1++;
0000a4  f8559b04          LDR      r9,[r5],#4
;;;148          /* Process sample for 3rd, 7th .. taps */
;;;149          /* fN-3(n) = fN-2(n) - kN-2 * gN-3(n-1) */
;;;150          fcurr = __QSUB(fnext, (q31_t) (((q63_t) gcurr * (*pk)) >> 31));
0000a8  f8d6b000          LDR      r11,[r6,#0]
0000ac  f8cdb010          STR      r11,[sp,#0x10]
0000b0  fb89be0b          SMULL    r11,lr,r9,r11
0000b4  ea4f7bdb          LSR      r11,r11,#31
0000b8  ea4b0b4e          ORR      r11,r11,lr,LSL #1
0000bc  fa8bf7a7          QSUB     r7,r7,r11
;;;151          /* gN-2(n) = kN-2 * fN-3(n) + gN-3(n-1) */
;;;152          gnext = __QADD(gcurr, (q31_t) (((q63_t) fcurr * (*pk++)) >> 31));
0000c0  f8ddb010          LDR      r11,[sp,#0x10]
0000c4  1d36              ADDS     r6,r6,#4
0000c6  fb87be0b          SMULL    r11,lr,r7,r11
0000ca  ea4f7bdb          LSR      r11,r11,#31
0000ce  ea4b0b4e          ORR      r11,r11,lr,LSL #1
0000d2  fa8bf989          QADD     r9,r9,r11
;;;153          /* y(n) += gN-2(n) * vN-2  */
;;;154          /* process for gN-6(n) * vN-6, gN-10(n) * vN-10 ... */
;;;155          acc += ((q63_t) gnext * *pv++);
0000d6  f854bb04          LDR      r11,[r4],#4
0000da  fb89eb0b          SMULL    lr,r11,r9,r11
0000de  eb1e0101          ADDS     r1,lr,r1
0000e2  eb4b0202          ADC      r2,r11,r2
;;;156          /* write gN-2(n) into state for next sample processing */
;;;157          *px2++ = gnext;
0000e6  f8439b04          STR      r9,[r3],#4
;;;158    
;;;159    
;;;160          /* Process sample for 4th, 8th ...taps */
;;;161          /* Read gN-4(n-1) from state buffer */
;;;162          gcurr = *px1++;
0000ea  f8559b04          LDR      r9,[r5],#4
;;;163          /* Process sample for 4th, 8th .. taps */
;;;164          /* fN-4(n) = fN-3(n) - kN-3 * gN-4(n-1) */
;;;165          fnext = __QSUB(fcurr, (q31_t) (((q63_t) gcurr * (*pk)) >> 31));
0000ee  f8d6b000          LDR      r11,[r6,#0]
0000f2  f8cdb00c          STR      r11,[sp,#0xc]
0000f6  fb89be0b          SMULL    r11,lr,r9,r11
0000fa  ea4f7bdb          LSR      r11,r11,#31
0000fe  ea4b0b4e          ORR      r11,r11,lr,LSL #1
000102  fa8bf7a7          QSUB     r7,r7,r11
;;;166          /* gN-3(n) = kN-3 * fN-4(n) + gN-4(n-1) */
;;;167          gnext = __QADD(gcurr, (q31_t) (((q63_t) fnext * (*pk++)) >> 31));
000106  f8ddb00c          LDR      r11,[sp,#0xc]
00010a  1d36              ADDS     r6,r6,#4
00010c  fb87be0b          SMULL    r11,lr,r7,r11
000110  ea4f7bdb          LSR      r11,r11,#31
000114  ea4b0b4e          ORR      r11,r11,lr,LSL #1
000118  fa8bf989          QADD     r9,r9,r11
;;;168          /* y(n) += gN-3(n) * vN-3  */
;;;169          /* process for gN-7(n) * vN-7, gN-11(n) * vN-11 ... */
;;;170          acc += ((q63_t) gnext * *pv++);
00011c  f854bb04          LDR      r11,[r4],#4
000120  fb89eb0b          SMULL    lr,r11,r9,r11
000124  eb1e0101          ADDS     r1,lr,r1
000128  eb4b0202          ADC      r2,r11,r2
;;;171          /* write gN-3(n) into state for next sample processing */
;;;172          *px2++ = gnext;
00012c  f8439b04          STR      r9,[r3],#4
;;;173    
;;;174    
;;;175          /* Process sample for 5th, 9th ...taps */
;;;176          /* Read gN-5(n-1) from state buffer */
;;;177          gcurr = *px1++;
000130  f8559b04          LDR      r9,[r5],#4
;;;178          /* Process sample for 5th, 9th .. taps */
;;;179          /* fN-5(n) = fN-4(n) - kN-4 * gN-1(n-1) */
;;;180          fcurr = __QSUB(fnext, (q31_t) (((q63_t) gcurr * (*pk)) >> 31));
000134  f8d6b000          LDR      r11,[r6,#0]
000138  f8cdb008          STR      r11,[sp,#8]
00013c  fb89be0b          SMULL    r11,lr,r9,r11
000140  ea4f7bdb          LSR      r11,r11,#31
000144  ea4b0b4e          ORR      r11,r11,lr,LSL #1
000148  fa8bf7a7          QSUB     r7,r7,r11
;;;181          /* gN-4(n) = kN-4 * fN-5(n) + gN-5(n-1) */
;;;182          gnext = __QADD(gcurr, (q31_t) (((q63_t) fcurr * (*pk++)) >> 31));
00014c  f8ddb008          LDR      r11,[sp,#8]
000150  1d36              ADDS     r6,r6,#4
000152  fb87be0b          SMULL    r11,lr,r7,r11
000156  ea4f7bdb          LSR      r11,r11,#31
00015a  ea4b0b4e          ORR      r11,r11,lr,LSL #1
00015e  fa8bf989          QADD     r9,r9,r11
;;;183          /* y(n) += gN-4(n) * vN-4  */
;;;184          /* process for gN-8(n) * vN-8, gN-12(n) * vN-12 ... */
;;;185          acc += ((q63_t) gnext * *pv++);
000162  f854bb04          LDR      r11,[r4],#4
000166  fb89eb0b          SMULL    lr,r11,r9,r11
00016a  eb1e0101          ADDS     r1,lr,r1
00016e  eb4b0202          ADC      r2,r11,r2
;;;186          /* write gN-4(n) into state for next sample processing */
;;;187          *px2++ = gnext;
000172  f8439b04          STR      r9,[r3],#4
;;;188    
;;;189          tapCnt--;
000176  f1ac0c01          SUB      r12,r12,#1
                  |L1.378|
00017a  f1bc0f00          CMP      r12,#0                ;129
00017e  f47faf6e          BNE      |L1.94|
;;;190    
;;;191        }
;;;192    
;;;193        fnext = fcurr;
000182  46bc              MOV      r12,r7
;;;194    
;;;195        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;196        tapCnt = (numStages - 1u) % 0x4u;
000184  f8dd9018          LDR      r9,[sp,#0x18]
000188  f0090903          AND      r9,r9,#3
;;;197    
;;;198        while(tapCnt > 0u)
00018c  e023              B        |L1.470|
                  |L1.398|
;;;199        {
;;;200          gcurr = *px1++;
00018e  f855bb04          LDR      r11,[r5],#4
;;;201          /* Process sample for last taps */
;;;202          fnext = __QSUB(fcurr, (q31_t) (((q63_t) gcurr * (*pk)) >> 31));
000192  f8d6e000          LDR      lr,[r6,#0]
000196  f8cde004          STR      lr,[sp,#4]
00019a  fb8bce0e          SMULL    r12,lr,r11,lr
00019e  ea4f7cdc          LSR      r12,r12,#31
0001a2  ea4c0c4e          ORR      r12,r12,lr,LSL #1
0001a6  fa8cfca7          QSUB     r12,r7,r12
;;;203          gnext = __QADD(gcurr, (q31_t) (((q63_t) fnext * (*pk++)) >> 31));
0001aa  f8dde004          LDR      lr,[sp,#4]
0001ae  1d36              ADDS     r6,r6,#4
0001b0  fb8c7e0e          SMULL    r7,lr,r12,lr
0001b4  0fff              LSRS     r7,r7,#31
0001b6  ea47074e          ORR      r7,r7,lr,LSL #1
0001ba  fa87f78b          QADD     r7,r11,r7
;;;204          /* Output samples for last taps */
;;;205          acc += ((q63_t) gnext * *pv++);
0001be  f854bb04          LDR      r11,[r4],#4
0001c2  fb87eb0b          SMULL    lr,r11,r7,r11
0001c6  eb1e0101          ADDS     r1,lr,r1
0001ca  eb4b0202          ADC      r2,r11,r2
;;;206          *px2++ = gnext;
0001ce  c380              STM      r3!,{r7}
;;;207          fcurr = fnext;
0001d0  4667              MOV      r7,r12
;;;208    
;;;209          tapCnt--;
0001d2  f1a90901          SUB      r9,r9,#1
                  |L1.470|
0001d6  f1b90f00          CMP      r9,#0                 ;198
0001da  d1d8              BNE      |L1.398|
;;;210    
;;;211        }
;;;212    
;;;213        /* y(n) += g0(n) * v0 */
;;;214        acc += (q63_t) fnext *(
0001dc  6824              LDR      r4,[r4,#0]
0001de  fb8c5404          SMULL    r5,r4,r12,r4
0001e2  1869              ADDS     r1,r5,r1
0001e4  4162              ADCS     r2,r2,r4
;;;215      *pv++);
;;;216    
;;;217        *px2++ = fnext;
0001e6  f8c3c000          STR      r12,[r3,#0]
;;;218    
;;;219        /* write out into pDst */
;;;220        *pDst++ = (q31_t) (acc >> 31u);
0001ea  0fc9              LSRS     r1,r1,#31
0001ec  ea410142          ORR      r1,r1,r2,LSL #1
0001f0  9a09              LDR      r2,[sp,#0x24]
0001f2  6011              STR      r1,[r2,#0]
0001f4  9909              LDR      r1,[sp,#0x24]
0001f6  1d09              ADDS     r1,r1,#4
0001f8  9109              STR      r1,[sp,#0x24]
;;;221    
;;;222        /* Advance the state pointer by 4 to process the next group of 4 samples */
;;;223        pState = pState + 1u;
0001fa  f1080804          ADD      r8,r8,#4
;;;224        blkCnt--;
0001fe  f1aa0a01          SUB      r10,r10,#1
                  |L1.514|
000202  f1ba0f00          CMP      r10,#0                ;94
000206  f47faf05          BNE      |L1.20|
;;;225    
;;;226      }
;;;227    
;;;228      /* Processing is complete. Now copy last S->numStages samples to start of the buffer    
;;;229         for the preperation of next frame process */
;;;230    
;;;231      /* Points to the start of the state buffer */
;;;232      pStateCurnt = &S->pState[0];
00020a  6840              LDR      r0,[r0,#4]
;;;233      pState = &S->pState[blockSize];
00020c  990a              LDR      r1,[sp,#0x28]
00020e  eb000181          ADD      r1,r0,r1,LSL #2
;;;234    
;;;235      tapCnt = numStages >> 2u;
000212  9a00              LDR      r2,[sp,#0]
000214  0892              LSRS     r2,r2,#2
;;;236    
;;;237      /* copy data */
;;;238      while(tapCnt > 0u)
000216  e00a              B        |L1.558|
                  |L1.536|
;;;239      {
;;;240        *pStateCurnt++ = *pState++;
000218  680b              LDR      r3,[r1,#0]
00021a  6003              STR      r3,[r0,#0]
;;;241        *pStateCurnt++ = *pState++;
00021c  684b              LDR      r3,[r1,#4]
00021e  6043              STR      r3,[r0,#4]
;;;242        *pStateCurnt++ = *pState++;
000220  688b              LDR      r3,[r1,#8]
000222  6083              STR      r3,[r0,#8]
;;;243        *pStateCurnt++ = *pState++;
000224  68cb              LDR      r3,[r1,#0xc]
000226  3110              ADDS     r1,r1,#0x10
000228  60c3              STR      r3,[r0,#0xc]
00022a  3010              ADDS     r0,r0,#0x10
;;;244    
;;;245        /* Decrement the loop counter */
;;;246        tapCnt--;
00022c  1e52              SUBS     r2,r2,#1
                  |L1.558|
00022e  2a00              CMP      r2,#0                 ;238
000230  d1f2              BNE      |L1.536|
;;;247    
;;;248      }
;;;249    
;;;250      /* Calculate remaining number of copies */
;;;251      tapCnt = (numStages) % 0x4u;
000232  9a00              LDR      r2,[sp,#0]
000234  f0020203          AND      r2,r2,#3
;;;252    
;;;253      /* Copy the remaining q31_t data */
;;;254      while(tapCnt > 0u)
000238  e002              B        |L1.576|
                  |L1.570|
;;;255      {
;;;256        *pStateCurnt++ = *pState++;
00023a  c908              LDM      r1!,{r3}
00023c  c008              STM      r0!,{r3}
;;;257    
;;;258        /* Decrement the loop counter */
;;;259        tapCnt--;
00023e  1e52              SUBS     r2,r2,#1
                  |L1.576|
000240  2a00              CMP      r2,#0                 ;254
000242  d1fa              BNE      |L1.570|
;;;260      };
;;;261    
;;;262    #else
;;;263    
;;;264      /* Run the below code for Cortex-M0 */
;;;265      /* Sample processing */
;;;266      while(blkCnt > 0u)
;;;267      {
;;;268        /* Read Sample from input buffer */
;;;269        /* fN(n) = x(n) */
;;;270        fcurr = *pSrc++;
;;;271    
;;;272        /* Initialize state read pointer */
;;;273        px1 = pState;
;;;274        /* Initialize state write pointer */
;;;275        px2 = pState;
;;;276        /* Set accumulator to zero */
;;;277        acc = 0;
;;;278        /* Initialize Ladder coeff pointer */
;;;279        pv = &S->pvCoeffs[0];
;;;280        /* Initialize Reflection coeff pointer */
;;;281        pk = &S->pkCoeffs[0];
;;;282    
;;;283        tapCnt = numStages;
;;;284    
;;;285        while(tapCnt > 0u)
;;;286        {
;;;287          gcurr = *px1++;
;;;288          /* Process sample */
;;;289          /* fN-1(n) = fN(n) - kN * gN-1(n-1) */
;;;290          fnext =
;;;291            clip_q63_to_q31(((q63_t) fcurr -
;;;292                             ((q31_t) (((q63_t) gcurr * (*pk)) >> 31))));
;;;293          /* gN(n) = kN * fN-1(n) + gN-1(n-1) */
;;;294          gnext =
;;;295            clip_q63_to_q31(((q63_t) gcurr +
;;;296                             ((q31_t) (((q63_t) fnext * (*pk++)) >> 31))));
;;;297          /* Output samples */
;;;298          /* y(n) += gN(n) * vN  */
;;;299          acc += ((q63_t) gnext * *pv++);
;;;300          /* write gN-1(n-1) into state for next sample processing */
;;;301          *px2++ = gnext;
;;;302          /* Update f values for next coefficient processing */
;;;303          fcurr = fnext;
;;;304    
;;;305          tapCnt--;
;;;306        }
;;;307    
;;;308        /* y(n) += g0(n) * v0 */
;;;309        acc += (q63_t) fnext *(
;;;310      *pv++);
;;;311    
;;;312        *px2++ = fnext;
;;;313    
;;;314        /* write out into pDst */
;;;315        *pDst++ = (q31_t) (acc >> 31u);
;;;316    
;;;317        /* Advance the state pointer by 1 to process the next group of samples */
;;;318        pState = pState + 1u;
;;;319        blkCnt--;
;;;320    
;;;321      }
;;;322    
;;;323      /* Processing is complete. Now copy last S->numStages samples to start of the buffer           
;;;324         for the preperation of next frame process */
;;;325    
;;;326      /* Points to the start of the state buffer */
;;;327      pStateCurnt = &S->pState[0];
;;;328      pState = &S->pState[blockSize];
;;;329    
;;;330      tapCnt = numStages;
;;;331    
;;;332      /* Copy the remaining q31_t data */
;;;333      while(tapCnt > 0u)
;;;334      {
;;;335        *pStateCurnt++ = *pState++;
;;;336    
;;;337        /* Decrement the loop counter */
;;;338        tapCnt--;
;;;339      }
;;;340    
;;;341    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;342    
;;;343    }
000244  b00b              ADD      sp,sp,#0x2c
000246  e8bd8ff0          POP      {r4-r11,pc}
;;;344    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_iir_lattice_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_iir_lattice_q31_c_4c78cbb1____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___21_arm_iir_lattice_q31_c_4c78cbb1____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_iir_lattice_q31_c_4c78cbb1____REVSH|
#line 144
|__asm___21_arm_iir_lattice_q31_c_4c78cbb1____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_iir_lattice_q31_c_4c78cbb1____RRX|
#line 300
|__asm___21_arm_iir_lattice_q31_c_4c78cbb1____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
