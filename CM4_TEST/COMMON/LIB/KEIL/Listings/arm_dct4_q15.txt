; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_dct4_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_dct4_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_dct4_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\TransformFunctions\arm_dct4_q15.c]
                          THUMB

                          AREA ||i.arm_dct4_q15||, CODE, READONLY, ALIGN=1

                  arm_dct4_q15 PROC
;;;62     
;;;63     void arm_dct4_q15(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;64       const arm_dct4_instance_q15 * S,
;;;65       q15_t * pState,
;;;66       q15_t * pInlineBuffer)
;;;67     {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;68       uint32_t i;                                    /* Loop counter */
;;;69       q15_t *weights = S->pTwiddle;                  /* Pointer to the Weights table */
00000a  f8d48008          LDR      r8,[r4,#8]
;;;70       q15_t *cosFact = S->pCosFactor;                /* Pointer to the cos factors table */
00000e  68e1              LDR      r1,[r4,#0xc]
;;;71       q15_t *pS1, *pS2, *pbuff;                      /* Temporary pointers for input buffer and pState buffer */
;;;72       q15_t in;                                      /* Temporary variable */
;;;73     
;;;74     
;;;75       /* DCT4 computation involves DCT2 (which is calculated using RFFT)    
;;;76        * along with some pre-processing and post-processing.    
;;;77        * Computational procedure is explained as follows:    
;;;78        * (a) Pre-processing involves multiplying input with cos factor,    
;;;79        *     r(n) = 2 * u(n) * cos(pi*(2*n+1)/(4*n))    
;;;80        *              where,    
;;;81        *                 r(n) -- output of preprocessing    
;;;82        *                 u(n) -- input to preprocessing(actual Source buffer)    
;;;83        * (b) Calculation of DCT2 using FFT is divided into three steps:    
;;;84        *                  Step1: Re-ordering of even and odd elements of input.    
;;;85        *                  Step2: Calculating FFT of the re-ordered input.    
;;;86        *                  Step3: Taking the real part of the product of FFT output and weights.    
;;;87        * (c) Post-processing - DCT4 can be obtained from DCT2 output using the following equation:    
;;;88        *                   Y4(k) = Y2(k) - Y4(k-1) and Y4(-1) = Y4(0)    
;;;89        *                        where,    
;;;90        *                           Y4 -- DCT4 output,   Y2 -- DCT2 output    
;;;91        * (d) Multiplying the output with the normalizing factor sqrt(2/N).    
;;;92        */
;;;93     
;;;94             /*-------- Pre-processing ------------*/
;;;95       /* Multiplying input with cos factor i.e. r(n) = 2 * x(n) * cos(pi*(2*n+1)/(4*n)) */
;;;96       arm_mult_q15(pInlineBuffer, cosFact, pInlineBuffer, S->N);
000010  8823              LDRH     r3,[r4,#0]
000012  4632              MOV      r2,r6
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       arm_mult_q15
;;;97       arm_shift_q15(pInlineBuffer, 1, pInlineBuffer, S->N);
00001a  8823              LDRH     r3,[r4,#0]
00001c  4632              MOV      r2,r6
00001e  2101              MOVS     r1,#1
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       arm_shift_q15
;;;98     
;;;99       /* ----------------------------------------------------------------    
;;;100       * Step1: Re-ordering of even and odd elements as    
;;;101       *             pState[i] =  pInlineBuffer[2*i] and    
;;;102       *             pState[N-i-1] = pInlineBuffer[2*i+1] where i = 0 to N/2    
;;;103       ---------------------------------------------------------------------*/
;;;104    
;;;105      /* pS1 initialized to pState */
;;;106      pS1 = pState;
;;;107    
;;;108      /* pS2 initialized to pState+N-1, so that it points to the end of the state buffer */
;;;109      pS2 = pState + (S->N - 1u);
000026  8820              LDRH     r0,[r4,#0]
000028  463d              MOV      r5,r7
00002a  1e40              SUBS     r0,r0,#1
00002c  eb070040          ADD      r0,r7,r0,LSL #1
;;;110    
;;;111      /* pbuff initialized to input buffer */
;;;112      pbuff = pInlineBuffer;
000030  4632              MOV      r2,r6
;;;113    
;;;114    
;;;115    #ifndef ARM_MATH_CM0_FAMILY
;;;116    
;;;117      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;118    
;;;119      /* Initializing the loop counter to N/2 >> 2 for loop unrolling by 4 */
;;;120      i = (uint32_t) S->Nby2 >> 2u;
000032  8861              LDRH     r1,[r4,#2]
000034  0889              LSRS     r1,r1,#2
                  |L1.54|
;;;121    
;;;122      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;123       ** a second loop below computes the remaining 1 to 3 samples. */
;;;124      do
;;;125      {
;;;126        /* Re-ordering of even and odd elements */
;;;127        /* pState[i] =  pInlineBuffer[2*i] */
;;;128        *pS1++ = *pbuff++;
000036  8813              LDRH     r3,[r2,#0]
000038  802b              STRH     r3,[r5,#0]
;;;129        /* pState[N-i-1] = pInlineBuffer[2*i+1] */
;;;130        *pS2-- = *pbuff++;
00003a  1f80              SUBS     r0,r0,#6
00003c  8853              LDRH     r3,[r2,#2]
00003e  80c3              STRH     r3,[r0,#6]
;;;131    
;;;132        *pS1++ = *pbuff++;
000040  8893              LDRH     r3,[r2,#4]
000042  806b              STRH     r3,[r5,#2]
;;;133        *pS2-- = *pbuff++;
000044  88d3              LDRH     r3,[r2,#6]
000046  8083              STRH     r3,[r0,#4]
;;;134    
;;;135        *pS1++ = *pbuff++;
000048  8913              LDRH     r3,[r2,#8]
00004a  80ab              STRH     r3,[r5,#4]
;;;136        *pS2-- = *pbuff++;
00004c  8953              LDRH     r3,[r2,#0xa]
00004e  8043              STRH     r3,[r0,#2]
;;;137    
;;;138        *pS1++ = *pbuff++;
000050  8993              LDRH     r3,[r2,#0xc]
000052  80eb              STRH     r3,[r5,#6]
000054  3508              ADDS     r5,r5,#8
;;;139        *pS2-- = *pbuff++;
000056  89d3              LDRH     r3,[r2,#0xe]
000058  3210              ADDS     r2,r2,#0x10
00005a  f8203902          STRH     r3,[r0],#-2
;;;140    
;;;141        /* Decrement the loop counter */
;;;142        i--;
00005e  1e49              SUBS     r1,r1,#1
;;;143      } while(i > 0u);
000060  2900              CMP      r1,#0
000062  d1e8              BNE      |L1.54|
;;;144    
;;;145      /* pbuff initialized to input buffer */
;;;146      pbuff = pInlineBuffer;
000064  4631              MOV      r1,r6
;;;147    
;;;148      /* pS1 initialized to pState */
;;;149      pS1 = pState;
000066  4638              MOV      r0,r7
;;;150    
;;;151      /* Initializing the loop counter to N/4 instead of N for loop unrolling */
;;;152      i = (uint32_t) S->N >> 2u;
000068  8822              LDRH     r2,[r4,#0]
00006a  0892              LSRS     r2,r2,#2
                  |L1.108|
;;;153    
;;;154      /* Processing with loop unrolling 4 times as N is always multiple of 4.    
;;;155       * Compute 4 outputs at a time */
;;;156      do
;;;157      {
;;;158        /* Writing the re-ordered output back to inplace input buffer */
;;;159        *pbuff++ = *pS1++;
00006c  8803              LDRH     r3,[r0,#0]
00006e  800b              STRH     r3,[r1,#0]
;;;160        *pbuff++ = *pS1++;
000070  8843              LDRH     r3,[r0,#2]
000072  804b              STRH     r3,[r1,#2]
;;;161        *pbuff++ = *pS1++;
000074  8883              LDRH     r3,[r0,#4]
000076  808b              STRH     r3,[r1,#4]
;;;162        *pbuff++ = *pS1++;
000078  88c3              LDRH     r3,[r0,#6]
00007a  3008              ADDS     r0,r0,#8
00007c  80cb              STRH     r3,[r1,#6]
00007e  3108              ADDS     r1,r1,#8
;;;163    
;;;164        /* Decrement the loop counter */
;;;165        i--;
000080  1e52              SUBS     r2,r2,#1
;;;166      } while(i > 0u);
000082  2a00              CMP      r2,#0
000084  d1f2              BNE      |L1.108|
;;;167    
;;;168    
;;;169      /* ---------------------------------------------------------    
;;;170       *     Step2: Calculate RFFT for N-point input    
;;;171       * ---------------------------------------------------------- */
;;;172      /* pInlineBuffer is real input of length N , pState is the complex output of length 2N */
;;;173      arm_rfft_q15(S->pRfft, pInlineBuffer, pState);
000086  463a              MOV      r2,r7
000088  4631              MOV      r1,r6
00008a  6920              LDR      r0,[r4,#0x10]
00008c  f7fffffe          BL       arm_rfft_q15
;;;174    
;;;175     /*----------------------------------------------------------------------    
;;;176      *  Step3: Multiply the FFT output with the weights.    
;;;177      *----------------------------------------------------------------------*/
;;;178      arm_cmplx_mult_cmplx_q15(pState, weights, pState, S->N);
000090  8823              LDRH     r3,[r4,#0]
000092  463a              MOV      r2,r7
000094  4641              MOV      r1,r8
000096  4638              MOV      r0,r7
000098  f7fffffe          BL       arm_cmplx_mult_cmplx_q15
;;;179    
;;;180      /* The output of complex multiplication is in 3.13 format.    
;;;181       * Hence changing the format of N (i.e. 2*N elements) complex numbers to 1.15 format by shifting left by 2 bits. */
;;;182      arm_shift_q15(pState, 2, pState, S->N * 2);
00009c  8820              LDRH     r0,[r4,#0]
00009e  463a              MOV      r2,r7
0000a0  0043              LSLS     r3,r0,#1
0000a2  2102              MOVS     r1,#2
0000a4  4638              MOV      r0,r7
0000a6  f7fffffe          BL       arm_shift_q15
;;;183    
;;;184      /* ----------- Post-processing ---------- */
;;;185      /* DCT-IV can be obtained from DCT-II by the equation,    
;;;186       *       Y4(k) = Y2(k) - Y4(k-1) and Y4(-1) = Y4(0)    
;;;187       *       Hence, Y4(0) = Y2(0)/2  */
;;;188      /* Getting only real part from the output and Converting to DCT-IV */
;;;189    
;;;190      /* Initializing the loop counter to N >> 2 for loop unrolling by 4 */
;;;191      i = ((uint32_t) S->N - 1u) >> 2u;
0000aa  8820              LDRH     r0,[r4,#0]
0000ac  1e40              SUBS     r0,r0,#1
0000ae  0882              LSRS     r2,r0,#2
;;;192    
;;;193      /* pbuff initialized to input buffer. */
;;;194      pbuff = pInlineBuffer;
0000b0  4631              MOV      r1,r6
;;;195    
;;;196      /* pS1 initialized to pState */
;;;197      pS1 = pState;
;;;198    
;;;199      /* Calculating Y4(0) from Y2(0) using Y4(0) = Y2(0)/2 */
;;;200      in = *pS1++ >> 1u;
0000b2  f9370b04          LDRSH    r0,[r7],#4
0000b6  1040              ASRS     r0,r0,#1
;;;201      /* input buffer acts as inplace, so output values are stored in the input itself. */
;;;202      *pbuff++ = in;
0000b8  f8210b02          STRH     r0,[r1],#2
                  |L1.188|
;;;203    
;;;204      /* pState pointer is incremented twice as the real values are located alternatively in the array */
;;;205      pS1++;
;;;206    
;;;207      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;208       ** a second loop below computes the remaining 1 to 3 samples. */
;;;209      do
;;;210      {
;;;211        /* Calculating Y4(1) to Y4(N-1) from Y2 using equation Y4(k) = Y2(k) - Y4(k-1) */
;;;212        /* pState pointer (pS1) is incremented twice as the real values are located alternatively in the array */
;;;213        in = *pS1++ - in;
0000bc  883b              LDRH     r3,[r7,#0]
0000be  1a18              SUBS     r0,r3,r0
;;;214        *pbuff++ = in;
0000c0  8008              STRH     r0,[r1,#0]
;;;215        /* points to the next real value */
;;;216        pS1++;
;;;217    
;;;218        in = *pS1++ - in;
0000c2  88bb              LDRH     r3,[r7,#4]
0000c4  1a18              SUBS     r0,r3,r0
;;;219        *pbuff++ = in;
0000c6  8048              STRH     r0,[r1,#2]
;;;220        pS1++;
;;;221    
;;;222        in = *pS1++ - in;
0000c8  893b              LDRH     r3,[r7,#8]
0000ca  1a18              SUBS     r0,r3,r0
;;;223        *pbuff++ = in;
0000cc  8088              STRH     r0,[r1,#4]
;;;224        pS1++;
;;;225    
;;;226        in = *pS1++ - in;
0000ce  89bb              LDRH     r3,[r7,#0xc]
0000d0  3710              ADDS     r7,r7,#0x10
0000d2  1a18              SUBS     r0,r3,r0
0000d4  b200              SXTH     r0,r0
;;;227        *pbuff++ = in;
0000d6  80c8              STRH     r0,[r1,#6]
0000d8  3108              ADDS     r1,r1,#8
;;;228        pS1++;
;;;229    
;;;230        /* Decrement the loop counter */
;;;231        i--;
0000da  1e52              SUBS     r2,r2,#1
;;;232      } while(i > 0u);
0000dc  2a00              CMP      r2,#0
0000de  d1ed              BNE      |L1.188|
;;;233    
;;;234      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;235       ** No loop unrolling is used. */
;;;236      i = ((uint32_t) S->N - 1u) % 0x4u;
0000e0  7822              LDRB     r2,[r4,#0]
0000e2  1e52              SUBS     r2,r2,#1
0000e4  f0020203          AND      r2,r2,#3
;;;237    
;;;238      while(i > 0u)
0000e8  e006              B        |L1.248|
                  |L1.234|
;;;239      {
;;;240        /* Calculating Y4(1) to Y4(N-1) from Y2 using equation Y4(k) = Y2(k) - Y4(k-1) */
;;;241        /* pState pointer (pS1) is incremented twice as the real values are located alternatively in the array */
;;;242        in = *pS1++ - in;
0000ea  f8373b04          LDRH     r3,[r7],#4
0000ee  1a18              SUBS     r0,r3,r0
0000f0  b200              SXTH     r0,r0
;;;243        *pbuff++ = in;
0000f2  f8210b02          STRH     r0,[r1],#2
;;;244        /* points to the next real value */
;;;245        pS1++;
;;;246    
;;;247        /* Decrement the loop counter */
;;;248        i--;
0000f6  1e52              SUBS     r2,r2,#1
                  |L1.248|
0000f8  2a00              CMP      r2,#0                 ;238
0000fa  d1f6              BNE      |L1.234|
;;;249      }
;;;250    
;;;251    
;;;252       /*------------ Normalizing the output by multiplying with the normalizing factor ----------*/
;;;253    
;;;254      /* Initializing the loop counter to N/4 instead of N for loop unrolling */
;;;255      i = (uint32_t) S->N >> 2u;
0000fc  8820              LDRH     r0,[r4,#0]
0000fe  0880              LSRS     r0,r0,#2
                  |L1.256|
;;;256    
;;;257      /* pbuff initialized to the pInlineBuffer(now contains the output values) */
;;;258      pbuff = pInlineBuffer;
;;;259    
;;;260      /* Processing with loop unrolling 4 times as N is always multiple of 4.  Compute 4 outputs at a time */
;;;261      do
;;;262      {
;;;263        /* Multiplying pInlineBuffer with the normalizing factor sqrt(2/N) */
;;;264        in = *pbuff;
000100  8831              LDRH     r1,[r6,#0]
;;;265        *pbuff++ = ((q15_t) (((q31_t) in * S->normalize) >> 15));
000102  88a2              LDRH     r2,[r4,#4]
000104  fb12f101          SMULBB   r1,r2,r1
000108  13c9              ASRS     r1,r1,#15
00010a  8031              STRH     r1,[r6,#0]
;;;266    
;;;267        in = *pbuff;
00010c  8871              LDRH     r1,[r6,#2]
;;;268        *pbuff++ = ((q15_t) (((q31_t) in * S->normalize) >> 15));
00010e  88a2              LDRH     r2,[r4,#4]
000110  fb12f101          SMULBB   r1,r2,r1
000114  13c9              ASRS     r1,r1,#15
000116  8071              STRH     r1,[r6,#2]
;;;269    
;;;270        in = *pbuff;
000118  88b1              LDRH     r1,[r6,#4]
;;;271        *pbuff++ = ((q15_t) (((q31_t) in * S->normalize) >> 15));
00011a  88a2              LDRH     r2,[r4,#4]
00011c  fb12f101          SMULBB   r1,r2,r1
000120  13c9              ASRS     r1,r1,#15
000122  80b1              STRH     r1,[r6,#4]
;;;272    
;;;273        in = *pbuff;
000124  88f1              LDRH     r1,[r6,#6]
;;;274        *pbuff++ = ((q15_t) (((q31_t) in * S->normalize) >> 15));
000126  88a2              LDRH     r2,[r4,#4]
000128  fb12f101          SMULBB   r1,r2,r1
00012c  13c9              ASRS     r1,r1,#15
00012e  80f1              STRH     r1,[r6,#6]
000130  3608              ADDS     r6,r6,#8
;;;275    
;;;276        /* Decrement the loop counter */
;;;277        i--;
000132  1e40              SUBS     r0,r0,#1
;;;278      } while(i > 0u);
000134  2800              CMP      r0,#0
000136  d1e3              BNE      |L1.256|
;;;279    
;;;280    
;;;281    #else
;;;282    
;;;283      /* Run the below code for Cortex-M0 */
;;;284    
;;;285      /* Initializing the loop counter to N/2 */
;;;286      i = (uint32_t) S->Nby2;
;;;287    
;;;288      do
;;;289      {
;;;290        /* Re-ordering of even and odd elements */
;;;291        /* pState[i] =  pInlineBuffer[2*i] */
;;;292        *pS1++ = *pbuff++;
;;;293        /* pState[N-i-1] = pInlineBuffer[2*i+1] */
;;;294        *pS2-- = *pbuff++;
;;;295    
;;;296        /* Decrement the loop counter */
;;;297        i--;
;;;298      } while(i > 0u);
;;;299    
;;;300      /* pbuff initialized to input buffer */
;;;301      pbuff = pInlineBuffer;
;;;302    
;;;303      /* pS1 initialized to pState */
;;;304      pS1 = pState;
;;;305    
;;;306      /* Initializing the loop counter */
;;;307      i = (uint32_t) S->N;
;;;308    
;;;309      do
;;;310      {
;;;311        /* Writing the re-ordered output back to inplace input buffer */
;;;312        *pbuff++ = *pS1++;
;;;313    
;;;314        /* Decrement the loop counter */
;;;315        i--;
;;;316      } while(i > 0u);
;;;317    
;;;318    
;;;319      /* ---------------------------------------------------------    
;;;320       *     Step2: Calculate RFFT for N-point input    
;;;321       * ---------------------------------------------------------- */
;;;322      /* pInlineBuffer is real input of length N , pState is the complex output of length 2N */
;;;323      arm_rfft_q15(S->pRfft, pInlineBuffer, pState);
;;;324    
;;;325     /*----------------------------------------------------------------------    
;;;326      *  Step3: Multiply the FFT output with the weights.    
;;;327      *----------------------------------------------------------------------*/
;;;328      arm_cmplx_mult_cmplx_q15(pState, weights, pState, S->N);
;;;329    
;;;330      /* The output of complex multiplication is in 3.13 format.    
;;;331       * Hence changing the format of N (i.e. 2*N elements) complex numbers to 1.15 format by shifting left by 2 bits. */
;;;332      arm_shift_q15(pState, 2, pState, S->N * 2);
;;;333    
;;;334      /* ----------- Post-processing ---------- */
;;;335      /* DCT-IV can be obtained from DCT-II by the equation,    
;;;336       *       Y4(k) = Y2(k) - Y4(k-1) and Y4(-1) = Y4(0)    
;;;337       *       Hence, Y4(0) = Y2(0)/2  */
;;;338      /* Getting only real part from the output and Converting to DCT-IV */
;;;339    
;;;340      /* Initializing the loop counter */
;;;341      i = ((uint32_t) S->N - 1u);
;;;342    
;;;343      /* pbuff initialized to input buffer. */
;;;344      pbuff = pInlineBuffer;
;;;345    
;;;346      /* pS1 initialized to pState */
;;;347      pS1 = pState;
;;;348    
;;;349      /* Calculating Y4(0) from Y2(0) using Y4(0) = Y2(0)/2 */
;;;350      in = *pS1++ >> 1u;
;;;351      /* input buffer acts as inplace, so output values are stored in the input itself. */
;;;352      *pbuff++ = in;
;;;353    
;;;354      /* pState pointer is incremented twice as the real values are located alternatively in the array */
;;;355      pS1++;
;;;356    
;;;357      do
;;;358      {
;;;359        /* Calculating Y4(1) to Y4(N-1) from Y2 using equation Y4(k) = Y2(k) - Y4(k-1) */
;;;360        /* pState pointer (pS1) is incremented twice as the real values are located alternatively in the array */
;;;361        in = *pS1++ - in;
;;;362        *pbuff++ = in;
;;;363        /* points to the next real value */
;;;364        pS1++;
;;;365    
;;;366        /* Decrement the loop counter */
;;;367        i--;
;;;368      } while(i > 0u);
;;;369    
;;;370       /*------------ Normalizing the output by multiplying with the normalizing factor ----------*/
;;;371    
;;;372      /* Initializing the loop counter */
;;;373      i = (uint32_t) S->N;
;;;374    
;;;375      /* pbuff initialized to the pInlineBuffer(now contains the output values) */
;;;376      pbuff = pInlineBuffer;
;;;377    
;;;378      do
;;;379      {
;;;380        /* Multiplying pInlineBuffer with the normalizing factor sqrt(2/N) */
;;;381        in = *pbuff;
;;;382        *pbuff++ = ((q15_t) (((q31_t) in * S->normalize) >> 15));
;;;383    
;;;384        /* Decrement the loop counter */
;;;385        i--;
;;;386      } while(i > 0u);
;;;387    
;;;388    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;389    
;;;390    }
000138  e8bd81f0          POP      {r4-r8,pc}
;;;391    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\TransformFunctions\\arm_dct4_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_dct4_q15_c_9bc07bf7____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___14_arm_dct4_q15_c_9bc07bf7____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_dct4_q15_c_9bc07bf7____REVSH|
#line 144
|__asm___14_arm_dct4_q15_c_9bc07bf7____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_dct4_q15_c_9bc07bf7____RRX|
#line 300
|__asm___14_arm_dct4_q15_c_9bc07bf7____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
