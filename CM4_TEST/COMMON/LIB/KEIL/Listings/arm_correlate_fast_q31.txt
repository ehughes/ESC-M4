; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_correlate_fast_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_correlate_fast_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE\_CMSIS_DSP_4_5_O3 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_correlate_fast_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_correlate_fast_q31.c]
                          THUMB

                          AREA ||i.arm_correlate_fast_q31||, CODE, READONLY, ALIGN=2

                  arm_correlate_fast_q31 PROC
;;;80     
;;;81     void arm_correlate_fast_q31(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;82       q31_t * pSrcA,
;;;83       uint32_t srcALen,
;;;84       q31_t * pSrcB,
;;;85       uint32_t srcBLen,
;;;86       q31_t * pDst)
;;;87     {
000004  b094              SUB      sp,sp,#0x50
000006  468e              MOV      lr,r1
;;;88       q31_t *pIn1;                                   /* inputA pointer               */
;;;89       q31_t *pIn2;                                   /* inputB pointer               */
;;;90       q31_t *pOut = pDst;                            /* output pointer               */
;;;91       q31_t *px;                                     /* Intermediate inputA pointer  */
;;;92       q31_t *py;                                     /* Intermediate inputB pointer  */
;;;93       q31_t *pSrc1;                                  /* Intermediate pointers        */
;;;94       q31_t sum, acc0, acc1, acc2, acc3;             /* Accumulators                  */
;;;95       q31_t x0, x1, x2, x3, c0;                      /* temporary variables for holding input and coefficient values */
;;;96       uint32_t j, k = 0u, count, blkCnt, outBlockSize, blockSize1, blockSize2, blockSize3;  /* loop counter                 */
;;;97       int32_t inc = 1;                               /* Destination address modifier */
000008  2401              MOVS     r4,#1
;;;98     
;;;99     
;;;100      /* The algorithm implementation is based on the lengths of the inputs. */
;;;101      /* srcB is always made to slide across srcA. */
;;;102      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;103      if(srcALen >= srcBLen)
;;;104      {
;;;105        /* Initialization of inputA pointer */
;;;106        pIn1 = (pSrcA);
;;;107    
;;;108        /* Initialization of inputB pointer */
;;;109        pIn2 = (pSrcB);
;;;110    
;;;111        /* Number of output samples is calculated */
;;;112        outBlockSize = (2u * srcALen) - 1u;
00000a  940c              STR      r4,[sp,#0x30]
00000c  991d              LDR      r1,[sp,#0x74]         ;97
00000e  1ea4              SUBS     r4,r4,#2
000010  4675              MOV      r5,lr                 ;103
000012  459e              CMP      lr,r3                 ;103
000014  d30b              BCC      |L1.46|
000016  9210              STR      r2,[sp,#0x40]
000018  900e              STR      r0,[sp,#0x38]
00001a  eb04004e          ADD      r0,r4,lr,LSL #1
;;;113    
;;;114        /* When srcALen > srcBLen, zero padding is done to srcB    
;;;115         * to make their lengths equal.    
;;;116         * Instead, (outBlockSize - (srcALen + srcBLen - 1))    
;;;117         * number of output samples are made zero */
;;;118        j = outBlockSize - (srcALen + (srcBLen - 1u));
00001e  eb0e0203          ADD      r2,lr,r3
000022  1a80              SUBS     r0,r0,r2
000024  1c40              ADDS     r0,r0,#1
;;;119    
;;;120        /* Updating the pointer position to non zero value */
;;;121        pOut += j;
000026  eb010080          ADD      r0,r1,r0,LSL #2
00002a  900b              STR      r0,[sp,#0x2c]
00002c  e00a              B        |L1.68|
                  |L1.46|
;;;122    
;;;123      }
;;;124      else
;;;125      {
;;;126        /* Initialization of inputA pointer */
;;;127        pIn1 = (pSrcB);
;;;128    
;;;129        /* Initialization of inputB pointer */
;;;130        pIn2 = (pSrcA);
;;;131    
;;;132        /* srcBLen is always considered as shorter or equal to srcALen */
;;;133        j = srcBLen;
00002e  469e              MOV      lr,r3
;;;134        srcBLen = srcALen;
000030  462b              MOV      r3,r5
;;;135        srcALen = j;
;;;136    
;;;137        /* CORR(x, y) = Reverse order(CORR(y, x)) */
;;;138        /* Hence set the destination pointer to point to the last output sample */
;;;139        pOut = pDst + ((srcALen + srcBLen) - 2u);
000032  9010              STR      r0,[sp,#0x40]
000034  eb0e0003          ADD      r0,lr,r3
000038  eb010080          ADD      r0,r1,r0,LSL #2
00003c  920e              STR      r2,[sp,#0x38]
00003e  3808              SUBS     r0,r0,#8
000040  e9cd040b          STRD     r0,r4,[sp,#0x2c]
                  |L1.68|
;;;140    
;;;141        /* Destination address modifier is set to -1 */
;;;142        inc = -1;
;;;143    
;;;144      }
;;;145    
;;;146      /* The function is internally    
;;;147       * divided into three parts according to the number of multiplications that has to be    
;;;148       * taken place between inputA samples and inputB samples. In the first part of the    
;;;149       * algorithm, the multiplications increase by one for every iteration.    
;;;150       * In the second part of the algorithm, srcBLen number of multiplications are done.    
;;;151       * In the third part of the algorithm, the multiplications decrease by one    
;;;152       * for every iteration.*/
;;;153      /* The algorithm is implemented in three stages.    
;;;154       * The loop counters of each stage is initiated here. */
;;;155      blockSize1 = srcBLen - 1u;
000044  1e5a              SUBS     r2,r3,#1
;;;156      blockSize2 = srcALen - (srcBLen - 1u);
000046  ebae0003          SUB      r0,lr,r3
;;;157      blockSize3 = blockSize1;
;;;158    
;;;159      /* --------------------------    
;;;160       * Initializations of stage1    
;;;161       * -------------------------*/
;;;162    
;;;163      /* sum = x[0] * y[srcBlen - 1]    
;;;164       * sum = x[0] * y[srcBlen - 2] + x[1] * y[srcBlen - 1]    
;;;165       * ....    
;;;166       * sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen - 1] * y[srcBLen - 1]    
;;;167       */
;;;168    
;;;169      /* In this stage the MAC operations are increased by 1 for every iteration.    
;;;170         The count variable holds the number of MAC operations performed */
;;;171      count = 1u;
00004a  2401              MOVS     r4,#1
00004c  1c40              ADDS     r0,r0,#1
00004e  e9cd2011          STRD     r2,r0,[sp,#0x44]
;;;172    
;;;173      /* Working pointer of inputA */
;;;174      px = pIn1;
;;;175    
;;;176      /* Working pointer of inputB */
;;;177      pSrc1 = pIn2 + (srcBLen - 1u);
000052  9910              LDR      r1,[sp,#0x40]
;;;178      py = pSrc1;
;;;179    
;;;180      /* ------------------------    
;;;181       * Stage1 process    
;;;182       * ----------------------*/
;;;183    
;;;184      /* The first stage starts here */
;;;185      while(blockSize1 > 0u)
000054  980e              LDR      r0,[sp,#0x38]
000056  eb010883          ADD      r8,r1,r3,LSL #2       ;177
00005a  f1a80804          SUB      r8,r8,#4              ;177
00005e  4641              MOV      r1,r8                 ;178
000060  e033              B        |L1.202|
                  |L1.98|
;;;186      {
;;;187        /* Accumulator is made zero for every iteration */
;;;188        sum = 0;
000062  2500              MOVS     r5,#0
;;;189    
;;;190        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;191        k = count >> 2;
000064  08a6              LSRS     r6,r4,#2
;;;192    
;;;193        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;194         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;195        while(k > 0u)
000066  e016              B        |L1.150|
                  |L1.104|
;;;196        {
;;;197          /* x[0] * y[srcBLen - 4] */
;;;198          sum = (q31_t) ((((q63_t) sum << 32) +
000068  c880              LDM      r0!,{r7}
00006a  f851cb04          LDR      r12,[r1],#4
00006e  fb57550c          SMMLA    r5,r7,r12,r5
;;;199                          ((q63_t) * px++ * (*py++))) >> 32);
;;;200          /* x[1] * y[srcBLen - 3] */
;;;201          sum = (q31_t) ((((q63_t) sum << 32) +
000072  c880              LDM      r0!,{r7}
000074  f851cb04          LDR      r12,[r1],#4
000078  fb57550c          SMMLA    r5,r7,r12,r5
;;;202                          ((q63_t) * px++ * (*py++))) >> 32);
;;;203          /* x[2] * y[srcBLen - 2] */
;;;204          sum = (q31_t) ((((q63_t) sum << 32) +
00007c  f8507b08          LDR      r7,[r0],#8
000080  f851cb04          LDR      r12,[r1],#4
000084  fb57550c          SMMLA    r5,r7,r12,r5
;;;205                          ((q63_t) * px++ * (*py++))) >> 32);
;;;206          /* x[3] * y[srcBLen - 1] */
;;;207          sum = (q31_t) ((((q63_t) sum << 32) +
000088  f8507c04          LDR      r7,[r0,#-4]
00008c  f851cb04          LDR      r12,[r1],#4
000090  fb57550c          SMMLA    r5,r7,r12,r5
000094  1e76              SUBS     r6,r6,#1
                  |L1.150|
000096  2e00              CMP      r6,#0                 ;195
000098  d1e6              BNE      |L1.104|
;;;208                          ((q63_t) * px++ * (*py++))) >> 32);
;;;209    
;;;210          /* Decrement the loop counter */
;;;211          k--;
;;;212        }
;;;213    
;;;214        /* If the count is not a multiple of 4, compute any remaining MACs here.    
;;;215         ** No loop unrolling is used. */
;;;216        k = count % 0x4u;
00009a  f0040603          AND      r6,r4,#3
;;;217    
;;;218        while(k > 0u)
00009e  e005              B        |L1.172|
                  |L1.160|
;;;219        {
;;;220          /* Perform the multiply-accumulates */
;;;221          /* x[0] * y[srcBLen - 1] */
;;;222          sum = (q31_t) ((((q63_t) sum << 32) +
0000a0  c880              LDM      r0!,{r7}
0000a2  f851cb04          LDR      r12,[r1],#4
0000a6  fb57550c          SMMLA    r5,r7,r12,r5
0000aa  1e76              SUBS     r6,r6,#1
                  |L1.172|
0000ac  2e00              CMP      r6,#0                 ;218
0000ae  d1f7              BNE      |L1.160|
;;;223                          ((q63_t) * px++ * (*py++))) >> 32);
;;;224    
;;;225          /* Decrement the loop counter */
;;;226          k--;
;;;227        }
;;;228    
;;;229        /* Store the result in the accumulator in the destination buffer. */
;;;230        *pOut = sum << 1;
0000b0  980b              LDR      r0,[sp,#0x2c]
0000b2  0069              LSLS     r1,r5,#1
;;;231        /* Destination pointer is updated according to the address modifier, inc */
;;;232        pOut += inc;
;;;233    
;;;234        /* Update the inputA and inputB pointers for next MAC calculation */
;;;235        py = pSrc1 - count;
;;;236        px = pIn1;
0000b4  1e52              SUBS     r2,r2,#1
0000b6  6001              STR      r1,[r0,#0]            ;230
0000b8  e9dd010b          LDRD     r0,r1,[sp,#0x2c]      ;230
0000bc  eb000081          ADD      r0,r0,r1,LSL #2       ;232
0000c0  900b              STR      r0,[sp,#0x2c]
0000c2  eba80184          SUB      r1,r8,r4,LSL #2       ;235
0000c6  980e              LDR      r0,[sp,#0x38]
0000c8  1c64              ADDS     r4,r4,#1
                  |L1.202|
0000ca  2a00              CMP      r2,#0                 ;185
0000cc  d1c9              BNE      |L1.98|
;;;237    
;;;238        /* Increment the MAC count */
;;;239        count++;
;;;240    
;;;241        /* Decrement the loop counter */
;;;242        blockSize1--;
;;;243      }
;;;244    
;;;245      /* --------------------------    
;;;246       * Initializations of stage2    
;;;247       * ------------------------*/
;;;248    
;;;249      /* sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen-1] * y[srcBLen-1]    
;;;250       * sum = x[1] * y[0] + x[2] * y[1] +...+ x[srcBLen] * y[srcBLen-1]    
;;;251       * ....    
;;;252       * sum = x[srcALen-srcBLen-2] * y[0] + x[srcALen-srcBLen-1] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]    
;;;253       */
;;;254    
;;;255      /* Working pointer of inputA */
;;;256      px = pIn1;
;;;257    
;;;258      /* Working pointer of inputB */
;;;259      py = pIn2;
;;;260    
;;;261      /* count is index by which the pointer pIn1 to be incremented */
;;;262      count = 0u;
0000ce  2100              MOVS     r1,#0
0000d0  f8dd8040          LDR      r8,[sp,#0x40]
;;;263    
;;;264      /* -------------------    
;;;265       * Stage2 process    
;;;266       * ------------------*/
;;;267    
;;;268      /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.    
;;;269       * So, to loop unroll over blockSize2,    
;;;270       * srcBLen should be greater than or equal to 4 */
;;;271      if(srcBLen >= 4u)
0000d4  910f              STR      r1,[sp,#0x3c]
0000d6  2b04              CMP      r3,#4
0000d8  d37e              BCC      |L1.472|
;;;272      {
;;;273        /* Loop unroll over blockSize2, by 4 */
;;;274        blkCnt = blockSize2 >> 2u;
0000da  9912              LDR      r1,[sp,#0x48]
0000dc  0889              LSRS     r1,r1,#2
;;;275    
;;;276        while(blkCnt > 0u)
0000de  e091              B        |L1.516|
                  |L1.224|
;;;277        {
;;;278          /* Set all accumulators to zero */
;;;279          acc0 = 0;
;;;280          acc1 = 0;
;;;281          acc2 = 0;
;;;282          acc3 = 0;
;;;283    
;;;284          /* read x[0], x[1], x[2] samples */
;;;285          x0 = *(px++);
0000e0  c810              LDM      r0!,{r4}
0000e2  2500              MOVS     r5,#0                 ;279
0000e4  e8f01202          LDRD     r1,r2,[r0],#8
;;;286          x1 = *(px++);
;;;287          x2 = *(px++);
;;;288    
;;;289          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;290          k = srcBLen >> 2u;
0000e8  089f              LSRS     r7,r3,#2
0000ea  46aa              MOV      r10,r5                ;280
0000ec  46ab              MOV      r11,r5                ;281
0000ee  462e              MOV      r6,r5                 ;282
0000f0  f8cd7034          STR.W    r7,[sp,#0x34]
                  |L1.244|
;;;291    
;;;292          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;293           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;294          do
;;;295          {
;;;296            /* Read y[0] sample */
;;;297            c0 = *(py++);
;;;298    
;;;299            /* Read x[3] sample */
;;;300            x3 = *(px++);
0000f4  c880              LDM      r0!,{r7}
0000f6  f858cb04          LDR      r12,[r8],#4           ;297
;;;301    
;;;302            /* Perform the multiply-accumulate */
;;;303            /* acc0 +=  x[0] * y[0] */
;;;304            acc0 = (q31_t) ((((q63_t) acc0 << 32) + ((q63_t) x0 * c0)) >> 32);
0000fa  fb54590c          SMMLA    r9,r4,r12,r5
;;;305            /* acc1 +=  x[1] * y[0] */
;;;306            acc1 = (q31_t) ((((q63_t) acc1 << 32) + ((q63_t) x1 * c0)) >> 32);
0000fe  fb51aa0c          SMMLA    r10,r1,r12,r10
;;;307            /* acc2 +=  x[2] * y[0] */
;;;308            acc2 = (q31_t) ((((q63_t) acc2 << 32) + ((q63_t) x2 * c0)) >> 32);
000102  f8cda00c          STR      r10,[sp,#0xc]
000106  fb52ba0c          SMMLA    r10,r2,r12,r11
;;;309            /* acc3 +=  x[3] * y[0] */
;;;310            acc3 = (q31_t) ((((q63_t) acc3 << 32) + ((q63_t) x3 * c0)) >> 32);
00010a  fb576b0c          SMMLA    r11,r7,r12,r6
;;;311    
;;;312            /* Read y[1] sample */
;;;313            c0 = *(py++);
00010e  f8cda008          STR      r10,[sp,#8]
;;;314    
;;;315            /* Read x[4] sample */
;;;316            x0 = *(px++);
000112  c810              LDM      r0!,{r4}
000114  f8585b04          LDR      r5,[r8],#4            ;313
;;;317    
;;;318            /* Perform the multiply-accumulates */
;;;319            /* acc0 +=  x[1] * y[1] */
;;;320            acc0 = (q31_t) ((((q63_t) acc0 << 32) + ((q63_t) x1 * c0)) >> 32);
000118  fb519605          SMMLA    r6,r1,r5,r9
;;;321            /* acc1 +=  x[2] * y[1] */
;;;322            acc1 = (q31_t) ((((q63_t) acc1 << 32) + ((q63_t) x2 * c0)) >> 32);
00011c  f8dda00c          LDR      r10,[sp,#0xc]
000120  fb52ac05          SMMLA    r12,r2,r5,r10
;;;323            /* acc2 +=  x[3] * y[1] */
;;;324            acc2 = (q31_t) ((((q63_t) acc2 << 32) + ((q63_t) x3 * c0)) >> 32);
000124  f8dda008          LDR      r10,[sp,#8]
000128  f8cdc00c          STR      r12,[sp,#0xc]
00012c  fb57ac05          SMMLA    r12,r7,r5,r10
;;;325            /* acc3 +=  x[4] * y[1] */
;;;326            acc3 = (q31_t) ((((q63_t) acc3 << 32) + ((q63_t) x0 * c0)) >> 32);
000130  fb54ba05          SMMLA    r10,r4,r5,r11
;;;327    
;;;328            /* Read y[2] sample */
;;;329            c0 = *(py++);
000134  f8cdc008          STR      r12,[sp,#8]
000138  f8585b04          LDR      r5,[r8],#4
;;;330    
;;;331            /* Read x[5] sample */
;;;332            x1 = *(px++);
00013c  f8501b08          LDR      r1,[r0],#8
;;;333    
;;;334            /* Perform the multiply-accumulates */
;;;335            /* acc0 +=  x[2] * y[2] */
;;;336            acc0 = (q31_t) ((((q63_t) acc0 << 32) + ((q63_t) x2 * c0)) >> 32);
000140  fb526b05          SMMLA    r11,r2,r5,r6
;;;337            /* acc1 +=  x[3] * y[2] */
;;;338            acc1 = (q31_t) ((((q63_t) acc1 << 32) + ((q63_t) x3 * c0)) >> 32);
000144  f8ddc00c          LDR      r12,[sp,#0xc]
000148  fb57c905          SMMLA    r9,r7,r5,r12
;;;339            /* acc2 +=  x[4] * y[2] */
;;;340            acc2 = (q31_t) ((((q63_t) acc2 << 32) + ((q63_t) x0 * c0)) >> 32);
00014c  f8ddc008          LDR      r12,[sp,#8]
000150  f8cd900c          STR      r9,[sp,#0xc]
000154  fb54cc05          SMMLA    r12,r4,r5,r12
;;;341            /* acc3 +=  x[5] * y[2] */
;;;342            acc3 = (q31_t) ((((q63_t) acc3 << 32) + ((q63_t) x1 * c0)) >> 32);
000158  fb51a905          SMMLA    r9,r1,r5,r10
;;;343    
;;;344            /* Read y[3] sample */
;;;345            c0 = *(py++);
00015c  f8cd9004          STR      r9,[sp,#4]
000160  f8586b04          LDR      r6,[r8],#4
;;;346    
;;;347            /* Read x[6] sample */
;;;348            x2 = *(px++);
000164  f8502c04          LDR      r2,[r0,#-4]
;;;349    
;;;350            /* Perform the multiply-accumulates */
;;;351            /* acc0 +=  x[3] * y[3] */
;;;352            acc0 = (q31_t) ((((q63_t) acc0 << 32) + ((q63_t) x3 * c0)) >> 32);
000168  fb57b506          SMMLA    r5,r7,r6,r11
;;;353            /* acc1 +=  x[4] * y[3] */
;;;354            acc1 = (q31_t) ((((q63_t) acc1 << 32) + ((q63_t) x0 * c0)) >> 32);
00016c  f8dd900c          LDR      r9,[sp,#0xc]
000170  fb549a06          SMMLA    r10,r4,r6,r9
;;;355            /* acc2 +=  x[5] * y[3] */
;;;356            acc2 = (q31_t) ((((q63_t) acc2 << 32) + ((q63_t) x1 * c0)) >> 32);
000174  fb51cb06          SMMLA    r11,r1,r6,r12
;;;357            /* acc3 +=  x[6] * y[3] */
;;;358            acc3 = (q31_t) ((((q63_t) acc3 << 32) + ((q63_t) x2 * c0)) >> 32);
000178  f8dd9004          LDR      r9,[sp,#4]
00017c  fb529606          SMMLA    r6,r2,r6,r9
;;;359    
;;;360    
;;;361          } while(--k);
000180  9f0d              LDR      r7,[sp,#0x34]
000182  1e7f              SUBS     r7,r7,#1
000184  970d              STR      r7,[sp,#0x34]
000186  d1b5              BNE      |L1.244|
;;;362    
;;;363          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.    
;;;364           ** No loop unrolling is used. */
;;;365          k = srcBLen % 0x4u;
000188  f0030703          AND      r7,r3,#3
;;;366    
;;;367          while(k > 0u)
00018c  e011              B        |L1.434|
;;;368          {
;;;369            /* Read y[4] sample */
;;;370            c0 = *(py++);
00018e  bf00              NOP      
                  |L1.400|
000190  f8587b04          LDR      r7,[r8],#4
;;;371    
;;;372            /* Read x[7] sample */
;;;373            x3 = *(px++);
000194  f850cb04          LDR      r12,[r0],#4
;;;374    
;;;375            /* Perform the multiply-accumulates */
;;;376            /* acc0 +=  x[4] * y[4] */
;;;377            acc0 = (q31_t) ((((q63_t) acc0 << 32) + ((q63_t) x0 * c0)) >> 32);
000198  fb545507          SMMLA    r5,r4,r7,r5
;;;378            /* acc1 +=  x[5] * y[4] */
;;;379            acc1 = (q31_t) ((((q63_t) acc1 << 32) + ((q63_t) x1 * c0)) >> 32);
00019c  fb51aa07          SMMLA    r10,r1,r7,r10
;;;380            /* acc2 +=  x[6] * y[4] */
;;;381            acc2 = (q31_t) ((((q63_t) acc2 << 32) + ((q63_t) x2 * c0)) >> 32);
0001a0  fb52bb07          SMMLA    r11,r2,r7,r11
;;;382            /* acc3 +=  x[7] * y[4] */
;;;383            acc3 = (q31_t) ((((q63_t) acc3 << 32) + ((q63_t) x3 * c0)) >> 32);
0001a4  fb5c6607          SMMLA    r6,r12,r7,r6
;;;384    
;;;385            /* Reuse the present samples for the next MAC */
;;;386            x0 = x1;
0001a8  460c              MOV      r4,r1
;;;387            x1 = x2;
0001aa  4611              MOV      r1,r2
;;;388            x2 = x3;
0001ac  4662              MOV      r2,r12
;;;389    
;;;390            /* Decrement the loop counter */
;;;391            k--;
0001ae  f1a90701          SUB      r7,r9,#1
                  |L1.434|
0001b2  ea5f0907          MOVS     r9,r7                 ;365
0001b6  d1eb              BNE      |L1.400|
;;;392          }
;;;393    
;;;394          /* Store the result in the accumulator in the destination buffer. */
;;;395          *pOut = (q31_t) (acc0 << 1);
0001b8  980b              LDR      r0,[sp,#0x2c]
0001ba  0069              LSLS     r1,r5,#1
0001bc  6001              STR      r1,[r0,#0]
0001be  e9dd100b          LDRD     r1,r0,[sp,#0x2c]
;;;396          /* Destination pointer is updated according to the address modifier, inc */
;;;397          pOut += inc;
0001c2  eb010080          ADD      r0,r1,r0,LSL #2
;;;398    
;;;399          *pOut = (q31_t) (acc1 << 1);
0001c6  ea4f014a          LSL      r1,r10,#1
;;;400          pOut += inc;
0001ca  6001              STR      r1,[r0,#0]
0001cc  990c              LDR      r1,[sp,#0x30]
0001ce  eb000081          ADD      r0,r0,r1,LSL #2
;;;401    
;;;402          *pOut = (q31_t) (acc2 << 1);
0001d2  ea4f014b          LSL      r1,r11,#1
;;;403          pOut += inc;
0001d6  e000              B        |L1.474|
                  |L1.472|
0001d8  e058              B        |L1.652|
                  |L1.474|
0001da  6001              STR      r1,[r0,#0]
0001dc  990c              LDR      r1,[sp,#0x30]
0001de  eb000081          ADD      r0,r0,r1,LSL #2
;;;404    
;;;405          *pOut = (q31_t) (acc3 << 1);
0001e2  0071              LSLS     r1,r6,#1
;;;406          pOut += inc;
0001e4  6001              STR      r1,[r0,#0]
0001e6  990c              LDR      r1,[sp,#0x30]
0001e8  eb000081          ADD      r0,r0,r1,LSL #2
;;;407    
;;;408          /* Increment the pointer pIn1 index, count by 4 */
;;;409          count += 4u;
0001ec  900b              STR      r0,[sp,#0x2c]
0001ee  980f              LDR      r0,[sp,#0x3c]
;;;410    
;;;411          /* Update the inputA and inputB pointers for next MAC calculation */
;;;412          px = pIn1 + count;
;;;413          py = pIn2;
;;;414    
;;;415    
;;;416          /* Decrement the loop counter */
;;;417          blkCnt--;
0001f0  f8dd8040          LDR      r8,[sp,#0x40]
0001f4  1d00              ADDS     r0,r0,#4              ;409
0001f6  900f              STR      r0,[sp,#0x3c]         ;409
0001f8  e9dd010e          LDRD     r0,r1,[sp,#0x38]      ;409
0001fc  eb000081          ADD      r0,r0,r1,LSL #2       ;412
000200  9913              LDR      r1,[sp,#0x4c]
000202  1e49              SUBS     r1,r1,#1
                  |L1.516|
000204  9113              STR      r1,[sp,#0x4c]         ;274
000206  2900              CMP      r1,#0                 ;274
000208  f47faf6a          BNE      |L1.224|
;;;418        }
;;;419    
;;;420        /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.    
;;;421         ** No loop unrolling is used. */
;;;422        blkCnt = blockSize2 % 0x4u;
00020c  9912              LDR      r1,[sp,#0x48]
00020e  f0010203          AND      r2,r1,#3
;;;423    
;;;424        while(blkCnt > 0u)
000212  e038              B        |L1.646|
                  |L1.532|
;;;425        {
;;;426          /* Accumulator is made zero for every iteration */
;;;427          sum = 0;
000214  2400              MOVS     r4,#0
;;;428    
;;;429          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;430          k = srcBLen >> 2u;
000216  0899              LSRS     r1,r3,#2
;;;431    
;;;432          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;433           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;434          while(k > 0u)
000218  e016              B        |L1.584|
                  |L1.538|
;;;435          {
;;;436            /* Perform the multiply-accumulates */
;;;437            sum = (q31_t) ((((q63_t) sum << 32) +
00021a  c820              LDM      r0!,{r5}
00021c  f8586b04          LDR      r6,[r8],#4
000220  fb554406          SMMLA    r4,r5,r6,r4
;;;438                            ((q63_t) * px++ * (*py++))) >> 32);
;;;439            sum = (q31_t) ((((q63_t) sum << 32) +
000224  c820              LDM      r0!,{r5}
000226  f8586b04          LDR      r6,[r8],#4
00022a  fb554406          SMMLA    r4,r5,r6,r4
;;;440                            ((q63_t) * px++ * (*py++))) >> 32);
;;;441            sum = (q31_t) ((((q63_t) sum << 32) +
00022e  f8505b08          LDR      r5,[r0],#8
000232  f8586b04          LDR      r6,[r8],#4
000236  fb554406          SMMLA    r4,r5,r6,r4
;;;442                            ((q63_t) * px++ * (*py++))) >> 32);
;;;443            sum = (q31_t) ((((q63_t) sum << 32) +
00023a  f8505c04          LDR      r5,[r0,#-4]
00023e  f8586b04          LDR      r6,[r8],#4
000242  fb554406          SMMLA    r4,r5,r6,r4
000246  1e49              SUBS     r1,r1,#1
                  |L1.584|
000248  2900              CMP      r1,#0                 ;434
00024a  d1e6              BNE      |L1.538|
;;;444                            ((q63_t) * px++ * (*py++))) >> 32);
;;;445    
;;;446            /* Decrement the loop counter */
;;;447            k--;
;;;448          }
;;;449    
;;;450          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.    
;;;451           ** No loop unrolling is used. */
;;;452          k = srcBLen % 0x4u;
00024c  f0030103          AND      r1,r3,#3
;;;453    
;;;454          while(k > 0u)
000250  e005              B        |L1.606|
                  |L1.594|
;;;455          {
;;;456            /* Perform the multiply-accumulate */
;;;457            sum = (q31_t) ((((q63_t) sum << 32) +
000252  c820              LDM      r0!,{r5}
000254  f8586b04          LDR      r6,[r8],#4
000258  fb554406          SMMLA    r4,r5,r6,r4
00025c  1e49              SUBS     r1,r1,#1
                  |L1.606|
00025e  2900              CMP      r1,#0                 ;454
000260  d1f7              BNE      |L1.594|
;;;458                            ((q63_t) * px++ * (*py++))) >> 32);
;;;459    
;;;460            /* Decrement the loop counter */
;;;461            k--;
;;;462          }
;;;463    
;;;464          /* Store the result in the accumulator in the destination buffer. */
;;;465          *pOut = sum << 1;
000262  980b              LDR      r0,[sp,#0x2c]
000264  0061              LSLS     r1,r4,#1
000266  6001              STR      r1,[r0,#0]
000268  e9dd010b          LDRD     r0,r1,[sp,#0x2c]
;;;466          /* Destination pointer is updated according to the address modifier, inc */
;;;467          pOut += inc;
00026c  eb000081          ADD      r0,r0,r1,LSL #2
;;;468    
;;;469          /* Increment the MAC count */
;;;470          count++;
000270  900b              STR      r0,[sp,#0x2c]
000272  980f              LDR      r0,[sp,#0x3c]
;;;471    
;;;472          /* Update the inputA and inputB pointers for next MAC calculation */
;;;473          px = pIn1 + count;
;;;474          py = pIn2;
000274  f8dd8040          LDR      r8,[sp,#0x40]
000278  1c40              ADDS     r0,r0,#1              ;470
00027a  900f              STR      r0,[sp,#0x3c]         ;470
00027c  e9dd010e          LDRD     r0,r1,[sp,#0x38]      ;470
000280  eb000081          ADD      r0,r0,r1,LSL #2       ;473
000284  1e52              SUBS     r2,r2,#1
                  |L1.646|
000286  2a00              CMP      r2,#0                 ;424
000288  d1c4              BNE      |L1.532|
00028a  e020              B        |L1.718|
                  |L1.652|
;;;475    
;;;476    
;;;477          /* Decrement the loop counter */
;;;478          blkCnt--;
;;;479        }
;;;480      }
;;;481      else
;;;482      {
;;;483        /* If the srcBLen is not a multiple of 4,    
;;;484         * the blockSize2 loop cannot be unrolled by 4 */
;;;485        blkCnt = blockSize2;
;;;486    
;;;487        while(blkCnt > 0u)
00028c  9a12              LDR      r2,[sp,#0x48]
00028e  e01c              B        |L1.714|
                  |L1.656|
;;;488        {
;;;489          /* Accumulator is made zero for every iteration */
;;;490          sum = 0;
000290  2400              MOVS     r4,#0
;;;491    
;;;492          /* Loop over srcBLen */
;;;493          k = srcBLen;
000292  4619              MOV      r1,r3
;;;494    
;;;495          while(k > 0u)
000294  e005              B        |L1.674|
                  |L1.662|
;;;496          {
;;;497            /* Perform the multiply-accumulate */
;;;498            sum = (q31_t) ((((q63_t) sum << 32) +
000296  c820              LDM      r0!,{r5}
000298  f8586b04          LDR      r6,[r8],#4
00029c  fb554406          SMMLA    r4,r5,r6,r4
0002a0  1e49              SUBS     r1,r1,#1
                  |L1.674|
0002a2  2900              CMP      r1,#0                 ;495
0002a4  d1f7              BNE      |L1.662|
;;;499                            ((q63_t) * px++ * (*py++))) >> 32);
;;;500    
;;;501            /* Decrement the loop counter */
;;;502            k--;
;;;503          }
;;;504    
;;;505          /* Store the result in the accumulator in the destination buffer. */
;;;506          *pOut = sum << 1;
0002a6  980b              LDR      r0,[sp,#0x2c]
0002a8  0061              LSLS     r1,r4,#1
0002aa  6001              STR      r1,[r0,#0]
0002ac  e9dd010b          LDRD     r0,r1,[sp,#0x2c]
;;;507          /* Destination pointer is updated according to the address modifier, inc */
;;;508          pOut += inc;
0002b0  eb000081          ADD      r0,r0,r1,LSL #2
;;;509    
;;;510          /* Increment the MAC count */
;;;511          count++;
0002b4  900b              STR      r0,[sp,#0x2c]
0002b6  980f              LDR      r0,[sp,#0x3c]
;;;512    
;;;513          /* Update the inputA and inputB pointers for next MAC calculation */
;;;514          px = pIn1 + count;
;;;515          py = pIn2;
0002b8  f8dd8040          LDR      r8,[sp,#0x40]
0002bc  1c40              ADDS     r0,r0,#1              ;511
0002be  900f              STR      r0,[sp,#0x3c]         ;511
0002c0  e9dd010e          LDRD     r0,r1,[sp,#0x38]      ;511
0002c4  eb000081          ADD      r0,r0,r1,LSL #2       ;514
0002c8  1e52              SUBS     r2,r2,#1
                  |L1.714|
0002ca  2a00              CMP      r2,#0                 ;487
0002cc  d1e0              BNE      |L1.656|
                  |L1.718|
;;;516    
;;;517          /* Decrement the loop counter */
;;;518          blkCnt--;
;;;519        }
;;;520      }
;;;521    
;;;522      /* --------------------------    
;;;523       * Initializations of stage3    
;;;524       * -------------------------*/
;;;525    
;;;526      /* sum += x[srcALen-srcBLen+1] * y[0] + x[srcALen-srcBLen+2] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]    
;;;527       * sum += x[srcALen-srcBLen+2] * y[0] + x[srcALen-srcBLen+3] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]    
;;;528       * ....    
;;;529       * sum +=  x[srcALen-2] * y[0] + x[srcALen-1] * y[1]    
;;;530       * sum +=  x[srcALen-1] * y[0]    
;;;531       */
;;;532    
;;;533      /* In this stage the MAC operations are decreased by 1 for every iteration.    
;;;534         The count variable holds the number of MAC operations performed */
;;;535      count = srcBLen - 1u;
;;;536    
;;;537      /* Working pointer of inputA */
;;;538      pSrc1 = ((pIn1 + srcALen) - srcBLen) + 1u;
0002ce  980e              LDR      r0,[sp,#0x38]
0002d0  1e5a              SUBS     r2,r3,#1              ;535
0002d2  eb00008e          ADD      r0,r0,lr,LSL #2
0002d6  eba00183          SUB      r1,r0,r3,LSL #2
0002da  1d09              ADDS     r1,r1,#4
;;;539      px = pSrc1;
0002dc  4608              MOV      r0,r1
;;;540    
;;;541      /* Working pointer of inputB */
;;;542      py = pIn2;
;;;543    
;;;544      /* -------------------    
;;;545       * Stage3 process    
;;;546       * ------------------*/
;;;547    
;;;548      while(blockSize3 > 0u)
0002de  9b11              LDR      r3,[sp,#0x44]
0002e0  e035              B        |L1.846|
                  |L1.738|
;;;549      {
;;;550        /* Accumulator is made zero for every iteration */
;;;551        sum = 0;
0002e2  2400              MOVS     r4,#0
;;;552    
;;;553        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;554        k = count >> 2u;
0002e4  0893              LSRS     r3,r2,#2
;;;555    
;;;556        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;557         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;558        while(k > 0u)
0002e6  e016              B        |L1.790|
                  |L1.744|
;;;559        {
;;;560          /* Perform the multiply-accumulates */
;;;561          /* sum += x[srcALen - srcBLen + 4] * y[3] */
;;;562          sum = (q31_t) ((((q63_t) sum << 32) +
0002e8  c820              LDM      r0!,{r5}
0002ea  f8586b04          LDR      r6,[r8],#4
0002ee  fb554406          SMMLA    r4,r5,r6,r4
;;;563                          ((q63_t) * px++ * (*py++))) >> 32);
;;;564          /* sum += x[srcALen - srcBLen + 3] * y[2] */
;;;565          sum = (q31_t) ((((q63_t) sum << 32) +
0002f2  c820              LDM      r0!,{r5}
0002f4  f8586b04          LDR      r6,[r8],#4
0002f8  fb554406          SMMLA    r4,r5,r6,r4
;;;566                          ((q63_t) * px++ * (*py++))) >> 32);
;;;567          /* sum += x[srcALen - srcBLen + 2] * y[1] */
;;;568          sum = (q31_t) ((((q63_t) sum << 32) +
0002fc  f8505b08          LDR      r5,[r0],#8
000300  f8586b04          LDR      r6,[r8],#4
000304  fb554406          SMMLA    r4,r5,r6,r4
;;;569                          ((q63_t) * px++ * (*py++))) >> 32);
;;;570          /* sum += x[srcALen - srcBLen + 1] * y[0] */
;;;571          sum = (q31_t) ((((q63_t) sum << 32) +
000308  f8505c04          LDR      r5,[r0,#-4]
00030c  f8586b04          LDR      r6,[r8],#4
000310  fb554406          SMMLA    r4,r5,r6,r4
000314  1e5b              SUBS     r3,r3,#1
                  |L1.790|
000316  2b00              CMP      r3,#0                 ;558
000318  d1e6              BNE      |L1.744|
;;;572                          ((q63_t) * px++ * (*py++))) >> 32);
;;;573    
;;;574          /* Decrement the loop counter */
;;;575          k--;
;;;576        }
;;;577    
;;;578        /* If the count is not a multiple of 4, compute any remaining MACs here.    
;;;579         ** No loop unrolling is used. */
;;;580        k = count % 0x4u;
00031a  f0020303          AND      r3,r2,#3
;;;581    
;;;582        while(k > 0u)
00031e  e005              B        |L1.812|
                  |L1.800|
;;;583        {
;;;584          /* Perform the multiply-accumulates */
;;;585          sum = (q31_t) ((((q63_t) sum << 32) +
000320  c820              LDM      r0!,{r5}
000322  f8586b04          LDR      r6,[r8],#4
000326  fb554406          SMMLA    r4,r5,r6,r4
00032a  1e5b              SUBS     r3,r3,#1
                  |L1.812|
00032c  2b00              CMP      r3,#0                 ;582
00032e  d1f7              BNE      |L1.800|
;;;586                          ((q63_t) * px++ * (*py++))) >> 32);
;;;587    
;;;588          /* Decrement the loop counter */
;;;589          k--;
;;;590        }
;;;591    
;;;592        /* Store the result in the accumulator in the destination buffer. */
;;;593        *pOut = sum << 1;
000330  980b              LDR      r0,[sp,#0x2c]
000332  0063              LSLS     r3,r4,#1
000334  6003              STR      r3,[r0,#0]
000336  e9dd030b          LDRD     r0,r3,[sp,#0x2c]
;;;594        /* Destination pointer is updated according to the address modifier, inc */
;;;595        pOut += inc;
00033a  eb000083          ADD      r0,r0,r3,LSL #2
;;;596    
;;;597        /* Update the inputA and inputB pointers for next MAC calculation */
;;;598        px = ++pSrc1;
00033e  900b              STR      r0,[sp,#0x2c]
000340  e9dd8310          LDRD     r8,r3,[sp,#0x40]
000344  1d08              ADDS     r0,r1,#4
000346  1e5b              SUBS     r3,r3,#1
000348  4601              MOV      r1,r0
;;;599        py = pIn2;
;;;600    
;;;601        /* Decrement the MAC count */
;;;602        count--;
;;;603    
;;;604        /* Decrement the loop counter */
;;;605        blockSize3--;
00034a  1e52              SUBS     r2,r2,#1
00034c  9311              STR      r3,[sp,#0x44]
                  |L1.846|
00034e  2b00              CMP      r3,#0                 ;548
000350  d1c7              BNE      |L1.738|
;;;606      }
;;;607    
;;;608    }
000352  b014              ADD      sp,sp,#0x50
000354  e8bd8ff0          POP      {r4-r11,pc}
;;;609    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_correlate_fast_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_correlate_fast_q31_c_d938499e____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___24_arm_correlate_fast_q31_c_d938499e____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_correlate_fast_q31_c_d938499e____REVSH|
#line 144
|__asm___24_arm_correlate_fast_q31_c_d938499e____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_correlate_fast_q31_c_d938499e____RRX|
#line 300
|__asm___24_arm_correlate_fast_q31_c_d938499e____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
