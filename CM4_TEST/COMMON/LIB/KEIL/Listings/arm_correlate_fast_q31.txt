; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_correlate_fast_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_correlate_fast_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_correlate_fast_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_correlate_fast_q31.c]
                          THUMB

                          AREA ||i.arm_correlate_fast_q31||, CODE, READONLY, ALIGN=1

                  arm_correlate_fast_q31 PROC
;;;80     
;;;81     void arm_correlate_fast_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;82       q31_t * pSrcA,
;;;83       uint32_t srcALen,
;;;84       q31_t * pSrcB,
;;;85       uint32_t srcBLen,
;;;86       q31_t * pDst)
;;;87     {
000004  b08c              SUB      sp,sp,#0x30
000006  9919              LDR      r1,[sp,#0x64]
;;;88       q31_t *pIn1;                                   /* inputA pointer               */
;;;89       q31_t *pIn2;                                   /* inputB pointer               */
;;;90       q31_t *pOut = pDst;                            /* output pointer               */
;;;91       q31_t *px;                                     /* Intermediate inputA pointer  */
;;;92       q31_t *py;                                     /* Intermediate inputB pointer  */
;;;93       q31_t *pSrc1;                                  /* Intermediate pointers        */
;;;94       q31_t sum, acc0, acc1, acc2, acc3;             /* Accumulators                  */
;;;95       q31_t x0, x1, x2, x3, c0;                      /* temporary variables for holding input and coefficient values */
;;;96       uint32_t j, k = 0u, count, blkCnt, outBlockSize, blockSize1, blockSize2, blockSize3;  /* loop counter                 */
;;;97       int32_t inc = 1;                               /* Destination address modifier */
000008  f04f0c01          MOV      r12,#1
;;;98     
;;;99     
;;;100      /* The algorithm implementation is based on the lengths of the inputs. */
;;;101      /* srcB is always made to slide across srcA. */
;;;102      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;103      if(srcALen >= srcBLen)
00000c  9d0d              LDR      r5,[sp,#0x34]
;;;104      {
;;;105        /* Initialization of inputA pointer */
;;;106        pIn1 = (pSrcA);
;;;107    
;;;108        /* Initialization of inputB pointer */
;;;109        pIn2 = (pSrcB);
;;;110    
;;;111        /* Number of output samples is calculated */
;;;112        outBlockSize = (2u * srcALen) - 1u;
00000e  f04f34ff          MOV      r4,#0xffffffff
000012  429d              CMP      r5,r3                 ;103
000014  d30b              BCC      |L1.46|
000016  900b              STR      r0,[sp,#0x2c]         ;106
000018  920a              STR      r2,[sp,#0x28]         ;109
00001a  980d              LDR      r0,[sp,#0x34]
00001c  eb040040          ADD      r0,r4,r0,LSL #1
;;;113    
;;;114        /* When srcALen > srcBLen, zero padding is done to srcB    
;;;115         * to make their lengths equal.    
;;;116         * Instead, (outBlockSize - (srcALen + srcBLen - 1))    
;;;117         * number of output samples are made zero */
;;;118        j = outBlockSize - (srcALen + (srcBLen - 1u));
000020  9a0d              LDR      r2,[sp,#0x34]
000022  441a              ADD      r2,r2,r3
000024  1a80              SUBS     r0,r0,r2
000026  1c40              ADDS     r0,r0,#1
;;;119    
;;;120        /* Updating the pointer position to non zero value */
;;;121        pOut += j;
000028  eb010180          ADD      r1,r1,r0,LSL #2
00002c  e00a              B        |L1.68|
                  |L1.46|
;;;122    
;;;123      }
;;;124      else
;;;125      {
;;;126        /* Initialization of inputA pointer */
;;;127        pIn1 = (pSrcB);
00002e  920b              STR      r2,[sp,#0x2c]
;;;128    
;;;129        /* Initialization of inputB pointer */
;;;130        pIn2 = (pSrcA);
000030  900a              STR      r0,[sp,#0x28]
;;;131    
;;;132        /* srcBLen is always considered as shorter or equal to srcALen */
;;;133        j = srcBLen;
000032  4618              MOV      r0,r3
;;;134        srcBLen = srcALen;
000034  9b0d              LDR      r3,[sp,#0x34]
;;;135        srcALen = j;
000036  900d              STR      r0,[sp,#0x34]
;;;136    
;;;137        /* CORR(x, y) = Reverse order(CORR(y, x)) */
;;;138        /* Hence set the destination pointer to point to the last output sample */
;;;139        pOut = pDst + ((srcALen + srcBLen) - 2u);
000038  980d              LDR      r0,[sp,#0x34]
00003a  4418              ADD      r0,r0,r3
00003c  1e80              SUBS     r0,r0,#2
00003e  eb010180          ADD      r1,r1,r0,LSL #2
;;;140    
;;;141        /* Destination address modifier is set to -1 */
;;;142        inc = -1;
000042  46a4              MOV      r12,r4
                  |L1.68|
;;;143    
;;;144      }
;;;145    
;;;146      /* The function is internally    
;;;147       * divided into three parts according to the number of multiplications that has to be    
;;;148       * taken place between inputA samples and inputB samples. In the first part of the    
;;;149       * algorithm, the multiplications increase by one for every iteration.    
;;;150       * In the second part of the algorithm, srcBLen number of multiplications are done.    
;;;151       * In the third part of the algorithm, the multiplications decrease by one    
;;;152       * for every iteration.*/
;;;153      /* The algorithm is implemented in three stages.    
;;;154       * The loop counters of each stage is initiated here. */
;;;155      blockSize1 = srcBLen - 1u;
000044  1e5f              SUBS     r7,r3,#1
;;;156      blockSize2 = srcALen - (srcBLen - 1u);
000046  980d              LDR      r0,[sp,#0x34]
000048  1ac0              SUBS     r0,r0,r3
00004a  1c40              ADDS     r0,r0,#1
00004c  9001              STR      r0,[sp,#4]
;;;157      blockSize3 = blockSize1;
00004e  9700              STR      r7,[sp,#0]
;;;158    
;;;159      /* --------------------------    
;;;160       * Initializations of stage1    
;;;161       * -------------------------*/
;;;162    
;;;163      /* sum = x[0] * y[srcBlen - 1]    
;;;164       * sum = x[0] * y[srcBlen - 2] + x[1] * y[srcBlen - 1]    
;;;165       * ....    
;;;166       * sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen - 1] * y[srcBLen - 1]    
;;;167       */
;;;168    
;;;169      /* In this stage the MAC operations are increased by 1 for every iteration.    
;;;170         The count variable holds the number of MAC operations performed */
;;;171      count = 1u;
000050  2401              MOVS     r4,#1
;;;172    
;;;173      /* Working pointer of inputA */
;;;174      px = pIn1;
000052  9e0b              LDR      r6,[sp,#0x2c]
;;;175    
;;;176      /* Working pointer of inputB */
;;;177      pSrc1 = pIn2 + (srcBLen - 1u);
000054  980a              LDR      r0,[sp,#0x28]
000056  1e5a              SUBS     r2,r3,#1
000058  eb000882          ADD      r8,r0,r2,LSL #2
;;;178      py = pSrc1;
00005c  4640              MOV      r0,r8
;;;179    
;;;180      /* ------------------------    
;;;181       * Stage1 process    
;;;182       * ----------------------*/
;;;183    
;;;184      /* The first stage starts here */
;;;185      while(blockSize1 > 0u)
00005e  e032              B        |L1.198|
                  |L1.96|
;;;186      {
;;;187        /* Accumulator is made zero for every iteration */
;;;188        sum = 0;
000060  2200              MOVS     r2,#0
;;;189    
;;;190        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;191        k = count >> 2;
000062  08a5              LSRS     r5,r4,#2
;;;192    
;;;193        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;194         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;195        while(k > 0u)
000064  e018              B        |L1.152|
                  |L1.102|
;;;196        {
;;;197          /* x[0] * y[srcBLen - 4] */
;;;198          sum = (q31_t) ((((q63_t) sum << 32) +
000066  f8569b04          LDR      r9,[r6],#4
00006a  f850ab04          LDR      r10,[r0],#4
00006e  fb59220a          SMMLA    r2,r9,r10,r2
;;;199                          ((q63_t) * px++ * (*py++))) >> 32);
;;;200          /* x[1] * y[srcBLen - 3] */
;;;201          sum = (q31_t) ((((q63_t) sum << 32) +
000072  f8569b04          LDR      r9,[r6],#4
000076  f850ab04          LDR      r10,[r0],#4
00007a  fb59220a          SMMLA    r2,r9,r10,r2
;;;202                          ((q63_t) * px++ * (*py++))) >> 32);
;;;203          /* x[2] * y[srcBLen - 2] */
;;;204          sum = (q31_t) ((((q63_t) sum << 32) +
00007e  f8569b04          LDR      r9,[r6],#4
000082  f850ab04          LDR      r10,[r0],#4
000086  fb59220a          SMMLA    r2,r9,r10,r2
;;;205                          ((q63_t) * px++ * (*py++))) >> 32);
;;;206          /* x[3] * y[srcBLen - 1] */
;;;207          sum = (q31_t) ((((q63_t) sum << 32) +
00008a  f8569b04          LDR      r9,[r6],#4
00008e  f850ab04          LDR      r10,[r0],#4
000092  fb59220a          SMMLA    r2,r9,r10,r2
;;;208                          ((q63_t) * px++ * (*py++))) >> 32);
;;;209    
;;;210          /* Decrement the loop counter */
;;;211          k--;
000096  1e6d              SUBS     r5,r5,#1
                  |L1.152|
000098  2d00              CMP      r5,#0                 ;195
00009a  d1e4              BNE      |L1.102|
;;;212        }
;;;213    
;;;214        /* If the count is not a multiple of 4, compute any remaining MACs here.    
;;;215         ** No loop unrolling is used. */
;;;216        k = count % 0x4u;
00009c  f0040503          AND      r5,r4,#3
;;;217    
;;;218        while(k > 0u)
0000a0  e006              B        |L1.176|
                  |L1.162|
;;;219        {
;;;220          /* Perform the multiply-accumulates */
;;;221          /* x[0] * y[srcBLen - 1] */
;;;222          sum = (q31_t) ((((q63_t) sum << 32) +
0000a2  f8569b04          LDR      r9,[r6],#4
0000a6  f850ab04          LDR      r10,[r0],#4
0000aa  fb59220a          SMMLA    r2,r9,r10,r2
;;;223                          ((q63_t) * px++ * (*py++))) >> 32);
;;;224    
;;;225          /* Decrement the loop counter */
;;;226          k--;
0000ae  1e6d              SUBS     r5,r5,#1
                  |L1.176|
0000b0  2d00              CMP      r5,#0                 ;218
0000b2  d1f6              BNE      |L1.162|
;;;227        }
;;;228    
;;;229        /* Store the result in the accumulator in the destination buffer. */
;;;230        *pOut = sum << 1;
0000b4  0050              LSLS     r0,r2,#1
0000b6  6008              STR      r0,[r1,#0]
;;;231        /* Destination pointer is updated according to the address modifier, inc */
;;;232        pOut += inc;
0000b8  eb01018c          ADD      r1,r1,r12,LSL #2
;;;233    
;;;234        /* Update the inputA and inputB pointers for next MAC calculation */
;;;235        py = pSrc1 - count;
0000bc  eba80084          SUB      r0,r8,r4,LSL #2
;;;236        px = pIn1;
0000c0  9e0b              LDR      r6,[sp,#0x2c]
;;;237    
;;;238        /* Increment the MAC count */
;;;239        count++;
0000c2  1c64              ADDS     r4,r4,#1
;;;240    
;;;241        /* Decrement the loop counter */
;;;242        blockSize1--;
0000c4  1e7f              SUBS     r7,r7,#1
                  |L1.198|
0000c6  2f00              CMP      r7,#0                 ;185
0000c8  d1ca              BNE      |L1.96|
;;;243      }
;;;244    
;;;245      /* --------------------------    
;;;246       * Initializations of stage2    
;;;247       * ------------------------*/
;;;248    
;;;249      /* sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen-1] * y[srcBLen-1]    
;;;250       * sum = x[1] * y[0] + x[2] * y[1] +...+ x[srcBLen] * y[srcBLen-1]    
;;;251       * ....    
;;;252       * sum = x[srcALen-srcBLen-2] * y[0] + x[srcALen-srcBLen-1] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]    
;;;253       */
;;;254    
;;;255      /* Working pointer of inputA */
;;;256      px = pIn1;
;;;257    
;;;258      /* Working pointer of inputB */
;;;259      py = pIn2;
0000ca  980a              LDR      r0,[sp,#0x28]
;;;260    
;;;261      /* count is index by which the pointer pIn1 to be incremented */
;;;262      count = 0u;
;;;263    
;;;264      /* -------------------    
;;;265       * Stage2 process    
;;;266       * ------------------*/
;;;267    
;;;268      /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.    
;;;269       * So, to loop unroll over blockSize2,    
;;;270       * srcBLen should be greater than or equal to 4 */
;;;271      if(srcBLen >= 4u)
0000cc  2b04              CMP      r3,#4
0000ce  d37d              BCC      |L1.460|
;;;272      {
;;;273        /* Loop unroll over blockSize2, by 4 */
;;;274        blkCnt = blockSize2 >> 2u;
0000d0  9a01              LDR      r2,[sp,#4]
0000d2  0892              LSRS     r2,r2,#2
0000d4  9202              STR      r2,[sp,#8]
;;;275    
;;;276        while(blkCnt > 0u)
0000d6  e0aa              B        |L1.558|
                  |L1.216|
;;;277        {
;;;278          /* Set all accumulators to zero */
;;;279          acc0 = 0;
0000d8  f04f0800          MOV      r8,#0
;;;280          acc1 = 0;
0000dc  46c1              MOV      r9,r8
;;;281          acc2 = 0;
0000de  46c2              MOV      r10,r8
;;;282          acc3 = 0;
0000e0  46c3              MOV      r11,r8
;;;283    
;;;284          /* read x[0], x[1], x[2] samples */
;;;285          x0 = *(px++);
0000e2  6835              LDR      r5,[r6,#0]
;;;286          x1 = *(px++);
0000e4  6874              LDR      r4,[r6,#4]
;;;287          x2 = *(px++);
0000e6  68b2              LDR      r2,[r6,#8]
0000e8  360c              ADDS     r6,r6,#0xc
;;;288    
;;;289          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;290          k = srcBLen >> 2u;
0000ea  ea4f0e93          LSR      lr,r3,#2
0000ee  f8cde00c          STR      lr,[sp,#0xc]
                  |L1.242|
;;;291    
;;;292          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;293           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;294          do
;;;295          {
;;;296            /* Read y[0] sample */
;;;297            c0 = *(py++);
0000f2  f850eb04          LDR      lr,[r0],#4
0000f6  9009              STR      r0,[sp,#0x24]
;;;298    
;;;299            /* Read x[3] sample */
;;;300            x3 = *(px++);
0000f8  6830              LDR      r0,[r6,#0]
0000fa  9005              STR      r0,[sp,#0x14]
;;;301    
;;;302            /* Perform the multiply-accumulate */
;;;303            /* acc0 +=  x[0] * y[0] */
;;;304            acc0 = (q31_t) ((((q63_t) acc0 << 32) + ((q63_t) x0 * c0)) >> 32);
0000fc  fb55880e          SMMLA    r8,r5,lr,r8
;;;305            /* acc1 +=  x[1] * y[0] */
;;;306            acc1 = (q31_t) ((((q63_t) acc1 << 32) + ((q63_t) x1 * c0)) >> 32);
000100  fb54900e          SMMLA    r0,r4,lr,r9
;;;307            /* acc2 +=  x[2] * y[0] */
;;;308            acc2 = (q31_t) ((((q63_t) acc2 << 32) + ((q63_t) x2 * c0)) >> 32);
000104  fb52a50e          SMMLA    r5,r2,lr,r10
000108  9506              STR      r5,[sp,#0x18]
;;;309            /* acc3 +=  x[3] * y[0] */
;;;310            acc3 = (q31_t) ((((q63_t) acc3 << 32) + ((q63_t) x3 * c0)) >> 32);
00010a  9d05              LDR      r5,[sp,#0x14]
00010c  fb55bb0e          SMMLA    r11,r5,lr,r11
;;;311    
;;;312            /* Read y[1] sample */
;;;313            c0 = *(py++);
000110  9d09              LDR      r5,[sp,#0x24]
000112  46aa              MOV      r10,r5
000114  f8d59000          LDR      r9,[r5,#0]
;;;314    
;;;315            /* Read x[4] sample */
;;;316            x0 = *(px++);
000118  6875              LDR      r5,[r6,#4]
;;;317    
;;;318            /* Perform the multiply-accumulates */
;;;319            /* acc0 +=  x[1] * y[1] */
;;;320            acc0 = (q31_t) ((((q63_t) acc0 << 32) + ((q63_t) x1 * c0)) >> 32);
00011a  fb548e09          SMMLA    lr,r4,r9,r8
00011e  f8cde020          STR      lr,[sp,#0x20]
;;;321            /* acc1 +=  x[2] * y[1] */
;;;322            acc1 = (q31_t) ((((q63_t) acc1 << 32) + ((q63_t) x2 * c0)) >> 32);
000122  fb520e09          SMMLA    lr,r2,r9,r0
000126  f8cde01c          STR      lr,[sp,#0x1c]
;;;323            /* acc2 +=  x[3] * y[1] */
;;;324            acc2 = (q31_t) ((((q63_t) acc2 << 32) + ((q63_t) x3 * c0)) >> 32);
00012a  e9dd4005          LDRD     r4,r0,[sp,#0x14]
00012e  fb540e09          SMMLA    lr,r4,r9,r0
000132  f8cde018          STR      lr,[sp,#0x18]
;;;325            /* acc3 +=  x[4] * y[1] */
;;;326            acc3 = (q31_t) ((((q63_t) acc3 << 32) + ((q63_t) x0 * c0)) >> 32);
000136  fb55bb09          SMMLA    r11,r5,r9,r11
;;;327    
;;;328            /* Read y[2] sample */
;;;329            c0 = *(py++);
00013a  f85a8f04          LDR      r8,[r10,#4]!
00013e  f10a0004          ADD      r0,r10,#4
;;;330    
;;;331            /* Read x[5] sample */
;;;332            x1 = *(px++);
000142  68b4              LDR      r4,[r6,#8]
;;;333    
;;;334            /* Perform the multiply-accumulates */
;;;335            /* acc0 +=  x[2] * y[2] */
;;;336            acc0 = (q31_t) ((((q63_t) acc0 << 32) + ((q63_t) x2 * c0)) >> 32);
000144  f8dde020          LDR      lr,[sp,#0x20]
000148  fb52e908          SMMLA    r9,r2,r8,lr
00014c  f8cd9020          STR      r9,[sp,#0x20]
;;;337            /* acc1 +=  x[3] * y[2] */
;;;338            acc1 = (q31_t) ((((q63_t) acc1 << 32) + ((q63_t) x3 * c0)) >> 32);
000150  f8dde01c          LDR      lr,[sp,#0x1c]
000154  9a05              LDR      r2,[sp,#0x14]
000156  fb52e908          SMMLA    r9,r2,r8,lr
00015a  f8cd901c          STR      r9,[sp,#0x1c]
;;;339            /* acc2 +=  x[4] * y[2] */
;;;340            acc2 = (q31_t) ((((q63_t) acc2 << 32) + ((q63_t) x0 * c0)) >> 32);
00015e  f8dde018          LDR      lr,[sp,#0x18]
000162  fb55ea08          SMMLA    r10,r5,r8,lr
;;;341            /* acc3 +=  x[5] * y[2] */
;;;342            acc3 = (q31_t) ((((q63_t) acc3 << 32) + ((q63_t) x1 * c0)) >> 32);
000166  fb54be08          SMMLA    lr,r4,r8,r11
;;;343    
;;;344            /* Read y[3] sample */
;;;345            c0 = *(py++);
00016a  f850bb04          LDR      r11,[r0],#4
;;;346    
;;;347            /* Read x[6] sample */
;;;348            x2 = *(px++);
00016e  68f2              LDR      r2,[r6,#0xc]
000170  3610              ADDS     r6,r6,#0x10
;;;349    
;;;350            /* Perform the multiply-accumulates */
;;;351            /* acc0 +=  x[3] * y[3] */
;;;352            acc0 = (q31_t) ((((q63_t) acc0 << 32) + ((q63_t) x3 * c0)) >> 32);
000172  f8dd9020          LDR      r9,[sp,#0x20]
000176  f8dd8014          LDR      r8,[sp,#0x14]
00017a  fb58980b          SMMLA    r8,r8,r11,r9
;;;353            /* acc1 +=  x[4] * y[3] */
;;;354            acc1 = (q31_t) ((((q63_t) acc1 << 32) + ((q63_t) x0 * c0)) >> 32);
00017e  f8dd901c          LDR      r9,[sp,#0x1c]
000182  fb55990b          SMMLA    r9,r5,r11,r9
;;;355            /* acc2 +=  x[5] * y[3] */
;;;356            acc2 = (q31_t) ((((q63_t) acc2 << 32) + ((q63_t) x1 * c0)) >> 32);
000186  fb54aa0b          SMMLA    r10,r4,r11,r10
;;;357            /* acc3 +=  x[6] * y[3] */
;;;358            acc3 = (q31_t) ((((q63_t) acc3 << 32) + ((q63_t) x2 * c0)) >> 32);
00018a  fb52eb0b          SMMLA    r11,r2,r11,lr
;;;359    
;;;360    
;;;361          } while(--k);
00018e  f8dde00c          LDR      lr,[sp,#0xc]
000192  f1be0e01          SUBS     lr,lr,#1
000196  f8cde00c          STR      lr,[sp,#0xc]
00019a  d1aa              BNE      |L1.242|
;;;362    
;;;363          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.    
;;;364           ** No loop unrolling is used. */
;;;365          k = srcBLen % 0x4u;
00019c  f0030e03          AND      lr,r3,#3
0001a0  f8cde00c          STR      lr,[sp,#0xc]
;;;366    
;;;367          while(k > 0u)
0001a4  e022              B        |L1.492|
                  |L1.422|
;;;368          {
;;;369            /* Read y[4] sample */
;;;370            c0 = *(py++);
0001a6  f850eb04          LDR      lr,[r0],#4
0001aa  f8cde010          STR      lr,[sp,#0x10]
;;;371    
;;;372            /* Read x[7] sample */
;;;373            x3 = *(px++);
0001ae  f856eb04          LDR      lr,[r6],#4
0001b2  f8cde014          STR      lr,[sp,#0x14]
;;;374    
;;;375            /* Perform the multiply-accumulates */
;;;376            /* acc0 +=  x[4] * y[4] */
;;;377            acc0 = (q31_t) ((((q63_t) acc0 << 32) + ((q63_t) x0 * c0)) >> 32);
0001b6  f8dde010          LDR      lr,[sp,#0x10]
0001ba  fb55880e          SMMLA    r8,r5,lr,r8
;;;378            /* acc1 +=  x[5] * y[4] */
;;;379            acc1 = (q31_t) ((((q63_t) acc1 << 32) + ((q63_t) x1 * c0)) >> 32);
0001be  f8dde010          LDR      lr,[sp,#0x10]
0001c2  fb54990e          SMMLA    r9,r4,lr,r9
;;;380            /* acc2 +=  x[6] * y[4] */
;;;381            acc2 = (q31_t) ((((q63_t) acc2 << 32) + ((q63_t) x2 * c0)) >> 32);
0001c6  f8dde010          LDR      lr,[sp,#0x10]
0001ca  e000              B        |L1.462|
                  |L1.460|
0001cc  e06e              B        |L1.684|
                  |L1.462|
0001ce  fb52aa0e          SMMLA    r10,r2,lr,r10
;;;382            /* acc3 +=  x[7] * y[4] */
;;;383            acc3 = (q31_t) ((((q63_t) acc3 << 32) + ((q63_t) x3 * c0)) >> 32);
0001d2  e9dde504          LDRD     lr,r5,[sp,#0x10]
0001d6  fb55bb0e          SMMLA    r11,r5,lr,r11
;;;384    
;;;385            /* Reuse the present samples for the next MAC */
;;;386            x0 = x1;
0001da  4625              MOV      r5,r4
;;;387            x1 = x2;
0001dc  4614              MOV      r4,r2
;;;388            x2 = x3;
0001de  9a05              LDR      r2,[sp,#0x14]
;;;389    
;;;390            /* Decrement the loop counter */
;;;391            k--;
0001e0  f8dde00c          LDR      lr,[sp,#0xc]
0001e4  f1ae0e01          SUB      lr,lr,#1
0001e8  f8cde00c          STR      lr,[sp,#0xc]
                  |L1.492|
0001ec  f8dde00c          LDR      lr,[sp,#0xc]          ;367
0001f0  f1be0f00          CMP      lr,#0                 ;367
0001f4  d1d7              BNE      |L1.422|
;;;392          }
;;;393    
;;;394          /* Store the result in the accumulator in the destination buffer. */
;;;395          *pOut = (q31_t) (acc0 << 1);
0001f6  ea4f0048          LSL      r0,r8,#1
0001fa  6008              STR      r0,[r1,#0]
;;;396          /* Destination pointer is updated according to the address modifier, inc */
;;;397          pOut += inc;
0001fc  eb01008c          ADD      r0,r1,r12,LSL #2
;;;398    
;;;399          *pOut = (q31_t) (acc1 << 1);
000200  ea4f0149          LSL      r1,r9,#1
000204  6001              STR      r1,[r0,#0]
;;;400          pOut += inc;
000206  eb00008c          ADD      r0,r0,r12,LSL #2
;;;401    
;;;402          *pOut = (q31_t) (acc2 << 1);
00020a  ea4f014a          LSL      r1,r10,#1
00020e  6001              STR      r1,[r0,#0]
;;;403          pOut += inc;
000210  eb00008c          ADD      r0,r0,r12,LSL #2
;;;404    
;;;405          *pOut = (q31_t) (acc3 << 1);
000214  ea4f014b          LSL      r1,r11,#1
000218  6001              STR      r1,[r0,#0]
;;;406          pOut += inc;
00021a  eb00018c          ADD      r1,r0,r12,LSL #2
;;;407    
;;;408          /* Increment the pointer pIn1 index, count by 4 */
;;;409          count += 4u;
00021e  1d3f              ADDS     r7,r7,#4
;;;410    
;;;411          /* Update the inputA and inputB pointers for next MAC calculation */
;;;412          px = pIn1 + count;
000220  980b              LDR      r0,[sp,#0x2c]
000222  eb000687          ADD      r6,r0,r7,LSL #2
;;;413          py = pIn2;
000226  980a              LDR      r0,[sp,#0x28]
;;;414    
;;;415    
;;;416          /* Decrement the loop counter */
;;;417          blkCnt--;
000228  9a02              LDR      r2,[sp,#8]
00022a  1e52              SUBS     r2,r2,#1
00022c  9202              STR      r2,[sp,#8]
                  |L1.558|
00022e  9a02              LDR      r2,[sp,#8]            ;276
000230  2a00              CMP      r2,#0                 ;276
000232  f47faf51          BNE      |L1.216|
;;;418        }
;;;419    
;;;420        /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.    
;;;421         ** No loop unrolling is used. */
;;;422        blkCnt = blockSize2 % 0x4u;
000236  9a01              LDR      r2,[sp,#4]
000238  f0020503          AND      r5,r2,#3
;;;423    
;;;424        while(blkCnt > 0u)
00023c  e033              B        |L1.678|
                  |L1.574|
;;;425        {
;;;426          /* Accumulator is made zero for every iteration */
;;;427          sum = 0;
00023e  2200              MOVS     r2,#0
;;;428    
;;;429          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;430          k = srcBLen >> 2u;
000240  089c              LSRS     r4,r3,#2
;;;431    
;;;432          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;433           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;434          while(k > 0u)
000242  e018              B        |L1.630|
                  |L1.580|
;;;435          {
;;;436            /* Perform the multiply-accumulates */
;;;437            sum = (q31_t) ((((q63_t) sum << 32) +
000244  f8568b04          LDR      r8,[r6],#4
000248  f8509b04          LDR      r9,[r0],#4
00024c  fb582209          SMMLA    r2,r8,r9,r2
;;;438                            ((q63_t) * px++ * (*py++))) >> 32);
;;;439            sum = (q31_t) ((((q63_t) sum << 32) +
000250  f8568b04          LDR      r8,[r6],#4
000254  f8509b04          LDR      r9,[r0],#4
000258  fb582209          SMMLA    r2,r8,r9,r2
;;;440                            ((q63_t) * px++ * (*py++))) >> 32);
;;;441            sum = (q31_t) ((((q63_t) sum << 32) +
00025c  f8568b04          LDR      r8,[r6],#4
000260  f8509b04          LDR      r9,[r0],#4
000264  fb582209          SMMLA    r2,r8,r9,r2
;;;442                            ((q63_t) * px++ * (*py++))) >> 32);
;;;443            sum = (q31_t) ((((q63_t) sum << 32) +
000268  f8568b04          LDR      r8,[r6],#4
00026c  f8509b04          LDR      r9,[r0],#4
000270  fb582209          SMMLA    r2,r8,r9,r2
;;;444                            ((q63_t) * px++ * (*py++))) >> 32);
;;;445    
;;;446            /* Decrement the loop counter */
;;;447            k--;
000274  1e64              SUBS     r4,r4,#1
                  |L1.630|
000276  2c00              CMP      r4,#0                 ;434
000278  d1e4              BNE      |L1.580|
;;;448          }
;;;449    
;;;450          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.    
;;;451           ** No loop unrolling is used. */
;;;452          k = srcBLen % 0x4u;
00027a  f0030403          AND      r4,r3,#3
;;;453    
;;;454          while(k > 0u)
00027e  e006              B        |L1.654|
                  |L1.640|
;;;455          {
;;;456            /* Perform the multiply-accumulate */
;;;457            sum = (q31_t) ((((q63_t) sum << 32) +
000280  f8568b04          LDR      r8,[r6],#4
000284  f8509b04          LDR      r9,[r0],#4
000288  fb582209          SMMLA    r2,r8,r9,r2
;;;458                            ((q63_t) * px++ * (*py++))) >> 32);
;;;459    
;;;460            /* Decrement the loop counter */
;;;461            k--;
00028c  1e64              SUBS     r4,r4,#1
                  |L1.654|
00028e  2c00              CMP      r4,#0                 ;454
000290  d1f6              BNE      |L1.640|
;;;462          }
;;;463    
;;;464          /* Store the result in the accumulator in the destination buffer. */
;;;465          *pOut = sum << 1;
000292  0050              LSLS     r0,r2,#1
000294  6008              STR      r0,[r1,#0]
;;;466          /* Destination pointer is updated according to the address modifier, inc */
;;;467          pOut += inc;
000296  eb01018c          ADD      r1,r1,r12,LSL #2
;;;468    
;;;469          /* Increment the MAC count */
;;;470          count++;
00029a  1c7f              ADDS     r7,r7,#1
;;;471    
;;;472          /* Update the inputA and inputB pointers for next MAC calculation */
;;;473          px = pIn1 + count;
00029c  980b              LDR      r0,[sp,#0x2c]
00029e  eb000687          ADD      r6,r0,r7,LSL #2
;;;474          py = pIn2;
0002a2  980a              LDR      r0,[sp,#0x28]
;;;475    
;;;476    
;;;477          /* Decrement the loop counter */
;;;478          blkCnt--;
0002a4  1e6d              SUBS     r5,r5,#1
                  |L1.678|
0002a6  2d00              CMP      r5,#0                 ;424
0002a8  d1c9              BNE      |L1.574|
0002aa  e019              B        |L1.736|
                  |L1.684|
;;;479        }
;;;480      }
;;;481      else
;;;482      {
;;;483        /* If the srcBLen is not a multiple of 4,    
;;;484         * the blockSize2 loop cannot be unrolled by 4 */
;;;485        blkCnt = blockSize2;
0002ac  9d01              LDR      r5,[sp,#4]
;;;486    
;;;487        while(blkCnt > 0u)
0002ae  e015              B        |L1.732|
                  |L1.688|
;;;488        {
;;;489          /* Accumulator is made zero for every iteration */
;;;490          sum = 0;
0002b0  2400              MOVS     r4,#0
;;;491    
;;;492          /* Loop over srcBLen */
;;;493          k = srcBLen;
0002b2  461a              MOV      r2,r3
;;;494    
;;;495          while(k > 0u)
0002b4  e006              B        |L1.708|
                  |L1.694|
;;;496          {
;;;497            /* Perform the multiply-accumulate */
;;;498            sum = (q31_t) ((((q63_t) sum << 32) +
0002b6  f8568b04          LDR      r8,[r6],#4
0002ba  f8509b04          LDR      r9,[r0],#4
0002be  fb584409          SMMLA    r4,r8,r9,r4
;;;499                            ((q63_t) * px++ * (*py++))) >> 32);
;;;500    
;;;501            /* Decrement the loop counter */
;;;502            k--;
0002c2  1e52              SUBS     r2,r2,#1
                  |L1.708|
0002c4  2a00              CMP      r2,#0                 ;495
0002c6  d1f6              BNE      |L1.694|
;;;503          }
;;;504    
;;;505          /* Store the result in the accumulator in the destination buffer. */
;;;506          *pOut = sum << 1;
0002c8  0060              LSLS     r0,r4,#1
0002ca  6008              STR      r0,[r1,#0]
;;;507          /* Destination pointer is updated according to the address modifier, inc */
;;;508          pOut += inc;
0002cc  eb01018c          ADD      r1,r1,r12,LSL #2
;;;509    
;;;510          /* Increment the MAC count */
;;;511          count++;
0002d0  1c7f              ADDS     r7,r7,#1
;;;512    
;;;513          /* Update the inputA and inputB pointers for next MAC calculation */
;;;514          px = pIn1 + count;
0002d2  980b              LDR      r0,[sp,#0x2c]
0002d4  eb000687          ADD      r6,r0,r7,LSL #2
;;;515          py = pIn2;
0002d8  980a              LDR      r0,[sp,#0x28]
;;;516    
;;;517          /* Decrement the loop counter */
;;;518          blkCnt--;
0002da  1e6d              SUBS     r5,r5,#1
                  |L1.732|
0002dc  2d00              CMP      r5,#0                 ;487
0002de  d1e7              BNE      |L1.688|
                  |L1.736|
;;;519        }
;;;520      }
;;;521    
;;;522      /* --------------------------    
;;;523       * Initializations of stage3    
;;;524       * -------------------------*/
;;;525    
;;;526      /* sum += x[srcALen-srcBLen+1] * y[0] + x[srcALen-srcBLen+2] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]    
;;;527       * sum += x[srcALen-srcBLen+2] * y[0] + x[srcALen-srcBLen+3] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]    
;;;528       * ....    
;;;529       * sum +=  x[srcALen-2] * y[0] + x[srcALen-1] * y[1]    
;;;530       * sum +=  x[srcALen-1] * y[0]    
;;;531       */
;;;532    
;;;533      /* In this stage the MAC operations are decreased by 1 for every iteration.    
;;;534         The count variable holds the number of MAC operations performed */
;;;535      count = srcBLen - 1u;
0002e0  1e5e              SUBS     r6,r3,#1
;;;536    
;;;537      /* Working pointer of inputA */
;;;538      pSrc1 = ((pIn1 + srcALen) - srcBLen) + 1u;
0002e2  9c0d              LDR      r4,[sp,#0x34]
0002e4  9a0b              LDR      r2,[sp,#0x2c]
0002e6  eb020284          ADD      r2,r2,r4,LSL #2
0002ea  eba20383          SUB      r3,r2,r3,LSL #2
0002ee  1d1b              ADDS     r3,r3,#4
;;;539      px = pSrc1;
0002f0  461a              MOV      r2,r3
;;;540    
;;;541      /* Working pointer of inputB */
;;;542      py = pIn2;
;;;543    
;;;544      /* -------------------    
;;;545       * Stage3 process    
;;;546       * ------------------*/
;;;547    
;;;548      while(blockSize3 > 0u)
0002f2  e030              B        |L1.854|
                  |L1.756|
;;;549      {
;;;550        /* Accumulator is made zero for every iteration */
;;;551        sum = 0;
0002f4  2400              MOVS     r4,#0
;;;552    
;;;553        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;554        k = count >> 2u;
0002f6  08b5              LSRS     r5,r6,#2
;;;555    
;;;556        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;557         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;558        while(k > 0u)
0002f8  e015              B        |L1.806|
                  |L1.762|
;;;559        {
;;;560          /* Perform the multiply-accumulates */
;;;561          /* sum += x[srcALen - srcBLen + 4] * y[3] */
;;;562          sum = (q31_t) ((((q63_t) sum << 32) +
0002fa  6817              LDR      r7,[r2,#0]
0002fc  f8508b04          LDR      r8,[r0],#4
000300  fb574408          SMMLA    r4,r7,r8,r4
;;;563                          ((q63_t) * px++ * (*py++))) >> 32);
;;;564          /* sum += x[srcALen - srcBLen + 3] * y[2] */
;;;565          sum = (q31_t) ((((q63_t) sum << 32) +
000304  6857              LDR      r7,[r2,#4]
000306  f8508b04          LDR      r8,[r0],#4
00030a  fb574408          SMMLA    r4,r7,r8,r4
;;;566                          ((q63_t) * px++ * (*py++))) >> 32);
;;;567          /* sum += x[srcALen - srcBLen + 2] * y[1] */
;;;568          sum = (q31_t) ((((q63_t) sum << 32) +
00030e  6897              LDR      r7,[r2,#8]
000310  f8508b04          LDR      r8,[r0],#4
000314  fb574408          SMMLA    r4,r7,r8,r4
;;;569                          ((q63_t) * px++ * (*py++))) >> 32);
;;;570          /* sum += x[srcALen - srcBLen + 1] * y[0] */
;;;571          sum = (q31_t) ((((q63_t) sum << 32) +
000318  68d7              LDR      r7,[r2,#0xc]
00031a  f8508b04          LDR      r8,[r0],#4
00031e  3210              ADDS     r2,r2,#0x10
000320  fb574408          SMMLA    r4,r7,r8,r4
;;;572                          ((q63_t) * px++ * (*py++))) >> 32);
;;;573    
;;;574          /* Decrement the loop counter */
;;;575          k--;
000324  1e6d              SUBS     r5,r5,#1
                  |L1.806|
000326  2d00              CMP      r5,#0                 ;558
000328  d1e7              BNE      |L1.762|
;;;576        }
;;;577    
;;;578        /* If the count is not a multiple of 4, compute any remaining MACs here.    
;;;579         ** No loop unrolling is used. */
;;;580        k = count % 0x4u;
00032a  f0060503          AND      r5,r6,#3
;;;581    
;;;582        while(k > 0u)
00032e  e005              B        |L1.828|
                  |L1.816|
;;;583        {
;;;584          /* Perform the multiply-accumulates */
;;;585          sum = (q31_t) ((((q63_t) sum << 32) +
000330  ca80              LDM      r2!,{r7}
000332  f8508b04          LDR      r8,[r0],#4
000336  fb574408          SMMLA    r4,r7,r8,r4
;;;586                          ((q63_t) * px++ * (*py++))) >> 32);
;;;587    
;;;588          /* Decrement the loop counter */
;;;589          k--;
00033a  1e6d              SUBS     r5,r5,#1
                  |L1.828|
00033c  2d00              CMP      r5,#0                 ;582
00033e  d1f7              BNE      |L1.816|
;;;590        }
;;;591    
;;;592        /* Store the result in the accumulator in the destination buffer. */
;;;593        *pOut = sum << 1;
000340  0060              LSLS     r0,r4,#1
000342  6008              STR      r0,[r1,#0]
;;;594        /* Destination pointer is updated according to the address modifier, inc */
;;;595        pOut += inc;
000344  eb01018c          ADD      r1,r1,r12,LSL #2
;;;596    
;;;597        /* Update the inputA and inputB pointers for next MAC calculation */
;;;598        px = ++pSrc1;
000348  1d1a              ADDS     r2,r3,#4
00034a  4613              MOV      r3,r2
;;;599        py = pIn2;
00034c  980a              LDR      r0,[sp,#0x28]
;;;600    
;;;601        /* Decrement the MAC count */
;;;602        count--;
00034e  1e76              SUBS     r6,r6,#1
;;;603    
;;;604        /* Decrement the loop counter */
;;;605        blockSize3--;
000350  9c00              LDR      r4,[sp,#0]
000352  1e64              SUBS     r4,r4,#1
000354  9400              STR      r4,[sp,#0]
                  |L1.854|
000356  9c00              LDR      r4,[sp,#0]            ;548
000358  2c00              CMP      r4,#0                 ;548
00035a  d1cb              BNE      |L1.756|
;;;606      }
;;;607    
;;;608    }
00035c  b010              ADD      sp,sp,#0x40
00035e  e8bd8ff0          POP      {r4-r11,pc}
;;;609    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_correlate_fast_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_correlate_fast_q31_c_d938499e____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___24_arm_correlate_fast_q31_c_d938499e____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_correlate_fast_q31_c_d938499e____REVSH|
#line 144
|__asm___24_arm_correlate_fast_q31_c_d938499e____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_correlate_fast_q31_c_d938499e____RRX|
#line 300
|__asm___24_arm_correlate_fast_q31_c_d938499e____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
