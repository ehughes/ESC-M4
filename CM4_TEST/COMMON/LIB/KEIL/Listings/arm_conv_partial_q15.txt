; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_partial_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_partial_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_conv_partial_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_partial_q15.c]
                          THUMB

                          AREA ||i.arm_conv_partial_q15||, CODE, READONLY, ALIGN=1

                  arm_conv_partial_q15 PROC
;;;70     
;;;71     arm_status arm_conv_partial_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;72       q15_t * pSrcA,
;;;73       uint32_t srcALen,
;;;74       q15_t * pSrcB,
;;;75       uint32_t srcBLen,
;;;76       q15_t * pDst,
;;;77       uint32_t firstIndex,
;;;78       uint32_t numPoints)
;;;79     {
000004  b097              SUB      sp,sp,#0x5c
000006  4699              MOV      r9,r3
000008  e9dd7425          LDRD     r7,r4,[sp,#0x94]
00000c  9b24              LDR      r3,[sp,#0x90]
;;;80     
;;;81     #if (defined(ARM_MATH_CM4) || defined(ARM_MATH_CM3)) && !defined(UNALIGNED_SUPPORT_DISABLE)
;;;82     
;;;83       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;84     
;;;85       q15_t *pIn1;                                   /* inputA pointer               */
;;;86       q15_t *pIn2;                                   /* inputB pointer               */
;;;87       q15_t *pOut = pDst;                            /* output pointer               */
;;;88       q63_t sum, acc0, acc1, acc2, acc3;             /* Accumulator                  */
;;;89       q15_t *px;                                     /* Intermediate inputA pointer  */
;;;90       q15_t *py;                                     /* Intermediate inputB pointer  */
;;;91       q15_t *pSrc1, *pSrc2;                          /* Intermediate pointers        */
;;;92       q31_t x0, x1, x2, x3, c0;                      /* Temporary input variables */
;;;93       uint32_t j, k, count, check, blkCnt;
;;;94       int32_t blockSize1, blockSize2, blockSize3;    /* loop counter                 */
;;;95       arm_status status;                             /* status of Partial convolution */
;;;96     
;;;97       /* Check for range of output samples to be calculated */
;;;98       if((firstIndex + numPoints) > ((srcALen + (srcBLen - 1u))))
00000e  9d18              LDR      r5,[sp,#0x60]
000010  1939              ADDS     r1,r7,r4
000012  444d              ADD      r5,r5,r9
000014  1e6d              SUBS     r5,r5,#1
000016  42a9              CMP      r1,r5
000018  d904              BLS      |L1.36|
;;;99       {
;;;100        /* Set status as ARM_MATH_ARGUMENT_ERROR */
;;;101        status = ARM_MATH_ARGUMENT_ERROR;
00001a  f04f30ff          MOV      r0,#0xffffffff
                  |L1.30|
;;;102      }
;;;103      else
;;;104      {
;;;105    
;;;106        /* The algorithm implementation is based on the lengths of the inputs. */
;;;107        /* srcB is always made to slide across srcA. */
;;;108        /* So srcBLen is always considered as shorter or equal to srcALen */
;;;109        if(srcALen >= srcBLen)
;;;110        {
;;;111          /* Initialization of inputA pointer */
;;;112          pIn1 = pSrcA;
;;;113    
;;;114          /* Initialization of inputB pointer */
;;;115          pIn2 = pSrcB;
;;;116        }
;;;117        else
;;;118        {
;;;119          /* Initialization of inputA pointer */
;;;120          pIn1 = pSrcB;
;;;121    
;;;122          /* Initialization of inputB pointer */
;;;123          pIn2 = pSrcA;
;;;124    
;;;125          /* srcBLen is always considered as shorter or equal to srcALen */
;;;126          j = srcBLen;
;;;127          srcBLen = srcALen;
;;;128          srcALen = j;
;;;129        }
;;;130    
;;;131        /* Conditions to check which loopCounter holds   
;;;132         * the first and last indices of the output samples to be calculated. */
;;;133        check = firstIndex + numPoints;
;;;134        blockSize3 = ((int32_t)check > (int32_t)srcALen) ? (int32_t)check - (int32_t)srcALen : 0;
;;;135        blockSize3 = ((int32_t)firstIndex > (int32_t)srcALen - 1) ? blockSize3 - (int32_t)firstIndex + (int32_t)srcALen : blockSize3;
;;;136        blockSize1 = (((int32_t) srcBLen - 1) - (int32_t) firstIndex);
;;;137        blockSize1 = (blockSize1 > 0) ? ((check > (srcBLen - 1u)) ? blockSize1 :
;;;138                                         (int32_t) numPoints) : 0;
;;;139        blockSize2 = (int32_t) check - ((blockSize3 + blockSize1) +
;;;140                                        (int32_t) firstIndex);
;;;141        blockSize2 = (blockSize2 > 0) ? blockSize2 : 0;
;;;142    
;;;143        /* conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1] */
;;;144        /* The function is internally   
;;;145         * divided into three stages according to the number of multiplications that has to be   
;;;146         * taken place between inputA samples and inputB samples. In the first stage of the   
;;;147         * algorithm, the multiplications increase by one for every iteration.   
;;;148         * In the second stage of the algorithm, srcBLen number of multiplications are done.   
;;;149         * In the third stage of the algorithm, the multiplications decrease by one   
;;;150         * for every iteration. */
;;;151    
;;;152        /* Set the output pointer to point to the firstIndex   
;;;153         * of the output sample to be calculated. */
;;;154        pOut = pDst + firstIndex;
;;;155    
;;;156        /* --------------------------   
;;;157         * Initializations of stage1   
;;;158         * -------------------------*/
;;;159    
;;;160        /* sum = x[0] * y[0]   
;;;161         * sum = x[0] * y[1] + x[1] * y[0]   
;;;162         * ....   
;;;163         * sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]   
;;;164         */
;;;165    
;;;166        /* In this stage the MAC operations are increased by 1 for every iteration.   
;;;167           The count variable holds the number of MAC operations performed.   
;;;168           Since the partial convolution starts from firstIndex   
;;;169           Number of Macs to be performed is firstIndex + 1 */
;;;170        count = 1u + firstIndex;
;;;171    
;;;172        /* Working pointer of inputA */
;;;173        px = pIn1;
;;;174    
;;;175        /* Working pointer of inputB */
;;;176        pSrc2 = pIn2 + firstIndex;
;;;177        py = pSrc2;
;;;178    
;;;179        /* ------------------------   
;;;180         * Stage1 process   
;;;181         * ----------------------*/
;;;182    
;;;183        /* For loop unrolling by 4, this stage is divided into two. */
;;;184        /* First part of this stage computes the MAC operations less than 4 */
;;;185        /* Second part of this stage computes the MAC operations greater than or equal to 4 */
;;;186    
;;;187        /* The first part of the stage starts here */
;;;188        while((count < 4u) && (blockSize1 > 0))
;;;189        {
;;;190          /* Accumulator is made zero for every iteration */
;;;191          sum = 0;
;;;192    
;;;193          /* Loop over number of MAC operations between   
;;;194           * inputA samples and inputB samples */
;;;195          k = count;
;;;196    
;;;197          while(k > 0u)
;;;198          {
;;;199            /* Perform the multiply-accumulates */
;;;200            sum = __SMLALD(*px++, *py--, sum);
;;;201    
;;;202            /* Decrement the loop counter */
;;;203            k--;
;;;204          }
;;;205    
;;;206          /* Store the result in the accumulator in the destination buffer. */
;;;207          *pOut++ = (q15_t) (__SSAT((sum >> 15), 16));
;;;208    
;;;209          /* Update the inputA and inputB pointers for next MAC calculation */
;;;210          py = ++pSrc2;
;;;211          px = pIn1;
;;;212    
;;;213          /* Increment the MAC count */
;;;214          count++;
;;;215    
;;;216          /* Decrement the loop counter */
;;;217          blockSize1--;
;;;218        }
;;;219    
;;;220        /* The second part of the stage starts here */
;;;221        /* The internal loop, over count, is unrolled by 4 */
;;;222        /* To, read the last two inputB samples using SIMD:   
;;;223         * y[srcBLen] and y[srcBLen-1] coefficients, py is decremented by 1 */
;;;224        py = py - 1;
;;;225    
;;;226        while(blockSize1 > 0)
;;;227        {
;;;228          /* Accumulator is made zero for every iteration */
;;;229          sum = 0;
;;;230    
;;;231          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;232          k = count >> 2u;
;;;233    
;;;234          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;235           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;236          while(k > 0u)
;;;237          {
;;;238            /* Perform the multiply-accumulates */
;;;239            /* x[0], x[1] are multiplied with y[srcBLen - 1], y[srcBLen - 2] respectively */
;;;240            sum = __SMLALDX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
;;;241            /* x[2], x[3] are multiplied with y[srcBLen - 3], y[srcBLen - 4] respectively */
;;;242            sum = __SMLALDX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
;;;243    
;;;244            /* Decrement the loop counter */
;;;245            k--;
;;;246          }
;;;247    
;;;248          /* For the next MAC operations, the pointer py is used without SIMD   
;;;249           * So, py is incremented by 1 */
;;;250          py = py + 1u;
;;;251    
;;;252          /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;253           ** No loop unrolling is used. */
;;;254          k = count % 0x4u;
;;;255    
;;;256          while(k > 0u)
;;;257          {
;;;258            /* Perform the multiply-accumulates */
;;;259            sum = __SMLALD(*px++, *py--, sum);
;;;260    
;;;261            /* Decrement the loop counter */
;;;262            k--;
;;;263          }
;;;264    
;;;265          /* Store the result in the accumulator in the destination buffer. */
;;;266          *pOut++ = (q15_t) (__SSAT((sum >> 15), 16));
;;;267    
;;;268          /* Update the inputA and inputB pointers for next MAC calculation */
;;;269          py = ++pSrc2 - 1u;
;;;270          px = pIn1;
;;;271    
;;;272          /* Increment the MAC count */
;;;273          count++;
;;;274    
;;;275          /* Decrement the loop counter */
;;;276          blockSize1--;
;;;277        }
;;;278    
;;;279        /* --------------------------   
;;;280         * Initializations of stage2   
;;;281         * ------------------------*/
;;;282    
;;;283        /* sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0]   
;;;284         * sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0]   
;;;285         * ....   
;;;286         * sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]   
;;;287         */
;;;288    
;;;289        /* Working pointer of inputA */
;;;290        if((int32_t)firstIndex - (int32_t)srcBLen + 1 > 0)
;;;291        {
;;;292          px = pIn1 + firstIndex - srcBLen + 1;
;;;293        }
;;;294        else
;;;295        {
;;;296          px = pIn1;
;;;297        }
;;;298    
;;;299        /* Working pointer of inputB */
;;;300        pSrc2 = pIn2 + (srcBLen - 1u);
;;;301        py = pSrc2;
;;;302    
;;;303      /* count is the index by which the pointer pIn1 to be incremented */
;;;304      count = 0u;
;;;305    
;;;306    
;;;307      /* --------------------   
;;;308       * Stage2 process   
;;;309       * -------------------*/
;;;310    
;;;311      /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.   
;;;312       * So, to loop unroll over blockSize2,   
;;;313       * srcBLen should be greater than or equal to 4 */
;;;314      if(srcBLen >= 4u)
;;;315      {
;;;316        /* Loop unroll over blockSize2, by 4 */
;;;317        blkCnt = blockSize2 >> 2u;
;;;318    
;;;319        while(blkCnt > 0u)
;;;320        {
;;;321          py = py - 1u;
;;;322    
;;;323          /* Set all accumulators to zero */
;;;324          acc0 = 0;
;;;325          acc1 = 0;
;;;326          acc2 = 0;
;;;327          acc3 = 0;
;;;328    
;;;329    
;;;330          /* read x[0], x[1] samples */
;;;331          x0 = *__SIMD32(px);
;;;332          /* read x[1], x[2] samples */
;;;333          x1 = _SIMD32_OFFSET(px+1);
;;;334    	  px+= 2u;
;;;335    
;;;336    
;;;337          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;338          k = srcBLen >> 2u;
;;;339    
;;;340          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;341           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;342          do
;;;343          {
;;;344            /* Read the last two inputB samples using SIMD:   
;;;345             * y[srcBLen - 1] and y[srcBLen - 2] */
;;;346            c0 = *__SIMD32(py)--;
;;;347    
;;;348            /* acc0 +=  x[0] * y[srcBLen - 1] + x[1] * y[srcBLen - 2] */
;;;349            acc0 = __SMLALDX(x0, c0, acc0);
;;;350    
;;;351            /* acc1 +=  x[1] * y[srcBLen - 1] + x[2] * y[srcBLen - 2] */
;;;352            acc1 = __SMLALDX(x1, c0, acc1);
;;;353    
;;;354            /* Read x[2], x[3] */
;;;355            x2 = *__SIMD32(px);
;;;356    
;;;357            /* Read x[3], x[4] */
;;;358            x3 = _SIMD32_OFFSET(px+1);
;;;359    
;;;360            /* acc2 +=  x[2] * y[srcBLen - 1] + x[3] * y[srcBLen - 2] */
;;;361            acc2 = __SMLALDX(x2, c0, acc2);
;;;362    
;;;363            /* acc3 +=  x[3] * y[srcBLen - 1] + x[4] * y[srcBLen - 2] */
;;;364            acc3 = __SMLALDX(x3, c0, acc3);
;;;365    
;;;366            /* Read y[srcBLen - 3] and y[srcBLen - 4] */
;;;367            c0 = *__SIMD32(py)--;
;;;368    
;;;369            /* acc0 +=  x[2] * y[srcBLen - 3] + x[3] * y[srcBLen - 4] */
;;;370            acc0 = __SMLALDX(x2, c0, acc0);
;;;371    
;;;372            /* acc1 +=  x[3] * y[srcBLen - 3] + x[4] * y[srcBLen - 4] */
;;;373            acc1 = __SMLALDX(x3, c0, acc1);
;;;374    
;;;375            /* Read x[4], x[5] */
;;;376            x0 = _SIMD32_OFFSET(px+2);
;;;377    
;;;378            /* Read x[5], x[6] */
;;;379            x1 = _SIMD32_OFFSET(px+3);
;;;380    		px += 4u;
;;;381    
;;;382            /* acc2 +=  x[4] * y[srcBLen - 3] + x[5] * y[srcBLen - 4] */
;;;383            acc2 = __SMLALDX(x0, c0, acc2);
;;;384    
;;;385            /* acc3 +=  x[5] * y[srcBLen - 3] + x[6] * y[srcBLen - 4] */
;;;386            acc3 = __SMLALDX(x1, c0, acc3);
;;;387    
;;;388          } while(--k);
;;;389    
;;;390          /* For the next MAC operations, SIMD is not used   
;;;391           * So, the 16 bit pointer if inputB, py is updated */
;;;392    
;;;393          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;394           ** No loop unrolling is used. */
;;;395          k = srcBLen % 0x4u;
;;;396    
;;;397          if(k == 1u)
;;;398          {
;;;399            /* Read y[srcBLen - 5] */
;;;400            c0 = *(py+1);
;;;401    
;;;402    #ifdef  ARM_MATH_BIG_ENDIAN
;;;403    
;;;404            c0 = c0 << 16u;
;;;405    
;;;406    #else
;;;407    
;;;408            c0 = c0 & 0x0000FFFF;
;;;409    
;;;410    #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;411    
;;;412            /* Read x[7] */
;;;413            x3 = *__SIMD32(px);
;;;414    		px++;
;;;415    
;;;416            /* Perform the multiply-accumulates */
;;;417            acc0 = __SMLALD(x0, c0, acc0);
;;;418            acc1 = __SMLALD(x1, c0, acc1);
;;;419            acc2 = __SMLALDX(x1, c0, acc2);
;;;420            acc3 = __SMLALDX(x3, c0, acc3);
;;;421          }
;;;422    
;;;423          if(k == 2u)
;;;424          {
;;;425            /* Read y[srcBLen - 5], y[srcBLen - 6] */
;;;426            c0 = _SIMD32_OFFSET(py);
;;;427    
;;;428            /* Read x[7], x[8] */
;;;429            x3 = *__SIMD32(px);
;;;430    
;;;431            /* Read x[9] */
;;;432            x2 = _SIMD32_OFFSET(px+1);
;;;433    		px += 2u;
;;;434    
;;;435            /* Perform the multiply-accumulates */
;;;436            acc0 = __SMLALDX(x0, c0, acc0);
;;;437            acc1 = __SMLALDX(x1, c0, acc1);
;;;438            acc2 = __SMLALDX(x3, c0, acc2);
;;;439            acc3 = __SMLALDX(x2, c0, acc3);
;;;440          }
;;;441    
;;;442          if(k == 3u)
;;;443          {
;;;444            /* Read y[srcBLen - 5], y[srcBLen - 6] */
;;;445            c0 = _SIMD32_OFFSET(py);
;;;446    
;;;447            /* Read x[7], x[8] */
;;;448            x3 = *__SIMD32(px);
;;;449    
;;;450            /* Read x[9] */
;;;451            x2 = _SIMD32_OFFSET(px+1);
;;;452    
;;;453            /* Perform the multiply-accumulates */
;;;454            acc0 = __SMLALDX(x0, c0, acc0);
;;;455            acc1 = __SMLALDX(x1, c0, acc1);
;;;456            acc2 = __SMLALDX(x3, c0, acc2);
;;;457            acc3 = __SMLALDX(x2, c0, acc3);
;;;458    
;;;459    		c0 = *(py-1);
;;;460    
;;;461    #ifdef  ARM_MATH_BIG_ENDIAN
;;;462    
;;;463            c0 = c0 << 16u;
;;;464    #else
;;;465    
;;;466            c0 = c0 & 0x0000FFFF;
;;;467    #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;468    
;;;469            /* Read x[10] */
;;;470            x3 =  _SIMD32_OFFSET(px+2);
;;;471    		px += 3u;
;;;472    
;;;473            /* Perform the multiply-accumulates */
;;;474            acc0 = __SMLALDX(x1, c0, acc0);
;;;475            acc1 = __SMLALD(x2, c0, acc1);
;;;476            acc2 = __SMLALDX(x2, c0, acc2);
;;;477            acc3 = __SMLALDX(x3, c0, acc3);
;;;478          }
;;;479    
;;;480    
;;;481          /* Store the results in the accumulators in the destination buffer. */
;;;482    
;;;483    #ifndef  ARM_MATH_BIG_ENDIAN
;;;484    
;;;485          *__SIMD32(pOut)++ =
;;;486            __PKHBT(__SSAT((acc0 >> 15), 16), __SSAT((acc1 >> 15), 16), 16);
;;;487          *__SIMD32(pOut)++ =
;;;488            __PKHBT(__SSAT((acc2 >> 15), 16), __SSAT((acc3 >> 15), 16), 16);
;;;489    
;;;490    #else
;;;491    
;;;492          *__SIMD32(pOut)++ =
;;;493            __PKHBT(__SSAT((acc1 >> 15), 16), __SSAT((acc0 >> 15), 16), 16);
;;;494          *__SIMD32(pOut)++ =
;;;495            __PKHBT(__SSAT((acc3 >> 15), 16), __SSAT((acc2 >> 15), 16), 16);
;;;496    
;;;497    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;498    
;;;499          /* Increment the pointer pIn1 index, count by 4 */
;;;500          count += 4u;
;;;501    
;;;502          /* Update the inputA and inputB pointers for next MAC calculation */
;;;503          px = pIn1 + count;
;;;504          py = pSrc2;
;;;505    
;;;506            /* Decrement the loop counter */
;;;507            blkCnt--;
;;;508          }
;;;509    
;;;510          /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.   
;;;511           ** No loop unrolling is used. */
;;;512          blkCnt = (uint32_t) blockSize2 % 0x4u;
;;;513      	  
;;;514          while(blkCnt > 0u)
;;;515          {
;;;516            /* Accumulator is made zero for every iteration */
;;;517            sum = 0;
;;;518    
;;;519            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;520            k = srcBLen >> 2u;
;;;521    
;;;522            /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;523             ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;524            while(k > 0u)
;;;525            {
;;;526              /* Perform the multiply-accumulates */
;;;527              sum += (q63_t) ((q31_t) * px++ * *py--);
;;;528              sum += (q63_t) ((q31_t) * px++ * *py--);
;;;529              sum += (q63_t) ((q31_t) * px++ * *py--);
;;;530              sum += (q63_t) ((q31_t) * px++ * *py--);
;;;531    
;;;532              /* Decrement the loop counter */
;;;533              k--;
;;;534            }
;;;535    
;;;536            /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;537             ** No loop unrolling is used. */
;;;538            k = srcBLen % 0x4u;
;;;539    
;;;540            while(k > 0u)
;;;541            {
;;;542              /* Perform the multiply-accumulates */
;;;543              sum += (q63_t) ((q31_t) * px++ * *py--);
;;;544    
;;;545              /* Decrement the loop counter */
;;;546              k--;
;;;547            }
;;;548    
;;;549            /* Store the result in the accumulator in the destination buffer. */
;;;550            *pOut++ = (q15_t) (__SSAT(sum >> 15, 16));
;;;551    
;;;552            /* Increment the pointer pIn1 index, count by 1 */
;;;553            count++;
;;;554    
;;;555            /* Update the inputA and inputB pointers for next MAC calculation */
;;;556            px = pIn1 + count;
;;;557            py = pSrc2;
;;;558    
;;;559            /* Decrement the loop counter */
;;;560            blkCnt--;
;;;561          }
;;;562        }
;;;563        else
;;;564        {
;;;565          /* If the srcBLen is not a multiple of 4,   
;;;566           * the blockSize2 loop cannot be unrolled by 4 */
;;;567          blkCnt = (uint32_t) blockSize2;
;;;568    
;;;569          while(blkCnt > 0u)
;;;570          {
;;;571            /* Accumulator is made zero for every iteration */
;;;572            sum = 0;
;;;573    
;;;574            /* srcBLen number of MACS should be performed */
;;;575            k = srcBLen;
;;;576    
;;;577            while(k > 0u)
;;;578            {
;;;579              /* Perform the multiply-accumulate */
;;;580              sum += (q63_t) ((q31_t) * px++ * *py--);
;;;581    
;;;582              /* Decrement the loop counter */
;;;583              k--;
;;;584            }
;;;585    
;;;586            /* Store the result in the accumulator in the destination buffer. */
;;;587            *pOut++ = (q15_t) (__SSAT(sum >> 15, 16));
;;;588    
;;;589            /* Increment the MAC count */
;;;590            count++;
;;;591    
;;;592            /* Update the inputA and inputB pointers for next MAC calculation */
;;;593            px = pIn1 + count;
;;;594            py = pSrc2;
;;;595      
;;;596            /* Decrement the loop counter */
;;;597            blkCnt--;
;;;598          }
;;;599        }
;;;600    
;;;601    
;;;602        /* --------------------------   
;;;603         * Initializations of stage3   
;;;604         * -------------------------*/
;;;605    
;;;606        /* sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1]   
;;;607         * sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2]   
;;;608         * ....   
;;;609         * sum +=  x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2]   
;;;610         * sum +=  x[srcALen-1] * y[srcBLen-1]   
;;;611         */
;;;612    
;;;613        /* In this stage the MAC operations are decreased by 1 for every iteration.   
;;;614           The count variable holds the number of MAC operations performed */
;;;615        count = srcBLen - 1u;
;;;616    
;;;617        /* Working pointer of inputA */
;;;618        pSrc1 = (pIn1 + srcALen) - (srcBLen - 1u);
;;;619        px = pSrc1;
;;;620    
;;;621        /* Working pointer of inputB */
;;;622        pSrc2 = pIn2 + (srcBLen - 1u);
;;;623        pIn2 = pSrc2 - 1u;
;;;624        py = pIn2;
;;;625    
;;;626        /* -------------------   
;;;627         * Stage3 process   
;;;628         * ------------------*/
;;;629    
;;;630        /* For loop unrolling by 4, this stage is divided into two. */
;;;631        /* First part of this stage computes the MAC operations greater than 4 */
;;;632        /* Second part of this stage computes the MAC operations less than or equal to 4 */
;;;633    
;;;634        /* The first part of the stage starts here */
;;;635        j = count >> 2u;
;;;636    
;;;637        while((j > 0u) && (blockSize3 > 0))
;;;638        {
;;;639          /* Accumulator is made zero for every iteration */
;;;640          sum = 0;
;;;641    
;;;642          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;643          k = count >> 2u;
;;;644    
;;;645          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;646           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;647          while(k > 0u)
;;;648          {
;;;649            /* x[srcALen - srcBLen + 1], x[srcALen - srcBLen + 2] are multiplied   
;;;650             * with y[srcBLen - 1], y[srcBLen - 2] respectively */
;;;651            sum = __SMLALDX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
;;;652            /* x[srcALen - srcBLen + 3], x[srcALen - srcBLen + 4] are multiplied   
;;;653             * with y[srcBLen - 3], y[srcBLen - 4] respectively */
;;;654            sum = __SMLALDX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
;;;655    
;;;656            /* Decrement the loop counter */
;;;657            k--;
;;;658          }
;;;659    
;;;660          /* For the next MAC operations, the pointer py is used without SIMD   
;;;661           * So, py is incremented by 1 */
;;;662          py = py + 1u;
;;;663    
;;;664          /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;665           ** No loop unrolling is used. */
;;;666          k = count % 0x4u;
;;;667    
;;;668          while(k > 0u)
;;;669          {
;;;670            /* sum += x[srcALen - srcBLen + 5] * y[srcBLen - 5] */
;;;671            sum = __SMLALD(*px++, *py--, sum);
;;;672    
;;;673            /* Decrement the loop counter */
;;;674            k--;
;;;675          }
;;;676    
;;;677          /* Store the result in the accumulator in the destination buffer. */
;;;678          *pOut++ = (q15_t) (__SSAT((sum >> 15), 16));
;;;679    
;;;680          /* Update the inputA and inputB pointers for next MAC calculation */
;;;681          px = ++pSrc1;
;;;682          py = pIn2;
;;;683    
;;;684          /* Decrement the MAC count */
;;;685          count--;
;;;686    
;;;687          /* Decrement the loop counter */
;;;688          blockSize3--;
;;;689    
;;;690          j--;
;;;691        }
;;;692    
;;;693        /* The second part of the stage starts here */
;;;694        /* SIMD is not used for the next MAC operations,   
;;;695         * so pointer py is updated to read only one sample at a time */
;;;696        py = py + 1u;
;;;697    
;;;698        while(blockSize3 > 0)
;;;699        {
;;;700          /* Accumulator is made zero for every iteration */
;;;701          sum = 0;
;;;702    
;;;703          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;704          k = count;
;;;705    
;;;706          while(k > 0u)
;;;707          {
;;;708            /* Perform the multiply-accumulates */
;;;709            /* sum +=  x[srcALen-1] * y[srcBLen-1] */
;;;710            sum = __SMLALD(*px++, *py--, sum);
;;;711    
;;;712            /* Decrement the loop counter */
;;;713            k--;
;;;714          }
;;;715    
;;;716          /* Store the result in the accumulator in the destination buffer. */
;;;717          *pOut++ = (q15_t) (__SSAT((sum >> 15), 16));
;;;718    
;;;719          /* Update the inputA and inputB pointers for next MAC calculation */
;;;720          px = ++pSrc1;
;;;721          py = pSrc2;
;;;722    
;;;723          /* Decrement the MAC count */
;;;724          count--;
;;;725    
;;;726          /* Decrement the loop counter */
;;;727          blockSize3--;
;;;728        }
;;;729    
;;;730        /* set status as ARM_MATH_SUCCESS */
;;;731        status = ARM_MATH_SUCCESS;
;;;732      }
;;;733    
;;;734      /* Return to application */
;;;735      return (status);
;;;736    
;;;737    #else
;;;738    
;;;739      /* Run the below code for Cortex-M0 */
;;;740    
;;;741      q15_t *pIn1 = pSrcA;                           /* inputA pointer */
;;;742      q15_t *pIn2 = pSrcB;                           /* inputB pointer */
;;;743      q63_t sum;                                     /* Accumulator */
;;;744      uint32_t i, j;                                 /* loop counters */
;;;745      arm_status status;                             /* status of Partial convolution */
;;;746    
;;;747      /* Check for range of output samples to be calculated */
;;;748      if((firstIndex + numPoints) > ((srcALen + (srcBLen - 1u))))
;;;749      {
;;;750        /* Set status as ARM_ARGUMENT_ERROR */
;;;751        status = ARM_MATH_ARGUMENT_ERROR;
;;;752      }
;;;753      else
;;;754      {
;;;755        /* Loop to calculate convolution for output length number of values */
;;;756        for (i = firstIndex; i <= (firstIndex + numPoints - 1); i++)
;;;757        {
;;;758          /* Initialize sum with zero to carry on MAC operations */
;;;759          sum = 0;
;;;760    
;;;761          /* Loop to perform MAC operations according to convolution equation */
;;;762          for (j = 0; j <= i; j++)
;;;763          {
;;;764            /* Check the array limitations */
;;;765            if(((i - j) < srcBLen) && (j < srcALen))
;;;766            {
;;;767              /* z[i] += x[i-j] * y[j] */
;;;768              sum += ((q31_t) pIn1[j] * (pIn2[i - j]));
;;;769            }
;;;770          }
;;;771    
;;;772          /* Store the output in the destination buffer */
;;;773          pDst[i] = (q15_t) __SSAT((sum >> 15u), 16u);
;;;774        }
;;;775        /* set status as ARM_SUCCESS as there are no argument errors */
;;;776        status = ARM_MATH_SUCCESS;
;;;777      }
;;;778      return (status);
;;;779    
;;;780    #endif /* #if (defined(ARM_MATH_CM4) || defined(ARM_MATH_CM3)) && !defined(UNALIGNED_SUPPORT_DISABLE)  */
;;;781    
;;;782    }
00001e  b01b              ADD      sp,sp,#0x6c
000020  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.36|
000024  9d18              LDR      r5,[sp,#0x60]         ;109
000026  454d              CMP      r5,r9                 ;109
000028  d302              BCC      |L1.48|
00002a  900f              STR      r0,[sp,#0x3c]         ;112
00002c  920e              STR      r2,[sp,#0x38]         ;115
00002e  e005              B        |L1.60|
                  |L1.48|
000030  920f              STR      r2,[sp,#0x3c]         ;120
000032  900e              STR      r0,[sp,#0x38]         ;123
000034  4648              MOV      r0,r9                 ;126
000036  f8dd9060          LDR      r9,[sp,#0x60]         ;127
00003a  9018              STR      r0,[sp,#0x60]         ;128
                  |L1.60|
00003c  9818              LDR      r0,[sp,#0x60]         ;134
00003e  4281              CMP      r1,r0                 ;134
000040  dd02              BLE      |L1.72|
000042  9818              LDR      r0,[sp,#0x60]         ;134
000044  1a08              SUBS     r0,r1,r0              ;134
000046  e000              B        |L1.74|
                  |L1.72|
000048  2000              MOVS     r0,#0                 ;134
                  |L1.74|
00004a  9a18              LDR      r2,[sp,#0x60]         ;135
00004c  1e52              SUBS     r2,r2,#1              ;135
00004e  4297              CMP      r7,r2                 ;135
000050  dd02              BLE      |L1.88|
000052  1bc2              SUBS     r2,r0,r7              ;135
000054  9818              LDR      r0,[sp,#0x60]         ;135
000056  4410              ADD      r0,r0,r2              ;135
                  |L1.88|
000058  9003              STR      r0,[sp,#0xc]          ;135
00005a  eba90207          SUB      r2,r9,r7              ;136
00005e  1e52              SUBS     r2,r2,#1              ;136
000060  2a00              CMP      r2,#0                 ;137
000062  dd05              BLE      |L1.112|
000064  f1a90001          SUB      r0,r9,#1              ;137
000068  4281              CMP      r1,r0                 ;137
00006a  d802              BHI      |L1.114|
00006c  4622              MOV      r2,r4                 ;138
00006e  e000              B        |L1.114|
                  |L1.112|
000070  2200              MOVS     r2,#0                 ;138
                  |L1.114|
000072  9803              LDR      r0,[sp,#0xc]          ;139
000074  4410              ADD      r0,r0,r2              ;139
000076  4438              ADD      r0,r0,r7              ;139
000078  1a08              SUBS     r0,r1,r0              ;139
00007a  2800              CMP      r0,#0                 ;141
00007c  dc00              BGT      |L1.128|
00007e  2000              MOVS     r0,#0                 ;141
                  |L1.128|
000080  9004              STR      r0,[sp,#0x10]         ;141
000082  eb030c47          ADD      r12,r3,r7,LSL #1      ;154
000086  1c7b              ADDS     r3,r7,#1              ;170
000088  f8dd803c          LDR      r8,[sp,#0x3c]         ;173
00008c  980e              LDR      r0,[sp,#0x38]         ;176
00008e  eb000447          ADD      r4,r0,r7,LSL #1       ;176
000092  4626              MOV      r6,r4                 ;177
000094  e019              B        |L1.202|
                  |L1.150|
000096  2000              MOVS     r0,#0                 ;191
000098  4601              MOV      r1,r0                 ;191
00009a  461d              MOV      r5,r3                 ;195
00009c  e006              B        |L1.172|
                  |L1.158|
00009e  f938bb02          LDRSH    r11,[r8],#2           ;200
0000a2  f936a902          LDRSH    r10,[r6],#-2          ;200
0000a6  fbcb01ca          SMLALD   r0,r1,r11,r10         ;200
0000aa  1e6d              SUBS     r5,r5,#1              ;203
                  |L1.172|
0000ac  2d00              CMP      r5,#0                 ;197
0000ae  d1f6              BNE      |L1.158|
0000b0  0bc0              LSRS     r0,r0,#15             ;207
0000b2  ea404041          ORR      r0,r0,r1,LSL #17      ;207
0000b6  f300000f          SSAT     r0,#16,r0             ;207
0000ba  f82c0b02          STRH     r0,[r12],#2           ;207
0000be  1ca4              ADDS     r4,r4,#2              ;210
0000c0  4626              MOV      r6,r4                 ;210
0000c2  f8dd803c          LDR      r8,[sp,#0x3c]         ;211
0000c6  1c5b              ADDS     r3,r3,#1              ;214
0000c8  1e52              SUBS     r2,r2,#1              ;217
                  |L1.202|
0000ca  2b04              CMP      r3,#4                 ;188
0000cc  d201              BCS      |L1.210|
0000ce  2a00              CMP      r2,#0                 ;188
0000d0  dce1              BGT      |L1.150|
                  |L1.210|
0000d2  1eb6              SUBS     r6,r6,#2              ;224
0000d4  e02c              B        |L1.304|
                  |L1.214|
0000d6  2000              MOVS     r0,#0                 ;229
0000d8  4601              MOV      r1,r0                 ;229
0000da  089d              LSRS     r5,r3,#2              ;232
0000dc  e00c              B        |L1.248|
                  |L1.222|
0000de  f858bb04          LDR      r11,[r8],#4           ;240
0000e2  f856a904          LDR      r10,[r6],#-4          ;240
0000e6  fbcb01da          SMLALDX  r0,r1,r11,r10         ;240
0000ea  f858bb04          LDR      r11,[r8],#4           ;242
0000ee  f856a904          LDR      r10,[r6],#-4          ;242
0000f2  fbcb01da          SMLALDX  r0,r1,r11,r10         ;242
0000f6  1e6d              SUBS     r5,r5,#1              ;245
                  |L1.248|
0000f8  2d00              CMP      r5,#0                 ;236
0000fa  d1f0              BNE      |L1.222|
0000fc  1cb6              ADDS     r6,r6,#2              ;250
0000fe  f0030503          AND      r5,r3,#3              ;254
000102  e006              B        |L1.274|
                  |L1.260|
000104  f938bb02          LDRSH    r11,[r8],#2           ;259
000108  f936a902          LDRSH    r10,[r6],#-2          ;259
00010c  fbcb01ca          SMLALD   r0,r1,r11,r10         ;259
000110  1e6d              SUBS     r5,r5,#1              ;262
                  |L1.274|
000112  2d00              CMP      r5,#0                 ;256
000114  d1f6              BNE      |L1.260|
000116  0bc0              LSRS     r0,r0,#15             ;266
000118  ea404041          ORR      r0,r0,r1,LSL #17      ;266
00011c  f300000f          SSAT     r0,#16,r0             ;266
000120  f82c0b02          STRH     r0,[r12],#2           ;266
000124  1ca4              ADDS     r4,r4,#2              ;269
000126  1ea6              SUBS     r6,r4,#2              ;269
000128  f8dd803c          LDR      r8,[sp,#0x3c]         ;270
00012c  1c5b              ADDS     r3,r3,#1              ;273
00012e  1e52              SUBS     r2,r2,#1              ;276
                  |L1.304|
000130  2a00              CMP      r2,#0                 ;226
000132  dcd0              BGT      |L1.214|
000134  eba70009          SUB      r0,r7,r9              ;290
000138  1c40              ADDS     r0,r0,#1              ;290
00013a  2800              CMP      r0,#0                 ;290
00013c  dd06              BLE      |L1.332|
00013e  980f              LDR      r0,[sp,#0x3c]         ;292
000140  eb000047          ADD      r0,r0,r7,LSL #1       ;292
000144  eba00849          SUB      r8,r0,r9,LSL #1       ;292
000148  f1080802          ADD      r8,r8,#2              ;292
                  |L1.332|
00014c  990e              LDR      r1,[sp,#0x38]         ;300
00014e  f1a90001          SUB      r0,r9,#1              ;300
000152  eb010240          ADD      r2,r1,r0,LSL #1       ;300
000156  e9cd2014          STRD     r2,r0,[sp,#0x50]      ;300
00015a  920c              STR      r2,[sp,#0x30]         ;300
00015c  9a0c              LDR      r2,[sp,#0x30]         ;301
00015e  2000              MOVS     r0,#0                 ;304
000160  9006              STR      r0,[sp,#0x18]         ;304
000162  f1b90f04          CMP      r9,#4                 ;314
000166  d37d              BCC      |L1.612|
000168  9804              LDR      r0,[sp,#0x10]         ;317
00016a  1080              ASRS     r0,r0,#2              ;317
00016c  9005              STR      r0,[sp,#0x14]         ;317
00016e  e137              B        |L1.992|
                  |L1.368|
000170  1e92              SUBS     r2,r2,#2              ;321
000172  920d              STR      r2,[sp,#0x34]         ;321
000174  2000              MOVS     r0,#0                 ;324
000176  4601              MOV      r1,r0                 ;324
000178  2200              MOVS     r2,#0                 ;325
00017a  4613              MOV      r3,r2                 ;325
00017c  2400              MOVS     r4,#0                 ;326
00017e  4625              MOV      r5,r4                 ;326
000180  2600              MOVS     r6,#0                 ;327
000182  4637              MOV      r7,r6                 ;327
000184  f8d8a000          LDR      r10,[r8,#0]           ;331
000188  f8cda02c          STR      r10,[sp,#0x2c]        ;331
00018c  f8d8a002          LDR      r10,[r8,#2]           ;333
000190  f1080804          ADD      r8,r8,#4              ;334
000194  ea4f0b99          LSR      r11,r9,#2             ;338
000198  f8cdb01c          STR      r11,[sp,#0x1c]        ;338
                  |L1.412|
00019c  f8ddb034          LDR      r11,[sp,#0x34]        ;346
0001a0  f8dbb000          LDR      r11,[r11,#0]          ;346
0001a4  f8cdb020          STR      r11,[sp,#0x20]        ;346
0001a8  f8ddb034          LDR      r11,[sp,#0x34]        ;346
0001ac  f1ab0b04          SUB      r11,r11,#4            ;346
0001b0  f8cdb034          STR      r11,[sp,#0x34]        ;346
0001b4  f8dde02c          LDR      lr,[sp,#0x2c]         ;349
0001b8  f8ddb020          LDR      r11,[sp,#0x20]        ;349
0001bc  f8cde008          STR      lr,[sp,#8]            ;349
0001c0  fbce01db          SMLALDX  r0,r1,lr,r11          ;349
0001c4  f8ddb020          LDR      r11,[sp,#0x20]        ;352
0001c8  fbca23db          SMLALDX  r2,r3,r10,r11         ;352
0001cc  f8d8e000          LDR      lr,[r8,#0]            ;355
0001d0  f8d8a002          LDR      r10,[r8,#2]           ;358
0001d4  f8cda04c          STR      r10,[sp,#0x4c]        ;358
0001d8  f8ddb020          LDR      r11,[sp,#0x20]        ;361
0001dc  fbce45db          SMLALDX  r4,r5,lr,r11          ;361
0001e0  f8ddb020          LDR      r11,[sp,#0x20]        ;364
0001e4  f8dda04c          LDR      r10,[sp,#0x4c]        ;364
0001e8  fbca67db          SMLALDX  r6,r7,r10,r11         ;364
0001ec  f8ddb034          LDR      r11,[sp,#0x34]        ;367
0001f0  f8dbb000          LDR      r11,[r11,#0]          ;367
0001f4  f8cdb020          STR      r11,[sp,#0x20]        ;367
0001f8  f8ddb034          LDR      r11,[sp,#0x34]        ;367
0001fc  f1ab0b04          SUB      r11,r11,#4            ;367
000200  f8cdb034          STR      r11,[sp,#0x34]        ;367
000204  f8ddb020          LDR      r11,[sp,#0x20]        ;370
000208  fbce01db          SMLALDX  r0,r1,lr,r11          ;370
00020c  f8ddb020          LDR      r11,[sp,#0x20]        ;373
000210  f8dda04c          LDR      r10,[sp,#0x4c]        ;373
000214  fbca23db          SMLALDX  r2,r3,r10,r11         ;373
000218  f8d8a004          LDR      r10,[r8,#4]           ;376
00021c  f8cda02c          STR      r10,[sp,#0x2c]        ;376
000220  f8d8a006          LDR      r10,[r8,#6]           ;379
000224  f1080808          ADD      r8,r8,#8              ;380
000228  9502              STR      r5,[sp,#8]            ;383
00022a  f8dde008          LDR      lr,[sp,#8]            ;383
00022e  f8ddb020          LDR      r11,[sp,#0x20]        ;383
000232  9d0b              LDR      r5,[sp,#0x2c]         ;383
000234  fbc54edb          SMLALDX  r4,lr,r5,r11          ;383
000238  4675              MOV      r5,lr                 ;383
00023a  f8ddb020          LDR      r11,[sp,#0x20]        ;386
00023e  fbca67db          SMLALDX  r6,r7,r10,r11         ;386
000242  f8ddb01c          LDR      r11,[sp,#0x1c]        ;388
000246  f1bb0b01          SUBS     r11,r11,#1            ;388
00024a  f8cdb01c          STR      r11,[sp,#0x1c]        ;388
00024e  d1a5              BNE      |L1.412|
000250  f0090b03          AND      r11,r9,#3             ;395
000254  f8cdb01c          STR      r11,[sp,#0x1c]        ;395
000258  f8ddb01c          LDR      r11,[sp,#0x1c]        ;397
00025c  f1bb0f01          CMP      r11,#1                ;397
000260  d12c              BNE      |L1.700|
000262  e000              B        |L1.614|
                  |L1.612|
000264  e104              B        |L1.1136|
                  |L1.614|
000266  f8ddb034          LDR      r11,[sp,#0x34]        ;400
00026a  f8bbb002          LDRH     r11,[r11,#2]          ;400
00026e  fa1ffb8b          UXTH     r11,r11               ;408
000272  f8cdb020          STR      r11,[sp,#0x20]        ;408
000276  f8d8b000          LDR      r11,[r8,#0]           ;413
00027a  f8cdb024          STR      r11,[sp,#0x24]        ;413
00027e  f1080802          ADD      r8,r8,#2              ;414
000282  9102              STR      r1,[sp,#8]            ;417
000284  e9cd0100          STRD     r0,r1,[sp,#0]         ;417
000288  f8dde008          LDR      lr,[sp,#8]            ;417
00028c  f8ddb020          LDR      r11,[sp,#0x20]        ;417
000290  990b              LDR      r1,[sp,#0x2c]         ;417
000292  fbc10ecb          SMLALD   r0,lr,r1,r11          ;417
000296  4671              MOV      r1,lr                 ;417
000298  f8ddb020          LDR      r11,[sp,#0x20]        ;418
00029c  fbca23cb          SMLALD   r2,r3,r10,r11         ;418
0002a0  f8ddb020          LDR      r11,[sp,#0x20]        ;419
0002a4  fbca45db          SMLALDX  r4,r5,r10,r11         ;419
0002a8  9702              STR      r7,[sp,#8]            ;420
0002aa  e9cd6700          STRD     r6,r7,[sp,#0]         ;420
0002ae  e9ddb708          LDRD     r11,r7,[sp,#0x20]     ;420
0002b2  f8dde008          LDR      lr,[sp,#8]            ;420
0002b6  fbc76edb          SMLALDX  r6,lr,r7,r11          ;420
0002ba  4677              MOV      r7,lr                 ;420
                  |L1.700|
0002bc  f8ddb01c          LDR      r11,[sp,#0x1c]        ;423
0002c0  f1bb0f02          CMP      r11,#2                ;423
0002c4  d125              BNE      |L1.786|
0002c6  f8ddb034          LDR      r11,[sp,#0x34]        ;426
0002ca  f8dbe000          LDR      lr,[r11,#0]           ;426
0002ce  f8cde048          STR      lr,[sp,#0x48]         ;426
0002d2  f8d8b000          LDR      r11,[r8,#0]           ;429
0002d6  f8cdb024          STR      r11,[sp,#0x24]        ;429
0002da  f8d8b002          LDR      r11,[r8,#2]           ;432
0002de  f8cdb028          STR      r11,[sp,#0x28]        ;432
0002e2  f1080804          ADD      r8,r8,#4              ;433
0002e6  f8dde048          LDR      lr,[sp,#0x48]         ;436
0002ea  f8ddb02c          LDR      r11,[sp,#0x2c]        ;436
0002ee  fbcb01de          SMLALDX  r0,r1,r11,lr          ;436
0002f2  f8dde048          LDR      lr,[sp,#0x48]         ;437
0002f6  fbca23de          SMLALDX  r2,r3,r10,lr          ;437
0002fa  f8dde048          LDR      lr,[sp,#0x48]         ;438
0002fe  f8ddb024          LDR      r11,[sp,#0x24]        ;438
000302  fbcb45de          SMLALDX  r4,r5,r11,lr          ;438
000306  f8dde048          LDR      lr,[sp,#0x48]         ;439
00030a  f8ddb028          LDR      r11,[sp,#0x28]        ;439
00030e  fbcb67de          SMLALDX  r6,r7,r11,lr          ;439
                  |L1.786|
000312  f8ddb01c          LDR      r11,[sp,#0x1c]        ;442
000316  f1bb0f03          CMP      r11,#3                ;442
00031a  d13a              BNE      |L1.914|
00031c  f8ddb034          LDR      r11,[sp,#0x34]        ;445
000320  f8dbb000          LDR      r11,[r11,#0]          ;445
000324  f8d8e000          LDR      lr,[r8,#0]            ;448
000328  f8cde044          STR      lr,[sp,#0x44]         ;448
00032c  f8d8e002          LDR      lr,[r8,#2]            ;451
000330  f8cde040          STR      lr,[sp,#0x40]         ;451
000334  f8cde028          STR      lr,[sp,#0x28]         ;451
000338  e9cd0100          STRD     r0,r1,[sp,#0]         ;454
00033c  f8dde000          LDR      lr,[sp,#0]            ;454
000340  980b              LDR      r0,[sp,#0x2c]         ;454
000342  9102              STR      r1,[sp,#8]            ;454
000344  fbc0e1db          SMLALDX  lr,r1,r0,r11          ;454
000348  4670              MOV      r0,lr                 ;454
00034a  fbca23db          SMLALDX  r2,r3,r10,r11         ;455
00034e  f8dde044          LDR      lr,[sp,#0x44]         ;456
000352  fbce45db          SMLALDX  r4,r5,lr,r11          ;456
000356  f8dde040          LDR      lr,[sp,#0x40]         ;457
00035a  fbce67db          SMLALDX  r6,r7,lr,r11          ;457
00035e  f8ddb034          LDR      r11,[sp,#0x34]        ;459
000362  f83bbc02          LDRH     r11,[r11,#-2]         ;459
000366  fa1ffb8b          UXTH     r11,r11               ;466
00036a  f8d88004          LDR      r8,[r8,#4]            ;470
00036e  f8cd8024          STR      r8,[sp,#0x24]         ;470
000372  fbca01db          SMLALDX  r0,r1,r10,r11         ;474
000376  4698              MOV      r8,r3                 ;475
000378  9b0a              LDR      r3,[sp,#0x28]         ;475
00037a  fbc328cb          SMLALD   r2,r8,r3,r11          ;475
00037e  4643              MOV      r3,r8                 ;475
000380  46a8              MOV      r8,r5                 ;476
000382  9d0a              LDR      r5,[sp,#0x28]         ;476
000384  fbc548db          SMLALDX  r4,r8,r5,r11          ;476
000388  4645              MOV      r5,r8                 ;476
00038a  f8dd8024          LDR      r8,[sp,#0x24]         ;477
00038e  fbc867db          SMLALDX  r6,r7,r8,r11          ;477
                  |L1.914|
000392  0bc0              LSRS     r0,r0,#15             ;485
000394  ea404041          ORR      r0,r0,r1,LSL #17      ;485
000398  f300010f          SSAT     r1,#16,r0             ;485
00039c  0bd0              LSRS     r0,r2,#15             ;485
00039e  ea404043          ORR      r0,r0,r3,LSL #17      ;485
0003a2  f300000f          SSAT     r0,#16,r0             ;485
0003a6  eac14000          PKHBT    r0,r1,r0,LSL #16      ;485
0003aa  f84c0b04          STR      r0,[r12],#4           ;485
0003ae  0be0              LSRS     r0,r4,#15             ;487
0003b0  ea404045          ORR      r0,r0,r5,LSL #17      ;487
0003b4  f300010f          SSAT     r1,#16,r0             ;487
0003b8  0bf0              LSRS     r0,r6,#15             ;487
0003ba  ea404047          ORR      r0,r0,r7,LSL #17      ;487
0003be  f300000f          SSAT     r0,#16,r0             ;487
0003c2  eac14000          PKHBT    r0,r1,r0,LSL #16      ;487
0003c6  f84c0b04          STR      r0,[r12],#4           ;487
0003ca  9806              LDR      r0,[sp,#0x18]         ;500
0003cc  1d00              ADDS     r0,r0,#4              ;500
0003ce  9006              STR      r0,[sp,#0x18]         ;500
0003d0  9906              LDR      r1,[sp,#0x18]         ;503
0003d2  980f              LDR      r0,[sp,#0x3c]         ;503
0003d4  eb000841          ADD      r8,r0,r1,LSL #1       ;503
0003d8  9a0c              LDR      r2,[sp,#0x30]         ;504
0003da  9805              LDR      r0,[sp,#0x14]         ;507
0003dc  1e40              SUBS     r0,r0,#1              ;507
0003de  9005              STR      r0,[sp,#0x14]         ;507
                  |L1.992|
0003e0  9805              LDR      r0,[sp,#0x14]         ;319
0003e2  2800              CMP      r0,#0                 ;319
0003e4  f47faec4          BNE      |L1.368|
0003e8  9804              LDR      r0,[sp,#0x10]         ;512
0003ea  f0000403          AND      r4,r0,#3              ;512
0003ee  e03c              B        |L1.1130|
                  |L1.1008|
0003f0  2000              MOVS     r0,#0                 ;517
0003f2  4601              MOV      r1,r0                 ;517
0003f4  ea4f0399          LSR      r3,r9,#2              ;520
0003f8  e019              B        |L1.1070|
                  |L1.1018|
0003fa  1f92              SUBS     r2,r2,#6              ;527
0003fc  f9385b02          LDRSH    r5,[r8],#2            ;527
000400  f9b26006          LDRSH    r6,[r2,#6]            ;527
000404  fbc50186          SMLALBB  r0,r1,r5,r6           ;527
000408  f9385b02          LDRSH    r5,[r8],#2            ;528
00040c  f9b26004          LDRSH    r6,[r2,#4]            ;528
000410  fbc50186          SMLALBB  r0,r1,r5,r6           ;528
000414  f9385b02          LDRSH    r5,[r8],#2            ;529
000418  f9b26002          LDRSH    r6,[r2,#2]            ;529
00041c  fbc50186          SMLALBB  r0,r1,r5,r6           ;529
000420  f9385b02          LDRSH    r5,[r8],#2            ;530
000424  f9326902          LDRSH    r6,[r2],#-2           ;530
000428  fbc50186          SMLALBB  r0,r1,r5,r6           ;530
00042c  1e5b              SUBS     r3,r3,#1              ;533
                  |L1.1070|
00042e  2b00              CMP      r3,#0                 ;524
000430  d1e3              BNE      |L1.1018|
000432  f0090303          AND      r3,r9,#3              ;538
000436  e006              B        |L1.1094|
                  |L1.1080|
000438  f9387b02          LDRSH    r7,[r8],#2            ;543
00043c  f9325902          LDRSH    r5,[r2],#-2           ;543
000440  fbc70185          SMLALBB  r0,r1,r7,r5           ;543
000444  1e5b              SUBS     r3,r3,#1              ;546
                  |L1.1094|
000446  2b00              CMP      r3,#0                 ;540
000448  d1f6              BNE      |L1.1080|
00044a  0bc0              LSRS     r0,r0,#15             ;550
00044c  ea404041          ORR      r0,r0,r1,LSL #17      ;550
000450  f300000f          SSAT     r0,#16,r0             ;550
000454  f82c0b02          STRH     r0,[r12],#2           ;550
000458  9806              LDR      r0,[sp,#0x18]         ;553
00045a  1c40              ADDS     r0,r0,#1              ;553
00045c  9006              STR      r0,[sp,#0x18]         ;553
00045e  9906              LDR      r1,[sp,#0x18]         ;556
000460  980f              LDR      r0,[sp,#0x3c]         ;556
000462  eb000841          ADD      r8,r0,r1,LSL #1       ;556
000466  9a0c              LDR      r2,[sp,#0x30]         ;557
000468  1e64              SUBS     r4,r4,#1              ;560
                  |L1.1130|
00046a  2c00              CMP      r4,#0                 ;514
00046c  d1c0              BNE      |L1.1008|
00046e  e020              B        |L1.1202|
                  |L1.1136|
000470  9c04              LDR      r4,[sp,#0x10]         ;567
000472  e01c              B        |L1.1198|
                  |L1.1140|
000474  2000              MOVS     r0,#0                 ;572
000476  4601              MOV      r1,r0                 ;572
000478  464b              MOV      r3,r9                 ;575
00047a  e006              B        |L1.1162|
                  |L1.1148|
00047c  f9387b02          LDRSH    r7,[r8],#2            ;580
000480  f9325902          LDRSH    r5,[r2],#-2           ;580
000484  fbc70185          SMLALBB  r0,r1,r7,r5           ;580
000488  1e5b              SUBS     r3,r3,#1              ;583
                  |L1.1162|
00048a  2b00              CMP      r3,#0                 ;577
00048c  d1f6              BNE      |L1.1148|
00048e  0bc0              LSRS     r0,r0,#15             ;587
000490  ea404041          ORR      r0,r0,r1,LSL #17      ;587
000494  f300000f          SSAT     r0,#16,r0             ;587
000498  f82c0b02          STRH     r0,[r12],#2           ;587
00049c  9806              LDR      r0,[sp,#0x18]         ;590
00049e  1c40              ADDS     r0,r0,#1              ;590
0004a0  9006              STR      r0,[sp,#0x18]         ;590
0004a2  9906              LDR      r1,[sp,#0x18]         ;593
0004a4  980f              LDR      r0,[sp,#0x3c]         ;593
0004a6  eb000841          ADD      r8,r0,r1,LSL #1       ;593
0004aa  9a0c              LDR      r2,[sp,#0x30]         ;594
0004ac  1e64              SUBS     r4,r4,#1              ;597
                  |L1.1198|
0004ae  2c00              CMP      r4,#0                 ;569
0004b0  d1e0              BNE      |L1.1140|
                  |L1.1202|
0004b2  f1a90901          SUB      r9,r9,#1              ;615
0004b6  9918              LDR      r1,[sp,#0x60]         ;618
0004b8  980f              LDR      r0,[sp,#0x3c]         ;618
0004ba  eb000141          ADD      r1,r0,r1,LSL #1       ;618
0004be  9815              LDR      r0,[sp,#0x54]         ;618
0004c0  eba10340          SUB      r3,r1,r0,LSL #1       ;618
0004c4  461a              MOV      r2,r3                 ;619
0004c6  9f14              LDR      r7,[sp,#0x50]         ;622
0004c8  f1a70b02          SUB      r11,r7,#2             ;623
0004cc  465d              MOV      r5,r11                ;624
0004ce  ea4f0499          LSR      r4,r9,#2              ;635
0004d2  e030              B        |L1.1334|
                  |L1.1236|
0004d4  2000              MOVS     r0,#0                 ;640
0004d6  4601              MOV      r1,r0                 ;640
0004d8  ea4f0699          LSR      r6,r9,#2              ;643
0004dc  e00c              B        |L1.1272|
                  |L1.1246|
0004de  f8528b04          LDR      r8,[r2],#4            ;651
0004e2  f855a904          LDR      r10,[r5],#-4          ;651
0004e6  fbc801da          SMLALDX  r0,r1,r8,r10          ;651
0004ea  f8528b04          LDR      r8,[r2],#4            ;654
0004ee  f855a904          LDR      r10,[r5],#-4          ;654
0004f2  fbc801da          SMLALDX  r0,r1,r8,r10          ;654
0004f6  1e76              SUBS     r6,r6,#1              ;657
                  |L1.1272|
0004f8  2e00              CMP      r6,#0                 ;647
0004fa  d1f0              BNE      |L1.1246|
0004fc  1cad              ADDS     r5,r5,#2              ;662
0004fe  f0090603          AND      r6,r9,#3              ;666
000502  e006              B        |L1.1298|
                  |L1.1284|
000504  f932ab02          LDRSH    r10,[r2],#2           ;671
000508  f9358902          LDRSH    r8,[r5],#-2           ;671
00050c  fbca01c8          SMLALD   r0,r1,r10,r8          ;671
000510  1e76              SUBS     r6,r6,#1              ;674
                  |L1.1298|
000512  2e00              CMP      r6,#0                 ;668
000514  d1f6              BNE      |L1.1284|
000516  0bc0              LSRS     r0,r0,#15             ;678
000518  ea404041          ORR      r0,r0,r1,LSL #17      ;678
00051c  f300000f          SSAT     r0,#16,r0             ;678
000520  f82c0b02          STRH     r0,[r12],#2           ;678
000524  1c9a              ADDS     r2,r3,#2              ;681
000526  4613              MOV      r3,r2                 ;681
000528  465d              MOV      r5,r11                ;682
00052a  f1a90901          SUB      r9,r9,#1              ;685
00052e  9803              LDR      r0,[sp,#0xc]          ;688
000530  1e40              SUBS     r0,r0,#1              ;688
000532  9003              STR      r0,[sp,#0xc]          ;688
000534  1e64              SUBS     r4,r4,#1              ;690
                  |L1.1334|
000536  b114              CBZ      r4,|L1.1342|
000538  9803              LDR      r0,[sp,#0xc]          ;637
00053a  2800              CMP      r0,#0                 ;637
00053c  dcca              BGT      |L1.1236|
                  |L1.1342|
00053e  1cad              ADDS     r5,r5,#2              ;696
000540  e01b              B        |L1.1402|
                  |L1.1346|
000542  2000              MOVS     r0,#0                 ;701
000544  4601              MOV      r1,r0                 ;701
000546  464c              MOV      r4,r9                 ;704
000548  e006              B        |L1.1368|
                  |L1.1354|
00054a  f932ab02          LDRSH    r10,[r2],#2           ;710
00054e  f9356902          LDRSH    r6,[r5],#-2           ;710
000552  fbca01c6          SMLALD   r0,r1,r10,r6          ;710
000556  1e64              SUBS     r4,r4,#1              ;713
                  |L1.1368|
000558  2c00              CMP      r4,#0                 ;706
00055a  d1f6              BNE      |L1.1354|
00055c  0bc0              LSRS     r0,r0,#15             ;717
00055e  ea404041          ORR      r0,r0,r1,LSL #17      ;717
000562  f300000f          SSAT     r0,#16,r0             ;717
000566  f82c0b02          STRH     r0,[r12],#2           ;717
00056a  1c9a              ADDS     r2,r3,#2              ;720
00056c  4613              MOV      r3,r2                 ;720
00056e  463d              MOV      r5,r7                 ;721
000570  f1a90901          SUB      r9,r9,#1              ;724
000574  9803              LDR      r0,[sp,#0xc]          ;727
000576  1e40              SUBS     r0,r0,#1              ;727
000578  9003              STR      r0,[sp,#0xc]          ;727
                  |L1.1402|
00057a  9803              LDR      r0,[sp,#0xc]          ;698
00057c  2800              CMP      r0,#0                 ;698
00057e  dce0              BGT      |L1.1346|
000580  2000              MOVS     r0,#0                 ;731
000582  e54c              B        |L1.30|
;;;783    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_partial_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_conv_partial_q15_c_2501e473____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___22_arm_conv_partial_q15_c_2501e473____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_conv_partial_q15_c_2501e473____REVSH|
#line 144
|__asm___22_arm_conv_partial_q15_c_2501e473____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_conv_partial_q15_c_2501e473____RRX|
#line 300
|__asm___22_arm_conv_partial_q15_c_2501e473____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
