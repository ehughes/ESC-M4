; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_partial_opt_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_partial_opt_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_conv_partial_opt_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_partial_opt_q15.c]
                          THUMB

                          AREA ||i.arm_conv_partial_opt_q15||, CODE, READONLY, ALIGN=1

                  arm_conv_partial_opt_q15 PROC
;;;75     
;;;76     arm_status arm_conv_partial_opt_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;77       q15_t * pSrcA,
;;;78       uint32_t srcALen,
;;;79       q15_t * pSrcB,
;;;80       uint32_t srcBLen,
;;;81       q15_t * pDst,
;;;82       uint32_t firstIndex,
;;;83       uint32_t numPoints,
;;;84       q15_t * pScratch1,
;;;85       q15_t * pScratch2)
;;;86     {
000004  b089              SUB      sp,sp,#0x24
000006  460c              MOV      r4,r1
000008  e9dd7516          LDRD     r7,r5,[sp,#0x58]
00000c  e9dd6319          LDRD     r6,r3,[sp,#0x64]
;;;87     
;;;88       q15_t *pOut = pDst;                            /* output pointer */
;;;89       q15_t *pScr1 = pScratch1;                      /* Temporary pointer for scratch1 */
;;;90       q15_t *pScr2 = pScratch2;                      /* Temporary pointer for scratch1 */
;;;91       q63_t acc0, acc1, acc2, acc3;                  /* Accumulator */
;;;92       q31_t x1, x2, x3;                              /* Temporary variables to hold state and coefficient values */
;;;93       q31_t y1, y2;                                  /* State variables */
;;;94       q15_t *pIn1;                                   /* inputA pointer */
;;;95       q15_t *pIn2;                                   /* inputB pointer */
;;;96       q15_t *px;                                     /* Intermediate inputA pointer  */
;;;97       q15_t *py;                                     /* Intermediate inputB pointer  */
;;;98       uint32_t j, k, blkCnt;                         /* loop counter */
;;;99       arm_status status;                             /* Status variable */
;;;100      uint32_t tapCnt;                               /* loop count */
;;;101    
;;;102      /* Check for range of output samples to be calculated */
;;;103      if((firstIndex + numPoints) > ((srcALen + (srcBLen - 1u))))
000010  9918              LDR      r1,[sp,#0x60]
000012  eb050c01          ADD      r12,r5,r1
000016  990c              LDR      r1,[sp,#0x30]
000018  4421              ADD      r1,r1,r4
00001a  1e49              SUBS     r1,r1,#1
00001c  458c              CMP      r12,r1
00001e  d904              BLS      |L1.42|
;;;104      {
;;;105        /* Set status as ARM_MATH_ARGUMENT_ERROR */
;;;106        status = ARM_MATH_ARGUMENT_ERROR;
000020  f04f30ff          MOV      r0,#0xffffffff
                  |L1.36|
;;;107      }
;;;108      else
;;;109      {
;;;110    
;;;111        /* The algorithm implementation is based on the lengths of the inputs. */
;;;112        /* srcB is always made to slide across srcA. */
;;;113        /* So srcBLen is always considered as shorter or equal to srcALen */
;;;114        if(srcALen >= srcBLen)
;;;115        {
;;;116          /* Initialization of inputA pointer */
;;;117          pIn1 = pSrcA;
;;;118    
;;;119          /* Initialization of inputB pointer */
;;;120          pIn2 = pSrcB;
;;;121        }
;;;122        else
;;;123        {
;;;124          /* Initialization of inputA pointer */
;;;125          pIn1 = pSrcB;
;;;126    
;;;127          /* Initialization of inputB pointer */
;;;128          pIn2 = pSrcA;
;;;129    
;;;130          /* srcBLen is always considered as shorter or equal to srcALen */
;;;131          j = srcBLen;
;;;132          srcBLen = srcALen;
;;;133          srcALen = j;
;;;134        }
;;;135    
;;;136        /* Temporary pointer for scratch2 */
;;;137        py = pScratch2;
;;;138    
;;;139        /* pointer to take end of scratch2 buffer */
;;;140        pScr2 = pScratch2 + srcBLen - 1;
;;;141    
;;;142        /* points to smaller length sequence */
;;;143        px = pIn2;
;;;144    
;;;145        /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;146        k = srcBLen >> 2u;
;;;147    
;;;148        /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;149         ** a second loop below copies for the remaining 1 to 3 samples. */
;;;150        while(k > 0u)
;;;151        {
;;;152          /* copy second buffer in reversal manner */
;;;153          *pScr2-- = *px++;
;;;154          *pScr2-- = *px++;
;;;155          *pScr2-- = *px++;
;;;156          *pScr2-- = *px++;
;;;157    
;;;158          /* Decrement the loop counter */
;;;159          k--;
;;;160        }
;;;161    
;;;162        /* If the count is not a multiple of 4, copy remaining samples here.       
;;;163         ** No loop unrolling is used. */
;;;164        k = srcBLen % 0x4u;
;;;165    
;;;166        while(k > 0u)
;;;167        {
;;;168          /* copy second buffer in reversal manner for remaining samples */
;;;169          *pScr2-- = *px++;
;;;170    
;;;171          /* Decrement the loop counter */
;;;172          k--;
;;;173        }
;;;174    
;;;175        /* Initialze temporary scratch pointer */
;;;176        pScr1 = pScratch1;
;;;177    
;;;178        /* Fill (srcBLen - 1u) zeros in scratch buffer */
;;;179        arm_fill_q15(0, pScr1, (srcBLen - 1u));
;;;180    
;;;181        /* Update temporary scratch pointer */
;;;182        pScr1 += (srcBLen - 1u);
;;;183    
;;;184        /* Copy bigger length sequence(srcALen) samples in scratch1 buffer */
;;;185    
;;;186        /* Copy (srcALen) samples in scratch buffer */
;;;187        arm_copy_q15(pIn1, pScr1, srcALen);
;;;188    
;;;189        /* Update pointers */
;;;190        pScr1 += srcALen;
;;;191    
;;;192        /* Fill (srcBLen - 1u) zeros at end of scratch buffer */
;;;193        arm_fill_q15(0, pScr1, (srcBLen - 1u));
;;;194    
;;;195        /* Update pointer */
;;;196        pScr1 += (srcBLen - 1u);
;;;197    
;;;198        /* Initialization of pIn2 pointer */
;;;199        pIn2 = py;
;;;200    
;;;201        pScratch1 += firstIndex;
;;;202    
;;;203        pOut = pDst + firstIndex;
;;;204    
;;;205        /* Actual convolution process starts here */
;;;206        blkCnt = (numPoints) >> 2;
;;;207    
;;;208        while(blkCnt > 0)
;;;209        {
;;;210          /* Initialze temporary scratch pointer as scratch1 */
;;;211          pScr1 = pScratch1;
;;;212    
;;;213          /* Clear Accumlators */
;;;214          acc0 = 0;
;;;215          acc1 = 0;
;;;216          acc2 = 0;
;;;217          acc3 = 0;
;;;218    
;;;219          /* Read two samples from scratch1 buffer */
;;;220          x1 = *__SIMD32(pScr1)++;
;;;221    
;;;222          /* Read next two samples from scratch1 buffer */
;;;223          x2 = *__SIMD32(pScr1)++;
;;;224    
;;;225          tapCnt = (srcBLen) >> 2u;
;;;226    
;;;227          while(tapCnt > 0u)
;;;228          {
;;;229    
;;;230            /* Read four samples from smaller buffer */
;;;231            y1 = _SIMD32_OFFSET(pIn2);
;;;232            y2 = _SIMD32_OFFSET(pIn2 + 2u);
;;;233    
;;;234            /* multiply and accumlate */
;;;235            acc0 = __SMLALD(x1, y1, acc0);
;;;236            acc2 = __SMLALD(x2, y1, acc2);
;;;237    
;;;238            /* pack input data */
;;;239    #ifndef ARM_MATH_BIG_ENDIAN
;;;240            x3 = __PKHBT(x2, x1, 0);
;;;241    #else
;;;242            x3 = __PKHBT(x1, x2, 0);
;;;243    #endif
;;;244    
;;;245            /* multiply and accumlate */
;;;246            acc1 = __SMLALDX(x3, y1, acc1);
;;;247    
;;;248            /* Read next two samples from scratch1 buffer */
;;;249            x1 = _SIMD32_OFFSET(pScr1);
;;;250    
;;;251            /* multiply and accumlate */
;;;252            acc0 = __SMLALD(x2, y2, acc0);
;;;253            acc2 = __SMLALD(x1, y2, acc2);
;;;254    
;;;255            /* pack input data */
;;;256    #ifndef ARM_MATH_BIG_ENDIAN
;;;257            x3 = __PKHBT(x1, x2, 0);
;;;258    #else
;;;259            x3 = __PKHBT(x2, x1, 0);
;;;260    #endif
;;;261    
;;;262            acc3 = __SMLALDX(x3, y1, acc3);
;;;263            acc1 = __SMLALDX(x3, y2, acc1);
;;;264    
;;;265            x2 = _SIMD32_OFFSET(pScr1 + 2u);
;;;266    
;;;267    #ifndef ARM_MATH_BIG_ENDIAN
;;;268            x3 = __PKHBT(x2, x1, 0);
;;;269    #else
;;;270            x3 = __PKHBT(x1, x2, 0);
;;;271    #endif
;;;272    
;;;273            acc3 = __SMLALDX(x3, y2, acc3);
;;;274    
;;;275            /* update scratch pointers */
;;;276            pIn2 += 4u;
;;;277            pScr1 += 4u;
;;;278    
;;;279    
;;;280            /* Decrement the loop counter */
;;;281            tapCnt--;
;;;282          }
;;;283    
;;;284          /* Update scratch pointer for remaining samples of smaller length sequence */
;;;285          pScr1 -= 4u;
;;;286    
;;;287          /* apply same above for remaining samples of smaller length sequence */
;;;288          tapCnt = (srcBLen) & 3u;
;;;289    
;;;290          while(tapCnt > 0u)
;;;291          {
;;;292            /* accumlate the results */
;;;293            acc0 += (*pScr1++ * *pIn2);
;;;294            acc1 += (*pScr1++ * *pIn2);
;;;295            acc2 += (*pScr1++ * *pIn2);
;;;296            acc3 += (*pScr1++ * *pIn2++);
;;;297    
;;;298            pScr1 -= 3u;
;;;299    
;;;300            /* Decrement the loop counter */
;;;301            tapCnt--;
;;;302          }
;;;303    
;;;304          blkCnt--;
;;;305    
;;;306    
;;;307          /* Store the results in the accumulators in the destination buffer. */
;;;308    
;;;309    #ifndef  ARM_MATH_BIG_ENDIAN
;;;310    
;;;311          *__SIMD32(pOut)++ =
;;;312            __PKHBT(__SSAT((acc0 >> 15), 16), __SSAT((acc1 >> 15), 16), 16);
;;;313          *__SIMD32(pOut)++ =
;;;314            __PKHBT(__SSAT((acc2 >> 15), 16), __SSAT((acc3 >> 15), 16), 16);
;;;315    
;;;316    #else
;;;317    
;;;318          *__SIMD32(pOut)++ =
;;;319            __PKHBT(__SSAT((acc1 >> 15), 16), __SSAT((acc0 >> 15), 16), 16);
;;;320          *__SIMD32(pOut)++ =
;;;321            __PKHBT(__SSAT((acc3 >> 15), 16), __SSAT((acc2 >> 15), 16), 16);
;;;322    
;;;323    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;324    
;;;325          /* Initialization of inputB pointer */
;;;326          pIn2 = py;
;;;327    
;;;328          pScratch1 += 4u;
;;;329    
;;;330        }
;;;331    
;;;332    
;;;333        blkCnt = numPoints & 0x3;
;;;334    
;;;335        /* Calculate convolution for remaining samples of Bigger length sequence */
;;;336        while(blkCnt > 0)
;;;337        {
;;;338          /* Initialze temporary scratch pointer as scratch1 */
;;;339          pScr1 = pScratch1;
;;;340    
;;;341          /* Clear Accumlators */
;;;342          acc0 = 0;
;;;343    
;;;344          tapCnt = (srcBLen) >> 1u;
;;;345    
;;;346          while(tapCnt > 0u)
;;;347          {
;;;348    
;;;349            /* Read next two samples from scratch1 buffer */
;;;350            x1 = *__SIMD32(pScr1)++;
;;;351    
;;;352            /* Read two samples from smaller buffer */
;;;353            y1 = *__SIMD32(pIn2)++;
;;;354    
;;;355            acc0 = __SMLALD(x1, y1, acc0);
;;;356    
;;;357            /* Decrement the loop counter */
;;;358            tapCnt--;
;;;359          }
;;;360    
;;;361          tapCnt = (srcBLen) & 1u;
;;;362    
;;;363          /* apply same above for remaining samples of smaller length sequence */
;;;364          while(tapCnt > 0u)
;;;365          {
;;;366    
;;;367            /* accumlate the results */
;;;368            acc0 += (*pScr1++ * *pIn2++);
;;;369    
;;;370            /* Decrement the loop counter */
;;;371            tapCnt--;
;;;372          }
;;;373    
;;;374          blkCnt--;
;;;375    
;;;376          /* Store the result in the accumulator in the destination buffer. */
;;;377          *pOut++ = (q15_t) (__SSAT((acc0 >> 15), 16));
;;;378    
;;;379          /* Initialization of inputB pointer */
;;;380          pIn2 = py;
;;;381    
;;;382          pScratch1 += 1u;
;;;383    
;;;384        }
;;;385    
;;;386        /* set status as ARM_MATH_SUCCESS */
;;;387        status = ARM_MATH_SUCCESS;
;;;388    
;;;389      }
;;;390    
;;;391      /* Return to application */
;;;392      return (status);
;;;393    }
000024  b00d              ADD      sp,sp,#0x34
000026  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.42|
00002a  990c              LDR      r1,[sp,#0x30]         ;114
00002c  428c              CMP      r4,r1                 ;114
00002e  d302              BCC      |L1.54|
000030  4680              MOV      r8,r0                 ;117
000032  4610              MOV      r0,r2                 ;120
000034  e003              B        |L1.62|
                  |L1.54|
000036  4690              MOV      r8,r2                 ;125
000038  990c              LDR      r1,[sp,#0x30]         ;131
00003a  940c              STR      r4,[sp,#0x30]         ;132
00003c  460c              MOV      r4,r1                 ;133
                  |L1.62|
00003e  9303              STR      r3,[sp,#0xc]          ;137
000040  990c              LDR      r1,[sp,#0x30]         ;140
000042  eb030241          ADD      r2,r3,r1,LSL #1       ;140
000046  1e92              SUBS     r2,r2,#2              ;140
000048  990c              LDR      r1,[sp,#0x30]         ;146
00004a  0889              LSRS     r1,r1,#2              ;146
00004c  9108              STR      r1,[sp,#0x20]         ;146
00004e  e00b              B        |L1.104|
                  |L1.80|
000050  1f92              SUBS     r2,r2,#6              ;153
000052  8803              LDRH     r3,[r0,#0]            ;153
000054  80d3              STRH     r3,[r2,#6]            ;153
000056  8843              LDRH     r3,[r0,#2]            ;154
000058  8093              STRH     r3,[r2,#4]            ;154
00005a  8883              LDRH     r3,[r0,#4]            ;155
00005c  8053              STRH     r3,[r2,#2]            ;155
00005e  88c3              LDRH     r3,[r0,#6]            ;156
000060  3008              ADDS     r0,r0,#8              ;156
000062  f8223902          STRH     r3,[r2],#-2           ;156
000066  1e49              SUBS     r1,r1,#1              ;159
                  |L1.104|
000068  2900              CMP      r1,#0                 ;150
00006a  d1f1              BNE      |L1.80|
00006c  990c              LDR      r1,[sp,#0x30]         ;164
00006e  f0010103          AND      r1,r1,#3              ;164
000072  9107              STR      r1,[sp,#0x1c]         ;164
000074  e004              B        |L1.128|
                  |L1.118|
000076  f8303b02          LDRH     r3,[r0],#2            ;169
00007a  f8223902          STRH     r3,[r2],#-2           ;169
00007e  1e49              SUBS     r1,r1,#1              ;172
                  |L1.128|
000080  2900              CMP      r1,#0                 ;166
000082  d1f8              BNE      |L1.118|
000084  9a0c              LDR      r2,[sp,#0x30]         ;179
000086  4631              MOV      r1,r6                 ;179
000088  1e52              SUBS     r2,r2,#1              ;179
00008a  2000              MOVS     r0,#0                 ;179
00008c  f7fffffe          BL       arm_fill_q15
000090  980c              LDR      r0,[sp,#0x30]         ;182
000092  1e40              SUBS     r0,r0,#1              ;182
000094  eb060940          ADD      r9,r6,r0,LSL #1       ;182
000098  4622              MOV      r2,r4                 ;187
00009a  4649              MOV      r1,r9                 ;187
00009c  4640              MOV      r0,r8                 ;187
00009e  f7fffffe          BL       arm_copy_q15
0000a2  eb090144          ADD      r1,r9,r4,LSL #1       ;190
0000a6  9a0c              LDR      r2,[sp,#0x30]         ;193
0000a8  2000              MOVS     r0,#0                 ;193
0000aa  1e52              SUBS     r2,r2,#1              ;193
0000ac  f7fffffe          BL       arm_fill_q15
0000b0  f8ddc00c          LDR      r12,[sp,#0xc]         ;199
0000b4  eb060045          ADD      r0,r6,r5,LSL #1       ;201
0000b8  9019              STR      r0,[sp,#0x64]         ;201
0000ba  eb070045          ADD      r0,r7,r5,LSL #1       ;203
0000be  9004              STR      r0,[sp,#0x10]         ;203
0000c0  9818              LDR      r0,[sp,#0x60]         ;206
0000c2  0880              LSRS     r0,r0,#2              ;206
0000c4  9002              STR      r0,[sp,#8]            ;206
0000c6  e098              B        |L1.506|
                  |L1.200|
0000c8  f8dda064          LDR      r10,[sp,#0x64]        ;211
0000cc  2000              MOVS     r0,#0                 ;214
0000ce  4601              MOV      r1,r0                 ;214
0000d0  2200              MOVS     r2,#0                 ;215
0000d2  4613              MOV      r3,r2                 ;215
0000d4  2400              MOVS     r4,#0                 ;216
0000d6  4625              MOV      r5,r4                 ;216
0000d8  2600              MOVS     r6,#0                 ;217
0000da  4637              MOV      r7,r6                 ;217
0000dc  f85a9b04          LDR      r9,[r10],#4           ;220
0000e0  f85a8b04          LDR      r8,[r10],#4           ;223
0000e4  f8ddb020          LDR      r11,[sp,#0x20]        ;225
0000e8  f8cdb004          STR      r11,[sp,#4]           ;225
0000ec  e033              B        |L1.342|
                  |L1.238|
0000ee  f8dcb000          LDR      r11,[r12,#0]          ;231
0000f2  f8dce004          LDR      lr,[r12,#4]           ;232
0000f6  f8cde018          STR      lr,[sp,#0x18]         ;232
0000fa  fbc901cb          SMLALD   r0,r1,r9,r11          ;235
0000fe  fbc845cb          SMLALD   r4,r5,r8,r11          ;236
000102  eac80909          PKHBT    r9,r8,r9              ;240
000106  fbc923db          SMLALDX  r2,r3,r9,r11          ;246
00010a  f8da9000          LDR      r9,[r10,#0]           ;249
00010e  f8cd9014          STR      r9,[sp,#0x14]         ;249
000112  f8dde018          LDR      lr,[sp,#0x18]         ;252
000116  fbc801ce          SMLALD   r0,r1,r8,lr           ;252
00011a  e9dd9e05          LDRD     r9,lr,[sp,#0x14]      ;253
00011e  fbc945ce          SMLALD   r4,r5,r9,lr           ;253
000122  eac90808          PKHBT    r8,r9,r8              ;257
000126  fbc867db          SMLALDX  r6,r7,r8,r11          ;262
00012a  f8dde018          LDR      lr,[sp,#0x18]         ;263
00012e  fbc823de          SMLALDX  r2,r3,r8,lr           ;263
000132  f8da8004          LDR      r8,[r10,#4]           ;265
000136  eac80b09          PKHBT    r11,r8,r9             ;268
00013a  f8dde018          LDR      lr,[sp,#0x18]         ;273
00013e  fbcb67de          SMLALDX  r6,r7,r11,lr          ;273
000142  f10c0c08          ADD      r12,r12,#8            ;276
000146  f10a0a08          ADD      r10,r10,#8            ;277
00014a  f8ddb004          LDR      r11,[sp,#4]           ;281
00014e  f1ab0b01          SUB      r11,r11,#1            ;281
000152  f8cdb004          STR      r11,[sp,#4]           ;281
                  |L1.342|
000156  f8ddb004          LDR      r11,[sp,#4]           ;227
00015a  f1bb0f00          CMP      r11,#0                ;227
00015e  d1c6              BNE      |L1.238|
000160  f1aa0a08          SUB      r10,r10,#8            ;285
000164  f8dd901c          LDR      r9,[sp,#0x1c]         ;288
000168  e01b              B        |L1.418|
                  |L1.362|
00016a  468e              MOV      lr,r1                 ;293
00016c  f93a1b02          LDRSH    r1,[r10],#2           ;293
000170  f9bc8000          LDRSH    r8,[r12,#0]           ;293
000174  fbc10e88          SMLALBB  r0,lr,r1,r8           ;293
000178  4671              MOV      r1,lr                 ;293
00017a  469e              MOV      lr,r3                 ;294
00017c  f93a3b02          LDRSH    r3,[r10],#2           ;294
000180  fbc32e88          SMLALBB  r2,lr,r3,r8           ;294
000184  4673              MOV      r3,lr                 ;294
000186  f93aeb02          LDRSH    lr,[r10],#2           ;295
00018a  fbce4588          SMLALBB  r4,r5,lr,r8           ;295
00018e  f9bae000          LDRSH    lr,[r10,#0]           ;296
000192  f10c0c02          ADD      r12,r12,#2            ;296
000196  fbce6788          SMLALBB  r6,r7,lr,r8           ;296
00019a  f1aa0a04          SUB      r10,r10,#4            ;298
00019e  f1a90901          SUB      r9,r9,#1              ;301
                  |L1.418|
0001a2  f1b90f00          CMP      r9,#0                 ;290
0001a6  d1e0              BNE      |L1.362|
0001a8  f8ddc008          LDR      r12,[sp,#8]           ;304
0001ac  f1ac0c01          SUB      r12,r12,#1            ;304
0001b0  f8cdc008          STR      r12,[sp,#8]           ;304
0001b4  0bc0              LSRS     r0,r0,#15             ;311
0001b6  ea404041          ORR      r0,r0,r1,LSL #17      ;311
0001ba  f300010f          SSAT     r1,#16,r0             ;311
0001be  0bd0              LSRS     r0,r2,#15             ;311
0001c0  ea404043          ORR      r0,r0,r3,LSL #17      ;311
0001c4  f300000f          SSAT     r0,#16,r0             ;311
0001c8  eac14100          PKHBT    r1,r1,r0,LSL #16      ;311
0001cc  9804              LDR      r0,[sp,#0x10]         ;311
0001ce  6001              STR      r1,[r0,#0]            ;311
0001d0  9804              LDR      r0,[sp,#0x10]         ;311
0001d2  0be1              LSRS     r1,r4,#15             ;313
0001d4  ea414145          ORR      r1,r1,r5,LSL #17      ;313
0001d8  f301020f          SSAT     r2,#16,r1             ;313
0001dc  0bf1              LSRS     r1,r6,#15             ;313
0001de  ea414147          ORR      r1,r1,r7,LSL #17      ;313
0001e2  f301010f          SSAT     r1,#16,r1             ;313
0001e6  eac24101          PKHBT    r1,r2,r1,LSL #16      ;313
0001ea  6041              STR      r1,[r0,#4]            ;313
0001ec  3008              ADDS     r0,r0,#8              ;313
0001ee  9004              STR      r0,[sp,#0x10]         ;313
0001f0  f8ddc00c          LDR      r12,[sp,#0xc]         ;326
0001f4  9819              LDR      r0,[sp,#0x64]         ;328
0001f6  3008              ADDS     r0,r0,#8              ;328
0001f8  9019              STR      r0,[sp,#0x64]         ;328
                  |L1.506|
0001fa  9802              LDR      r0,[sp,#8]            ;208
0001fc  2800              CMP      r0,#0                 ;208
0001fe  f47faf63          BNE      |L1.200|
000202  9818              LDR      r0,[sp,#0x60]         ;333
000204  f0000403          AND      r4,r0,#3              ;333
000208  e02b              B        |L1.610|
                  |L1.522|
00020a  9a19              LDR      r2,[sp,#0x64]         ;339
00020c  2000              MOVS     r0,#0                 ;342
00020e  4601              MOV      r1,r0                 ;342
000210  9b0c              LDR      r3,[sp,#0x30]         ;344
000212  085b              LSRS     r3,r3,#1              ;344
000214  e006              B        |L1.548|
                  |L1.534|
000216  f8526b04          LDR      r6,[r2],#4            ;350
00021a  f85c5b04          LDR      r5,[r12],#4           ;353
00021e  fbc601c5          SMLALD   r0,r1,r6,r5           ;355
000222  1e5b              SUBS     r3,r3,#1              ;358
                  |L1.548|
000224  2b00              CMP      r3,#0                 ;346
000226  d1f6              BNE      |L1.534|
000228  9b0c              LDR      r3,[sp,#0x30]         ;361
00022a  f0030301          AND      r3,r3,#1              ;361
00022e  e006              B        |L1.574|
                  |L1.560|
000230  f9326b02          LDRSH    r6,[r2],#2            ;368
000234  f93c5b02          LDRSH    r5,[r12],#2           ;368
000238  fbc60185          SMLALBB  r0,r1,r6,r5           ;368
00023c  1e5b              SUBS     r3,r3,#1              ;371
                  |L1.574|
00023e  2b00              CMP      r3,#0                 ;364
000240  d1f6              BNE      |L1.560|
000242  1e64              SUBS     r4,r4,#1              ;374
000244  0bc0              LSRS     r0,r0,#15             ;377
000246  ea404041          ORR      r0,r0,r1,LSL #17      ;377
00024a  f300010f          SSAT     r1,#16,r0             ;377
00024e  9804              LDR      r0,[sp,#0x10]         ;377
000250  8001              STRH     r1,[r0,#0]            ;377
000252  9804              LDR      r0,[sp,#0x10]         ;377
000254  1c80              ADDS     r0,r0,#2              ;377
000256  9004              STR      r0,[sp,#0x10]         ;377
000258  f8ddc00c          LDR      r12,[sp,#0xc]         ;380
00025c  9819              LDR      r0,[sp,#0x64]         ;382
00025e  1c80              ADDS     r0,r0,#2              ;382
000260  9019              STR      r0,[sp,#0x64]         ;382
                  |L1.610|
000262  2c00              CMP      r4,#0                 ;336
000264  d1d1              BNE      |L1.522|
000266  2000              MOVS     r0,#0                 ;387
000268  e6dc              B        |L1.36|
;;;394    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_partial_opt_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___26_arm_conv_partial_opt_q15_c_64ffdcb5____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___26_arm_conv_partial_opt_q15_c_64ffdcb5____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___26_arm_conv_partial_opt_q15_c_64ffdcb5____REVSH|
#line 144
|__asm___26_arm_conv_partial_opt_q15_c_64ffdcb5____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___26_arm_conv_partial_opt_q15_c_64ffdcb5____RRX|
#line 300
|__asm___26_arm_conv_partial_opt_q15_c_64ffdcb5____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
