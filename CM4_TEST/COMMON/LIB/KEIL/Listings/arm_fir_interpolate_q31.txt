; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_interpolate_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_interpolate_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_fir_interpolate_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_fir_interpolate_q31.c]
                          THUMB

                          AREA ||i.arm_fir_interpolate_q31||, CODE, READONLY, ALIGN=1

                  arm_fir_interpolate_q31 PROC
;;;73     
;;;74     void arm_fir_interpolate_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;75       const arm_fir_interpolate_instance_q31 * S,
;;;76       q31_t * pSrc,
;;;77       q31_t * pDst,
;;;78       uint32_t blockSize)
;;;79     {
000004  b089              SUB      sp,sp,#0x24
;;;80       q31_t *pState = S->pState;                     /* State pointer */
000006  6887              LDR      r7,[r0,#8]
;;;81       q31_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
000008  6841              LDR      r1,[r0,#4]
00000a  9107              STR      r1,[sp,#0x1c]
;;;82       q31_t *pStateCurnt;                            /* Points to the current sample of the state */
;;;83       q31_t *ptr1, *ptr2;                            /* Temporary pointers for state and coefficient buffers */
;;;84       q63_t sum0;                                    /* Accumulators */
;;;85       q31_t x0, c0;                                  /* Temporary variables to hold state and coefficient values */
;;;86       uint32_t i, blkCnt, j;                         /* Loop counters */
;;;87       uint16_t phaseLen = S->phaseLength, tapCnt;    /* Length of each polyphase filter component */
00000c  8841              LDRH     r1,[r0,#2]
00000e  9101              STR      r1,[sp,#4]
;;;88     
;;;89       uint32_t blkCntN2;
;;;90       q63_t acc0, acc1;
;;;91       q31_t x1;
;;;92     
;;;93       /* S->pState buffer contains previous frame (phaseLen - 1) samples */
;;;94       /* pStateCurnt points to the location where the new input data should be written */
;;;95       pStateCurnt = S->pState + ((q31_t) phaseLen - 1);
000010  9901              LDR      r1,[sp,#4]
000012  1e49              SUBS     r1,r1,#1
000014  9108              STR      r1,[sp,#0x20]
000016  eb070181          ADD      r1,r7,r1,LSL #2
00001a  9106              STR      r1,[sp,#0x18]
;;;96     
;;;97       /* Initialise  blkCnt */
;;;98       blkCnt = blockSize / 2;
00001c  0859              LSRS     r1,r3,#1
00001e  9103              STR      r1,[sp,#0xc]
;;;99       blkCntN2 = blockSize - (2 * blkCnt);
000020  9903              LDR      r1,[sp,#0xc]
000022  4249              RSBS     r1,r1,#0
000024  eb030141          ADD      r1,r3,r1,LSL #1
000028  9100              STR      r1,[sp,#0]
00002a  e088              B        |L1.318|
                  |L1.44|
;;;100    
;;;101      /* Samples loop unrolled by 2 */
;;;102      while(blkCnt > 0u)
;;;103      {
;;;104        /* Copy new input sample into the state buffer */
;;;105        *pStateCurnt++ = *pSrc++;
00002c  990a              LDR      r1,[sp,#0x28]
00002e  680b              LDR      r3,[r1,#0]
000030  9906              LDR      r1,[sp,#0x18]
000032  600b              STR      r3,[r1,#0]
000034  9b06              LDR      r3,[sp,#0x18]
000036  990a              LDR      r1,[sp,#0x28]
;;;106        *pStateCurnt++ = *pSrc++;
000038  684c              LDR      r4,[r1,#4]
00003a  3108              ADDS     r1,r1,#8
00003c  605c              STR      r4,[r3,#4]
00003e  3308              ADDS     r3,r3,#8
000040  9306              STR      r3,[sp,#0x18]
000042  910a              STR      r1,[sp,#0x28]
;;;107    
;;;108        /* Address modifier index of coefficient buffer */
;;;109        j = 1u;
000044  2101              MOVS     r1,#1
000046  9102              STR      r1,[sp,#8]
;;;110    
;;;111        /* Loop over the Interpolation factor. */
;;;112        i = (S->L);
000048  7801              LDRB     r1,[r0,#0]
00004a  9104              STR      r1,[sp,#0x10]
;;;113    
;;;114        while(i > 0u)
00004c  e06d              B        |L1.298|
                  |L1.78|
;;;115        {
;;;116          /* Set accumulator to zero */
;;;117          acc0 = 0;
00004e  2300              MOVS     r3,#0
000050  461c              MOV      r4,r3
;;;118          acc1 = 0;
000052  2500              MOVS     r5,#0
000054  462e              MOV      r6,r5
;;;119    
;;;120          /* Initialize state pointer */
;;;121          ptr1 = pState;
;;;122    
;;;123          /* Initialize coefficient pointer */
;;;124          ptr2 = pCoeffs + (S->L - j);
000056  f8908000          LDRB     r8,[r0,#0]
00005a  9902              LDR      r1,[sp,#8]
00005c  eba80c01          SUB      r12,r8,r1
000060  9907              LDR      r1,[sp,#0x1c]
000062  eb01018c          ADD      r1,r1,r12,LSL #2
;;;125    
;;;126          /* Loop over the polyPhase length. Unroll by a factor of 4.        
;;;127           ** Repeat until we've computed numTaps-(4*S->L) coefficients. */
;;;128          tapCnt = phaseLen >> 2u;
000066  f8ddc004          LDR      r12,[sp,#4]
00006a  ea4f099c          LSR      r9,r12,#2
;;;129    
;;;130          x0 = *(ptr1++);
00006e  f1070c04          ADD      r12,r7,#4
000072  f8d7b000          LDR      r11,[r7,#0]
;;;131    
;;;132          while(tapCnt > 0u)
000076  e02d              B        |L1.212|
                  |L1.120|
;;;133          {
;;;134    
;;;135            /* Read the input sample */
;;;136            x1 = *(ptr1++);
000078  f8dca000          LDR      r10,[r12,#0]
00007c  f10c0e04          ADD      lr,r12,#4
;;;137    
;;;138            /* Read the coefficient */
;;;139            c0 = *(ptr2);
000080  f8d1c000          LDR      r12,[r1,#0]
;;;140    
;;;141            /* Perform the multiply-accumulate */
;;;142            acc0 += (q63_t) x0 *c0;
000084  fbcb340c          SMLAL    r3,r4,r11,r12
;;;143            acc1 += (q63_t) x1 *c0;
000088  fbca560c          SMLAL    r5,r6,r10,r12
;;;144    
;;;145    
;;;146            /* Read the coefficient */
;;;147            c0 = *(ptr2 + S->L);
00008c  f851b028          LDR      r11,[r1,r8,LSL #2]
;;;148    
;;;149            /* Read the input sample */
;;;150            x0 = *(ptr1++);
000090  f85ecb04          LDR      r12,[lr],#4
;;;151    
;;;152            /* Perform the multiply-accumulate */
;;;153            acc0 += (q63_t) x1 *c0;
000094  fbca340b          SMLAL    r3,r4,r10,r11
;;;154            acc1 += (q63_t) x0 *c0;
000098  fbcc560b          SMLAL    r5,r6,r12,r11
;;;155    
;;;156    
;;;157            /* Read the coefficient */
;;;158            c0 = *(ptr2 + S->L * 2);
00009c  f851b038          LDR      r11,[r1,r8,LSL #3]
;;;159    
;;;160            /* Read the input sample */
;;;161            x1 = *(ptr1++);
0000a0  f85eab04          LDR      r10,[lr],#4
0000a4  f8cde014          STR      lr,[sp,#0x14]
;;;162    
;;;163            /* Perform the multiply-accumulate */
;;;164            acc0 += (q63_t) x0 *c0;
0000a8  fbcc340b          SMLAL    r3,r4,r12,r11
;;;165            acc1 += (q63_t) x1 *c0;
0000ac  fbca560b          SMLAL    r5,r6,r10,r11
;;;166    
;;;167            /* Read the coefficient */
;;;168            c0 = *(ptr2 + S->L * 3);
0000b0  eb080c48          ADD      r12,r8,r8,LSL #1
0000b4  f851e02c          LDR      lr,[r1,r12,LSL #2]
;;;169    
;;;170            /* Read the input sample */
;;;171            x0 = *(ptr1++);
0000b8  f8ddc014          LDR      r12,[sp,#0x14]
0000bc  f85cbb04          LDR      r11,[r12],#4
;;;172    
;;;173            /* Perform the multiply-accumulate */
;;;174            acc0 += (q63_t) x1 *c0;
0000c0  fbca340e          SMLAL    r3,r4,r10,lr
;;;175            acc1 += (q63_t) x0 *c0;
0000c4  fbcb560e          SMLAL    r5,r6,r11,lr
;;;176    
;;;177    
;;;178            /* Upsampling is done by stuffing L-1 zeros between each sample.        
;;;179             * So instead of multiplying zeros with coefficients,        
;;;180             * Increment the coefficient pointer by interpolation factor times. */
;;;181            ptr2 += 4 * S->L;
0000c8  eb011108          ADD      r1,r1,r8,LSL #4
;;;182    
;;;183            /* Decrement the loop counter */
;;;184            tapCnt--;
0000cc  f1a90901          SUB      r9,r9,#1
0000d0  fa1ff989          UXTH     r9,r9
                  |L1.212|
0000d4  f1b90f00          CMP      r9,#0                 ;132
0000d8  d1ce              BNE      |L1.120|
;;;185          }
;;;186    
;;;187          /* If the polyPhase length is not a multiple of 4, compute the remaining filter taps */
;;;188          tapCnt = phaseLen % 0x4u;
0000da  f8dd9004          LDR      r9,[sp,#4]
0000de  f0090903          AND      r9,r9,#3
;;;189    
;;;190          while(tapCnt > 0u)
0000e2  e00e              B        |L1.258|
                  |L1.228|
;;;191          {
;;;192    
;;;193            /* Read the input sample */
;;;194            x1 = *(ptr1++);
0000e4  f85cab04          LDR      r10,[r12],#4
;;;195    
;;;196            /* Read the coefficient */
;;;197            c0 = *(ptr2);
0000e8  f8d1e000          LDR      lr,[r1,#0]
;;;198    
;;;199            /* Perform the multiply-accumulate */
;;;200            acc0 += (q63_t) x0 *c0;
0000ec  fbcb340e          SMLAL    r3,r4,r11,lr
;;;201            acc1 += (q63_t) x1 *c0;
0000f0  fbca560e          SMLAL    r5,r6,r10,lr
;;;202    
;;;203            /* Increment the coefficient pointer by interpolation factor times. */
;;;204            ptr2 += S->L;
0000f4  eb010188          ADD      r1,r1,r8,LSL #2
;;;205    
;;;206            /* update states for next sample processing */
;;;207            x0 = x1;
0000f8  46d3              MOV      r11,r10
;;;208    
;;;209            /* Decrement the loop counter */
;;;210            tapCnt--;
0000fa  f1a90901          SUB      r9,r9,#1
0000fe  fa1ff989          UXTH     r9,r9
                  |L1.258|
000102  f1b90f00          CMP      r9,#0                 ;190
000106  d1ed              BNE      |L1.228|
;;;211          }
;;;212    
;;;213          /* The result is in the accumulator, store in the destination buffer. */
;;;214          *pDst = (q31_t) (acc0 >> 31);
000108  0fd9              LSRS     r1,r3,#31
00010a  ea410144          ORR      r1,r1,r4,LSL #1
00010e  6011              STR      r1,[r2,#0]
;;;215          *(pDst + S->L) = (q31_t) (acc1 >> 31);
000110  7803              LDRB     r3,[r0,#0]
000112  0fe9              LSRS     r1,r5,#31
000114  ea410146          ORR      r1,r1,r6,LSL #1
000118  f8421023          STR      r1,[r2,r3,LSL #2]
;;;216    
;;;217    
;;;218          pDst++;
00011c  1d12              ADDS     r2,r2,#4
;;;219    
;;;220          /* Increment the address modifier index of coefficient buffer */
;;;221          j++;
00011e  9902              LDR      r1,[sp,#8]
000120  1c49              ADDS     r1,r1,#1
000122  9102              STR      r1,[sp,#8]
;;;222    
;;;223          /* Decrement the loop counter */
;;;224          i--;
000124  9904              LDR      r1,[sp,#0x10]
000126  1e49              SUBS     r1,r1,#1
000128  9104              STR      r1,[sp,#0x10]
                  |L1.298|
00012a  9904              LDR      r1,[sp,#0x10]         ;114
00012c  2900              CMP      r1,#0                 ;114
00012e  d18e              BNE      |L1.78|
;;;225        }
;;;226    
;;;227        /* Advance the state pointer by 1        
;;;228         * to process the next group of interpolation factor number samples */
;;;229        pState = pState + 2;
000130  3708              ADDS     r7,r7,#8
;;;230    
;;;231        pDst += S->L;
000132  7801              LDRB     r1,[r0,#0]
000134  eb020281          ADD      r2,r2,r1,LSL #2
;;;232    
;;;233        /* Decrement the loop counter */
;;;234        blkCnt--;
000138  9903              LDR      r1,[sp,#0xc]
00013a  1e49              SUBS     r1,r1,#1
00013c  9103              STR      r1,[sp,#0xc]
                  |L1.318|
00013e  9903              LDR      r1,[sp,#0xc]          ;102
000140  2900              CMP      r1,#0                 ;102
000142  f47faf73          BNE      |L1.44|
;;;235      }
;;;236    
;;;237      /* If the blockSize is not a multiple of 2, compute any remaining output samples here.        
;;;238       ** No loop unrolling is used. */
;;;239      blkCnt = blkCntN2;
000146  f8dde000          LDR      lr,[sp,#0]
;;;240    
;;;241      /* Loop over the blockSize. */
;;;242      while(blkCnt > 0u)
00014a  e065              B        |L1.536|
                  |L1.332|
;;;243      {
;;;244        /* Copy new input sample into the state buffer */
;;;245        *pStateCurnt++ = *pSrc++;
00014c  990a              LDR      r1,[sp,#0x28]
00014e  680b              LDR      r3,[r1,#0]
000150  9906              LDR      r1,[sp,#0x18]
000152  600b              STR      r3,[r1,#0]
000154  990a              LDR      r1,[sp,#0x28]
000156  1d09              ADDS     r1,r1,#4
000158  910a              STR      r1,[sp,#0x28]
00015a  9906              LDR      r1,[sp,#0x18]
00015c  1d09              ADDS     r1,r1,#4
00015e  9106              STR      r1,[sp,#0x18]
;;;246    
;;;247        /* Address modifier index of coefficient buffer */
;;;248        j = 1u;
000160  f04f0901          MOV      r9,#1
;;;249    
;;;250        /* Loop over the Interpolation factor. */
;;;251        i = S->L;
000164  f8908000          LDRB     r8,[r0,#0]
;;;252        while(i > 0u)
000168  e050              B        |L1.524|
                  |L1.362|
;;;253        {
;;;254          /* Set accumulator to zero */
;;;255          sum0 = 0;
00016a  2300              MOVS     r3,#0
00016c  461c              MOV      r4,r3
;;;256    
;;;257          /* Initialize state pointer */
;;;258          ptr1 = pState;
00016e  4639              MOV      r1,r7
;;;259    
;;;260          /* Initialize coefficient pointer */
;;;261          ptr2 = pCoeffs + (S->L - j);
000170  7806              LDRB     r6,[r0,#0]
000172  9d07              LDR      r5,[sp,#0x1c]
000174  eba60c09          SUB      r12,r6,r9
000178  eb05058c          ADD      r5,r5,r12,LSL #2
;;;262    
;;;263          /* Loop over the polyPhase length. Unroll by a factor of 4.        
;;;264           ** Repeat until we've computed numTaps-(4*S->L) coefficients. */
;;;265          tapCnt = phaseLen >> 2;
00017c  f8ddc004          LDR      r12,[sp,#4]
000180  ea4f0c9c          LSR      r12,r12,#2
;;;266          while(tapCnt > 0u)
000184  e023              B        |L1.462|
                  |L1.390|
;;;267          {
;;;268    
;;;269            /* Read the coefficient */
;;;270            c0 = *(ptr2);
000186  f8d5a000          LDR      r10,[r5,#0]
;;;271    
;;;272            /* Upsampling is done by stuffing L-1 zeros between each sample.        
;;;273             * So instead of multiplying zeros with coefficients,        
;;;274             * Increment the coefficient pointer by interpolation factor times. */
;;;275            ptr2 += S->L;
00018a  eb050586          ADD      r5,r5,r6,LSL #2
;;;276    
;;;277            /* Read the input sample */
;;;278            x0 = *(ptr1++);
00018e  f851bb04          LDR      r11,[r1],#4
;;;279    
;;;280            /* Perform the multiply-accumulate */
;;;281            sum0 += (q63_t) x0 *c0;
000192  fbcb340a          SMLAL    r3,r4,r11,r10
;;;282    
;;;283            /* Read the coefficient */
;;;284            c0 = *(ptr2);
000196  f8d5a000          LDR      r10,[r5,#0]
;;;285    
;;;286            /* Increment the coefficient pointer by interpolation factor times. */
;;;287            ptr2 += S->L;
00019a  eb050586          ADD      r5,r5,r6,LSL #2
;;;288    
;;;289            /* Read the input sample */
;;;290            x0 = *(ptr1++);
00019e  f851bb04          LDR      r11,[r1],#4
;;;291    
;;;292            /* Perform the multiply-accumulate */
;;;293            sum0 += (q63_t) x0 *c0;
0001a2  fbcb340a          SMLAL    r3,r4,r11,r10
;;;294    
;;;295            /* Read the coefficient */
;;;296            c0 = *(ptr2);
0001a6  f8d5a000          LDR      r10,[r5,#0]
;;;297    
;;;298            /* Increment the coefficient pointer by interpolation factor times. */
;;;299            ptr2 += S->L;
0001aa  eb050586          ADD      r5,r5,r6,LSL #2
;;;300    
;;;301            /* Read the input sample */
;;;302            x0 = *(ptr1++);
0001ae  f851bb04          LDR      r11,[r1],#4
;;;303    
;;;304            /* Perform the multiply-accumulate */
;;;305            sum0 += (q63_t) x0 *c0;
0001b2  fbcb340a          SMLAL    r3,r4,r11,r10
;;;306    
;;;307            /* Read the coefficient */
;;;308            c0 = *(ptr2);
0001b6  f8d5b000          LDR      r11,[r5,#0]
;;;309    
;;;310            /* Increment the coefficient pointer by interpolation factor times. */
;;;311            ptr2 += S->L;
0001ba  eb050586          ADD      r5,r5,r6,LSL #2
;;;312    
;;;313            /* Read the input sample */
;;;314            x0 = *(ptr1++);
0001be  f851ab04          LDR      r10,[r1],#4
;;;315    
;;;316            /* Perform the multiply-accumulate */
;;;317            sum0 += (q63_t) x0 *c0;
0001c2  fbca340b          SMLAL    r3,r4,r10,r11
;;;318    
;;;319            /* Decrement the loop counter */
;;;320            tapCnt--;
0001c6  f1ac0c01          SUB      r12,r12,#1
0001ca  fa1ffc8c          UXTH     r12,r12
                  |L1.462|
0001ce  f1bc0f00          CMP      r12,#0                ;266
0001d2  d1d8              BNE      |L1.390|
;;;321          }
;;;322    
;;;323          /* If the polyPhase length is not a multiple of 4, compute the remaining filter taps */
;;;324          tapCnt = phaseLen & 0x3u;
0001d4  f8ddc004          LDR      r12,[sp,#4]
0001d8  f00c0c03          AND      r12,r12,#3
;;;325    
;;;326          while(tapCnt > 0u)
0001dc  e00b              B        |L1.502|
                  |L1.478|
;;;327          {
;;;328            /* Read the coefficient */
;;;329            c0 = *(ptr2);
0001de  f8d5b000          LDR      r11,[r5,#0]
;;;330    
;;;331            /* Increment the coefficient pointer by interpolation factor times. */
;;;332            ptr2 += S->L;
0001e2  eb050586          ADD      r5,r5,r6,LSL #2
;;;333    
;;;334            /* Read the input sample */
;;;335            x0 = *(ptr1++);
0001e6  f851ab04          LDR      r10,[r1],#4
;;;336    
;;;337            /* Perform the multiply-accumulate */
;;;338            sum0 += (q63_t) x0 *c0;
0001ea  fbca340b          SMLAL    r3,r4,r10,r11
;;;339    
;;;340            /* Decrement the loop counter */
;;;341            tapCnt--;
0001ee  f1ac0c01          SUB      r12,r12,#1
0001f2  fa1ffc8c          UXTH     r12,r12
                  |L1.502|
0001f6  f1bc0f00          CMP      r12,#0                ;326
0001fa  d1f0              BNE      |L1.478|
;;;342          }
;;;343    
;;;344          /* The result is in the accumulator, store in the destination buffer. */
;;;345          *pDst++ = (q31_t) (sum0 >> 31);
0001fc  0fd9              LSRS     r1,r3,#31
0001fe  ea410144          ORR      r1,r1,r4,LSL #1
000202  c202              STM      r2!,{r1}
;;;346    
;;;347          /* Increment the address modifier index of coefficient buffer */
;;;348          j++;
000204  f1090901          ADD      r9,r9,#1
;;;349    
;;;350          /* Decrement the loop counter */
;;;351          i--;
000208  f1a80801          SUB      r8,r8,#1
                  |L1.524|
00020c  f1b80f00          CMP      r8,#0                 ;252
000210  d1ab              BNE      |L1.362|
;;;352        }
;;;353    
;;;354        /* Advance the state pointer by 1        
;;;355         * to process the next group of interpolation factor number samples */
;;;356        pState = pState + 1;
000212  1d3f              ADDS     r7,r7,#4
;;;357    
;;;358        /* Decrement the loop counter */
;;;359        blkCnt--;
000214  f1ae0e01          SUB      lr,lr,#1
                  |L1.536|
000218  ea5f010e          MOVS     r1,lr                 ;242
00021c  d196              BNE      |L1.332|
;;;360      }
;;;361    
;;;362      /* Processing is complete.        
;;;363       ** Now copy the last phaseLen - 1 samples to the satrt of the state buffer.        
;;;364       ** This prepares the state buffer for the next function call. */
;;;365    
;;;366      /* Points to the start of the state buffer */
;;;367      pStateCurnt = S->pState;
00021e  6880              LDR      r0,[r0,#8]
;;;368    
;;;369      tapCnt = (phaseLen - 1u) >> 2u;
000220  9908              LDR      r1,[sp,#0x20]
000222  f3c1018f          UBFX     r1,r1,#2,#16
;;;370    
;;;371      /* copy data */
;;;372      while(tapCnt > 0u)
000226  e00b              B        |L1.576|
                  |L1.552|
;;;373      {
;;;374        *pStateCurnt++ = *pState++;
000228  683a              LDR      r2,[r7,#0]
00022a  6002              STR      r2,[r0,#0]
;;;375        *pStateCurnt++ = *pState++;
00022c  687a              LDR      r2,[r7,#4]
00022e  6042              STR      r2,[r0,#4]
;;;376        *pStateCurnt++ = *pState++;
000230  68ba              LDR      r2,[r7,#8]
000232  6082              STR      r2,[r0,#8]
;;;377        *pStateCurnt++ = *pState++;
000234  68fa              LDR      r2,[r7,#0xc]
000236  3710              ADDS     r7,r7,#0x10
000238  60c2              STR      r2,[r0,#0xc]
00023a  3010              ADDS     r0,r0,#0x10
;;;378    
;;;379        /* Decrement the loop counter */
;;;380        tapCnt--;
00023c  1e49              SUBS     r1,r1,#1
00023e  b289              UXTH     r1,r1
                  |L1.576|
000240  2900              CMP      r1,#0                 ;372
000242  d1f1              BNE      |L1.552|
;;;381      }
;;;382    
;;;383      tapCnt = (phaseLen - 1u) % 0x04u;
000244  9908              LDR      r1,[sp,#0x20]
000246  f0010103          AND      r1,r1,#3
;;;384    
;;;385      /* copy data */
;;;386      while(tapCnt > 0u)
00024a  e003              B        |L1.596|
                  |L1.588|
;;;387      {
;;;388        *pStateCurnt++ = *pState++;
00024c  cf04              LDM      r7!,{r2}
00024e  c004              STM      r0!,{r2}
;;;389    
;;;390        /* Decrement the loop counter */
;;;391        tapCnt--;
000250  1e49              SUBS     r1,r1,#1
000252  b289              UXTH     r1,r1
                  |L1.596|
000254  2900              CMP      r1,#0                 ;386
000256  d1f9              BNE      |L1.588|
;;;392      }
;;;393    
;;;394    }
000258  b00d              ADD      sp,sp,#0x34
00025a  e8bd8ff0          POP      {r4-r11,pc}
;;;395    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_fir_interpolate_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_fir_interpolate_q31_c_34175ccb____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___25_arm_fir_interpolate_q31_c_34175ccb____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_fir_interpolate_q31_c_34175ccb____REVSH|
#line 144
|__asm___25_arm_fir_interpolate_q31_c_34175ccb____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_fir_interpolate_q31_c_34175ccb____RRX|
#line 300
|__asm___25_arm_fir_interpolate_q31_c_34175ccb____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
