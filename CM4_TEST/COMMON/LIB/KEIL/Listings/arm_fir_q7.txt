; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_q7.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_q7.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_fir_q7.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_fir_q7.c]
                          THUMB

                          AREA ||i.arm_fir_q7||, CODE, READONLY, ALIGN=1

                  arm_fir_q7 PROC
;;;68     
;;;69     void arm_fir_q7(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;70       const arm_fir_instance_q7 * S,
;;;71       q7_t * pSrc,
;;;72       q7_t * pDst,
;;;73       uint32_t blockSize)
;;;74     {
000004  b088              SUB      sp,sp,#0x20
;;;75     
;;;76     #ifndef ARM_MATH_CM0_FAMILY
;;;77     
;;;78       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;79     
;;;80       q7_t *pState = S->pState;                      /* State pointer */
000006  9808              LDR      r0,[sp,#0x20]
000008  6845              LDR      r5,[r0,#4]
;;;81       q7_t *pCoeffs = S->pCoeffs;                    /* Coefficient pointer */
00000a  9808              LDR      r0,[sp,#0x20]
00000c  6880              LDR      r0,[r0,#8]
00000e  9006              STR      r0,[sp,#0x18]
;;;82       q7_t *pStateCurnt;                             /* Points to the current sample of the state */
;;;83       q7_t x0, x1, x2, x3;                           /* Temporary variables to hold state */
;;;84       q7_t c0;                                       /* Temporary variable to hold coefficient value */
;;;85       q7_t *px;                                      /* Temporary pointer for state */
;;;86       q7_t *pb;                                      /* Temporary pointer for coefficient buffer */
;;;87       q31_t acc0, acc1, acc2, acc3;                  /* Accumulators */
;;;88       uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
000010  9808              LDR      r0,[sp,#0x20]
000012  8800              LDRH     r0,[r0,#0]
000014  9003              STR      r0,[sp,#0xc]
;;;89       uint32_t i, tapCnt, blkCnt;                    /* Loop counters */
;;;90     
;;;91       /* S->pState points to state array which contains previous frame (numTaps - 1) samples */
;;;92       /* pStateCurnt points to the location where the new input data should be written */
;;;93       pStateCurnt = &(S->pState[(numTaps - 1u)]);
000016  9803              LDR      r0,[sp,#0xc]
000018  1e40              SUBS     r0,r0,#1
00001a  eb050e00          ADD      lr,r5,r0
00001e  9007              STR      r0,[sp,#0x1c]
;;;94     
;;;95       /* Apply loop unrolling and compute 4 output values simultaneously.    
;;;96        * The variables acc0 ... acc3 hold output values that are being computed:    
;;;97        *    
;;;98        *    acc0 =  b[numTaps-1] * x[n-numTaps-1] + b[numTaps-2] * x[n-numTaps-2] + b[numTaps-3] * x[n-numTaps-3] +...+ b[0] * x[0]    
;;;99        *    acc1 =  b[numTaps-1] * x[n-numTaps] +   b[numTaps-2] * x[n-numTaps-1] + b[numTaps-3] * x[n-numTaps-2] +...+ b[0] * x[1]    
;;;100       *    acc2 =  b[numTaps-1] * x[n-numTaps+1] + b[numTaps-2] * x[n-numTaps] +   b[numTaps-3] * x[n-numTaps-1] +...+ b[0] * x[2]    
;;;101       *    acc3 =  b[numTaps-1] * x[n-numTaps+2] + b[numTaps-2] * x[n-numTaps+1] + b[numTaps-3] * x[n-numTaps]   +...+ b[0] * x[3]    
;;;102       */
;;;103      blkCnt = blockSize >> 2;
000020  980b              LDR      r0,[sp,#0x2c]
000022  0880              LSRS     r0,r0,#2
000024  9000              STR      r0,[sp,#0]
000026  e0aa              B        |L1.382|
                  |L1.40|
;;;104    
;;;105      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;106       ** a second loop below computes the remaining 1 to 3 samples. */
;;;107      while(blkCnt > 0u)
;;;108      {
;;;109        /* Copy four new input samples into the state buffer */
;;;110        *pStateCurnt++ = *pSrc++;
000028  9809              LDR      r0,[sp,#0x24]
00002a  7800              LDRB     r0,[r0,#0]
00002c  f80e0b01          STRB     r0,[lr],#1
000030  9809              LDR      r0,[sp,#0x24]
;;;111        *pStateCurnt++ = *pSrc++;
000032  7841              LDRB     r1,[r0,#1]
000034  f80e1b01          STRB     r1,[lr],#1
;;;112        *pStateCurnt++ = *pSrc++;
000038  7881              LDRB     r1,[r0,#2]
00003a  f80e1b01          STRB     r1,[lr],#1
;;;113        *pStateCurnt++ = *pSrc++;
00003e  78c1              LDRB     r1,[r0,#3]
000040  1d00              ADDS     r0,r0,#4
000042  f80e1b01          STRB     r1,[lr],#1
000046  9009              STR      r0,[sp,#0x24]
;;;114    
;;;115        /* Set all accumulators to zero */
;;;116        acc0 = 0;
000048  2700              MOVS     r7,#0
;;;117        acc1 = 0;
00004a  46bc              MOV      r12,r7
;;;118        acc2 = 0;
00004c  46b8              MOV      r8,r7
;;;119        acc3 = 0;
00004e  46b9              MOV      r9,r7
;;;120    
;;;121        /* Initialize state pointer */
;;;122        px = pState;
000050  4628              MOV      r0,r5
;;;123    
;;;124        /* Initialize coefficient pointer */
;;;125        pb = pCoeffs;
000052  9906              LDR      r1,[sp,#0x18]
;;;126    
;;;127        /* Read the first three samples from the state buffer:    
;;;128         *  x[n-numTaps], x[n-numTaps-1], x[n-numTaps-2] */
;;;129        x0 = *(px++);
000054  f9906000          LDRSB    r6,[r0,#0]
;;;130        x1 = *(px++);
000058  f9903001          LDRSB    r3,[r0,#1]
;;;131        x2 = *(px++);
00005c  f9904002          LDRSB    r4,[r0,#2]
000060  1cc0              ADDS     r0,r0,#3
;;;132    
;;;133        /* Loop unrolling.  Process 4 taps at a time. */
;;;134        tapCnt = numTaps >> 2;
000062  f8dda00c          LDR      r10,[sp,#0xc]
000066  ea4f0a9a          LSR      r10,r10,#2
00006a  f8cda004          STR      r10,[sp,#4]
;;;135        i = tapCnt;
00006e  f8dda004          LDR      r10,[sp,#4]
000072  f8cda008          STR      r10,[sp,#8]
;;;136    
;;;137        while(i > 0u)
000076  e047              B        |L1.264|
                  |L1.120|
;;;138        {
;;;139          /* Read the b[numTaps] coefficient */
;;;140          c0 = *pb;
000078  f991b000          LDRSB    r11,[r1,#0]
;;;141    
;;;142          /* Read x[n-numTaps-3] sample */
;;;143          x3 = *px;
00007c  f990a000          LDRSB    r10,[r0,#0]
;;;144          
;;;145          /* acc0 +=  b[numTaps] * x[n-numTaps] */
;;;146          acc0 += ((q15_t) x0 * c0);
000080  fb06770b          MLA      r7,r6,r11,r7
;;;147    
;;;148          /* acc1 +=  b[numTaps] * x[n-numTaps-1] */
;;;149          acc1 += ((q15_t) x1 * c0);
000084  fb03cc0b          MLA      r12,r3,r11,r12
;;;150    
;;;151          /* acc2 +=  b[numTaps] * x[n-numTaps-2] */
;;;152          acc2 += ((q15_t) x2 * c0);
000088  fb04860b          MLA      r6,r4,r11,r8
00008c  9605              STR      r6,[sp,#0x14]
;;;153    
;;;154          /* acc3 +=  b[numTaps] * x[n-numTaps-3] */
;;;155          acc3 += ((q15_t) x3 * c0);
00008e  fb1a960b          SMLABB   r6,r10,r11,r9
000092  9604              STR      r6,[sp,#0x10]
;;;156    
;;;157          /* Read the b[numTaps-1] coefficient */
;;;158          c0 = *(pb + 1u);
000094  f9918001          LDRSB    r8,[r1,#1]
;;;159    
;;;160          /* Read x[n-numTaps-4] sample */
;;;161          x0 = *(px + 1u);
000098  f9906001          LDRSB    r6,[r0,#1]
;;;162    
;;;163          /* Perform the multiply-accumulates */
;;;164          acc0 += ((q15_t) x1 * c0);
00009c  fb037908          MLA      r9,r3,r8,r7
;;;165          acc1 += ((q15_t) x2 * c0);
0000a0  fb04cb08          MLA      r11,r4,r8,r12
;;;166          acc2 += ((q15_t) x3 * c0);
0000a4  9b05              LDR      r3,[sp,#0x14]
0000a6  fb1a3308          SMLABB   r3,r10,r8,r3
0000aa  9305              STR      r3,[sp,#0x14]
;;;167          acc3 += ((q15_t) x0 * c0);
0000ac  9b04              LDR      r3,[sp,#0x10]
0000ae  fb163308          SMLABB   r3,r6,r8,r3
0000b2  9304              STR      r3,[sp,#0x10]
;;;168    
;;;169          /* Read the b[numTaps-2] coefficient */
;;;170          c0 = *(pb + 2u);
0000b4  f9917002          LDRSB    r7,[r1,#2]
;;;171    
;;;172          /* Read x[n-numTaps-5] sample */
;;;173          x1 = *(px + 2u);
0000b8  f9903002          LDRSB    r3,[r0,#2]
;;;174    
;;;175          /* Perform the multiply-accumulates */
;;;176          acc0 += ((q15_t) x2 * c0);
0000bc  fb049c07          MLA      r12,r4,r7,r9
;;;177          acc1 += ((q15_t) x3 * c0);
0000c0  fb1ab807          SMLABB   r8,r10,r7,r11
;;;178          acc2 += ((q15_t) x0 * c0);
0000c4  9c05              LDR      r4,[sp,#0x14]
0000c6  fb164b07          SMLABB   r11,r6,r7,r4
0000ca  f8cdb014          STR      r11,[sp,#0x14]
;;;179          acc3 += ((q15_t) x1 * c0);
0000ce  9c04              LDR      r4,[sp,#0x10]
0000d0  fb134b07          SMLABB   r11,r3,r7,r4
0000d4  f8cdb010          STR      r11,[sp,#0x10]
;;;180    
;;;181          /* Read the b[numTaps-3] coefficients */
;;;182          c0 = *(pb + 3u);
0000d8  f9919003          LDRSB    r9,[r1,#3]
;;;183    
;;;184          /* Read x[n-numTaps-6] sample */
;;;185          x2 = *(px + 3u);
0000dc  f9904003          LDRSB    r4,[r0,#3]
;;;186          
;;;187          /* Perform the multiply-accumulates */
;;;188          acc0 += ((q15_t) x3 * c0);
0000e0  fb1ac709          SMLABB   r7,r10,r9,r12
;;;189          acc1 += ((q15_t) x0 * c0);
0000e4  fb168c09          SMLABB   r12,r6,r9,r8
;;;190          acc2 += ((q15_t) x1 * c0);
0000e8  f8ddb014          LDR      r11,[sp,#0x14]
0000ec  fb13b809          SMLABB   r8,r3,r9,r11
;;;191          acc3 += ((q15_t) x2 * c0);
0000f0  f8ddb010          LDR      r11,[sp,#0x10]
0000f4  fb14b909          SMLABB   r9,r4,r9,r11
;;;192    
;;;193          /* update coefficient pointer */
;;;194          pb += 4u;
0000f8  1d09              ADDS     r1,r1,#4
;;;195          px += 4u;
0000fa  1d00              ADDS     r0,r0,#4
;;;196          
;;;197          /* Decrement the loop counter */
;;;198          i--;
0000fc  f8dda008          LDR      r10,[sp,#8]
000100  f1aa0a01          SUB      r10,r10,#1
000104  f8cda008          STR      r10,[sp,#8]
                  |L1.264|
000108  f8dda008          LDR      r10,[sp,#8]           ;137
00010c  f1ba0f00          CMP      r10,#0                ;137
000110  d1b2              BNE      |L1.120|
;;;199        }
;;;200    
;;;201        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;202    
;;;203        i = numTaps - (tapCnt * 4u);
000112  f8dda004          LDR      r10,[sp,#4]
000116  f1ca0b00          RSB      r11,r10,#0
00011a  f8dda00c          LDR      r10,[sp,#0xc]
00011e  eb0a0a8b          ADD      r10,r10,r11,LSL #2
000122  f8cda008          STR      r10,[sp,#8]
;;;204        while(i > 0u)
000126  e014              B        |L1.338|
                  |L1.296|
;;;205        {
;;;206          /* Read coefficients */
;;;207          c0 = *(pb++);
000128  f911ab01          LDRSB    r10,[r1],#1
;;;208    
;;;209          /* Fetch 1 state variable */
;;;210          x3 = *(px++);
00012c  f910bb01          LDRSB    r11,[r0],#1
;;;211    
;;;212          /* Perform the multiply-accumulates */
;;;213          acc0 += ((q15_t) x0 * c0);
000130  fb06770a          MLA      r7,r6,r10,r7
;;;214          acc1 += ((q15_t) x1 * c0);
000134  fb03cc0a          MLA      r12,r3,r10,r12
;;;215          acc2 += ((q15_t) x2 * c0);
000138  fb04880a          MLA      r8,r4,r10,r8
;;;216          acc3 += ((q15_t) x3 * c0);
00013c  fb1b990a          SMLABB   r9,r11,r10,r9
;;;217    
;;;218          /* Reuse the present sample states for next sample */
;;;219          x0 = x1;
000140  461e              MOV      r6,r3
;;;220          x1 = x2;
000142  4623              MOV      r3,r4
;;;221          x2 = x3;
000144  465c              MOV      r4,r11
;;;222    
;;;223          /* Decrement the loop counter */
;;;224          i--;
000146  f8dda008          LDR      r10,[sp,#8]
00014a  f1aa0a01          SUB      r10,r10,#1
00014e  f8cda008          STR      r10,[sp,#8]
                  |L1.338|
000152  f8dda008          LDR      r10,[sp,#8]           ;204
000156  f1ba0f00          CMP      r10,#0                ;204
00015a  d1e5              BNE      |L1.296|
;;;225        }
;;;226    
;;;227        /* Advance the state pointer by 4 to process the next group of 4 samples */
;;;228        pState = pState + 4;
00015c  1d2d              ADDS     r5,r5,#4
;;;229    
;;;230        /* The results in the 4 accumulators are in 2.62 format.  Convert to 1.31    
;;;231         ** Then store the 4 outputs in the destination buffer. */
;;;232        acc0 = __SSAT((acc0 >> 7u), 8);
00015e  f32710c7          SSAT     r0,#8,r7,ASR #7
;;;233        *pDst++ = acc0;
000162  7010              STRB     r0,[r2,#0]
;;;234        acc1 = __SSAT((acc1 >> 7u), 8);
000164  f32c10c7          SSAT     r0,#8,r12,ASR #7
;;;235        *pDst++ = acc1;
000168  7050              STRB     r0,[r2,#1]
;;;236        acc2 = __SSAT((acc2 >> 7u), 8);
00016a  f32810c7          SSAT     r0,#8,r8,ASR #7
;;;237        *pDst++ = acc2;
00016e  7090              STRB     r0,[r2,#2]
;;;238        acc3 = __SSAT((acc3 >> 7u), 8);
000170  f32910c7          SSAT     r0,#8,r9,ASR #7
;;;239        *pDst++ = acc3;
000174  70d0              STRB     r0,[r2,#3]
000176  1d12              ADDS     r2,r2,#4
;;;240    
;;;241        /* Decrement the samples loop counter */
;;;242        blkCnt--;
000178  9800              LDR      r0,[sp,#0]
00017a  1e40              SUBS     r0,r0,#1
00017c  9000              STR      r0,[sp,#0]
                  |L1.382|
00017e  9800              LDR      r0,[sp,#0]            ;107
000180  2800              CMP      r0,#0                 ;107
000182  f47faf51          BNE      |L1.40|
;;;243      }
;;;244    
;;;245    
;;;246      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;247       ** No loop unrolling is used. */
;;;248      blkCnt = blockSize % 4u;
000186  980b              LDR      r0,[sp,#0x2c]
000188  f0000603          AND      r6,r0,#3
;;;249    
;;;250      while(blkCnt > 0u)
00018c  e019              B        |L1.450|
                  |L1.398|
;;;251      {
;;;252        /* Copy one sample at a time into state buffer */
;;;253        *pStateCurnt++ = *pSrc++;
00018e  9809              LDR      r0,[sp,#0x24]
000190  7800              LDRB     r0,[r0,#0]
000192  f80e0b01          STRB     r0,[lr],#1
000196  9809              LDR      r0,[sp,#0x24]
000198  1c40              ADDS     r0,r0,#1
00019a  9009              STR      r0,[sp,#0x24]
;;;254    
;;;255        /* Set the accumulator to zero */
;;;256        acc0 = 0;
00019c  2400              MOVS     r4,#0
;;;257    
;;;258        /* Initialize state pointer */
;;;259        px = pState;
00019e  4628              MOV      r0,r5
;;;260    
;;;261        /* Initialize Coefficient pointer */
;;;262        pb = (pCoeffs);
0001a0  9906              LDR      r1,[sp,#0x18]
;;;263    
;;;264        i = numTaps;
0001a2  9b03              LDR      r3,[sp,#0xc]
                  |L1.420|
;;;265    
;;;266        /* Perform the multiply-accumulates */
;;;267        do
;;;268        {
;;;269          acc0 += (q15_t) * (px++) * (*(pb++));
0001a4  f9107b01          LDRSB    r7,[r0],#1
0001a8  f911cb01          LDRSB    r12,[r1],#1
0001ac  fb17440c          SMLABB   r4,r7,r12,r4
;;;270          i--;
0001b0  1e5b              SUBS     r3,r3,#1
;;;271        } while(i > 0u);
0001b2  2b00              CMP      r3,#0
0001b4  d1f6              BNE      |L1.420|
;;;272    
;;;273        /* The result is in 2.14 format.  Convert to 1.7    
;;;274         ** Then store the output in the destination buffer. */
;;;275        *pDst++ = __SSAT((acc0 >> 7u), 8);
0001b6  f32410c7          SSAT     r0,#8,r4,ASR #7
0001ba  f8020b01          STRB     r0,[r2],#1
;;;276    
;;;277        /* Advance state pointer by 1 for the next sample */
;;;278        pState = pState + 1;
0001be  1c6d              ADDS     r5,r5,#1
;;;279    
;;;280        /* Decrement the samples loop counter */
;;;281        blkCnt--;
0001c0  1e76              SUBS     r6,r6,#1
                  |L1.450|
0001c2  2e00              CMP      r6,#0                 ;250
0001c4  d1e3              BNE      |L1.398|
;;;282      }
;;;283    
;;;284      /* Processing is complete.    
;;;285       ** Now copy the last numTaps - 1 samples to the satrt of the state buffer.    
;;;286       ** This prepares the state buffer for the next function call. */
;;;287    
;;;288      /* Points to the start of the state buffer */
;;;289      pStateCurnt = S->pState;
0001c6  9808              LDR      r0,[sp,#0x20]
0001c8  6840              LDR      r0,[r0,#4]
;;;290    
;;;291      tapCnt = (numTaps - 1u) >> 2u;
0001ca  9907              LDR      r1,[sp,#0x1c]
0001cc  0889              LSRS     r1,r1,#2
;;;292    
;;;293      /* copy data */
;;;294      while(tapCnt > 0u)
0001ce  e00a              B        |L1.486|
                  |L1.464|
;;;295      {
;;;296        *pStateCurnt++ = *pState++;
0001d0  782a              LDRB     r2,[r5,#0]
0001d2  7002              STRB     r2,[r0,#0]
;;;297        *pStateCurnt++ = *pState++;
0001d4  786a              LDRB     r2,[r5,#1]
0001d6  7042              STRB     r2,[r0,#1]
;;;298        *pStateCurnt++ = *pState++;
0001d8  78aa              LDRB     r2,[r5,#2]
0001da  7082              STRB     r2,[r0,#2]
;;;299        *pStateCurnt++ = *pState++;
0001dc  78ea              LDRB     r2,[r5,#3]
0001de  1d2d              ADDS     r5,r5,#4
0001e0  70c2              STRB     r2,[r0,#3]
0001e2  1d00              ADDS     r0,r0,#4
;;;300    
;;;301        /* Decrement the loop counter */
;;;302        tapCnt--;
0001e4  1e49              SUBS     r1,r1,#1
                  |L1.486|
0001e6  2900              CMP      r1,#0                 ;294
0001e8  d1f2              BNE      |L1.464|
;;;303      }
;;;304    
;;;305      /* Calculate remaining number of copies */
;;;306      tapCnt = (numTaps - 1u) % 0x4u;
0001ea  9907              LDR      r1,[sp,#0x1c]
0001ec  f0010103          AND      r1,r1,#3
;;;307    
;;;308      /* Copy the remaining q31_t data */
;;;309      while(tapCnt > 0u)
0001f0  e004              B        |L1.508|
                  |L1.498|
;;;310      {
;;;311        *pStateCurnt++ = *pState++;
0001f2  f8152b01          LDRB     r2,[r5],#1
0001f6  f8002b01          STRB     r2,[r0],#1
;;;312    
;;;313        /* Decrement the loop counter */
;;;314        tapCnt--;
0001fa  1e49              SUBS     r1,r1,#1
                  |L1.508|
0001fc  2900              CMP      r1,#0                 ;309
0001fe  d1f8              BNE      |L1.498|
;;;315      }
;;;316    
;;;317    #else
;;;318    
;;;319    /* Run the below code for Cortex-M0 */
;;;320    
;;;321      uint32_t numTaps = S->numTaps;                 /* Number of taps in the filter */
;;;322      uint32_t i, blkCnt;                            /* Loop counters */
;;;323      q7_t *pState = S->pState;                      /* State pointer */
;;;324      q7_t *pCoeffs = S->pCoeffs;                    /* Coefficient pointer */
;;;325      q7_t *px, *pb;                                 /* Temporary pointers to state and coeff */
;;;326      q31_t acc = 0;                                 /* Accumlator */
;;;327      q7_t *pStateCurnt;                             /* Points to the current sample of the state */
;;;328    
;;;329    
;;;330      /* S->pState points to state array which contains previous frame (numTaps - 1) samples */
;;;331      /* pStateCurnt points to the location where the new input data should be written */
;;;332      pStateCurnt = S->pState + (numTaps - 1u);
;;;333    
;;;334      /* Initialize blkCnt with blockSize */
;;;335      blkCnt = blockSize;
;;;336    
;;;337      /* Perform filtering upto BlockSize - BlockSize%4  */
;;;338      while(blkCnt > 0u)
;;;339      {
;;;340        /* Copy one sample at a time into state buffer */
;;;341        *pStateCurnt++ = *pSrc++;
;;;342    
;;;343        /* Set accumulator to zero */
;;;344        acc = 0;
;;;345    
;;;346        /* Initialize state pointer of type q7 */
;;;347        px = pState;
;;;348    
;;;349        /* Initialize coeff pointer of type q7 */
;;;350        pb = pCoeffs;
;;;351    
;;;352    
;;;353        i = numTaps;
;;;354    
;;;355        while(i > 0u)
;;;356        {
;;;357          /* acc =  b[numTaps-1] * x[n-numTaps-1] + b[numTaps-2] * x[n-numTaps-2] + b[numTaps-3] * x[n-numTaps-3] +...+ b[0] * x[0] */
;;;358          acc += (q15_t) * px++ * *pb++;
;;;359          i--;
;;;360        }
;;;361    
;;;362        /* Store the 1.7 format filter output in destination buffer */
;;;363        *pDst++ = (q7_t) __SSAT((acc >> 7), 8);
;;;364    
;;;365        /* Advance the state pointer by 1 to process the next sample */
;;;366        pState = pState + 1;
;;;367    
;;;368        /* Decrement the loop counter */
;;;369        blkCnt--;
;;;370      }
;;;371    
;;;372      /* Processing is complete.         
;;;373       ** Now copy the last numTaps - 1 samples to the satrt of the state buffer.       
;;;374       ** This prepares the state buffer for the next function call. */
;;;375    
;;;376    
;;;377      /* Points to the start of the state buffer */
;;;378      pStateCurnt = S->pState;
;;;379    
;;;380    
;;;381      /* Copy numTaps number of values */
;;;382      i = (numTaps - 1u);
;;;383    
;;;384      /* Copy q7_t data */
;;;385      while(i > 0u)
;;;386      {
;;;387        *pStateCurnt++ = *pState++;
;;;388        i--;
;;;389      }
;;;390    
;;;391    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;392    
;;;393    }
000200  b00c              ADD      sp,sp,#0x30
000202  e8bd8ff0          POP      {r4-r11,pc}
;;;394    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_fir_q7.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_arm_fir_q7_c_ff49d506____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___12_arm_fir_q7_c_ff49d506____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_arm_fir_q7_c_ff49d506____REVSH|
#line 144
|__asm___12_arm_fir_q7_c_ff49d506____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_arm_fir_q7_c_ff49d506____RRX|
#line 300
|__asm___12_arm_fir_q7_c_ff49d506____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
