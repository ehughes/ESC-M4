; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_sqrt_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_sqrt_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_sqrt_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FastMathFunctions\arm_sqrt_q15.c]
                          THUMB

                          AREA ||i.arm_sqrt_q15||, CODE, READONLY, ALIGN=2

                  arm_sqrt_q15 PROC
;;;61     
;;;62     arm_status arm_sqrt_q15(
000000  b538              PUSH     {r3-r5,lr}
;;;63       q15_t in,
;;;64       q15_t * pOut)
;;;65     {
;;;66       q15_t number, temp1, var1, signBits1, half;
;;;67       q31_t bits_val1;
;;;68       float32_t temp_float1;
;;;69       union
;;;70       {
;;;71         q31_t fracval;
;;;72         float32_t floatval;
;;;73       } tempconv;
;;;74     
;;;75       number = in;
;;;76     
;;;77       /* If the input is a positive number then compute the signBits. */
;;;78       if(number > 0)
000002  2800              CMP      r0,#0
000004  dd79              BLE      |L1.250|
;;;79       {
;;;80         signBits1 = __CLZ(number) - 17;
000006  fab0f280          CLZ      r2,r0
00000a  3a11              SUBS     r2,r2,#0x11
;;;81     
;;;82         /* Shift by the number of signBits1 */
;;;83         if((signBits1 % 2) == 0)
00000c  07d3              LSLS     r3,r2,#31
00000e  2b00              CMP      r3,#0
000010  d062              BEQ      |L1.216|
;;;84         {
;;;85           number = number << signBits1;
;;;86         }
;;;87         else
;;;88         {
;;;89           number = number << (signBits1 - 1);
000012  f1a20301          SUB      r3,r2,#1
000016  fa00f003          LSL      r0,r0,r3
00001a  b200              SXTH     r0,r0
                  |L1.28|
;;;90         }
;;;91     
;;;92         /* Calculate half value of the number */
;;;93         half = number >> 1;
00001c  ea4f0360          ASR      r3,r0,#1
;;;94         /* Store the number for later use */
;;;95         temp1 = number;
;;;96     
;;;97         /* Convert to float */
;;;98         temp_float1 = number * 3.051757812500000e-005f;
000020  ee000a10          VMOV     s0,r0
000024  eddf0a38          VLDR     s1,|L1.264|
000028  eeb80ac0          VCVT.F32.S32 s0,s0
00002c  ee200a20          VMUL.F32 s0,s0,s1
;;;99         /*Store as integer */
;;;100        tempconv.floatval = temp_float1;
000030  ed8d0a00          VSTR     s0,[sp,#0]
;;;101        bits_val1 = tempconv.fracval;
000034  9c00              LDR      r4,[sp,#0]
;;;102        /* Subtract the shifted value from the magic number to give intial guess */
;;;103        bits_val1 = 0x5f3759df - (bits_val1 >> 1);  /* gives initial guess */
000036  4d35              LDR      r5,|L1.268|
000038  eba50464          SUB      r4,r5,r4,ASR #1
;;;104        /* Store as float */
;;;105        tempconv.fracval = bits_val1;
00003c  9400              STR      r4,[sp,#0]
;;;106        temp_float1 = tempconv.floatval;
00003e  ed9d0a00          VLDR     s0,[sp,#0]
;;;107        /* Convert to integer format */
;;;108        var1 = (q31_t) (temp_float1 * 16384);
000042  eddf0a33          VLDR     s1,|L1.272|
000046  ee200a20          VMUL.F32 s0,s0,s1
00004a  eebd0ac0          VCVT.S32.F32 s0,s0
00004e  ee104a10          VMOV     r4,s0
000052  b224              SXTH     r4,r4
;;;109    
;;;110        /* 1st iteration */
;;;111        var1 = ((q15_t) ((q31_t) var1 * (0x3000 -
000054  fb14f504          SMULBB   r5,r4,r4
000058  f34535cf          SBFX     r5,r5,#15,#16
00005c  fb05f503          MUL      r5,r5,r3
000060  f34535cf          SBFX     r5,r5,#15,#16
000064  f5c55540          RSB      r5,r5,#0x3000
000068  fb05f504          MUL      r5,r5,r4
00006c  ea4f34e5          ASR      r4,r5,#15
000070  ea4f0484          LSL      r4,r4,#2
000074  b224              SXTH     r4,r4
;;;112                                         ((q15_t)
;;;113                                          ((((q15_t)
;;;114                                             (((q31_t) var1 * var1) >> 15)) *
;;;115                                            (q31_t) half) >> 15))) >> 15)) << 2;
;;;116        /* 2nd iteration */
;;;117        var1 = ((q15_t) ((q31_t) var1 * (0x3000 -
000076  fb14f504          SMULBB   r5,r4,r4
00007a  f34535cf          SBFX     r5,r5,#15,#16
00007e  fb05f503          MUL      r5,r5,r3
000082  f34535cf          SBFX     r5,r5,#15,#16
000086  f5c55540          RSB      r5,r5,#0x3000
00008a  fb05f504          MUL      r5,r5,r4
00008e  ea4f34e5          ASR      r4,r5,#15
000092  ea4f0484          LSL      r4,r4,#2
000096  b224              SXTH     r4,r4
;;;118                                         ((q15_t)
;;;119                                          ((((q15_t)
;;;120                                             (((q31_t) var1 * var1) >> 15)) *
;;;121                                            (q31_t) half) >> 15))) >> 15)) << 2;
;;;122        /* 3rd iteration */
;;;123        var1 = ((q15_t) ((q31_t) var1 * (0x3000 -
000098  fb14f504          SMULBB   r5,r4,r4
00009c  f34535cf          SBFX     r5,r5,#15,#16
0000a0  fb05f503          MUL      r5,r5,r3
0000a4  f34533cf          SBFX     r3,r5,#15,#16
0000a8  f5c35340          RSB      r3,r3,#0x3000
0000ac  fb03f304          MUL      r3,r3,r4
0000b0  ea4f33e3          ASR      r3,r3,#15
0000b4  ea4f0383          LSL      r3,r3,#2
0000b8  b21b              SXTH     r3,r3
;;;124                                         ((q15_t)
;;;125                                          ((((q15_t)
;;;126                                             (((q31_t) var1 * var1) >> 15)) *
;;;127                                            (q31_t) half) >> 15))) >> 15)) << 2;
;;;128    
;;;129        /* Multiply the inverse square root with the original value */
;;;130        var1 = ((q15_t) (((q31_t) temp1 * var1) >> 15)) << 1;
0000ba  fb00f003          MUL      r0,r0,r3
0000be  ea4f30e0          ASR      r0,r0,#15
0000c2  ea4f0040          LSL      r0,r0,#1
0000c6  b200              SXTH     r0,r0
;;;131    
;;;132        /* Shift the output down accordingly */
;;;133        if((signBits1 % 2) == 0)
0000c8  d10a              BNE      |L1.224|
;;;134        {
;;;135          var1 = var1 >> (signBits1 / 2);
0000ca  eb0272d2          ADD      r2,r2,r2,LSR #31
0000ce  ea4f0262          ASR      r2,r2,#1
0000d2  fa40f002          ASR      r0,r0,r2
0000d6  e00b              B        |L1.240|
                  |L1.216|
0000d8  fa00f002          LSL      r0,r0,r2              ;85
0000dc  b200              SXTH     r0,r0                 ;85
0000de  e79d              B        |L1.28|
                  |L1.224|
;;;136        }
;;;137        else
;;;138        {
;;;139          var1 = var1 >> ((signBits1 - 1) / 2);
0000e0  f1a20201          SUB      r2,r2,#1
0000e4  eb0272d2          ADD      r2,r2,r2,LSR #31
0000e8  ea4f0262          ASR      r2,r2,#1
0000ec  fa40f002          ASR      r0,r0,r2
                  |L1.240|
;;;140        }
;;;141        *pOut = var1;
0000f0  8008              STRH     r0,[r1,#0]
;;;142    
;;;143        return (ARM_MATH_SUCCESS);
0000f2  f04f0000          MOV      r0,#0
                  |L1.246|
;;;144      }
;;;145      /* If the number is a negative number then store zero as its square root value */
;;;146      else
;;;147      {
;;;148        *pOut = 0;
;;;149        return (ARM_MATH_ARGUMENT_ERROR);
;;;150      }
;;;151    }
0000f6  bd38              POP      {r3-r5,pc}
0000f8  e7ff              B        |L1.250|
                  |L1.250|
0000fa  f04f0000          MOV      r0,#0                 ;148
0000fe  8008              STRH     r0,[r1,#0]            ;148
000100  f04f30ff          MOV      r0,#0xffffffff        ;149
000104  e7f7              B        |L1.246|
;;;152    
                          ENDP

000106  0000              DCW      0x0000
                  |L1.264|
000108  38000000          DCFS     0x38000000 ; 3.0517578125e-05
                  |L1.268|
                          DCD      0x5f3759df
                  |L1.272|
000110  46800000          DCFS     0x46800000 ; 16384

;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FastMathFunctions\\arm_sqrt_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_sqrt_q15_c_93557576____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___14_arm_sqrt_q15_c_93557576____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_sqrt_q15_c_93557576____REVSH|
#line 144
|__asm___14_arm_sqrt_q15_c_93557576____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_sqrt_q15_c_93557576____RRX|
#line 300
|__asm___14_arm_sqrt_q15_c_93557576____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
