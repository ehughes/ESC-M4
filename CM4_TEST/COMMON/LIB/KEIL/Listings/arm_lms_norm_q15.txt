; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_lms_norm_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_lms_norm_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_lms_norm_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_lms_norm_q15.c]
                          THUMB

                          AREA ||i.arm_lms_norm_q15||, CODE, READONLY, ALIGN=1

                  arm_lms_norm_q15 PROC
;;;78     
;;;79     void arm_lms_norm_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;80       arm_lms_norm_instance_q15 * S,
;;;81       q15_t * pSrc,
;;;82       q15_t * pRef,
;;;83       q15_t * pOut,
;;;84       q15_t * pErr,
;;;85       uint32_t blockSize)
;;;86     {
000004  b089              SUB      sp,sp,#0x24
000006  9f17              LDR      r7,[sp,#0x5c]
;;;87       q15_t *pState = S->pState;                     /* State pointer */
000008  6844              LDR      r4,[r0,#4]
;;;88       q15_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
00000a  6882              LDR      r2,[r0,#8]
00000c  9205              STR      r2,[sp,#0x14]
;;;89       q15_t *pStateCurnt;                            /* Points to the current sample of the state */
;;;90       q15_t *px, *pb;                                /* Temporary pointers for state and coefficient buffers */
;;;91       q15_t mu = S->mu;                              /* Adaptive factor */
00000e  f9b0200c          LDRSH    r2,[r0,#0xc]
000012  9204              STR      r2,[sp,#0x10]
;;;92       uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
000014  f8b0a000          LDRH     r10,[r0,#0]
;;;93       uint32_t tapCnt, blkCnt;                       /* Loop counters */
;;;94       q31_t energy;                                  /* Energy of the input */
;;;95       q63_t acc;                                     /* Accumulator */
;;;96       q15_t e = 0, d = 0;                            /* error, reference data sample */
;;;97       q15_t w = 0, in;                               /* weight factor and state */
;;;98       q15_t x0;                                      /* temporary variable to hold input sample */
;;;99       //uint32_t shift = (uint32_t) S->postShift + 1u; /* Shift to be applied to the output */ 
;;;100      q15_t errorXmu, oneByEnergy;                   /* Temporary variables to store error and mu product and reciprocal of energy */
;;;101      q15_t postShift;                               /* Post shift to be applied to weight after reciprocal calculation */
;;;102      q31_t coef;                                    /* Teporary variable for coefficient */
;;;103      q31_t acc_l, acc_h;
;;;104      int32_t lShift = (15 - (int32_t) S->postShift);       /*  Post shift  */
000018  7b82              LDRB     r2,[r0,#0xe]
00001a  f1c2020f          RSB      r2,r2,#0xf
00001e  9202              STR      r2,[sp,#8]
;;;105      int32_t uShift = (32 - lShift);
000020  9a02              LDR      r2,[sp,#8]
000022  f1c20220          RSB      r2,r2,#0x20
000026  9201              STR      r2,[sp,#4]
;;;106    
;;;107      energy = S->energy;
000028  f9b06014          LDRSH    r6,[r0,#0x14]
;;;108      x0 = S->x0;
00002c  f9b02016          LDRSH    r2,[r0,#0x16]
;;;109    
;;;110      /* S->pState points to buffer which contains previous frame (numTaps - 1) samples */
;;;111      /* pStateCurnt points to the location where the new input data should be written */
;;;112      pStateCurnt = &(S->pState[(numTaps - 1u)]);
000030  f1aa0301          SUB      r3,r10,#1
000034  eb040943          ADD      r9,r4,r3,LSL #1
000038  9308              STR      r3,[sp,#0x20]
00003a  e0dd              B        |L1.504|
                  |L1.60|
;;;113    
;;;114      /* Loop over blockSize number of values */
;;;115      blkCnt = blockSize;
;;;116    
;;;117    
;;;118    #ifndef ARM_MATH_CM0_FAMILY
;;;119    
;;;120      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;121    
;;;122      while(blkCnt > 0u)
;;;123      {
;;;124        /* Copy the new input sample into the state buffer */
;;;125        *pStateCurnt++ = *pSrc;
00003c  880b              LDRH     r3,[r1,#0]
00003e  f8293b02          STRH     r3,[r9],#2
;;;126    
;;;127        /* Initialize pState pointer */
;;;128        px = pState;
000042  46a4              MOV      r12,r4
;;;129    
;;;130        /* Initialize coeff pointer */
;;;131        pb = (pCoeffs);
000044  9d05              LDR      r5,[sp,#0x14]
;;;132    
;;;133        /* Read the sample from input buffer */
;;;134        in = *pSrc++;
000046  f8313b02          LDRH     r3,[r1],#2
;;;135    
;;;136        /* Update the energy calculation */
;;;137        energy -= (((q31_t) x0 * (x0)) >> 15);
00004a  4352              MULS     r2,r2,r2
00004c  eba632e2          SUB      r2,r6,r2,ASR #15
;;;138        energy += (((q31_t) in * (in)) >> 15);
000050  fb13f303          SMULBB   r3,r3,r3
000054  eb0236e3          ADD      r6,r2,r3,ASR #15
;;;139    
;;;140        /* Set the accumulator to zero */
;;;141        acc = 0;
000058  2200              MOVS     r2,#0
00005a  4613              MOV      r3,r2
;;;142    
;;;143        /* Loop unrolling.  Process 4 taps at a time. */
;;;144        tapCnt = numTaps >> 2;
00005c  ea4f089a          LSR      r8,r10,#2
000060  f8cd801c          STR      r8,[sp,#0x1c]
;;;145    
;;;146        while(tapCnt > 0u)
000064  e00d              B        |L1.130|
                  |L1.102|
;;;147        {
;;;148    
;;;149          /* Perform the multiply-accumulate */
;;;150    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;151    
;;;152          acc = __SMLALD(*__SIMD32(px)++, (*__SIMD32(pb)++), acc);
000066  f85ceb04          LDR      lr,[r12],#4
00006a  f855bb04          LDR      r11,[r5],#4
00006e  fbce23cb          SMLALD   r2,r3,lr,r11
;;;153          acc = __SMLALD(*__SIMD32(px)++, (*__SIMD32(pb)++), acc);
000072  f85ceb04          LDR      lr,[r12],#4
000076  f855bb04          LDR      r11,[r5],#4
00007a  fbce23cb          SMLALD   r2,r3,lr,r11
;;;154    
;;;155    #else
;;;156    
;;;157          acc += (((q31_t) * px++ * (*pb++)));
;;;158          acc += (((q31_t) * px++ * (*pb++)));
;;;159          acc += (((q31_t) * px++ * (*pb++)));
;;;160          acc += (((q31_t) * px++ * (*pb++)));
;;;161    
;;;162    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;163    
;;;164          /* Decrement the loop counter */
;;;165          tapCnt--;
00007e  f1a80801          SUB      r8,r8,#1
                  |L1.130|
000082  f1b80f00          CMP      r8,#0                 ;146
000086  d1ee              BNE      |L1.102|
;;;166        }
;;;167    
;;;168        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;169        tapCnt = numTaps % 0x4u;
000088  f00a0803          AND      r8,r10,#3
00008c  f8cd8018          STR      r8,[sp,#0x18]
;;;170    
;;;171        while(tapCnt > 0u)
000090  e007              B        |L1.162|
                  |L1.146|
;;;172        {
;;;173          /* Perform the multiply-accumulate */
;;;174          acc += (((q31_t) * px++ * (*pb++)));
000092  f93ceb02          LDRSH    lr,[r12],#2
000096  f935bb02          LDRSH    r11,[r5],#2
00009a  fbce238b          SMLALBB  r2,r3,lr,r11
;;;175    
;;;176          /* Decrement the loop counter */
;;;177          tapCnt--;
00009e  f1a80801          SUB      r8,r8,#1
                  |L1.162|
0000a2  f1b80f00          CMP      r8,#0                 ;171
0000a6  d1f4              BNE      |L1.146|
;;;178        }
;;;179    
;;;180        /* Calc lower part of acc */
;;;181        acc_l = acc & 0xffffffff;
;;;182    
;;;183        /* Calc upper part of acc */
;;;184        acc_h = (acc >> 32) & 0xffffffff;
;;;185    
;;;186        /* Apply shift for lower part of acc and upper part of acc */
;;;187        acc = (uint32_t) acc_l >> lShift | acc_h << uShift;
0000a8  9d02              LDR      r5,[sp,#8]
0000aa  40ea              LSRS     r2,r2,r5
0000ac  9d01              LDR      r5,[sp,#4]
0000ae  40ab              LSLS     r3,r3,r5
0000b0  431a              ORRS     r2,r2,r3
;;;188    
;;;189        /* Converting the result to 1.15 format and saturate the output */
;;;190        acc = __SSAT(acc, 16u);
0000b2  f302020f          SSAT     r2,#16,r2
;;;191    
;;;192        /* Store the result from accumulator into the destination buffer. */
;;;193        *pOut++ = (q15_t) acc;
0000b6  9b0c              LDR      r3,[sp,#0x30]
0000b8  801a              STRH     r2,[r3,#0]
0000ba  9b0c              LDR      r3,[sp,#0x30]
0000bc  1c9b              ADDS     r3,r3,#2
0000be  930c              STR      r3,[sp,#0x30]
;;;194    
;;;195        /* Compute and store error */
;;;196        d = *pRef++;
0000c0  9b0b              LDR      r3,[sp,#0x2c]
0000c2  9d0b              LDR      r5,[sp,#0x2c]
0000c4  881b              LDRH     r3,[r3,#0]
0000c6  1cad              ADDS     r5,r5,#2
0000c8  950b              STR      r5,[sp,#0x2c]
;;;197        e = d - (q15_t) acc;
0000ca  1a9a              SUBS     r2,r3,r2
0000cc  fa0ff882          SXTH     r8,r2
;;;198        *pErr++ = e;
0000d0  9a16              LDR      r2,[sp,#0x58]
0000d2  f8a28000          STRH     r8,[r2,#0]
0000d6  9a16              LDR      r2,[sp,#0x58]
0000d8  1c92              ADDS     r2,r2,#2
0000da  9216              STR      r2,[sp,#0x58]
;;;199    
;;;200        /* Calculation of 1/energy */
;;;201        postShift = arm_recip_q15((q15_t) energy + DELTA_Q15,
0000dc  2205              MOVS     r2,#5
0000de  fa02f286          SXTAH    r2,r2,r6
0000e2  ab03              ADD      r3,sp,#0xc
0000e4  9300              STR      r3,[sp,#0]
0000e6  f8d0b010          LDR      r11,[r0,#0x10]
0000ea  b212              SXTH     r2,r2
0000ec  2300              MOVS     r3,#0
0000ee  2a00              CMP      r2,#0
0000f0  dd03              BLE      |L1.250|
0000f2  fab2f582          CLZ      r5,r2
0000f6  3d11              SUBS     r5,r5,#0x11
0000f8  e003              B        |L1.258|
                  |L1.250|
0000fa  4255              RSBS     r5,r2,#0
0000fc  fab5f585          CLZ      r5,r5
000100  3d11              SUBS     r5,r5,#0x11
                  |L1.258|
000102  40aa              LSLS     r2,r2,r5
000104  fa0ffc82          SXTH     r12,r2
000108  ea4f222c          ASR      r2,r12,#8
00010c  f002023f          AND      r2,r2,#0x3f
000110  f93b2012          LDRSH    r2,[r11,r2,LSL #1]
000114  f6477eff          MOV      lr,#0x7fff
                  |L1.280|
000118  fb0cfb02          MUL      r11,r12,r2
00011c  f34b3bcf          SBFX     r11,r11,#15,#16
000120  ebae0b0b          SUB      r11,lr,r11
000124  fb02f20b          MUL      r2,r2,r11
000128  f342328f          SBFX     r2,r2,#14,#16
00012c  1c5b              ADDS     r3,r3,#1
00012e  2b02              CMP      r3,#2
000130  d3f2              BCC      |L1.280|
000132  9b00              LDR      r3,[sp,#0]
000134  801a              STRH     r2,[r3,#0]
000136  1c6d              ADDS     r5,r5,#1
000138  b22b              SXTH     r3,r5
;;;202                                  &oneByEnergy, S->recipTable);
;;;203    
;;;204        /* Calculation of e * mu value */
;;;205        errorXmu = (q15_t) (((q31_t) e * mu) >> 15);
00013a  9a04              LDR      r2,[sp,#0x10]
00013c  fb08f802          MUL      r8,r8,r2
000140  ea4f32e8          ASR      r2,r8,#15
;;;206    
;;;207        /* Calculation of (e * mu) * (1/energy) value */
;;;208        acc = (((q31_t) errorXmu * oneByEnergy) >> (15 - postShift));
000144  f8bd500c          LDRH     r5,[sp,#0xc]
000148  fb12f205          SMULBB   r2,r2,r5
00014c  f1c3030f          RSB      r3,r3,#0xf
000150  411a              ASRS     r2,r2,r3
;;;209    
;;;210        /* Weighting factor for the normalized version */
;;;211        w = (q15_t) __SSAT((q31_t) acc, 16);
000152  f302050f          SSAT     r5,#16,r2
;;;212    
;;;213        /* Initialize pState pointer */
;;;214        px = pState;
000156  4623              MOV      r3,r4
;;;215    
;;;216        /* Initialize coeff pointer */
;;;217        pb = (pCoeffs);
000158  9a05              LDR      r2,[sp,#0x14]
;;;218    
;;;219        /* Loop unrolling.  Process 4 taps at a time. */
;;;220        tapCnt = numTaps >> 2;
00015a  f8ddc01c          LDR      r12,[sp,#0x1c]
;;;221    
;;;222        /* Update filter coefficients */
;;;223        while(tapCnt > 0u)
00015e  e031              B        |L1.452|
                  |L1.352|
;;;224        {
;;;225          coef = *pb + (((q31_t) w * (*px++)) >> 15);
000160  f9338b02          LDRSH    r8,[r3],#2
000164  f9b2b000          LDRSH    r11,[r2,#0]
000168  fb08f805          MUL      r8,r8,r5
00016c  eb0b38e8          ADD      r8,r11,r8,ASR #15
;;;226          *pb++ = (q15_t) __SSAT((coef), 16);
000170  f308080f          SSAT     r8,#16,r8
000174  f8a28000          STRH     r8,[r2,#0]
;;;227          coef = *pb + (((q31_t) w * (*px++)) >> 15);
000178  f9338b02          LDRSH    r8,[r3],#2
00017c  f9b2b002          LDRSH    r11,[r2,#2]
000180  fb08f805          MUL      r8,r8,r5
000184  eb0b38e8          ADD      r8,r11,r8,ASR #15
;;;228          *pb++ = (q15_t) __SSAT((coef), 16);
000188  f308080f          SSAT     r8,#16,r8
00018c  f8a28002          STRH     r8,[r2,#2]
;;;229          coef = *pb + (((q31_t) w * (*px++)) >> 15);
000190  f9338b02          LDRSH    r8,[r3],#2
000194  f9b2b004          LDRSH    r11,[r2,#4]
000198  fb08f805          MUL      r8,r8,r5
00019c  eb0b38e8          ADD      r8,r11,r8,ASR #15
;;;230          *pb++ = (q15_t) __SSAT((coef), 16);
0001a0  f308080f          SSAT     r8,#16,r8
0001a4  f8a28004          STRH     r8,[r2,#4]
;;;231          coef = *pb + (((q31_t) w * (*px++)) >> 15);
0001a8  f9338b02          LDRSH    r8,[r3],#2
0001ac  f932bf06          LDRSH    r11,[r2,#6]!
0001b0  fb08f805          MUL      r8,r8,r5
0001b4  eb0b38e8          ADD      r8,r11,r8,ASR #15
;;;232          *pb++ = (q15_t) __SSAT((coef), 16);
0001b8  f308080f          SSAT     r8,#16,r8
0001bc  f8228b02          STRH     r8,[r2],#2
;;;233    
;;;234          /* Decrement the loop counter */
;;;235          tapCnt--;
0001c0  f1ac0c01          SUB      r12,r12,#1
                  |L1.452|
0001c4  f1bc0f00          CMP      r12,#0                ;223
0001c8  d1ca              BNE      |L1.352|
;;;236        }
;;;237    
;;;238        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;239        tapCnt = numTaps % 0x4u;
0001ca  f8ddc018          LDR      r12,[sp,#0x18]
;;;240    
;;;241        while(tapCnt > 0u)
0001ce  e00d              B        |L1.492|
                  |L1.464|
;;;242        {
;;;243          /* Perform the multiply-accumulate */
;;;244          coef = *pb + (((q31_t) w * (*px++)) >> 15);
0001d0  f9338b02          LDRSH    r8,[r3],#2
0001d4  f9b2b000          LDRSH    r11,[r2,#0]
0001d8  fb08f805          MUL      r8,r8,r5
0001dc  eb0b38e8          ADD      r8,r11,r8,ASR #15
;;;245          *pb++ = (q15_t) __SSAT((coef), 16);
0001e0  f308080f          SSAT     r8,#16,r8
0001e4  f8228b02          STRH     r8,[r2],#2
;;;246    
;;;247          /* Decrement the loop counter */
;;;248          tapCnt--;
0001e8  f1ac0c01          SUB      r12,r12,#1
                  |L1.492|
0001ec  f1bc0f00          CMP      r12,#0                ;241
0001f0  d1ee              BNE      |L1.464|
;;;249        }
;;;250    
;;;251        /* Read the sample from state buffer */
;;;252        x0 = *pState;
0001f2  f9342b02          LDRSH    r2,[r4],#2
;;;253    
;;;254        /* Advance state pointer by 1 for the next sample */
;;;255        pState = pState + 1u;
;;;256    
;;;257        /* Decrement the loop counter */
;;;258        blkCnt--;
0001f6  1e7f              SUBS     r7,r7,#1
                  |L1.504|
0001f8  2f00              CMP      r7,#0                 ;122
0001fa  f47faf1f          BNE      |L1.60|
;;;259      }
;;;260    
;;;261      /* Save energy and x0 values for the next frame */
;;;262      S->energy = (q15_t) energy;
0001fe  8286              STRH     r6,[r0,#0x14]
;;;263      S->x0 = x0;
000200  82c2              STRH     r2,[r0,#0x16]
;;;264    
;;;265      /* Processing is complete. Now copy the last numTaps - 1 samples to the    
;;;266         satrt of the state buffer. This prepares the state buffer for the    
;;;267         next function call. */
;;;268    
;;;269      /* Points to the start of the pState buffer */
;;;270      pStateCurnt = S->pState;
000202  6840              LDR      r0,[r0,#4]
;;;271    
;;;272      /* Calculation of count for copying integer writes */
;;;273      tapCnt = (numTaps - 1u) >> 2;
000204  9908              LDR      r1,[sp,#0x20]
000206  0889              LSRS     r1,r1,#2
;;;274    
;;;275      while(tapCnt > 0u)
000208  e006              B        |L1.536|
                  |L1.522|
;;;276      {
;;;277    
;;;278    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;279    
;;;280        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
00020a  6822              LDR      r2,[r4,#0]
00020c  6002              STR      r2,[r0,#0]
;;;281        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
00020e  6862              LDR      r2,[r4,#4]
000210  3408              ADDS     r4,r4,#8
000212  6042              STR      r2,[r0,#4]
000214  3008              ADDS     r0,r0,#8
;;;282    
;;;283    #else
;;;284    
;;;285        *pStateCurnt++ = *pState++;
;;;286        *pStateCurnt++ = *pState++;
;;;287        *pStateCurnt++ = *pState++;
;;;288        *pStateCurnt++ = *pState++;
;;;289    
;;;290    #endif
;;;291    
;;;292        tapCnt--;
000216  1e49              SUBS     r1,r1,#1
                  |L1.536|
000218  2900              CMP      r1,#0                 ;275
00021a  d1f6              BNE      |L1.522|
;;;293    
;;;294      }
;;;295    
;;;296      /* Calculation of count for remaining q15_t data */
;;;297      tapCnt = (numTaps - 1u) % 0x4u;
00021c  9908              LDR      r1,[sp,#0x20]
00021e  f0010103          AND      r1,r1,#3
;;;298    
;;;299      /* copy data */
;;;300      while(tapCnt > 0u)
000222  e004              B        |L1.558|
                  |L1.548|
;;;301      {
;;;302        *pStateCurnt++ = *pState++;
000224  f8342b02          LDRH     r2,[r4],#2
000228  f8202b02          STRH     r2,[r0],#2
;;;303    
;;;304        /* Decrement the loop counter */
;;;305        tapCnt--;
00022c  1e49              SUBS     r1,r1,#1
                  |L1.558|
00022e  2900              CMP      r1,#0                 ;300
000230  d1f8              BNE      |L1.548|
;;;306      }
;;;307    
;;;308    #else
;;;309    
;;;310      /* Run the below code for Cortex-M0 */
;;;311    
;;;312      while(blkCnt > 0u)
;;;313      {
;;;314        /* Copy the new input sample into the state buffer */
;;;315        *pStateCurnt++ = *pSrc;
;;;316    
;;;317        /* Initialize pState pointer */
;;;318        px = pState;
;;;319    
;;;320        /* Initialize pCoeffs pointer */
;;;321        pb = pCoeffs;
;;;322    
;;;323        /* Read the sample from input buffer */
;;;324        in = *pSrc++;
;;;325    
;;;326        /* Update the energy calculation */
;;;327        energy -= (((q31_t) x0 * (x0)) >> 15);
;;;328        energy += (((q31_t) in * (in)) >> 15);
;;;329    
;;;330        /* Set the accumulator to zero */
;;;331        acc = 0;
;;;332    
;;;333        /* Loop over numTaps number of values */
;;;334        tapCnt = numTaps;
;;;335    
;;;336        while(tapCnt > 0u)
;;;337        {
;;;338          /* Perform the multiply-accumulate */
;;;339          acc += (((q31_t) * px++ * (*pb++)));
;;;340    
;;;341          /* Decrement the loop counter */
;;;342          tapCnt--;
;;;343        }
;;;344    
;;;345        /* Calc lower part of acc */
;;;346        acc_l = acc & 0xffffffff;
;;;347    
;;;348        /* Calc upper part of acc */
;;;349        acc_h = (acc >> 32) & 0xffffffff;
;;;350    
;;;351        /* Apply shift for lower part of acc and upper part of acc */
;;;352        acc = (uint32_t) acc_l >> lShift | acc_h << uShift;
;;;353    
;;;354        /* Converting the result to 1.15 format and saturate the output */
;;;355        acc = __SSAT(acc, 16u);
;;;356    
;;;357        /* Converting the result to 1.15 format */
;;;358        //acc = __SSAT((acc >> (16u - shift)), 16u); 
;;;359    
;;;360        /* Store the result from accumulator into the destination buffer. */
;;;361        *pOut++ = (q15_t) acc;
;;;362    
;;;363        /* Compute and store error */
;;;364        d = *pRef++;
;;;365        e = d - (q15_t) acc;
;;;366        *pErr++ = e;
;;;367    
;;;368        /* Calculation of 1/energy */
;;;369        postShift = arm_recip_q15((q15_t) energy + DELTA_Q15,
;;;370                                  &oneByEnergy, S->recipTable);
;;;371    
;;;372        /* Calculation of e * mu value */
;;;373        errorXmu = (q15_t) (((q31_t) e * mu) >> 15);
;;;374    
;;;375        /* Calculation of (e * mu) * (1/energy) value */
;;;376        acc = (((q31_t) errorXmu * oneByEnergy) >> (15 - postShift));
;;;377    
;;;378        /* Weighting factor for the normalized version */
;;;379        w = (q15_t) __SSAT((q31_t) acc, 16);
;;;380    
;;;381        /* Initialize pState pointer */
;;;382        px = pState;
;;;383    
;;;384        /* Initialize coeff pointer */
;;;385        pb = (pCoeffs);
;;;386    
;;;387        /* Loop over numTaps number of values */
;;;388        tapCnt = numTaps;
;;;389    
;;;390        while(tapCnt > 0u)
;;;391        {
;;;392          /* Perform the multiply-accumulate */
;;;393          coef = *pb + (((q31_t) w * (*px++)) >> 15);
;;;394          *pb++ = (q15_t) __SSAT((coef), 16);
;;;395    
;;;396          /* Decrement the loop counter */
;;;397          tapCnt--;
;;;398        }
;;;399    
;;;400        /* Read the sample from state buffer */
;;;401        x0 = *pState;
;;;402    
;;;403        /* Advance state pointer by 1 for the next sample */
;;;404        pState = pState + 1u;
;;;405    
;;;406        /* Decrement the loop counter */
;;;407        blkCnt--;
;;;408      }
;;;409    
;;;410      /* Save energy and x0 values for the next frame */
;;;411      S->energy = (q15_t) energy;
;;;412      S->x0 = x0;
;;;413    
;;;414      /* Processing is complete. Now copy the last numTaps - 1 samples to the        
;;;415         satrt of the state buffer. This prepares the state buffer for the        
;;;416         next function call. */
;;;417    
;;;418      /* Points to the start of the pState buffer */
;;;419      pStateCurnt = S->pState;
;;;420    
;;;421      /* copy (numTaps - 1u) data */
;;;422      tapCnt = (numTaps - 1u);
;;;423    
;;;424      /* copy data */
;;;425      while(tapCnt > 0u)
;;;426      {
;;;427        *pStateCurnt++ = *pState++;
;;;428    
;;;429        /* Decrement the loop counter */
;;;430        tapCnt--;
;;;431      }
;;;432    
;;;433    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;434    
;;;435    }
000232  b00d              ADD      sp,sp,#0x34
000234  e8bd8ff0          POP      {r4-r11,pc}
;;;436    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_lms_norm_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_lms_norm_q15_c_0f7c2473____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___18_arm_lms_norm_q15_c_0f7c2473____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_lms_norm_q15_c_0f7c2473____REVSH|
#line 144
|__asm___18_arm_lms_norm_q15_c_0f7c2473____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_lms_norm_q15_c_0f7c2473____RRX|
#line 300
|__asm___18_arm_lms_norm_q15_c_0f7c2473____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
