; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_partial_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_partial_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_conv_partial_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_partial_q31.c]
                          THUMB

                          AREA ||i.arm_conv_partial_q31||, CODE, READONLY, ALIGN=1

                  arm_conv_partial_q31 PROC
;;;65     
;;;66     arm_status arm_conv_partial_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;67       q31_t * pSrcA,
;;;68       uint32_t srcALen,
;;;69       q31_t * pSrcB,
;;;70       uint32_t srcBLen,
;;;71       q31_t * pDst,
;;;72       uint32_t firstIndex,
;;;73       uint32_t numPoints)
;;;74     {
000004  b089              SUB      sp,sp,#0x24
000006  e9dd7517          LDRD     r7,r5,[sp,#0x5c]
00000a  9c16              LDR      r4,[sp,#0x58]
;;;75     
;;;76     
;;;77     #ifndef ARM_MATH_CM0_FAMILY
;;;78     
;;;79       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;80     
;;;81       q31_t *pIn1;                                   /* inputA pointer               */
;;;82       q31_t *pIn2;                                   /* inputB pointer               */
;;;83       q31_t *pOut = pDst;                            /* output pointer               */
;;;84       q31_t *px;                                     /* Intermediate inputA pointer  */
;;;85       q31_t *py;                                     /* Intermediate inputB pointer  */
;;;86       q31_t *pSrc1, *pSrc2;                          /* Intermediate pointers        */
;;;87       q63_t sum, acc0, acc1, acc2;                   /* Accumulator                  */
;;;88       q31_t x0, x1, x2, c0;
;;;89       uint32_t j, k, count, check, blkCnt;
;;;90       int32_t blockSize1, blockSize2, blockSize3;    /* loop counter                 */
;;;91       arm_status status;                             /* status of Partial convolution */
;;;92     
;;;93     
;;;94       /* Check for range of output samples to be calculated */
;;;95       if((firstIndex + numPoints) > ((srcALen + (srcBLen - 1u))))
00000c  9e0a              LDR      r6,[sp,#0x28]
00000e  1979              ADDS     r1,r7,r5
000010  441e              ADD      r6,r6,r3
000012  1e76              SUBS     r6,r6,#1
000014  42b1              CMP      r1,r6
000016  d904              BLS      |L1.34|
;;;96       {
;;;97         /* Set status as ARM_MATH_ARGUMENT_ERROR */
;;;98         status = ARM_MATH_ARGUMENT_ERROR;
000018  f04f30ff          MOV      r0,#0xffffffff
                  |L1.28|
;;;99       }
;;;100      else
;;;101      {
;;;102    
;;;103        /* The algorithm implementation is based on the lengths of the inputs. */
;;;104        /* srcB is always made to slide across srcA. */
;;;105        /* So srcBLen is always considered as shorter or equal to srcALen */
;;;106        if(srcALen >= srcBLen)
;;;107        {
;;;108          /* Initialization of inputA pointer */
;;;109          pIn1 = pSrcA;
;;;110    
;;;111          /* Initialization of inputB pointer */
;;;112          pIn2 = pSrcB;
;;;113        }
;;;114        else
;;;115        {
;;;116          /* Initialization of inputA pointer */
;;;117          pIn1 = pSrcB;
;;;118    
;;;119          /* Initialization of inputB pointer */
;;;120          pIn2 = pSrcA;
;;;121    
;;;122          /* srcBLen is always considered as shorter or equal to srcALen */
;;;123          j = srcBLen;
;;;124          srcBLen = srcALen;
;;;125          srcALen = j;
;;;126        }
;;;127    
;;;128        /* Conditions to check which loopCounter holds    
;;;129         * the first and last indices of the output samples to be calculated. */
;;;130        check = firstIndex + numPoints;
;;;131        blockSize3 = ((int32_t)check > (int32_t)srcALen) ? (int32_t)check - (int32_t)srcALen : 0;
;;;132        blockSize3 = ((int32_t)firstIndex > (int32_t)srcALen - 1) ? blockSize3 - (int32_t)firstIndex + (int32_t)srcALen : blockSize3;
;;;133        blockSize1 = (((int32_t) srcBLen - 1) - (int32_t) firstIndex);
;;;134        blockSize1 = (blockSize1 > 0) ? ((check > (srcBLen - 1u)) ? blockSize1 :
;;;135                                         (int32_t) numPoints) : 0;
;;;136        blockSize2 = (int32_t) check - ((blockSize3 + blockSize1) +
;;;137                                        (int32_t) firstIndex);
;;;138        blockSize2 = (blockSize2 > 0) ? blockSize2 : 0;
;;;139    
;;;140        /* conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1] */
;;;141        /* The function is internally    
;;;142         * divided into three stages according to the number of multiplications that has to be    
;;;143         * taken place between inputA samples and inputB samples. In the first stage of the    
;;;144         * algorithm, the multiplications increase by one for every iteration.    
;;;145         * In the second stage of the algorithm, srcBLen number of multiplications are done.    
;;;146         * In the third stage of the algorithm, the multiplications decrease by one    
;;;147         * for every iteration. */
;;;148    
;;;149        /* Set the output pointer to point to the firstIndex    
;;;150         * of the output sample to be calculated. */
;;;151        pOut = pDst + firstIndex;
;;;152    
;;;153        /* --------------------------    
;;;154         * Initializations of stage1    
;;;155         * -------------------------*/
;;;156    
;;;157        /* sum = x[0] * y[0]    
;;;158         * sum = x[0] * y[1] + x[1] * y[0]    
;;;159         * ....    
;;;160         * sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]    
;;;161         */
;;;162    
;;;163        /* In this stage the MAC operations are increased by 1 for every iteration.    
;;;164           The count variable holds the number of MAC operations performed.    
;;;165           Since the partial convolution starts from firstIndex    
;;;166           Number of Macs to be performed is firstIndex + 1 */
;;;167        count = 1u + firstIndex;
;;;168    
;;;169        /* Working pointer of inputA */
;;;170        px = pIn1;
;;;171    
;;;172        /* Working pointer of inputB */
;;;173        pSrc2 = pIn2 + firstIndex;
;;;174        py = pSrc2;
;;;175    
;;;176        /* ------------------------    
;;;177         * Stage1 process    
;;;178         * ----------------------*/
;;;179    
;;;180        /* The first loop starts here */
;;;181        while(blockSize1 > 0)
;;;182        {
;;;183          /* Accumulator is made zero for every iteration */
;;;184          sum = 0;
;;;185    
;;;186          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;187          k = count >> 2u;
;;;188    
;;;189          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;190           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;191          while(k > 0u)
;;;192          {
;;;193            /* x[0] * y[srcBLen - 1] */
;;;194            sum += (q63_t) * px++ * (*py--);
;;;195            /* x[1] * y[srcBLen - 2] */
;;;196            sum += (q63_t) * px++ * (*py--);
;;;197            /* x[2] * y[srcBLen - 3] */
;;;198            sum += (q63_t) * px++ * (*py--);
;;;199            /* x[3] * y[srcBLen - 4] */
;;;200            sum += (q63_t) * px++ * (*py--);
;;;201    
;;;202            /* Decrement the loop counter */
;;;203            k--;
;;;204          }
;;;205    
;;;206          /* If the count is not a multiple of 4, compute any remaining MACs here.    
;;;207           ** No loop unrolling is used. */
;;;208          k = count % 0x4u;
;;;209    
;;;210          while(k > 0u)
;;;211          {
;;;212            /* Perform the multiply-accumulate */
;;;213            sum += (q63_t) * px++ * (*py--);
;;;214    
;;;215            /* Decrement the loop counter */
;;;216            k--;
;;;217          }
;;;218    
;;;219          /* Store the result in the accumulator in the destination buffer. */
;;;220          *pOut++ = (q31_t) (sum >> 31);
;;;221    
;;;222          /* Update the inputA and inputB pointers for next MAC calculation */
;;;223          py = ++pSrc2;
;;;224          px = pIn1;
;;;225    
;;;226          /* Increment the MAC count */
;;;227          count++;
;;;228    
;;;229          /* Decrement the loop counter */
;;;230          blockSize1--;
;;;231        }
;;;232    
;;;233        /* --------------------------    
;;;234         * Initializations of stage2    
;;;235         * ------------------------*/
;;;236    
;;;237        /* sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0]    
;;;238         * sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0]    
;;;239         * ....    
;;;240         * sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]    
;;;241         */
;;;242    
;;;243        /* Working pointer of inputA */
;;;244        if((int32_t)firstIndex - (int32_t)srcBLen + 1 > 0)
;;;245        {
;;;246          px = pIn1 + firstIndex - srcBLen + 1;
;;;247        }
;;;248        else
;;;249        {
;;;250          px = pIn1;
;;;251        }
;;;252    
;;;253        /* Working pointer of inputB */
;;;254        pSrc2 = pIn2 + (srcBLen - 1u);
;;;255        py = pSrc2;
;;;256    
;;;257        /* count is index by which the pointer pIn1 to be incremented */
;;;258        count = 0u;
;;;259    
;;;260        /* -------------------    
;;;261         * Stage2 process    
;;;262         * ------------------*/
;;;263    
;;;264        /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.    
;;;265         * So, to loop unroll over blockSize2,    
;;;266         * srcBLen should be greater than or equal to 4 */
;;;267        if(srcBLen >= 4u)
;;;268        {
;;;269          /* Loop unroll over blkCnt */
;;;270    
;;;271          blkCnt = blockSize2 / 3;
;;;272          while(blkCnt > 0u)
;;;273          {
;;;274            /* Set all accumulators to zero */
;;;275            acc0 = 0;
;;;276            acc1 = 0;
;;;277            acc2 = 0;
;;;278    
;;;279            /* read x[0], x[1] samples */
;;;280            x0 = *(px++);
;;;281            x1 = *(px++);
;;;282    
;;;283            /* Apply loop unrolling and compute 3 MACs simultaneously. */
;;;284            k = srcBLen / 3;
;;;285    
;;;286            /* First part of the processing with loop unrolling.  Compute 3 MACs at a time.        
;;;287             ** a second loop below computes MACs for the remaining 1 to 2 samples. */
;;;288            do
;;;289            {
;;;290              /* Read y[srcBLen - 1] sample */
;;;291              c0 = *(py);
;;;292    
;;;293              /* Read x[2] sample */
;;;294              x2 = *(px);
;;;295    
;;;296              /* Perform the multiply-accumulates */
;;;297              /* acc0 +=  x[0] * y[srcBLen - 1] */
;;;298              acc0 += (q63_t) x0 *c0;
;;;299              /* acc1 +=  x[1] * y[srcBLen - 1] */
;;;300              acc1 += (q63_t) x1 *c0;
;;;301              /* acc2 +=  x[2] * y[srcBLen - 1] */
;;;302              acc2 += (q63_t) x2 *c0;
;;;303    
;;;304              /* Read y[srcBLen - 2] sample */
;;;305              c0 = *(py - 1u);
;;;306    
;;;307              /* Read x[3] sample */
;;;308              x0 = *(px + 1u);
;;;309    
;;;310              /* Perform the multiply-accumulate */
;;;311              /* acc0 +=  x[1] * y[srcBLen - 2] */
;;;312              acc0 += (q63_t) x1 *c0;
;;;313              /* acc1 +=  x[2] * y[srcBLen - 2] */
;;;314              acc1 += (q63_t) x2 *c0;
;;;315              /* acc2 +=  x[3] * y[srcBLen - 2] */
;;;316              acc2 += (q63_t) x0 *c0;
;;;317    
;;;318              /* Read y[srcBLen - 3] sample */
;;;319              c0 = *(py - 2u);
;;;320    
;;;321              /* Read x[4] sample */
;;;322              x1 = *(px + 2u);
;;;323    
;;;324              /* Perform the multiply-accumulates */
;;;325              /* acc0 +=  x[2] * y[srcBLen - 3] */
;;;326              acc0 += (q63_t) x2 *c0;
;;;327              /* acc1 +=  x[3] * y[srcBLen - 2] */
;;;328              acc1 += (q63_t) x0 *c0;
;;;329              /* acc2 +=  x[4] * y[srcBLen - 2] */
;;;330              acc2 += (q63_t) x1 *c0;
;;;331    
;;;332    
;;;333              px += 3u;
;;;334    
;;;335              py -= 3u;
;;;336    
;;;337            } while(--k);
;;;338    
;;;339            /* If the srcBLen is not a multiple of 3, compute any remaining MACs here.        
;;;340             ** No loop unrolling is used. */
;;;341            k = srcBLen - (3 * (srcBLen / 3));
;;;342    
;;;343            while(k > 0u)
;;;344            {
;;;345              /* Read y[srcBLen - 5] sample */
;;;346              c0 = *(py--);
;;;347    
;;;348              /* Read x[7] sample */
;;;349              x2 = *(px++);
;;;350    
;;;351              /* Perform the multiply-accumulates */
;;;352              /* acc0 +=  x[4] * y[srcBLen - 5] */
;;;353              acc0 += (q63_t) x0 *c0;
;;;354              /* acc1 +=  x[5] * y[srcBLen - 5] */
;;;355              acc1 += (q63_t) x1 *c0;
;;;356              /* acc2 +=  x[6] * y[srcBLen - 5] */
;;;357              acc2 += (q63_t) x2 *c0;
;;;358    
;;;359              /* Reuse the present samples for the next MAC */
;;;360              x0 = x1;
;;;361              x1 = x2;
;;;362    
;;;363              /* Decrement the loop counter */
;;;364              k--;
;;;365            }
;;;366    
;;;367            /* Store the result in the accumulator in the destination buffer. */
;;;368            *pOut++ = (q31_t) (acc0 >> 31);
;;;369            *pOut++ = (q31_t) (acc1 >> 31);
;;;370            *pOut++ = (q31_t) (acc2 >> 31);
;;;371    
;;;372            /* Increment the pointer pIn1 index, count by 3 */
;;;373            count += 3u;
;;;374    
;;;375            /* Update the inputA and inputB pointers for next MAC calculation */
;;;376            px = pIn1 + count;
;;;377            py = pSrc2;
;;;378    
;;;379            /* Decrement the loop counter */
;;;380            blkCnt--;
;;;381          }
;;;382    
;;;383          /* If the blockSize2 is not a multiple of 3, compute any remaining output samples here.        
;;;384           ** No loop unrolling is used. */
;;;385          blkCnt = blockSize2 - 3 * (blockSize2 / 3);
;;;386    
;;;387          while(blkCnt > 0u)
;;;388          {
;;;389            /* Accumulator is made zero for every iteration */
;;;390            sum = 0;
;;;391    
;;;392            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;393            k = srcBLen >> 2u;
;;;394    
;;;395            /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;396             ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;397            while(k > 0u)
;;;398            {
;;;399              /* Perform the multiply-accumulates */
;;;400              sum += (q63_t) * px++ * (*py--);
;;;401              sum += (q63_t) * px++ * (*py--);
;;;402              sum += (q63_t) * px++ * (*py--);
;;;403              sum += (q63_t) * px++ * (*py--);
;;;404    
;;;405              /* Decrement the loop counter */
;;;406              k--;
;;;407            }
;;;408    
;;;409            /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.    
;;;410             ** No loop unrolling is used. */
;;;411            k = srcBLen % 0x4u;
;;;412    
;;;413            while(k > 0u)
;;;414            {
;;;415              /* Perform the multiply-accumulate */
;;;416              sum += (q63_t) * px++ * (*py--);
;;;417    
;;;418              /* Decrement the loop counter */
;;;419              k--;
;;;420            }
;;;421    
;;;422            /* Store the result in the accumulator in the destination buffer. */
;;;423            *pOut++ = (q31_t) (sum >> 31);
;;;424    
;;;425            /* Increment the MAC count */
;;;426            count++;
;;;427    
;;;428            /* Update the inputA and inputB pointers for next MAC calculation */
;;;429            px = pIn1 + count;
;;;430            py = pSrc2;
;;;431    
;;;432            /* Decrement the loop counter */
;;;433            blkCnt--;
;;;434          }
;;;435        }
;;;436        else
;;;437        {
;;;438          /* If the srcBLen is not a multiple of 4,    
;;;439           * the blockSize2 loop cannot be unrolled by 4 */
;;;440          blkCnt = (uint32_t) blockSize2;
;;;441    
;;;442          while(blkCnt > 0u)
;;;443          {
;;;444            /* Accumulator is made zero for every iteration */
;;;445            sum = 0;
;;;446    
;;;447            /* srcBLen number of MACS should be performed */
;;;448            k = srcBLen;
;;;449    
;;;450            while(k > 0u)
;;;451            {
;;;452              /* Perform the multiply-accumulate */
;;;453              sum += (q63_t) * px++ * (*py--);
;;;454    
;;;455              /* Decrement the loop counter */
;;;456              k--;
;;;457            }
;;;458    
;;;459            /* Store the result in the accumulator in the destination buffer. */
;;;460            *pOut++ = (q31_t) (sum >> 31);
;;;461    
;;;462            /* Increment the MAC count */
;;;463            count++;
;;;464    
;;;465            /* Update the inputA and inputB pointers for next MAC calculation */
;;;466            px = pIn1 + count;
;;;467            py = pSrc2;
;;;468    
;;;469            /* Decrement the loop counter */
;;;470            blkCnt--;
;;;471          }
;;;472        }
;;;473    
;;;474    
;;;475        /* --------------------------    
;;;476         * Initializations of stage3    
;;;477         * -------------------------*/
;;;478    
;;;479        /* sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1]    
;;;480         * sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2]    
;;;481         * ....    
;;;482         * sum +=  x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2]    
;;;483         * sum +=  x[srcALen-1] * y[srcBLen-1]    
;;;484         */
;;;485    
;;;486        /* In this stage the MAC operations are decreased by 1 for every iteration.    
;;;487           The blockSize3 variable holds the number of MAC operations performed */
;;;488        count = srcBLen - 1u;
;;;489    
;;;490        /* Working pointer of inputA */
;;;491        pSrc1 = (pIn1 + srcALen) - (srcBLen - 1u);
;;;492        px = pSrc1;
;;;493    
;;;494        /* Working pointer of inputB */
;;;495        pSrc2 = pIn2 + (srcBLen - 1u);
;;;496        py = pSrc2;
;;;497    
;;;498        /* -------------------    
;;;499         * Stage3 process    
;;;500         * ------------------*/
;;;501    
;;;502        while(blockSize3 > 0)
;;;503        {
;;;504          /* Accumulator is made zero for every iteration */
;;;505          sum = 0;
;;;506    
;;;507          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;508          k = count >> 2u;
;;;509    
;;;510          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;511           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;512          while(k > 0u)
;;;513          {
;;;514            sum += (q63_t) * px++ * (*py--);
;;;515            sum += (q63_t) * px++ * (*py--);
;;;516            sum += (q63_t) * px++ * (*py--);
;;;517            sum += (q63_t) * px++ * (*py--);
;;;518    
;;;519            /* Decrement the loop counter */
;;;520            k--;
;;;521          }
;;;522    
;;;523          /* If the blockSize3 is not a multiple of 4, compute any remaining MACs here.    
;;;524           ** No loop unrolling is used. */
;;;525          k = count % 0x4u;
;;;526    
;;;527          while(k > 0u)
;;;528          {
;;;529            /* Perform the multiply-accumulate */
;;;530            sum += (q63_t) * px++ * (*py--);
;;;531    
;;;532            /* Decrement the loop counter */
;;;533            k--;
;;;534          }
;;;535    
;;;536          /* Store the result in the accumulator in the destination buffer. */
;;;537          *pOut++ = (q31_t) (sum >> 31);
;;;538    
;;;539          /* Update the inputA and inputB pointers for next MAC calculation */
;;;540          px = ++pSrc1;
;;;541          py = pSrc2;
;;;542    
;;;543          /* Decrement the MAC count */
;;;544          count--;
;;;545    
;;;546          /* Decrement the loop counter */
;;;547          blockSize3--;
;;;548    
;;;549        }
;;;550    
;;;551        /* set status as ARM_MATH_SUCCESS */
;;;552        status = ARM_MATH_SUCCESS;
;;;553      }
;;;554    
;;;555      /* Return to application */
;;;556      return (status);
;;;557    
;;;558    #else
;;;559    
;;;560      /* Run the below code for Cortex-M0 */
;;;561    
;;;562      q31_t *pIn1 = pSrcA;                           /* inputA pointer */
;;;563      q31_t *pIn2 = pSrcB;                           /* inputB pointer */
;;;564      q63_t sum;                                     /* Accumulator */
;;;565      uint32_t i, j;                                 /* loop counters */
;;;566      arm_status status;                             /* status of Partial convolution */
;;;567    
;;;568      /* Check for range of output samples to be calculated */
;;;569      if((firstIndex + numPoints) > ((srcALen + (srcBLen - 1u))))
;;;570      {
;;;571        /* Set status as ARM_ARGUMENT_ERROR */
;;;572        status = ARM_MATH_ARGUMENT_ERROR;
;;;573      }
;;;574      else
;;;575      {
;;;576        /* Loop to calculate convolution for output length number of values */
;;;577        for (i = firstIndex; i <= (firstIndex + numPoints - 1); i++)
;;;578        {
;;;579          /* Initialize sum with zero to carry on MAC operations */
;;;580          sum = 0;
;;;581    
;;;582          /* Loop to perform MAC operations according to convolution equation */
;;;583          for (j = 0; j <= i; j++)
;;;584          {
;;;585            /* Check the array limitations */
;;;586            if(((i - j) < srcBLen) && (j < srcALen))
;;;587            {
;;;588              /* z[i] += x[i-j] * y[j] */
;;;589              sum += ((q63_t) pIn1[j] * (pIn2[i - j]));
;;;590            }
;;;591          }
;;;592    
;;;593          /* Store the output in the destination buffer */
;;;594          pDst[i] = (q31_t) (sum >> 31u);
;;;595        }
;;;596        /* set status as ARM_SUCCESS as there are no argument errors */
;;;597        status = ARM_MATH_SUCCESS;
;;;598      }
;;;599      return (status);
;;;600    
;;;601    #endif /*    #ifndef ARM_MATH_CM0_FAMILY      */
;;;602    
;;;603    }
00001c  b00d              ADD      sp,sp,#0x34
00001e  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.34|
000022  9e0a              LDR      r6,[sp,#0x28]         ;106
000024  429e              CMP      r6,r3                 ;106
000026  d301              BCC      |L1.44|
000028  9006              STR      r0,[sp,#0x18]         ;109
00002a  e004              B        |L1.54|
                  |L1.44|
00002c  9206              STR      r2,[sp,#0x18]         ;117
00002e  4602              MOV      r2,r0                 ;120
000030  4618              MOV      r0,r3                 ;123
000032  9b0a              LDR      r3,[sp,#0x28]         ;124
000034  900a              STR      r0,[sp,#0x28]         ;125
                  |L1.54|
000036  980a              LDR      r0,[sp,#0x28]         ;131
000038  4281              CMP      r1,r0                 ;131
00003a  dd02              BLE      |L1.66|
00003c  980a              LDR      r0,[sp,#0x28]         ;131
00003e  1a08              SUBS     r0,r1,r0              ;131
000040  e000              B        |L1.68|
                  |L1.66|
000042  2000              MOVS     r0,#0                 ;131
                  |L1.68|
000044  9e0a              LDR      r6,[sp,#0x28]         ;132
000046  1e76              SUBS     r6,r6,#1              ;132
000048  42b7              CMP      r7,r6                 ;132
00004a  dd02              BLE      |L1.82|
00004c  1bc6              SUBS     r6,r0,r7              ;132
00004e  980a              LDR      r0,[sp,#0x28]         ;132
000050  4430              ADD      r0,r0,r6              ;132
                  |L1.82|
000052  9000              STR      r0,[sp,#0]            ;132
000054  eba30a07          SUB      r10,r3,r7             ;133
000058  f1aa0a01          SUB      r10,r10,#1            ;133
00005c  f1ba0f00          CMP      r10,#0                ;134
000060  dd04              BLE      |L1.108|
000062  1e58              SUBS     r0,r3,#1              ;134
000064  4281              CMP      r1,r0                 ;134
000066  d803              BHI      |L1.112|
000068  46aa              MOV      r10,r5                ;135
00006a  e001              B        |L1.112|
                  |L1.108|
00006c  f04f0a00          MOV      r10,#0                ;135
                  |L1.112|
000070  9800              LDR      r0,[sp,#0]            ;136
000072  4450              ADD      r0,r0,r10             ;136
000074  4438              ADD      r0,r0,r7              ;136
000076  1a08              SUBS     r0,r1,r0              ;136
000078  2800              CMP      r0,#0                 ;138
00007a  dc00              BGT      |L1.126|
00007c  2000              MOVS     r0,#0                 ;138
                  |L1.126|
00007e  9001              STR      r0,[sp,#4]            ;138
000080  eb040c87          ADD      r12,r4,r7,LSL #2      ;151
000084  f1070901          ADD      r9,r7,#1              ;167
000088  f8dd8018          LDR      r8,[sp,#0x18]         ;170
00008c  eb020b87          ADD      r11,r2,r7,LSL #2      ;173
000090  4659              MOV      r1,r11                ;174
000092  e046              B        |L1.290|
                  |L1.148|
000094  2400              MOVS     r4,#0                 ;184
000096  4625              MOV      r5,r4                 ;184
000098  ea4f0699          LSR      r6,r9,#2              ;187
00009c  e022              B        |L1.228|
                  |L1.158|
00009e  390c              SUBS     r1,r1,#0xc            ;194
0000a0  f858eb04          LDR      lr,[r8],#4            ;194
0000a4  68c8              LDR      r0,[r1,#0xc]          ;194
0000a6  fb8e0e00          SMULL    r0,lr,lr,r0           ;194
0000aa  1904              ADDS     r4,r0,r4              ;194
0000ac  eb4e0505          ADC      r5,lr,r5              ;194
0000b0  f858eb04          LDR      lr,[r8],#4            ;196
0000b4  6888              LDR      r0,[r1,#8]            ;196
0000b6  fb8e0e00          SMULL    r0,lr,lr,r0           ;196
0000ba  1904              ADDS     r4,r0,r4              ;196
0000bc  eb4e0505          ADC      r5,lr,r5              ;196
0000c0  f858eb04          LDR      lr,[r8],#4            ;198
0000c4  6848              LDR      r0,[r1,#4]            ;198
0000c6  fb8e0e00          SMULL    r0,lr,lr,r0           ;198
0000ca  1904              ADDS     r4,r0,r4              ;198
0000cc  eb4e0505          ADC      r5,lr,r5              ;198
0000d0  f858eb04          LDR      lr,[r8],#4            ;200
0000d4  f8510904          LDR      r0,[r1],#-4           ;200
0000d8  fb8e0e00          SMULL    r0,lr,lr,r0           ;200
0000dc  1904              ADDS     r4,r0,r4              ;200
0000de  eb4e0505          ADC      r5,lr,r5              ;200
0000e2  1e76              SUBS     r6,r6,#1              ;203
                  |L1.228|
0000e4  2e00              CMP      r6,#0                 ;191
0000e6  d1da              BNE      |L1.158|
0000e8  f0090603          AND      r6,r9,#3              ;208
0000ec  e009              B        |L1.258|
                  |L1.238|
0000ee  f8580b04          LDR      r0,[r8],#4            ;213
0000f2  f851e904          LDR      lr,[r1],#-4           ;213
0000f6  fb800e0e          SMULL    r0,lr,r0,lr           ;213
0000fa  1904              ADDS     r4,r0,r4              ;213
0000fc  eb4e0505          ADC      r5,lr,r5              ;213
000100  1e76              SUBS     r6,r6,#1              ;216
                  |L1.258|
000102  2e00              CMP      r6,#0                 ;210
000104  d1f3              BNE      |L1.238|
000106  0fe0              LSRS     r0,r4,#31             ;220
000108  ea400045          ORR      r0,r0,r5,LSL #1       ;220
00010c  f84c0b04          STR      r0,[r12],#4           ;220
000110  f10b0104          ADD      r1,r11,#4             ;223
000114  468b              MOV      r11,r1                ;223
000116  f8dd8018          LDR      r8,[sp,#0x18]         ;224
00011a  f1090901          ADD      r9,r9,#1              ;227
00011e  f1aa0a01          SUB      r10,r10,#1            ;230
                  |L1.290|
000122  f1ba0f00          CMP      r10,#0                ;181
000126  dcb5              BGT      |L1.148|
000128  1af8              SUBS     r0,r7,r3              ;244
00012a  1c40              ADDS     r0,r0,#1              ;244
00012c  2800              CMP      r0,#0                 ;244
00012e  dd06              BLE      |L1.318|
000130  9806              LDR      r0,[sp,#0x18]         ;246
000132  eb000087          ADD      r0,r0,r7,LSL #2       ;246
000136  eba00883          SUB      r8,r0,r3,LSL #2       ;246
00013a  f1080804          ADD      r8,r8,#4              ;246
                  |L1.318|
00013e  1e58              SUBS     r0,r3,#1              ;254
000140  eb020280          ADD      r2,r2,r0,LSL #2       ;254
000144  e9cd2007          STRD     r2,r0,[sp,#0x1c]      ;254
000148  9205              STR      r2,[sp,#0x14]         ;254
00014a  9a05              LDR      r2,[sp,#0x14]         ;255
00014c  2000              MOVS     r0,#0                 ;258
00014e  9003              STR      r0,[sp,#0xc]          ;258
000150  2b04              CMP      r3,#4                 ;267
000152  d37d              BCC      |L1.592|
000154  9901              LDR      r1,[sp,#4]            ;271
000156  2003              MOVS     r0,#3                 ;271
000158  fb91f1f0          SDIV     r1,r1,r0              ;271
00015c  9102              STR      r1,[sp,#8]            ;271
00015e  e072              B        |L1.582|
                  |L1.352|
000160  2000              MOVS     r0,#0                 ;275
000162  4601              MOV      r1,r0                 ;275
000164  2400              MOVS     r4,#0                 ;276
000166  4625              MOV      r5,r4                 ;276
000168  2600              MOVS     r6,#0                 ;277
00016a  4637              MOV      r7,r6                 ;277
00016c  f858ab04          LDR      r10,[r8],#4           ;280
000170  f8589b04          LDR      r9,[r8],#4            ;281
000174  f04f0b03          MOV      r11,#3                ;284
000178  fbb3fbfb          UDIV     r11,r3,r11            ;284
00017c  f8cdb010          STR      r11,[sp,#0x10]        ;284
                  |L1.384|
000180  f8d2e000          LDR      lr,[r2,#0]            ;291
000184  f8d8b000          LDR      r11,[r8,#0]           ;294
000188  fbca010e          SMLAL    r0,r1,r10,lr          ;298
00018c  fbc9450e          SMLAL    r4,r5,r9,lr           ;300
000190  fbcb670e          SMLAL    r6,r7,r11,lr          ;302
000194  f852ec04          LDR      lr,[r2,#-4]           ;305
000198  f8d8a004          LDR      r10,[r8,#4]           ;308
00019c  fbc9010e          SMLAL    r0,r1,r9,lr           ;312
0001a0  fbcb450e          SMLAL    r4,r5,r11,lr          ;314
0001a4  fbca670e          SMLAL    r6,r7,r10,lr          ;316
0001a8  f852ec08          LDR      lr,[r2,#-8]           ;319
0001ac  f8d89008          LDR      r9,[r8,#8]            ;322
0001b0  fbcb010e          SMLAL    r0,r1,r11,lr          ;326
0001b4  fbca450e          SMLAL    r4,r5,r10,lr          ;328
0001b8  fbc9670e          SMLAL    r6,r7,r9,lr           ;330
0001bc  f108080c          ADD      r8,r8,#0xc            ;333
0001c0  3a0c              SUBS     r2,r2,#0xc            ;335
0001c2  f8ddb010          LDR      r11,[sp,#0x10]        ;337
0001c6  f1bb0b01          SUBS     r11,r11,#1            ;337
0001ca  f8cdb010          STR      r11,[sp,#0x10]        ;337
0001ce  d1d7              BNE      |L1.384|
0001d0  f04f0b03          MOV      r11,#3                ;341
0001d4  fbb3fbfb          UDIV     r11,r3,r11            ;341
0001d8  ebab0b8b          SUB      r11,r11,r11,LSL #2    ;341
0001dc  449b              ADD      r11,r11,r3            ;341
0001de  f8cdb010          STR      r11,[sp,#0x10]        ;341
0001e2  e011              B        |L1.520|
                  |L1.484|
0001e4  f852e904          LDR      lr,[r2],#-4           ;346
0001e8  f858bb04          LDR      r11,[r8],#4           ;349
0001ec  fbca010e          SMLAL    r0,r1,r10,lr          ;353
0001f0  fbc9450e          SMLAL    r4,r5,r9,lr           ;355
0001f4  fbcb670e          SMLAL    r6,r7,r11,lr          ;357
0001f8  46ca              MOV      r10,r9                ;360
0001fa  46d9              MOV      r9,r11                ;361
0001fc  f8ddb010          LDR      r11,[sp,#0x10]        ;364
000200  f1ab0b01          SUB      r11,r11,#1            ;364
000204  f8cdb010          STR      r11,[sp,#0x10]        ;364
                  |L1.520|
000208  f8ddb010          LDR      r11,[sp,#0x10]        ;343
00020c  f1bb0f00          CMP      r11,#0                ;343
000210  d1e8              BNE      |L1.484|
000212  0fc0              LSRS     r0,r0,#31             ;368
000214  ea400041          ORR      r0,r0,r1,LSL #1       ;368
000218  f84c0b04          STR      r0,[r12],#4           ;368
00021c  0fe0              LSRS     r0,r4,#31             ;369
00021e  ea400045          ORR      r0,r0,r5,LSL #1       ;369
000222  f84c0b04          STR      r0,[r12],#4           ;369
000226  0ff0              LSRS     r0,r6,#31             ;370
000228  ea400047          ORR      r0,r0,r7,LSL #1       ;370
00022c  f84c0b04          STR      r0,[r12],#4           ;370
000230  9803              LDR      r0,[sp,#0xc]          ;373
000232  1cc0              ADDS     r0,r0,#3              ;373
000234  9003              STR      r0,[sp,#0xc]          ;373
000236  9903              LDR      r1,[sp,#0xc]          ;376
000238  9806              LDR      r0,[sp,#0x18]         ;376
00023a  eb000881          ADD      r8,r0,r1,LSL #2       ;376
00023e  9a05              LDR      r2,[sp,#0x14]         ;377
000240  9802              LDR      r0,[sp,#8]            ;380
000242  1e40              SUBS     r0,r0,#1              ;380
000244  9002              STR      r0,[sp,#8]            ;380
                  |L1.582|
000246  9802              LDR      r0,[sp,#8]            ;272
000248  2800              CMP      r0,#0                 ;272
00024a  d189              BNE      |L1.352|
00024c  2103              MOVS     r1,#3                 ;385
00024e  e000              B        |L1.594|
                  |L1.592|
000250  e04b              B        |L1.746|
                  |L1.594|
000252  9801              LDR      r0,[sp,#4]            ;385
000254  fb90f0f1          SDIV     r0,r0,r1              ;385
000258  eba00180          SUB      r1,r0,r0,LSL #2       ;385
00025c  9801              LDR      r0,[sp,#4]            ;385
00025e  4401              ADD      r1,r1,r0              ;385
000260  e040              B        |L1.740|
                  |L1.610|
000262  2400              MOVS     r4,#0                 ;390
000264  4625              MOV      r5,r4                 ;390
000266  0898              LSRS     r0,r3,#2              ;393
000268  e01e              B        |L1.680|
                  |L1.618|
00026a  3a0c              SUBS     r2,r2,#0xc            ;400
00026c  f8586b04          LDR      r6,[r8],#4            ;400
000270  68d7              LDR      r7,[r2,#0xc]          ;400
000272  fb867607          SMULL    r7,r6,r6,r7           ;400
000276  193c              ADDS     r4,r7,r4              ;400
000278  4175              ADCS     r5,r5,r6              ;400
00027a  f8586b04          LDR      r6,[r8],#4            ;401
00027e  6897              LDR      r7,[r2,#8]            ;401
000280  fb867607          SMULL    r7,r6,r6,r7           ;401
000284  193c              ADDS     r4,r7,r4              ;401
000286  4175              ADCS     r5,r5,r6              ;401
000288  f8586b04          LDR      r6,[r8],#4            ;402
00028c  6857              LDR      r7,[r2,#4]            ;402
00028e  fb867607          SMULL    r7,r6,r6,r7           ;402
000292  193c              ADDS     r4,r7,r4              ;402
000294  4175              ADCS     r5,r5,r6              ;402
000296  f8586b04          LDR      r6,[r8],#4            ;403
00029a  f8527904          LDR      r7,[r2],#-4           ;403
00029e  fb867607          SMULL    r7,r6,r6,r7           ;403
0002a2  193c              ADDS     r4,r7,r4              ;403
0002a4  4175              ADCS     r5,r5,r6              ;403
0002a6  1e40              SUBS     r0,r0,#1              ;406
                  |L1.680|
0002a8  2800              CMP      r0,#0                 ;397
0002aa  d1de              BNE      |L1.618|
0002ac  f0030003          AND      r0,r3,#3              ;411
0002b0  e008              B        |L1.708|
                  |L1.690|
0002b2  f8586b04          LDR      r6,[r8],#4            ;416
0002b6  f8527904          LDR      r7,[r2],#-4           ;416
0002ba  fb867607          SMULL    r7,r6,r6,r7           ;416
0002be  193c              ADDS     r4,r7,r4              ;416
0002c0  4175              ADCS     r5,r5,r6              ;416
0002c2  1e40              SUBS     r0,r0,#1              ;419
                  |L1.708|
0002c4  2800              CMP      r0,#0                 ;413
0002c6  d1f4              BNE      |L1.690|
0002c8  0fe0              LSRS     r0,r4,#31             ;423
0002ca  ea400045          ORR      r0,r0,r5,LSL #1       ;423
0002ce  f84c0b04          STR      r0,[r12],#4           ;423
0002d2  9803              LDR      r0,[sp,#0xc]          ;426
0002d4  1c40              ADDS     r0,r0,#1              ;426
0002d6  9003              STR      r0,[sp,#0xc]          ;426
0002d8  9a03              LDR      r2,[sp,#0xc]          ;429
0002da  9806              LDR      r0,[sp,#0x18]         ;429
0002dc  eb000882          ADD      r8,r0,r2,LSL #2       ;429
0002e0  9a05              LDR      r2,[sp,#0x14]         ;430
0002e2  1e49              SUBS     r1,r1,#1              ;433
                  |L1.740|
0002e4  2900              CMP      r1,#0                 ;387
0002e6  d1bc              BNE      |L1.610|
0002e8  e020              B        |L1.812|
                  |L1.746|
0002ea  9901              LDR      r1,[sp,#4]            ;440
0002ec  e01c              B        |L1.808|
                  |L1.750|
0002ee  2400              MOVS     r4,#0                 ;445
0002f0  4625              MOV      r5,r4                 ;445
0002f2  4618              MOV      r0,r3                 ;448
0002f4  e008              B        |L1.776|
                  |L1.758|
0002f6  f8586b04          LDR      r6,[r8],#4            ;453
0002fa  f8527904          LDR      r7,[r2],#-4           ;453
0002fe  fb867607          SMULL    r7,r6,r6,r7           ;453
000302  193c              ADDS     r4,r7,r4              ;453
000304  4175              ADCS     r5,r5,r6              ;453
000306  1e40              SUBS     r0,r0,#1              ;456
                  |L1.776|
000308  2800              CMP      r0,#0                 ;450
00030a  d1f4              BNE      |L1.758|
00030c  0fe0              LSRS     r0,r4,#31             ;460
00030e  ea400045          ORR      r0,r0,r5,LSL #1       ;460
000312  f84c0b04          STR      r0,[r12],#4           ;460
000316  9803              LDR      r0,[sp,#0xc]          ;463
000318  1c40              ADDS     r0,r0,#1              ;463
00031a  9003              STR      r0,[sp,#0xc]          ;463
00031c  9a03              LDR      r2,[sp,#0xc]          ;466
00031e  9806              LDR      r0,[sp,#0x18]         ;466
000320  eb000882          ADD      r8,r0,r2,LSL #2       ;466
000324  9a05              LDR      r2,[sp,#0x14]         ;467
000326  1e49              SUBS     r1,r1,#1              ;470
                  |L1.808|
000328  2900              CMP      r1,#0                 ;442
00032a  d1e0              BNE      |L1.750|
                  |L1.812|
00032c  1e5b              SUBS     r3,r3,#1              ;488
00032e  990a              LDR      r1,[sp,#0x28]         ;491
000330  9806              LDR      r0,[sp,#0x18]         ;491
000332  eb000181          ADD      r1,r0,r1,LSL #2       ;491
000336  9808              LDR      r0,[sp,#0x20]         ;491
000338  eba10680          SUB      r6,r1,r0,LSL #2       ;491
00033c  4630              MOV      r0,r6                 ;492
00033e  9f07              LDR      r7,[sp,#0x1c]         ;495
000340  4639              MOV      r1,r7                 ;496
000342  e04a              B        |L1.986|
                  |L1.836|
000344  2400              MOVS     r4,#0                 ;505
000346  4625              MOV      r5,r4                 ;505
000348  089a              LSRS     r2,r3,#2              ;508
00034a  e028              B        |L1.926|
                  |L1.844|
00034c  f8508b04          LDR      r8,[r0],#4            ;514
000350  f8519904          LDR      r9,[r1],#-4           ;514
000354  fb889809          SMULL    r9,r8,r8,r9           ;514
000358  eb190404          ADDS     r4,r9,r4              ;514
00035c  eb480505          ADC      r5,r8,r5              ;514
000360  f8508b04          LDR      r8,[r0],#4            ;515
000364  f8519904          LDR      r9,[r1],#-4           ;515
000368  fb889809          SMULL    r9,r8,r8,r9           ;515
00036c  eb190404          ADDS     r4,r9,r4              ;515
000370  eb480505          ADC      r5,r8,r5              ;515
000374  f8508b04          LDR      r8,[r0],#4            ;516
000378  f8519904          LDR      r9,[r1],#-4           ;516
00037c  fb889809          SMULL    r9,r8,r8,r9           ;516
000380  eb190404          ADDS     r4,r9,r4              ;516
000384  eb480505          ADC      r5,r8,r5              ;516
000388  f8508b04          LDR      r8,[r0],#4            ;517
00038c  f8519904          LDR      r9,[r1],#-4           ;517
000390  fb889809          SMULL    r9,r8,r8,r9           ;517
000394  eb190404          ADDS     r4,r9,r4              ;517
000398  eb480505          ADC      r5,r8,r5              ;517
00039c  1e52              SUBS     r2,r2,#1              ;520
                  |L1.926|
00039e  2a00              CMP      r2,#0                 ;512
0003a0  d1d4              BNE      |L1.844|
0003a2  f0030203          AND      r2,r3,#3              ;525
0003a6  e00a              B        |L1.958|
                  |L1.936|
0003a8  f8508b04          LDR      r8,[r0],#4            ;530
0003ac  f8519904          LDR      r9,[r1],#-4           ;530
0003b0  fb889809          SMULL    r9,r8,r8,r9           ;530
0003b4  eb190404          ADDS     r4,r9,r4              ;530
0003b8  eb480505          ADC      r5,r8,r5              ;530
0003bc  1e52              SUBS     r2,r2,#1              ;533
                  |L1.958|
0003be  2a00              CMP      r2,#0                 ;527
0003c0  d1f2              BNE      |L1.936|
0003c2  0fe0              LSRS     r0,r4,#31             ;537
0003c4  ea400045          ORR      r0,r0,r5,LSL #1       ;537
0003c8  f84c0b04          STR      r0,[r12],#4           ;537
0003cc  1d30              ADDS     r0,r6,#4              ;540
0003ce  4606              MOV      r6,r0                 ;540
0003d0  4639              MOV      r1,r7                 ;541
0003d2  1e5b              SUBS     r3,r3,#1              ;544
0003d4  9a00              LDR      r2,[sp,#0]            ;547
0003d6  1e52              SUBS     r2,r2,#1              ;547
0003d8  9200              STR      r2,[sp,#0]            ;547
                  |L1.986|
0003da  9a00              LDR      r2,[sp,#0]            ;502
0003dc  2a00              CMP      r2,#0                 ;502
0003de  dcb1              BGT      |L1.836|
0003e0  2000              MOVS     r0,#0                 ;552
0003e2  e61b              B        |L1.28|
;;;604    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_partial_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_conv_partial_q31_c_105a42e8____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___22_arm_conv_partial_q31_c_105a42e8____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_conv_partial_q31_c_105a42e8____REVSH|
#line 144
|__asm___22_arm_conv_partial_q31_c_105a42e8____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_conv_partial_q31_c_105a42e8____RRX|
#line 300
|__asm___22_arm_conv_partial_q31_c_105a42e8____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
