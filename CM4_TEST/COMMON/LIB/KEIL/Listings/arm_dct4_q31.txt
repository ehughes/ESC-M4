; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_dct4_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_dct4_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_dct4_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\TransformFunctions\arm_dct4_q31.c]
                          THUMB

                          AREA ||i.arm_dct4_q31||, CODE, READONLY, ALIGN=1

                  arm_dct4_q31 PROC
;;;63     
;;;64     void arm_dct4_q31(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;65       const arm_dct4_instance_q31 * S,
;;;66       q31_t * pState,
;;;67       q31_t * pInlineBuffer)
;;;68     {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;69       uint16_t i;                                    /* Loop counter */
;;;70       q31_t *weights = S->pTwiddle;                  /* Pointer to the Weights table */
00000a  f8d48008          LDR      r8,[r4,#8]
;;;71       q31_t *cosFact = S->pCosFactor;                /* Pointer to the cos factors table */
00000e  68e1              LDR      r1,[r4,#0xc]
;;;72       q31_t *pS1, *pS2, *pbuff;                      /* Temporary pointers for input buffer and pState buffer */
;;;73       q31_t in;                                      /* Temporary variable */
;;;74     
;;;75     
;;;76       /* DCT4 computation involves DCT2 (which is calculated using RFFT)    
;;;77        * along with some pre-processing and post-processing.    
;;;78        * Computational procedure is explained as follows:    
;;;79        * (a) Pre-processing involves multiplying input with cos factor,    
;;;80        *     r(n) = 2 * u(n) * cos(pi*(2*n+1)/(4*n))    
;;;81        *              where,    
;;;82        *                 r(n) -- output of preprocessing    
;;;83        *                 u(n) -- input to preprocessing(actual Source buffer)    
;;;84        * (b) Calculation of DCT2 using FFT is divided into three steps:    
;;;85        *                  Step1: Re-ordering of even and odd elements of input.    
;;;86        *                  Step2: Calculating FFT of the re-ordered input.    
;;;87        *                  Step3: Taking the real part of the product of FFT output and weights.    
;;;88        * (c) Post-processing - DCT4 can be obtained from DCT2 output using the following equation:    
;;;89        *                   Y4(k) = Y2(k) - Y4(k-1) and Y4(-1) = Y4(0)    
;;;90        *                        where,    
;;;91        *                           Y4 -- DCT4 output,   Y2 -- DCT2 output    
;;;92        * (d) Multiplying the output with the normalizing factor sqrt(2/N).    
;;;93        */
;;;94     
;;;95             /*-------- Pre-processing ------------*/
;;;96       /* Multiplying input with cos factor i.e. r(n) = 2 * x(n) * cos(pi*(2*n+1)/(4*n)) */
;;;97       arm_mult_q31(pInlineBuffer, cosFact, pInlineBuffer, S->N);
000010  8823              LDRH     r3,[r4,#0]
000012  4632              MOV      r2,r6
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       arm_mult_q31
;;;98       arm_shift_q31(pInlineBuffer, 1, pInlineBuffer, S->N);
00001a  8823              LDRH     r3,[r4,#0]
00001c  4632              MOV      r2,r6
00001e  2101              MOVS     r1,#1
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       arm_shift_q31
;;;99     
;;;100      /* ----------------------------------------------------------------    
;;;101       * Step1: Re-ordering of even and odd elements as    
;;;102       *             pState[i] =  pInlineBuffer[2*i] and    
;;;103       *             pState[N-i-1] = pInlineBuffer[2*i+1] where i = 0 to N/2    
;;;104       ---------------------------------------------------------------------*/
;;;105    
;;;106      /* pS1 initialized to pState */
;;;107      pS1 = pState;
;;;108    
;;;109      /* pS2 initialized to pState+N-1, so that it points to the end of the state buffer */
;;;110      pS2 = pState + (S->N - 1u);
000026  8820              LDRH     r0,[r4,#0]
000028  463d              MOV      r5,r7
00002a  1e40              SUBS     r0,r0,#1
00002c  eb070080          ADD      r0,r7,r0,LSL #2
;;;111    
;;;112      /* pbuff initialized to input buffer */
;;;113      pbuff = pInlineBuffer;
000030  4632              MOV      r2,r6
;;;114    
;;;115    #ifndef ARM_MATH_CM0_FAMILY
;;;116    
;;;117      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;118    
;;;119      /* Initializing the loop counter to N/2 >> 2 for loop unrolling by 4 */
;;;120      i = S->Nby2 >> 2u;
000032  8861              LDRH     r1,[r4,#2]
000034  0889              LSRS     r1,r1,#2
                  |L1.54|
;;;121    
;;;122      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;123       ** a second loop below computes the remaining 1 to 3 samples. */
;;;124      do
;;;125      {
;;;126        /* Re-ordering of even and odd elements */
;;;127        /* pState[i] =  pInlineBuffer[2*i] */
;;;128        *pS1++ = *pbuff++;
000036  6813              LDR      r3,[r2,#0]
000038  602b              STR      r3,[r5,#0]
;;;129        /* pState[N-i-1] = pInlineBuffer[2*i+1] */
;;;130        *pS2-- = *pbuff++;
00003a  380c              SUBS     r0,r0,#0xc
00003c  6853              LDR      r3,[r2,#4]
00003e  60c3              STR      r3,[r0,#0xc]
;;;131    
;;;132        *pS1++ = *pbuff++;
000040  6893              LDR      r3,[r2,#8]
000042  606b              STR      r3,[r5,#4]
;;;133        *pS2-- = *pbuff++;
000044  68d3              LDR      r3,[r2,#0xc]
000046  6083              STR      r3,[r0,#8]
;;;134    
;;;135        *pS1++ = *pbuff++;
000048  6913              LDR      r3,[r2,#0x10]
00004a  60ab              STR      r3,[r5,#8]
;;;136        *pS2-- = *pbuff++;
00004c  6953              LDR      r3,[r2,#0x14]
00004e  6043              STR      r3,[r0,#4]
;;;137    
;;;138        *pS1++ = *pbuff++;
000050  6993              LDR      r3,[r2,#0x18]
000052  60eb              STR      r3,[r5,#0xc]
000054  3510              ADDS     r5,r5,#0x10
;;;139        *pS2-- = *pbuff++;
000056  69d3              LDR      r3,[r2,#0x1c]
000058  3220              ADDS     r2,r2,#0x20
00005a  f8403904          STR      r3,[r0],#-4
;;;140    
;;;141        /* Decrement the loop counter */
;;;142        i--;
00005e  1e49              SUBS     r1,r1,#1
000060  b289              UXTH     r1,r1
;;;143      } while(i > 0u);
000062  2900              CMP      r1,#0
000064  d1e7              BNE      |L1.54|
;;;144    
;;;145      /* pbuff initialized to input buffer */
;;;146      pbuff = pInlineBuffer;
000066  4631              MOV      r1,r6
;;;147    
;;;148      /* pS1 initialized to pState */
;;;149      pS1 = pState;
000068  4638              MOV      r0,r7
;;;150    
;;;151      /* Initializing the loop counter to N/4 instead of N for loop unrolling */
;;;152      i = S->N >> 2u;
00006a  8822              LDRH     r2,[r4,#0]
00006c  0892              LSRS     r2,r2,#2
                  |L1.110|
;;;153    
;;;154      /* Processing with loop unrolling 4 times as N is always multiple of 4.    
;;;155       * Compute 4 outputs at a time */
;;;156      do
;;;157      {
;;;158        /* Writing the re-ordered output back to inplace input buffer */
;;;159        *pbuff++ = *pS1++;
00006e  6803              LDR      r3,[r0,#0]
000070  600b              STR      r3,[r1,#0]
;;;160        *pbuff++ = *pS1++;
000072  6843              LDR      r3,[r0,#4]
000074  604b              STR      r3,[r1,#4]
;;;161        *pbuff++ = *pS1++;
000076  6883              LDR      r3,[r0,#8]
000078  608b              STR      r3,[r1,#8]
;;;162        *pbuff++ = *pS1++;
00007a  68c3              LDR      r3,[r0,#0xc]
00007c  3010              ADDS     r0,r0,#0x10
00007e  60cb              STR      r3,[r1,#0xc]
000080  3110              ADDS     r1,r1,#0x10
;;;163    
;;;164        /* Decrement the loop counter */
;;;165        i--;
000082  1e52              SUBS     r2,r2,#1
000084  b292              UXTH     r2,r2
;;;166      } while(i > 0u);
000086  2a00              CMP      r2,#0
000088  d1f1              BNE      |L1.110|
;;;167    
;;;168    
;;;169      /* ---------------------------------------------------------    
;;;170       *     Step2: Calculate RFFT for N-point input    
;;;171       * ---------------------------------------------------------- */
;;;172      /* pInlineBuffer is real input of length N , pState is the complex output of length 2N */
;;;173      arm_rfft_q31(S->pRfft, pInlineBuffer, pState);
00008a  463a              MOV      r2,r7
00008c  4631              MOV      r1,r6
00008e  6920              LDR      r0,[r4,#0x10]
000090  f7fffffe          BL       arm_rfft_q31
;;;174    
;;;175      /*----------------------------------------------------------------------    
;;;176       *  Step3: Multiply the FFT output with the weights.    
;;;177       *----------------------------------------------------------------------*/
;;;178      arm_cmplx_mult_cmplx_q31(pState, weights, pState, S->N);
000094  8823              LDRH     r3,[r4,#0]
000096  463a              MOV      r2,r7
000098  4641              MOV      r1,r8
00009a  4638              MOV      r0,r7
00009c  f7fffffe          BL       arm_cmplx_mult_cmplx_q31
;;;179    
;;;180      /* The output of complex multiplication is in 3.29 format.    
;;;181       * Hence changing the format of N (i.e. 2*N elements) complex numbers to 1.31 format by shifting left by 2 bits. */
;;;182      arm_shift_q31(pState, 2, pState, S->N * 2);
0000a0  8820              LDRH     r0,[r4,#0]
0000a2  463a              MOV      r2,r7
0000a4  0043              LSLS     r3,r0,#1
0000a6  2102              MOVS     r1,#2
0000a8  4638              MOV      r0,r7
0000aa  f7fffffe          BL       arm_shift_q31
;;;183    
;;;184      /* ----------- Post-processing ---------- */
;;;185      /* DCT-IV can be obtained from DCT-II by the equation,    
;;;186       *       Y4(k) = Y2(k) - Y4(k-1) and Y4(-1) = Y4(0)    
;;;187       *       Hence, Y4(0) = Y2(0)/2  */
;;;188      /* Getting only real part from the output and Converting to DCT-IV */
;;;189    
;;;190      /* Initializing the loop counter to N >> 2 for loop unrolling by 4 */
;;;191      i = (S->N - 1u) >> 2u;
0000ae  8820              LDRH     r0,[r4,#0]
0000b0  1e40              SUBS     r0,r0,#1
0000b2  f3c0028f          UBFX     r2,r0,#2,#16
;;;192    
;;;193      /* pbuff initialized to input buffer. */
;;;194      pbuff = pInlineBuffer;
0000b6  4631              MOV      r1,r6
;;;195    
;;;196      /* pS1 initialized to pState */
;;;197      pS1 = pState;
;;;198    
;;;199      /* Calculating Y4(0) from Y2(0) using Y4(0) = Y2(0)/2 */
;;;200      in = *pS1++ >> 1u;
0000b8  cf01              LDM      r7!,{r0}
0000ba  1040              ASRS     r0,r0,#1
;;;201      /* input buffer acts as inplace, so output values are stored in the input itself. */
;;;202      *pbuff++ = in;
0000bc  c101              STM      r1!,{r0}
;;;203    
;;;204      /* pState pointer is incremented twice as the real values are located alternatively in the array */
;;;205      pS1++;
0000be  1d3f              ADDS     r7,r7,#4
                  |L1.192|
;;;206    
;;;207      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;208       ** a second loop below computes the remaining 1 to 3 samples. */
;;;209      do
;;;210      {
;;;211        /* Calculating Y4(1) to Y4(N-1) from Y2 using equation Y4(k) = Y2(k) - Y4(k-1) */
;;;212        /* pState pointer (pS1) is incremented twice as the real values are located alternatively in the array */
;;;213        in = *pS1++ - in;
0000c0  683b              LDR      r3,[r7,#0]
0000c2  1a18              SUBS     r0,r3,r0
;;;214        *pbuff++ = in;
0000c4  6008              STR      r0,[r1,#0]
;;;215        /* points to the next real value */
;;;216        pS1++;
;;;217    
;;;218        in = *pS1++ - in;
0000c6  68bb              LDR      r3,[r7,#8]
0000c8  1a18              SUBS     r0,r3,r0
;;;219        *pbuff++ = in;
0000ca  6048              STR      r0,[r1,#4]
;;;220        pS1++;
;;;221    
;;;222        in = *pS1++ - in;
0000cc  693b              LDR      r3,[r7,#0x10]
0000ce  1a18              SUBS     r0,r3,r0
;;;223        *pbuff++ = in;
0000d0  6088              STR      r0,[r1,#8]
;;;224        pS1++;
;;;225    
;;;226        in = *pS1++ - in;
0000d2  69bb              LDR      r3,[r7,#0x18]
0000d4  371c              ADDS     r7,r7,#0x1c
0000d6  1a18              SUBS     r0,r3,r0
;;;227        *pbuff++ = in;
0000d8  60c8              STR      r0,[r1,#0xc]
0000da  3110              ADDS     r1,r1,#0x10
;;;228        pS1++;
0000dc  1d3f              ADDS     r7,r7,#4
;;;229    
;;;230        /* Decrement the loop counter */
;;;231        i--;
0000de  1e52              SUBS     r2,r2,#1
0000e0  b292              UXTH     r2,r2
;;;232      } while(i > 0u);
0000e2  2a00              CMP      r2,#0
0000e4  d1ec              BNE      |L1.192|
;;;233    
;;;234      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;235       ** No loop unrolling is used. */
;;;236      i = (S->N - 1u) % 0x4u;
0000e6  7822              LDRB     r2,[r4,#0]
0000e8  1e52              SUBS     r2,r2,#1
0000ea  f0020203          AND      r2,r2,#3
;;;237    
;;;238      while(i > 0u)
0000ee  e005              B        |L1.252|
                  |L1.240|
;;;239      {
;;;240        /* Calculating Y4(1) to Y4(N-1) from Y2 using equation Y4(k) = Y2(k) - Y4(k-1) */
;;;241        /* pState pointer (pS1) is incremented twice as the real values are located alternatively in the array */
;;;242        in = *pS1++ - in;
0000f0  cf08              LDM      r7!,{r3}
0000f2  1a18              SUBS     r0,r3,r0
;;;243        *pbuff++ = in;
0000f4  c101              STM      r1!,{r0}
;;;244        /* points to the next real value */
;;;245        pS1++;
0000f6  1d3f              ADDS     r7,r7,#4
;;;246    
;;;247        /* Decrement the loop counter */
;;;248        i--;
0000f8  1e52              SUBS     r2,r2,#1
0000fa  b292              UXTH     r2,r2
                  |L1.252|
0000fc  2a00              CMP      r2,#0                 ;238
0000fe  d1f7              BNE      |L1.240|
;;;249      }
;;;250    
;;;251    
;;;252            /*------------ Normalizing the output by multiplying with the normalizing factor ----------*/
;;;253    
;;;254      /* Initializing the loop counter to N/4 instead of N for loop unrolling */
;;;255      i = S->N >> 2u;
000100  8820              LDRH     r0,[r4,#0]
000102  0880              LSRS     r0,r0,#2
                  |L1.260|
;;;256    
;;;257      /* pbuff initialized to the pInlineBuffer(now contains the output values) */
;;;258      pbuff = pInlineBuffer;
;;;259    
;;;260      /* Processing with loop unrolling 4 times as N is always multiple of 4.  Compute 4 outputs at a time */
;;;261      do
;;;262      {
;;;263        /* Multiplying pInlineBuffer with the normalizing factor sqrt(2/N) */
;;;264        in = *pbuff;
000104  6831              LDR      r1,[r6,#0]
;;;265        *pbuff++ = ((q31_t) (((q63_t) in * S->normalize) >> 31));
000106  6862              LDR      r2,[r4,#4]
000108  fb811202          SMULL    r1,r2,r1,r2
00010c  0fc9              LSRS     r1,r1,#31
00010e  ea410142          ORR      r1,r1,r2,LSL #1
000112  6031              STR      r1,[r6,#0]
;;;266    
;;;267        in = *pbuff;
000114  6871              LDR      r1,[r6,#4]
;;;268        *pbuff++ = ((q31_t) (((q63_t) in * S->normalize) >> 31));
000116  6862              LDR      r2,[r4,#4]
000118  fb811202          SMULL    r1,r2,r1,r2
00011c  0fc9              LSRS     r1,r1,#31
00011e  ea410142          ORR      r1,r1,r2,LSL #1
000122  6071              STR      r1,[r6,#4]
;;;269    
;;;270        in = *pbuff;
000124  68b1              LDR      r1,[r6,#8]
;;;271        *pbuff++ = ((q31_t) (((q63_t) in * S->normalize) >> 31));
000126  6862              LDR      r2,[r4,#4]
000128  fb812102          SMULL    r2,r1,r1,r2
00012c  004b              LSLS     r3,r1,#1
00012e  ea4371d2          ORR      r1,r3,r2,LSR #31
000132  60b1              STR      r1,[r6,#8]
;;;272    
;;;273        in = *pbuff;
000134  68f1              LDR      r1,[r6,#0xc]
;;;274        *pbuff++ = ((q31_t) (((q63_t) in * S->normalize) >> 31));
000136  6862              LDR      r2,[r4,#4]
000138  fb812102          SMULL    r2,r1,r1,r2
00013c  004b              LSLS     r3,r1,#1
00013e  ea4371d2          ORR      r1,r3,r2,LSR #31
000142  60f1              STR      r1,[r6,#0xc]
000144  3610              ADDS     r6,r6,#0x10
;;;275    
;;;276        /* Decrement the loop counter */
;;;277        i--;
000146  1e40              SUBS     r0,r0,#1
000148  b280              UXTH     r0,r0
;;;278      } while(i > 0u);
00014a  2800              CMP      r0,#0
00014c  d1da              BNE      |L1.260|
;;;279    
;;;280    
;;;281    #else
;;;282    
;;;283      /* Run the below code for Cortex-M0 */
;;;284    
;;;285      /* Initializing the loop counter to N/2 */
;;;286      i = S->Nby2;
;;;287    
;;;288      do
;;;289      {
;;;290        /* Re-ordering of even and odd elements */
;;;291        /* pState[i] =  pInlineBuffer[2*i] */
;;;292        *pS1++ = *pbuff++;
;;;293        /* pState[N-i-1] = pInlineBuffer[2*i+1] */
;;;294        *pS2-- = *pbuff++;
;;;295    
;;;296        /* Decrement the loop counter */
;;;297        i--;
;;;298      } while(i > 0u);
;;;299    
;;;300      /* pbuff initialized to input buffer */
;;;301      pbuff = pInlineBuffer;
;;;302    
;;;303      /* pS1 initialized to pState */
;;;304      pS1 = pState;
;;;305    
;;;306      /* Initializing the loop counter */
;;;307      i = S->N;
;;;308    
;;;309      do
;;;310      {
;;;311        /* Writing the re-ordered output back to inplace input buffer */
;;;312        *pbuff++ = *pS1++;
;;;313    
;;;314        /* Decrement the loop counter */
;;;315        i--;
;;;316      } while(i > 0u);
;;;317    
;;;318    
;;;319      /* ---------------------------------------------------------    
;;;320       *     Step2: Calculate RFFT for N-point input    
;;;321       * ---------------------------------------------------------- */
;;;322      /* pInlineBuffer is real input of length N , pState is the complex output of length 2N */
;;;323      arm_rfft_q31(S->pRfft, pInlineBuffer, pState);
;;;324    
;;;325      /*----------------------------------------------------------------------    
;;;326       *  Step3: Multiply the FFT output with the weights.    
;;;327       *----------------------------------------------------------------------*/
;;;328      arm_cmplx_mult_cmplx_q31(pState, weights, pState, S->N);
;;;329    
;;;330      /* The output of complex multiplication is in 3.29 format.    
;;;331       * Hence changing the format of N (i.e. 2*N elements) complex numbers to 1.31 format by shifting left by 2 bits. */
;;;332      arm_shift_q31(pState, 2, pState, S->N * 2);
;;;333    
;;;334      /* ----------- Post-processing ---------- */
;;;335      /* DCT-IV can be obtained from DCT-II by the equation,    
;;;336       *       Y4(k) = Y2(k) - Y4(k-1) and Y4(-1) = Y4(0)    
;;;337       *       Hence, Y4(0) = Y2(0)/2  */
;;;338      /* Getting only real part from the output and Converting to DCT-IV */
;;;339    
;;;340      /* pbuff initialized to input buffer. */
;;;341      pbuff = pInlineBuffer;
;;;342    
;;;343      /* pS1 initialized to pState */
;;;344      pS1 = pState;
;;;345    
;;;346      /* Calculating Y4(0) from Y2(0) using Y4(0) = Y2(0)/2 */
;;;347      in = *pS1++ >> 1u;
;;;348      /* input buffer acts as inplace, so output values are stored in the input itself. */
;;;349      *pbuff++ = in;
;;;350    
;;;351      /* pState pointer is incremented twice as the real values are located alternatively in the array */
;;;352      pS1++;
;;;353    
;;;354      /* Initializing the loop counter */
;;;355      i = (S->N - 1u);
;;;356    
;;;357      while(i > 0u)
;;;358      {
;;;359        /* Calculating Y4(1) to Y4(N-1) from Y2 using equation Y4(k) = Y2(k) - Y4(k-1) */
;;;360        /* pState pointer (pS1) is incremented twice as the real values are located alternatively in the array */
;;;361        in = *pS1++ - in;
;;;362        *pbuff++ = in;
;;;363        /* points to the next real value */
;;;364        pS1++;
;;;365    
;;;366        /* Decrement the loop counter */
;;;367        i--;
;;;368      }
;;;369    
;;;370    
;;;371            /*------------ Normalizing the output by multiplying with the normalizing factor ----------*/
;;;372    
;;;373      /* Initializing the loop counter */
;;;374      i = S->N;
;;;375    
;;;376      /* pbuff initialized to the pInlineBuffer(now contains the output values) */
;;;377      pbuff = pInlineBuffer;
;;;378    
;;;379      do
;;;380      {
;;;381        /* Multiplying pInlineBuffer with the normalizing factor sqrt(2/N) */
;;;382        in = *pbuff;
;;;383        *pbuff++ = ((q31_t) (((q63_t) in * S->normalize) >> 31));
;;;384    
;;;385        /* Decrement the loop counter */
;;;386        i--;
;;;387      } while(i > 0u);
;;;388    
;;;389    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;390    
;;;391    }
00014e  e8bd81f0          POP      {r4-r8,pc}
;;;392    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\TransformFunctions\\arm_dct4_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_dct4_q31_c_ae9bdd6c____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___14_arm_dct4_q31_c_ae9bdd6c____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_dct4_q31_c_ae9bdd6c____REVSH|
#line 144
|__asm___14_arm_dct4_q31_c_ae9bdd6c____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_dct4_q31_c_ae9bdd6c____RRX|
#line 300
|__asm___14_arm_dct4_q31_c_ae9bdd6c____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
