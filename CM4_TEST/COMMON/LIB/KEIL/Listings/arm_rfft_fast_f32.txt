; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_rfft_fast_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_rfft_fast_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_rfft_fast_f32.crf ..\..\SRC\CMSIS_DSP_4_5\src\TransformFunctions\arm_rfft_fast_f32.c]
                          THUMB

                          AREA ||i.arm_rfft_fast_f32||, CODE, READONLY, ALIGN=1

                  arm_rfft_fast_f32 PROC
;;;323    
;;;324    void arm_rfft_fast_f32(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;325    arm_rfft_fast_instance_f32 * S,
;;;326    float32_t * p, float32_t * pOut,
;;;327    uint8_t ifftFlag)
;;;328    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;329       arm_cfft_instance_f32 * Sint = &(S->Sint);
;;;330       Sint->fftLen = S->fftLenRFFT / 2;
00000c  8a20              LDRH     r0,[r4,#0x10]
00000e  0840              LSRS     r0,r0,#1
000010  8020              STRH     r0,[r4,#0]
;;;331    
;;;332       /* Calculation of Real FFT */
;;;333       if(ifftFlag)
000012  2d00              CMP      r5,#0
000014  d00c              BEQ      |L1.48|
;;;334       {
;;;335          /*  Real FFT compression */
;;;336          merge_rfft_f32(S, p, pOut);
000016  463a              MOV      r2,r7
000018  4631              MOV      r1,r6
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       merge_rfft_f32
;;;337    
;;;338          /* Complex radix-4 IFFT process */
;;;339          arm_cfft_f32( Sint, pOut, ifftFlag, 1);
000020  462a              MOV      r2,r5
000022  4639              MOV      r1,r7
000024  4620              MOV      r0,r4
000026  e8bd41f0          POP      {r4-r8,lr}
00002a  2301              MOVS     r3,#1
00002c  f7ffbffe          B.W      arm_cfft_f32
                  |L1.48|
;;;340       }
;;;341       else
;;;342       {
;;;343          /* Calculation of RFFT of input */
;;;344          arm_cfft_f32( Sint, p, ifftFlag, 1);
000030  2301              MOVS     r3,#1
000032  462a              MOV      r2,r5
000034  4631              MOV      r1,r6
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       arm_cfft_f32
;;;345       
;;;346          /*  Real FFT extraction */
;;;347          stage_rfft_f32(S, p, pOut);
00003c  463a              MOV      r2,r7
00003e  4631              MOV      r1,r6
000040  4620              MOV      r0,r4
000042  e8bd41f0          POP      {r4-r8,lr}
000046  f7ffbffe          B.W      stage_rfft_f32
;;;348       }
;;;349    }
;;;350    
                          ENDP


                          AREA ||i.merge_rfft_f32||, CODE, READONLY, ALIGN=1

                  merge_rfft_f32 PROC
;;;128    /* Prepares data for inverse cfft */
;;;129    void merge_rfft_f32(
000000  b510              PUSH     {r4,lr}
;;;130    arm_rfft_fast_instance_f32 * S,
;;;131    float32_t * p, float32_t * pOut)
;;;132    {
;;;133       uint32_t  k;								/* Loop Counter                     */
;;;134       float32_t twR, twI;						/* RFFT Twiddle coefficients        */
;;;135       float32_t *pCoeff = S->pTwiddleRFFT;		/* Points to RFFT Twiddle factors   */
000002  6944              LDR      r4,[r0,#0x14]
;;;136       float32_t *pA = p;						/* increasing pointer               */
;;;137       float32_t *pB = p;						/* decreasing pointer               */
;;;138       float32_t xAR, xAI, xBR, xBI;			/* temporary variables              */
;;;139       float32_t t1a, t1b, r, s, t, u;			/* temporary variables              */
;;;140    
;;;141       k = (S->Sint).fftLen - 1;					
000004  8803              LDRH     r3,[r0,#0]
000006  1e5b              SUBS     r3,r3,#1
;;;142    
;;;143       xAR = pA[0];
000008  ed910a00          VLDR     s0,[r1,#0]
;;;144       xAI = pA[1];
00000c  edd10a01          VLDR     s1,[r1,#4]
;;;145    
;;;146       pCoeff += 2 ;
000010  3408              ADDS     r4,r4,#8
;;;147    
;;;148       *pOut++ = 0.5f * ( xAR + xAI );
000012  eeb65a00          VMOV.F32 s10,#0.50000000
000016  ee301a20          VADD.F32 s2,s0,s1
00001a  ee211a05          VMUL.F32 s2,s2,s10
00001e  eca21a01          VSTM     r2!,{s2}
;;;149       *pOut++ = 0.5f * ( xAR - xAI );
000022  ee300a60          VSUB.F32 s0,s0,s1
000026  ee200a05          VMUL.F32 s0,s0,s10
00002a  eca20a01          VSTM     r2!,{s0}
;;;150    
;;;151       pB  =  p + 2*k ;
00002e  eb0100c3          ADD      r0,r1,r3,LSL #3
;;;152       pA +=  2	   ;
000032  3108              ADDS     r1,r1,#8
000034  e02e              B        |L2.148|
                  |L2.54|
;;;153    
;;;154       while(k > 0u)
;;;155       {
;;;156          /* G is half of the frequency complex spectrum */
;;;157          //for k = 2:N
;;;158          //    Xk(k) = 1/2 * (G(k) + conj(G(N-k+2)) + Tw(k)*( G(k) - conj(G(N-k+2))));
;;;159          xBI =   pB[1]    ;
000036  edd01a01          VLDR     s3,[r0,#4]
;;;160          xBR =   pB[0]    ;
00003a  ed901a00          VLDR     s2,[r0,#0]
;;;161          xAR =  pA[0];
00003e  ed913a00          VLDR     s6,[r1,#0]
;;;162          xAI =  pA[1];
000042  edd13a01          VLDR     s7,[r1,#4]
;;;163    
;;;164          twR = *pCoeff++;
000046  ecb40a01          VLDM     r4!,{s0}
;;;165          twI = *pCoeff++;
00004a  ecf40a01          VLDM     r4!,{s1}
;;;166    
;;;167          t1a = xAR - xBR ;
00004e  ee332a41          VSUB.F32 s4,s6,s2
;;;168          t1b = xAI + xBI ;
000052  ee732aa1          VADD.F32 s5,s7,s3
;;;169    
;;;170          r = twR * t1a;
000056  ee204a02          VMUL.F32 s8,s0,s4
;;;171          s = twI * t1b;
00005a  ee604aa2          VMUL.F32 s9,s1,s5
;;;172          t = twI * t1a;
00005e  ee600a82          VMUL.F32 s1,s1,s4
;;;173          u = twR * t1b;
000062  ee200a22          VMUL.F32 s0,s0,s5
;;;174    
;;;175          // real(tw * (xA - xB)) = twR * (xAR - xBR) - twI * (xAI - xBI);
;;;176          // imag(tw * (xA - xB)) = twI * (xAR - xBR) + twR * (xAI - xBI);
;;;177          *pOut++ = 0.5f * (xAR + xBR - r - s ); //xAR
000066  ee331a01          VADD.F32 s2,s6,s2
00006a  ee311a44          VSUB.F32 s2,s2,s8
00006e  ee311a64          VSUB.F32 s2,s2,s9
000072  ee211a05          VMUL.F32 s2,s2,s10
000076  eca21a01          VSTM     r2!,{s2}
;;;178          *pOut++ = 0.5f * (xAI - xBI + t - u ); //xAI
00007a  ee331ae1          VSUB.F32 s2,s7,s3
00007e  ee710a20          VADD.F32 s1,s2,s1
000082  ee300ac0          VSUB.F32 s0,s1,s0
000086  ee200a05          VMUL.F32 s0,s0,s10
00008a  eca20a01          VSTM     r2!,{s0}
;;;179    
;;;180          pA += 2;
00008e  3108              ADDS     r1,r1,#8
;;;181          pB -= 2;
000090  3808              SUBS     r0,r0,#8
;;;182          k--;
000092  1e5b              SUBS     r3,r3,#1
                  |L2.148|
000094  2b00              CMP      r3,#0                 ;154
000096  d1ce              BNE      |L2.54|
;;;183       }
;;;184    
;;;185    }
000098  bd10              POP      {r4,pc}
;;;186    
                          ENDP


                          AREA ||i.stage_rfft_f32||, CODE, READONLY, ALIGN=1

                  stage_rfft_f32 PROC
;;;42     
;;;43     void stage_rfft_f32(
000000  b510              PUSH     {r4,lr}
;;;44       arm_rfft_fast_instance_f32 * S,
;;;45       float32_t * p, float32_t * pOut)
;;;46     {
;;;47        uint32_t  k;								   /* Loop Counter                     */
;;;48        float32_t twR, twI;						   /* RFFT Twiddle coefficients        */
;;;49        float32_t * pCoeff = S->pTwiddleRFFT;  /* Points to RFFT Twiddle factors   */
000002  6944              LDR      r4,[r0,#0x14]
;;;50        float32_t *pA = p;						   /* increasing pointer               */
;;;51        float32_t *pB = p;						   /* decreasing pointer               */
;;;52        float32_t xAR, xAI, xBR, xBI;				/* temporary variables              */
;;;53        float32_t t1a, t1b;				         /* temporary variables              */
;;;54        float32_t p0, p1, p2, p3;				   /* temporary variables              */
;;;55     
;;;56     
;;;57        k = (S->Sint).fftLen - 1;					
000004  8803              LDRH     r3,[r0,#0]
000006  1e5b              SUBS     r3,r3,#1
;;;58     
;;;59        /* Pack first and last sample of the frequency domain together */
;;;60     
;;;61        xBR = pB[0];
000008  ed910a00          VLDR     s0,[r1,#0]
;;;62        xBI = pB[1];
00000c  edd10a01          VLDR     s1,[r1,#4]
;;;63        xAR = pA[0];
;;;64        xAI = pA[1];
;;;65     
;;;66        twR = *pCoeff++ ;
000010  1d24              ADDS     r4,r4,#4
;;;67        twI = *pCoeff++ ;
000012  1d24              ADDS     r4,r4,#4
;;;68        
;;;69        // U1 = XA(1) + XB(1); % It is real
;;;70        t1a = xBR + xAR  ;
000014  ee300a00          VADD.F32 s0,s0,s0
;;;71        
;;;72        // U2 = XB(1) - XA(1); % It is imaginary
;;;73        t1b = xBI + xAI  ;
000018  ee700aa0          VADD.F32 s1,s1,s1
;;;74     
;;;75        // real(tw * (xB - xA)) = twR * (xBR - xAR) - twI * (xBI - xAI);
;;;76        // imag(tw * (xB - xA)) = twI * (xBR - xAR) + twR * (xBI - xAI);
;;;77        *pOut++ = 0.5f * ( t1a + t1b );
00001c  eef64a00          VMOV.F32 s9,#0.50000000
000020  ee301a20          VADD.F32 s2,s0,s1
000024  ee211a24          VMUL.F32 s2,s2,s9
000028  eca21a01          VSTM     r2!,{s2}
;;;78        *pOut++ = 0.5f * ( t1a - t1b );
00002c  ee300a60          VSUB.F32 s0,s0,s1
000030  ee200a24          VMUL.F32 s0,s0,s9
000034  eca20a01          VSTM     r2!,{s0}
;;;79     
;;;80        // XA(1) = 1/2*( U1 - imag(U2) +  i*( U1 +imag(U2) ));
;;;81        pB  = p + 2*k;
000038  eb0100c3          ADD      r0,r1,r3,LSL #3
;;;82        pA += 2;
00003c  3108              ADDS     r1,r1,#8
                  |L3.62|
;;;83     
;;;84        do
;;;85        {
;;;86           /*
;;;87              function X = my_split_rfft(X, ifftFlag)
;;;88              % X is a series of real numbers
;;;89              L  = length(X);
;;;90              XC = X(1:2:end) +i*X(2:2:end);
;;;91              XA = fft(XC);
;;;92              XB = conj(XA([1 end:-1:2]));
;;;93              TW = i*exp(-2*pi*i*[0:L/2-1]/L).';
;;;94              for l = 2:L/2
;;;95                 XA(l) = 1/2 * (XA(l) + XB(l) + TW(l) * (XB(l) - XA(l)));
;;;96              end
;;;97              XA(1) = 1/2* (XA(1) + XB(1) + TW(1) * (XB(1) - XA(1))) + i*( 1/2*( XA(1) + XB(1) + i*( XA(1) - XB(1))));
;;;98              X = XA;
;;;99           */
;;;100    
;;;101          xBI = pB[1];
00003e  edd02a01          VLDR     s5,[r0,#4]
;;;102          xBR = pB[0];
000042  ed902a00          VLDR     s4,[r0,#0]
;;;103          xAR = pA[0];
000046  ed910a00          VLDR     s0,[r1,#0]
;;;104          xAI = pA[1];
00004a  edd11a01          VLDR     s3,[r1,#4]
;;;105    
;;;106          twR = *pCoeff++;
00004e  ecf40a01          VLDM     r4!,{s1}
;;;107          twI = *pCoeff++;
000052  ecb41a01          VLDM     r4!,{s2}
;;;108    
;;;109          t1a = xBR - xAR ;
000056  ee723a40          VSUB.F32 s7,s4,s0
;;;110          t1b = xBI + xAI ;
00005a  ee323aa1          VADD.F32 s6,s5,s3
;;;111    
;;;112          // real(tw * (xB - xA)) = twR * (xBR - xAR) - twI * (xBI - xAI);
;;;113          // imag(tw * (xB - xA)) = twI * (xBR - xAR) + twR * (xBI - xAI);
;;;114          p0 = twR * t1a;
00005e  ee204aa3          VMUL.F32 s8,s1,s7
;;;115          p1 = twI * t1a;
000062  ee613a23          VMUL.F32 s7,s2,s7
;;;116          p2 = twR * t1b;
000066  ee600a83          VMUL.F32 s1,s1,s6
;;;117          p3 = twI * t1b;
00006a  ee211a03          VMUL.F32 s2,s2,s6
;;;118    
;;;119          *pOut++ = 0.5f * (xAR + xBR + p0 + p3 ); //xAR
00006e  ee300a02          VADD.F32 s0,s0,s4
000072  ee300a04          VADD.F32 s0,s0,s8
000076  ee300a01          VADD.F32 s0,s0,s2
00007a  ee200a24          VMUL.F32 s0,s0,s9
00007e  eca20a01          VSTM     r2!,{s0}
;;;120          *pOut++ = 0.5f * (xAI - xBI + p1 - p2 ); //xAI
000082  ee310ae2          VSUB.F32 s0,s3,s5
000086  ee300a23          VADD.F32 s0,s0,s7
00008a  ee300a60          VSUB.F32 s0,s0,s1
00008e  ee200a24          VMUL.F32 s0,s0,s9
000092  eca20a01          VSTM     r2!,{s0}
;;;121    
;;;122          pA += 2;
000096  3108              ADDS     r1,r1,#8
;;;123          pB -= 2;
000098  3808              SUBS     r0,r0,#8
;;;124          k--;
00009a  1e5b              SUBS     r3,r3,#1
;;;125       } while(k > 0u);
00009c  2b00              CMP      r3,#0
00009e  d1ce              BNE      |L3.62|
;;;126    }
0000a0  bd10              POP      {r4,pc}
;;;127    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\TransformFunctions\\arm_rfft_fast_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_rfft_fast_f32_c_5aa1c2a8____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___19_arm_rfft_fast_f32_c_5aa1c2a8____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_rfft_fast_f32_c_5aa1c2a8____REVSH|
#line 144
|__asm___19_arm_rfft_fast_f32_c_5aa1c2a8____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_rfft_fast_f32_c_5aa1c2a8____RRX|
#line 300
|__asm___19_arm_rfft_fast_f32_c_5aa1c2a8____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
