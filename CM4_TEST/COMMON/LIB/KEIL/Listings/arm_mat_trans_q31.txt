; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_trans_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_trans_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_mat_trans_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\MatrixFunctions\arm_mat_trans_q31.c]
                          THUMB

                          AREA ||i.arm_mat_trans_q31||, CODE, READONLY, ALIGN=1

                  arm_mat_trans_q31 PROC
;;;59     
;;;60     arm_status arm_mat_trans_q31(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;61       const arm_matrix_instance_q31 * pSrc,
;;;62       arm_matrix_instance_q31 * pDst)
;;;63     {
;;;64       q31_t *pIn = pSrc->pData;                      /* input data matrix pointer  */
000004  6842              LDR      r2,[r0,#4]
;;;65       q31_t *pOut = pDst->pData;                     /* output data matrix pointer  */
000006  f8d1c004          LDR      r12,[r1,#4]
;;;66       q31_t *px;                                     /* Temporary output data matrix pointer */
;;;67       uint16_t nRows = pSrc->numRows;                /* number of nRows */
00000a  8801              LDRH     r1,[r0,#0]
;;;68       uint16_t nColumns = pSrc->numCols;             /* number of nColumns  */
00000c  8847              LDRH     r7,[r0,#2]
;;;69     
;;;70     #ifndef ARM_MATH_CM0_FAMILY
;;;71     
;;;72       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;73     
;;;74       uint16_t blkCnt, i = 0u, row = nRows;          /* loop counters */
00000e  2600              MOVS     r6,#0
000010  460d              MOV      r5,r1
;;;75       arm_status status;                             /* status of matrix transpose */
;;;76     
;;;77     
;;;78     #ifdef ARM_MATH_MATRIX_CHECK
;;;79     
;;;80     
;;;81       /* Check for matrix mismatch condition */
;;;82       if((pSrc->numRows != pDst->numCols) || (pSrc->numCols != pDst->numRows))
;;;83       {
;;;84         /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;85         status = ARM_MATH_SIZE_MISMATCH;
;;;86       }
;;;87       else
;;;88     #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;89     
;;;90       {
;;;91         /* Matrix transpose by exchanging the rows with columns */
;;;92         /* row loop     */
;;;93         do
;;;94         {
;;;95           /* Apply loop unrolling and exchange the columns with row elements */
;;;96           blkCnt = nColumns >> 2u;
000012  ea4f0897          LSR      r8,r7,#2
                  |L1.22|
000016  4643              MOV      r3,r8
;;;97     
;;;98           /* The pointer px is set to starting address of the column being processed */
;;;99           px = pOut + i;
000018  eb0c0086          ADD      r0,r12,r6,LSL #2
;;;100    
;;;101          /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;102           ** a second loop below computes the remaining 1 to 3 samples. */
;;;103          while(blkCnt > 0u)
00001c  e012              B        |L1.68|
                  |L1.30|
;;;104          {
;;;105            /* Read and store the input element in the destination */
;;;106            *px = *pIn++;
00001e  6814              LDR      r4,[r2,#0]
000020  6004              STR      r4,[r0,#0]
;;;107    
;;;108            /* Update the pointer px to point to the next row of the transposed matrix */
;;;109            px += nRows;
000022  eb000081          ADD      r0,r0,r1,LSL #2
;;;110    
;;;111            /* Read and store the input element in the destination */
;;;112            *px = *pIn++;
000026  6854              LDR      r4,[r2,#4]
000028  6004              STR      r4,[r0,#0]
;;;113    
;;;114            /* Update the pointer px to point to the next row of the transposed matrix */
;;;115            px += nRows;
00002a  eb000081          ADD      r0,r0,r1,LSL #2
;;;116    
;;;117            /* Read and store the input element in the destination */
;;;118            *px = *pIn++;
00002e  6894              LDR      r4,[r2,#8]
000030  6004              STR      r4,[r0,#0]
;;;119    
;;;120            /* Update the pointer px to point to the next row of the transposed matrix */
;;;121            px += nRows;
000032  eb000081          ADD      r0,r0,r1,LSL #2
;;;122    
;;;123            /* Read and store the input element in the destination */
;;;124            *px = *pIn++;
000036  68d4              LDR      r4,[r2,#0xc]
000038  3210              ADDS     r2,r2,#0x10
00003a  6004              STR      r4,[r0,#0]
;;;125    
;;;126            /* Update the pointer px to point to the next row of the transposed matrix */
;;;127            px += nRows;
00003c  eb000081          ADD      r0,r0,r1,LSL #2
;;;128    
;;;129            /* Decrement the column loop counter */
;;;130            blkCnt--;
000040  1e5b              SUBS     r3,r3,#1
000042  b29b              UXTH     r3,r3
                  |L1.68|
000044  2b00              CMP      r3,#0                 ;103
000046  d1ea              BNE      |L1.30|
;;;131          }
;;;132    
;;;133          /* Perform matrix transpose for last 3 samples here. */
;;;134          blkCnt = nColumns % 0x4u;
000048  f0070403          AND      r4,r7,#3
;;;135    
;;;136          while(blkCnt > 0u)
00004c  e005              B        |L1.90|
                  |L1.78|
;;;137          {
;;;138            /* Read and store the input element in the destination */
;;;139            *px = *pIn++;
00004e  ca08              LDM      r2!,{r3}
000050  6003              STR      r3,[r0,#0]
;;;140    
;;;141            /* Update the pointer px to point to the next row of the transposed matrix */
;;;142            px += nRows;
000052  eb000081          ADD      r0,r0,r1,LSL #2
;;;143    
;;;144            /* Decrement the column loop counter */
;;;145            blkCnt--;
000056  1e64              SUBS     r4,r4,#1
000058  b2a4              UXTH     r4,r4
                  |L1.90|
00005a  2c00              CMP      r4,#0                 ;136
00005c  d1f7              BNE      |L1.78|
;;;146          }
;;;147    
;;;148    #else
;;;149    
;;;150      /* Run the below code for Cortex-M0 */
;;;151    
;;;152      uint16_t col, i = 0u, row = nRows;             /* loop counters */
;;;153      arm_status status;                             /* status of matrix transpose */
;;;154    
;;;155    
;;;156    #ifdef ARM_MATH_MATRIX_CHECK
;;;157    
;;;158      /* Check for matrix mismatch condition */
;;;159      if((pSrc->numRows != pDst->numCols) || (pSrc->numCols != pDst->numRows))
;;;160      {
;;;161        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;162        status = ARM_MATH_SIZE_MISMATCH;
;;;163      }
;;;164      else
;;;165    #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;166    
;;;167      {
;;;168        /* Matrix transpose by exchanging the rows with columns */
;;;169        /* row loop     */
;;;170        do
;;;171        {
;;;172          /* The pointer px is set to starting address of the column being processed */
;;;173          px = pOut + i;
;;;174    
;;;175          /* Initialize column loop counter */
;;;176          col = nColumns;
;;;177    
;;;178          while(col > 0u)
;;;179          {
;;;180            /* Read and store the input element in the destination */
;;;181            *px = *pIn++;
;;;182    
;;;183            /* Update the pointer px to point to the next row of the transposed matrix */
;;;184            px += nRows;
;;;185    
;;;186            /* Decrement the column loop counter */
;;;187            col--;
;;;188          }
;;;189    
;;;190    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;191    
;;;192          i++;
00005e  1c76              ADDS     r6,r6,#1
000060  b2b6              UXTH     r6,r6
;;;193    
;;;194          /* Decrement the row loop counter */
;;;195          row--;
000062  1e6d              SUBS     r5,r5,#1
000064  b2ad              UXTH     r5,r5
;;;196    
;;;197        }
;;;198        while(row > 0u);            /* row loop end */
000066  2d00              CMP      r5,#0
000068  d1d5              BNE      |L1.22|
;;;199    
;;;200        /* set status as ARM_MATH_SUCCESS */
;;;201        status = ARM_MATH_SUCCESS;
00006a  2000              MOVS     r0,#0
;;;202      }
;;;203    
;;;204      /* Return to application */
;;;205      return (status);
;;;206    }
00006c  e8bd81f0          POP      {r4-r8,pc}
;;;207    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\MatrixFunctions\\arm_mat_trans_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_mat_trans_q31_c_d7961a34____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___19_arm_mat_trans_q31_c_d7961a34____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_mat_trans_q31_c_d7961a34____REVSH|
#line 144
|__asm___19_arm_mat_trans_q31_c_d7961a34____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_mat_trans_q31_c_d7961a34____RRX|
#line 300
|__asm___19_arm_mat_trans_q31_c_d7961a34____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
