; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_opt_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_opt_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_conv_opt_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_opt_q15.c]
                          THUMB

                          AREA ||i.arm_conv_opt_q15||, CODE, READONLY, ALIGN=1

                  arm_conv_opt_q15 PROC
;;;84     
;;;85     void arm_conv_opt_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;86       q15_t * pSrcA,
;;;87       uint32_t srcALen,
;;;88       q15_t * pSrcB,
;;;89       uint32_t srcBLen,
;;;90       q15_t * pDst,
;;;91       q15_t * pScratch1,
;;;92       q15_t * pScratch2)
;;;93     {
000004  b089              SUB      sp,sp,#0x24
000006  460c              MOV      r4,r1
000008  f8dd8060          LDR      r8,[sp,#0x60]
00000c  9916              LDR      r1,[sp,#0x58]
;;;94       q63_t acc0, acc1, acc2, acc3;                  /* Accumulator */
;;;95       q31_t x1, x2, x3;                              /* Temporary variables to hold state and coefficient values */
;;;96       q31_t y1, y2;                                  /* State variables */
;;;97       q15_t *pOut = pDst;                            /* output pointer */
00000e  9103              STR      r1,[sp,#0xc]
;;;98       q15_t *pScr1 = pScratch1;                      /* Temporary pointer for scratch1 */
;;;99       q15_t *pScr2 = pScratch2;                      /* Temporary pointer for scratch1 */
;;;100      q15_t *pIn1;                                   /* inputA pointer */
;;;101      q15_t *pIn2;                                   /* inputB pointer */
;;;102      q15_t *px;                                     /* Intermediate inputA pointer  */
;;;103      q15_t *py;                                     /* Intermediate inputB pointer  */
;;;104      uint32_t j, k, blkCnt;                         /* loop counter */
;;;105      uint32_t tapCnt;                               /* loop count */
;;;106    #ifdef UNALIGNED_SUPPORT_DISABLE
;;;107    
;;;108      q15_t a, b;
;;;109    
;;;110    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;111    
;;;112      /* The algorithm implementation is based on the lengths of the inputs. */
;;;113      /* srcB is always made to slide across srcA. */
;;;114      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;115      if(srcALen >= srcBLen)
000010  990c              LDR      r1,[sp,#0x30]
000012  428c              CMP      r4,r1
000014  d302              BCC      |L1.28|
;;;116      {
;;;117        /* Initialization of inputA pointer */
;;;118        pIn1 = pSrcA;
000016  4605              MOV      r5,r0
;;;119    
;;;120        /* Initialization of inputB pointer */
;;;121        pIn2 = pSrcB;
000018  4610              MOV      r0,r2
00001a  e003              B        |L1.36|
                  |L1.28|
;;;122    
;;;123      }
;;;124      else
;;;125      {
;;;126        /* Initialization of inputA pointer */
;;;127        pIn1 = pSrcB;
00001c  4615              MOV      r5,r2
;;;128    
;;;129        /* Initialization of inputB pointer */
;;;130        pIn2 = pSrcA;
;;;131    
;;;132        /* srcBLen is always considered as shorter or equal to srcALen */
;;;133        j = srcBLen;
00001e  990c              LDR      r1,[sp,#0x30]
;;;134        srcBLen = srcALen;
000020  940c              STR      r4,[sp,#0x30]
;;;135        srcALen = j;
000022  460c              MOV      r4,r1
                  |L1.36|
;;;136      }
;;;137    
;;;138      /* pointer to take end of scratch2 buffer */
;;;139      pScr2 = pScratch2 + srcBLen - 1;
000024  990c              LDR      r1,[sp,#0x30]
000026  eb080241          ADD      r2,r8,r1,LSL #1
00002a  1e92              SUBS     r2,r2,#2
;;;140    
;;;141      /* points to smaller length sequence */
;;;142      px = pIn2;
;;;143    
;;;144      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;145      k = srcBLen >> 2u;
00002c  990c              LDR      r1,[sp,#0x30]
00002e  088b              LSRS     r3,r1,#2
000030  9308              STR      r3,[sp,#0x20]
;;;146    
;;;147      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;148       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;149      /* Copy smaller length input sequence in reverse order into second scratch buffer */
;;;150      while(k > 0u)
000032  e00b              B        |L1.76|
                  |L1.52|
;;;151      {
;;;152        /* copy second buffer in reversal manner */
;;;153        *pScr2-- = *px++;
000034  1f92              SUBS     r2,r2,#6
000036  8801              LDRH     r1,[r0,#0]
000038  80d1              STRH     r1,[r2,#6]
;;;154        *pScr2-- = *px++;
00003a  8841              LDRH     r1,[r0,#2]
00003c  8091              STRH     r1,[r2,#4]
;;;155        *pScr2-- = *px++;
00003e  8881              LDRH     r1,[r0,#4]
000040  8051              STRH     r1,[r2,#2]
;;;156        *pScr2-- = *px++;
000042  88c1              LDRH     r1,[r0,#6]
000044  3008              ADDS     r0,r0,#8
000046  f8221902          STRH     r1,[r2],#-2
;;;157    
;;;158        /* Decrement the loop counter */
;;;159        k--;
00004a  1e5b              SUBS     r3,r3,#1
                  |L1.76|
00004c  2b00              CMP      r3,#0                 ;150
00004e  d1f1              BNE      |L1.52|
;;;160      }
;;;161    
;;;162      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;163       ** No loop unrolling is used. */
;;;164      k = srcBLen % 0x4u;
000050  990c              LDR      r1,[sp,#0x30]
000052  f0010303          AND      r3,r1,#3
000056  9307              STR      r3,[sp,#0x1c]
;;;165    
;;;166      while(k > 0u)
000058  e004              B        |L1.100|
                  |L1.90|
;;;167      {
;;;168        /* copy second buffer in reversal manner for remaining samples */
;;;169        *pScr2-- = *px++;
00005a  f8301b02          LDRH     r1,[r0],#2
00005e  f8221902          STRH     r1,[r2],#-2
;;;170    
;;;171        /* Decrement the loop counter */
;;;172        k--;
000062  1e5b              SUBS     r3,r3,#1
                  |L1.100|
000064  2b00              CMP      r3,#0                 ;166
000066  d1f8              BNE      |L1.90|
;;;173      }
;;;174    
;;;175      /* Initialze temporary scratch pointer */
;;;176      pScr1 = pScratch1;
000068  9e17              LDR      r6,[sp,#0x5c]
;;;177    
;;;178      /* Assuming scratch1 buffer is aligned by 32-bit */
;;;179      /* Fill (srcBLen - 1u) zeros in scratch buffer */
;;;180      arm_fill_q15(0, pScr1, (srcBLen - 1u));
00006a  9a0c              LDR      r2,[sp,#0x30]
00006c  4631              MOV      r1,r6
00006e  1e52              SUBS     r2,r2,#1
000070  2000              MOVS     r0,#0
000072  f7fffffe          BL       arm_fill_q15
;;;181    
;;;182      /* Update temporary scratch pointer */
;;;183      pScr1 += (srcBLen - 1u);
000076  980c              LDR      r0,[sp,#0x30]
000078  1e40              SUBS     r0,r0,#1
00007a  eb060640          ADD      r6,r6,r0,LSL #1
;;;184    
;;;185      /* Copy bigger length sequence(srcALen) samples in scratch1 buffer */
;;;186    
;;;187    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;188    
;;;189      /* Copy (srcALen) samples in scratch buffer */
;;;190      arm_copy_q15(pIn1, pScr1, srcALen);
00007e  4622              MOV      r2,r4
000080  4631              MOV      r1,r6
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       arm_copy_q15
;;;191    
;;;192      /* Update pointers */
;;;193      pScr1 += srcALen;
000088  eb060144          ADD      r1,r6,r4,LSL #1
;;;194    
;;;195    #else
;;;196    
;;;197      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;198      k = srcALen >> 2u;
;;;199    
;;;200      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;201       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;202      while(k > 0u)
;;;203      {
;;;204        /* copy second buffer in reversal manner */
;;;205        *pScr1++ = *pIn1++;
;;;206        *pScr1++ = *pIn1++;
;;;207        *pScr1++ = *pIn1++;
;;;208        *pScr1++ = *pIn1++;
;;;209    
;;;210        /* Decrement the loop counter */
;;;211        k--;
;;;212      }
;;;213    
;;;214      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;215       ** No loop unrolling is used. */
;;;216      k = srcALen % 0x4u;
;;;217    
;;;218      while(k > 0u)
;;;219      {
;;;220        /* copy second buffer in reversal manner for remaining samples */
;;;221        *pScr1++ = *pIn1++;
;;;222    
;;;223        /* Decrement the loop counter */
;;;224        k--;
;;;225      }
;;;226    
;;;227    #endif
;;;228    
;;;229    
;;;230    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;231    
;;;232      /* Fill (srcBLen - 1u) zeros at end of scratch buffer */
;;;233      arm_fill_q15(0, pScr1, (srcBLen - 1u));
00008c  9a0c              LDR      r2,[sp,#0x30]
00008e  2000              MOVS     r0,#0
000090  1e52              SUBS     r2,r2,#1
000092  f7fffffe          BL       arm_fill_q15
;;;234    
;;;235      /* Update pointer */
;;;236      pScr1 += (srcBLen - 1u);
;;;237    
;;;238    #else
;;;239    
;;;240      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;241      k = (srcBLen - 1u) >> 2u;
;;;242    
;;;243      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;244       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;245      while(k > 0u)
;;;246      {
;;;247        /* copy second buffer in reversal manner */
;;;248        *pScr1++ = 0;
;;;249        *pScr1++ = 0;
;;;250        *pScr1++ = 0;
;;;251        *pScr1++ = 0;
;;;252    
;;;253        /* Decrement the loop counter */
;;;254        k--;
;;;255      }
;;;256    
;;;257      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;258       ** No loop unrolling is used. */
;;;259      k = (srcBLen - 1u) % 0x4u;
;;;260    
;;;261      while(k > 0u)
;;;262      {
;;;263        /* copy second buffer in reversal manner for remaining samples */
;;;264        *pScr1++ = 0;
;;;265    
;;;266        /* Decrement the loop counter */
;;;267        k--;
;;;268      }
;;;269    
;;;270    #endif
;;;271    
;;;272      /* Temporary pointer for scratch2 */
;;;273      py = pScratch2;
000096  f8cd8008          STR      r8,[sp,#8]
;;;274    
;;;275    
;;;276      /* Initialization of pIn2 pointer */
;;;277      pIn2 = py;
00009a  f8dd8008          LDR      r8,[sp,#8]
;;;278    
;;;279      /* First part of the processing with loop unrolling process 4 data points at a time.       
;;;280       ** a second loop below process for the remaining 1 to 3 samples. */
;;;281    
;;;282      /* Actual convolution process starts here */
;;;283      blkCnt = (srcALen + srcBLen - 1u) >> 2;
00009e  980c              LDR      r0,[sp,#0x30]
0000a0  4420              ADD      r0,r0,r4
0000a2  1e40              SUBS     r0,r0,#1
0000a4  9006              STR      r0,[sp,#0x18]
0000a6  0880              LSRS     r0,r0,#2
0000a8  9001              STR      r0,[sp,#4]
;;;284    
;;;285      while(blkCnt > 0)
0000aa  e096              B        |L1.474|
                  |L1.172|
;;;286      {
;;;287        /* Initialze temporary scratch pointer as scratch1 */
;;;288        pScr1 = pScratch1;
0000ac  f8dda05c          LDR      r10,[sp,#0x5c]
;;;289    
;;;290        /* Clear Accumlators */
;;;291        acc0 = 0;
0000b0  2000              MOVS     r0,#0
0000b2  4601              MOV      r1,r0
;;;292        acc1 = 0;
0000b4  2200              MOVS     r2,#0
0000b6  4613              MOV      r3,r2
;;;293        acc2 = 0;
0000b8  2400              MOVS     r4,#0
0000ba  4625              MOV      r5,r4
;;;294        acc3 = 0;
0000bc  2600              MOVS     r6,#0
0000be  4637              MOV      r7,r6
;;;295    
;;;296        /* Read two samples from scratch1 buffer */
;;;297        x1 = *__SIMD32(pScr1)++;
0000c0  f85a9b04          LDR      r9,[r10],#4
;;;298    
;;;299        /* Read next two samples from scratch1 buffer */
;;;300        x2 = *__SIMD32(pScr1)++;
0000c4  f85acb04          LDR      r12,[r10],#4
;;;301    
;;;302        tapCnt = (srcBLen) >> 2u;
0000c8  f8ddb020          LDR      r11,[sp,#0x20]
0000cc  f8cdb000          STR      r11,[sp,#0]
;;;303    
;;;304        while(tapCnt > 0u)
0000d0  e033              B        |L1.314|
                  |L1.210|
;;;305        {
;;;306    
;;;307    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;308    
;;;309          /* Read four samples from smaller buffer */
;;;310          y1 = _SIMD32_OFFSET(pIn2);
0000d2  f8d8b000          LDR      r11,[r8,#0]
;;;311          y2 = _SIMD32_OFFSET(pIn2 + 2u);
0000d6  f8d8e004          LDR      lr,[r8,#4]
0000da  f8cde014          STR      lr,[sp,#0x14]
;;;312    
;;;313          /* multiply and accumlate */
;;;314          acc0 = __SMLALD(x1, y1, acc0);
0000de  fbc901cb          SMLALD   r0,r1,r9,r11
;;;315          acc2 = __SMLALD(x2, y1, acc2);
0000e2  fbcc45cb          SMLALD   r4,r5,r12,r11
;;;316    
;;;317          /* pack input data */
;;;318    #ifndef ARM_MATH_BIG_ENDIAN
;;;319          x3 = __PKHBT(x2, x1, 0);
0000e6  eacc0909          PKHBT    r9,r12,r9
;;;320    #else
;;;321          x3 = __PKHBT(x1, x2, 0);
;;;322    #endif
;;;323    
;;;324          /* multiply and accumlate */
;;;325          acc1 = __SMLALDX(x3, y1, acc1);
0000ea  fbc923db          SMLALDX  r2,r3,r9,r11
;;;326    
;;;327          /* Read next two samples from scratch1 buffer */
;;;328          x1 = _SIMD32_OFFSET(pScr1);
0000ee  f8da9000          LDR      r9,[r10,#0]
0000f2  f8cd9010          STR      r9,[sp,#0x10]
;;;329    
;;;330          /* multiply and accumlate */
;;;331          acc0 = __SMLALD(x2, y2, acc0);
0000f6  f8dde014          LDR      lr,[sp,#0x14]
0000fa  fbcc01ce          SMLALD   r0,r1,r12,lr
;;;332          acc2 = __SMLALD(x1, y2, acc2);
0000fe  e9dd9e04          LDRD     r9,lr,[sp,#0x10]
000102  fbc945ce          SMLALD   r4,r5,r9,lr
;;;333    
;;;334          /* pack input data */
;;;335    #ifndef ARM_MATH_BIG_ENDIAN
;;;336          x3 = __PKHBT(x1, x2, 0);
000106  eac90c0c          PKHBT    r12,r9,r12
;;;337    #else
;;;338          x3 = __PKHBT(x2, x1, 0);
;;;339    #endif
;;;340    
;;;341          acc3 = __SMLALDX(x3, y1, acc3);
00010a  fbcc67db          SMLALDX  r6,r7,r12,r11
;;;342          acc1 = __SMLALDX(x3, y2, acc1);
00010e  f8dde014          LDR      lr,[sp,#0x14]
000112  fbcc23de          SMLALDX  r2,r3,r12,lr
;;;343    
;;;344          x2 = _SIMD32_OFFSET(pScr1 + 2u);
000116  f8dac004          LDR      r12,[r10,#4]
;;;345    
;;;346    #ifndef ARM_MATH_BIG_ENDIAN
;;;347          x3 = __PKHBT(x2, x1, 0);
00011a  eacc0b09          PKHBT    r11,r12,r9
;;;348    #else
;;;349          x3 = __PKHBT(x1, x2, 0);
;;;350    #endif
;;;351    
;;;352          acc3 = __SMLALDX(x3, y2, acc3);
00011e  f8dde014          LDR      lr,[sp,#0x14]
000122  fbcb67de          SMLALDX  r6,r7,r11,lr
;;;353    
;;;354    #else	 
;;;355    
;;;356          /* Read four samples from smaller buffer */
;;;357    	  a = *pIn2;
;;;358    	  b = *(pIn2 + 1);
;;;359    
;;;360    #ifndef ARM_MATH_BIG_ENDIAN
;;;361          y1 = __PKHBT(a, b, 16);
;;;362    #else
;;;363          y1 = __PKHBT(b, a, 16);
;;;364    #endif
;;;365    	  
;;;366    	  a = *(pIn2 + 2);
;;;367    	  b = *(pIn2 + 3);
;;;368    #ifndef ARM_MATH_BIG_ENDIAN
;;;369          y2 = __PKHBT(a, b, 16);
;;;370    #else
;;;371          y2 = __PKHBT(b, a, 16);
;;;372    #endif				
;;;373    
;;;374          acc0 = __SMLALD(x1, y1, acc0);
;;;375    
;;;376          acc2 = __SMLALD(x2, y1, acc2);
;;;377    
;;;378    #ifndef ARM_MATH_BIG_ENDIAN
;;;379          x3 = __PKHBT(x2, x1, 0);
;;;380    #else
;;;381          x3 = __PKHBT(x1, x2, 0);
;;;382    #endif
;;;383    
;;;384          acc1 = __SMLALDX(x3, y1, acc1);
;;;385    
;;;386    	  a = *pScr1;
;;;387    	  b = *(pScr1 + 1);
;;;388    
;;;389    #ifndef ARM_MATH_BIG_ENDIAN
;;;390          x1 = __PKHBT(a, b, 16);
;;;391    #else
;;;392          x1 = __PKHBT(b, a, 16);
;;;393    #endif
;;;394    
;;;395          acc0 = __SMLALD(x2, y2, acc0);
;;;396    
;;;397          acc2 = __SMLALD(x1, y2, acc2);
;;;398    
;;;399    #ifndef ARM_MATH_BIG_ENDIAN
;;;400          x3 = __PKHBT(x1, x2, 0);
;;;401    #else
;;;402          x3 = __PKHBT(x2, x1, 0);
;;;403    #endif
;;;404    
;;;405          acc3 = __SMLALDX(x3, y1, acc3);
;;;406    
;;;407          acc1 = __SMLALDX(x3, y2, acc1);
;;;408    
;;;409    	  a = *(pScr1 + 2);
;;;410    	  b = *(pScr1 + 3);
;;;411    
;;;412    #ifndef ARM_MATH_BIG_ENDIAN
;;;413          x2 = __PKHBT(a, b, 16);
;;;414    #else
;;;415          x2 = __PKHBT(b, a, 16);
;;;416    #endif
;;;417    
;;;418    #ifndef ARM_MATH_BIG_ENDIAN
;;;419          x3 = __PKHBT(x2, x1, 0);
;;;420    #else
;;;421          x3 = __PKHBT(x1, x2, 0);
;;;422    #endif
;;;423    
;;;424          acc3 = __SMLALDX(x3, y2, acc3);
;;;425    
;;;426    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;427    
;;;428          pIn2 += 4u;
000126  f1080808          ADD      r8,r8,#8
;;;429          pScr1 += 4u;
00012a  f10a0a08          ADD      r10,r10,#8
;;;430    
;;;431    
;;;432          /* Decrement the loop counter */
;;;433          tapCnt--;
00012e  f8ddb000          LDR      r11,[sp,#0]
000132  f1ab0b01          SUB      r11,r11,#1
000136  f8cdb000          STR      r11,[sp,#0]
                  |L1.314|
00013a  f8ddb000          LDR      r11,[sp,#0]           ;304
00013e  f1bb0f00          CMP      r11,#0                ;304
000142  d1c6              BNE      |L1.210|
;;;434        }
;;;435    
;;;436        /* Update scratch pointer for remaining samples of smaller length sequence */
;;;437        pScr1 -= 4u;
000144  f1aa0a08          SUB      r10,r10,#8
;;;438    
;;;439        /* apply same above for remaining samples of smaller length sequence */
;;;440        tapCnt = (srcBLen) & 3u;
000148  f8dd901c          LDR      r9,[sp,#0x1c]
;;;441    
;;;442        while(tapCnt > 0u)
00014c  e019              B        |L1.386|
                  |L1.334|
;;;443        {
;;;444    
;;;445          /* accumlate the results */
;;;446          acc0 += (*pScr1++ * *pIn2);
00014e  f93aeb02          LDRSH    lr,[r10],#2
000152  f9b8c000          LDRSH    r12,[r8,#0]
000156  fbce018c          SMLALBB  r0,r1,lr,r12
;;;447          acc1 += (*pScr1++ * *pIn2);
00015a  f93aeb02          LDRSH    lr,[r10],#2
00015e  fbce238c          SMLALBB  r2,r3,lr,r12
;;;448          acc2 += (*pScr1++ * *pIn2);
000162  46ae              MOV      lr,r5
000164  f93a5b02          LDRSH    r5,[r10],#2
000168  fbc54e8c          SMLALBB  r4,lr,r5,r12
00016c  4675              MOV      r5,lr
;;;449          acc3 += (*pScr1++ * *pIn2++);
00016e  f9bae000          LDRSH    lr,[r10,#0]
000172  f1080802          ADD      r8,r8,#2
000176  fbce678c          SMLALBB  r6,r7,lr,r12
;;;450    
;;;451          pScr1 -= 3u;
00017a  f1aa0a04          SUB      r10,r10,#4
;;;452    
;;;453          /* Decrement the loop counter */
;;;454          tapCnt--;
00017e  f1a90901          SUB      r9,r9,#1
                  |L1.386|
000182  f1b90f00          CMP      r9,#0                 ;442
000186  d1e2              BNE      |L1.334|
;;;455        }
;;;456    
;;;457        blkCnt--;
000188  f8ddc004          LDR      r12,[sp,#4]
00018c  f1ac0c01          SUB      r12,r12,#1
000190  f8cdc004          STR      r12,[sp,#4]
;;;458    
;;;459    
;;;460        /* Store the results in the accumulators in the destination buffer. */
;;;461    
;;;462    #ifndef ARM_MATH_BIG_ENDIAN
;;;463    
;;;464        *__SIMD32(pOut)++ =
000194  0bc0              LSRS     r0,r0,#15
000196  ea404041          ORR      r0,r0,r1,LSL #17
00019a  f300010f          SSAT     r1,#16,r0
00019e  0bd0              LSRS     r0,r2,#15
0001a0  ea404043          ORR      r0,r0,r3,LSL #17
0001a4  f300000f          SSAT     r0,#16,r0
0001a8  eac14100          PKHBT    r1,r1,r0,LSL #16
0001ac  9803              LDR      r0,[sp,#0xc]
0001ae  6001              STR      r1,[r0,#0]
0001b0  9803              LDR      r0,[sp,#0xc]
;;;465          __PKHBT(__SSAT((acc0 >> 15), 16), __SSAT((acc1 >> 15), 16), 16);
;;;466    
;;;467        *__SIMD32(pOut)++ =
0001b2  0be1              LSRS     r1,r4,#15
0001b4  ea414145          ORR      r1,r1,r5,LSL #17
0001b8  f301020f          SSAT     r2,#16,r1
0001bc  0bf1              LSRS     r1,r6,#15
0001be  ea414147          ORR      r1,r1,r7,LSL #17
0001c2  f301010f          SSAT     r1,#16,r1
0001c6  eac24101          PKHBT    r1,r2,r1,LSL #16
0001ca  6041              STR      r1,[r0,#4]
0001cc  3008              ADDS     r0,r0,#8
0001ce  9003              STR      r0,[sp,#0xc]
;;;468          __PKHBT(__SSAT((acc2 >> 15), 16), __SSAT((acc3 >> 15), 16), 16);
;;;469    
;;;470    #else
;;;471    
;;;472        *__SIMD32(pOut)++ =
;;;473          __PKHBT(__SSAT((acc1 >> 15), 16), __SSAT((acc0 >> 15), 16), 16);
;;;474    
;;;475        *__SIMD32(pOut)++ =
;;;476          __PKHBT(__SSAT((acc3 >> 15), 16), __SSAT((acc2 >> 15), 16), 16);
;;;477    
;;;478    
;;;479    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN       */
;;;480    
;;;481        /* Initialization of inputB pointer */
;;;482        pIn2 = py;
0001d0  f8dd8008          LDR      r8,[sp,#8]
;;;483    
;;;484        pScratch1 += 4u;
0001d4  9817              LDR      r0,[sp,#0x5c]
0001d6  3008              ADDS     r0,r0,#8
0001d8  9017              STR      r0,[sp,#0x5c]
                  |L1.474|
0001da  9801              LDR      r0,[sp,#4]            ;285
0001dc  2800              CMP      r0,#0                 ;285
0001de  f47faf65          BNE      |L1.172|
;;;485    
;;;486      }
;;;487    
;;;488    
;;;489      blkCnt = (srcALen + srcBLen - 1u) & 0x3;
0001e2  9806              LDR      r0,[sp,#0x18]
0001e4  f0000403          AND      r4,r0,#3
;;;490    
;;;491      /* Calculate convolution for remaining samples of Bigger length sequence */
;;;492      while(blkCnt > 0)
0001e8  e032              B        |L1.592|
                  |L1.490|
;;;493      {
;;;494        /* Initialze temporary scratch pointer as scratch1 */
;;;495        pScr1 = pScratch1;
0001ea  9a17              LDR      r2,[sp,#0x5c]
;;;496    
;;;497        /* Clear Accumlators */
;;;498        acc0 = 0;
0001ec  2000              MOVS     r0,#0
0001ee  4601              MOV      r1,r0
;;;499    
;;;500        tapCnt = (srcBLen) >> 1u;
0001f0  9b0c              LDR      r3,[sp,#0x30]
0001f2  085b              LSRS     r3,r3,#1
;;;501    
;;;502        while(tapCnt > 0u)
0001f4  e00d              B        |L1.530|
                  |L1.502|
;;;503        {
;;;504    
;;;505          /* Read next two samples from scratch1 buffer */
;;;506          acc0 += (*pScr1++ * *pIn2++);
0001f6  f9b26000          LDRSH    r6,[r2,#0]
0001fa  f9387b02          LDRSH    r7,[r8],#2
0001fe  fbc60187          SMLALBB  r0,r1,r6,r7
;;;507          acc0 += (*pScr1++ * *pIn2++);
000202  f9b25002          LDRSH    r5,[r2,#2]
000206  f9386b02          LDRSH    r6,[r8],#2
00020a  1d12              ADDS     r2,r2,#4
00020c  fbc50186          SMLALBB  r0,r1,r5,r6
;;;508    
;;;509          /* Decrement the loop counter */
;;;510          tapCnt--;
000210  1e5b              SUBS     r3,r3,#1
                  |L1.530|
000212  2b00              CMP      r3,#0                 ;502
000214  d1ef              BNE      |L1.502|
;;;511        }
;;;512    
;;;513        tapCnt = (srcBLen) & 1u;
000216  9b0c              LDR      r3,[sp,#0x30]
000218  f0030301          AND      r3,r3,#1
;;;514    
;;;515        /* apply same above for remaining samples of smaller length sequence */
;;;516        while(tapCnt > 0u)
00021c  e006              B        |L1.556|
                  |L1.542|
;;;517        {
;;;518    
;;;519          /* accumlate the results */
;;;520          acc0 += (*pScr1++ * *pIn2++);
00021e  f9326b02          LDRSH    r6,[r2],#2
000222  f9385b02          LDRSH    r5,[r8],#2
000226  fbc60185          SMLALBB  r0,r1,r6,r5
;;;521    
;;;522          /* Decrement the loop counter */
;;;523          tapCnt--;
00022a  1e5b              SUBS     r3,r3,#1
                  |L1.556|
00022c  2b00              CMP      r3,#0                 ;516
00022e  d1f6              BNE      |L1.542|
;;;524        }
;;;525    
;;;526        blkCnt--;
000230  1e64              SUBS     r4,r4,#1
;;;527    
;;;528        /* The result is in 2.30 format.  Convert to 1.15 with saturation.       
;;;529         ** Then store the output in the destination buffer. */
;;;530        *pOut++ = (q15_t) (__SSAT((acc0 >> 15), 16));
000232  0bc0              LSRS     r0,r0,#15
000234  ea404041          ORR      r0,r0,r1,LSL #17
000238  f300010f          SSAT     r1,#16,r0
00023c  9803              LDR      r0,[sp,#0xc]
00023e  8001              STRH     r1,[r0,#0]
000240  9803              LDR      r0,[sp,#0xc]
000242  1c80              ADDS     r0,r0,#2
000244  9003              STR      r0,[sp,#0xc]
;;;531    
;;;532    
;;;533        /* Initialization of inputB pointer */
;;;534        pIn2 = py;
000246  f8dd8008          LDR      r8,[sp,#8]
;;;535    
;;;536        pScratch1 += 1u;
00024a  9817              LDR      r0,[sp,#0x5c]
00024c  1c80              ADDS     r0,r0,#2
00024e  9017              STR      r0,[sp,#0x5c]
                  |L1.592|
000250  2c00              CMP      r4,#0                 ;492
000252  d1ca              BNE      |L1.490|
;;;537    
;;;538      }
;;;539    
;;;540    }
000254  b00d              ADD      sp,sp,#0x34
000256  e8bd8ff0          POP      {r4-r11,pc}
;;;541    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_opt_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_conv_opt_q15_c_b0d93b78____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___18_arm_conv_opt_q15_c_b0d93b78____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_conv_opt_q15_c_b0d93b78____REVSH|
#line 144
|__asm___18_arm_conv_opt_q15_c_b0d93b78____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_conv_opt_q15_c_b0d93b78____RRX|
#line 300
|__asm___18_arm_conv_opt_q15_c_b0d93b78____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
