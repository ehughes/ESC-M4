; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_correlate_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_correlate_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_correlate_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_correlate_q31.c]
                          THUMB

                          AREA ||i.arm_correlate_q31||, CODE, READONLY, ALIGN=1

                  arm_correlate_q31 PROC
;;;77     
;;;78     void arm_correlate_q31(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;79       q31_t * pSrcA,
;;;80       uint32_t srcALen,
;;;81       q31_t * pSrcB,
;;;82       uint32_t srcBLen,
;;;83       q31_t * pDst)
;;;84     {
000004  b089              SUB      sp,sp,#0x24
000006  9c12              LDR      r4,[sp,#0x48]
;;;85     
;;;86     #ifndef ARM_MATH_CM0_FAMILY
;;;87     
;;;88       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;89     
;;;90       q31_t *pIn1;                                   /* inputA pointer               */
;;;91       q31_t *pIn2;                                   /* inputB pointer               */
;;;92       q31_t *pOut = pDst;                            /* output pointer               */
;;;93       q31_t *px;                                     /* Intermediate inputA pointer  */
;;;94       q31_t *py;                                     /* Intermediate inputB pointer  */
;;;95       q31_t *pSrc1;                                  /* Intermediate pointers        */
;;;96       q63_t sum, acc0, acc1, acc2;                   /* Accumulators                  */
;;;97       q31_t x0, x1, x2, c0;                          /* temporary variables for holding input and coefficient values */
;;;98       uint32_t j, k = 0u, count, blkCnt, outBlockSize, blockSize1, blockSize2, blockSize3;  /* loop counter                 */
;;;99       int32_t inc = 1;                               /* Destination address modifier */
000008  2501              MOVS     r5,#1
00000a  9500              STR      r5,[sp,#0]
;;;100    
;;;101    
;;;102      /* The algorithm implementation is based on the lengths of the inputs. */
;;;103      /* srcB is always made to slide across srcA. */
;;;104      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;105      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;106      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;107      /* and the destination pointer modifier, inc is set to -1 */
;;;108      /* If srcALen > srcBLen, zero pad has to be done to srcB to make the two inputs of same length */
;;;109      /* But to improve the performance,    
;;;110       * we include zeroes in the output instead of zero padding either of the the inputs*/
;;;111      /* If srcALen > srcBLen,    
;;;112       * (srcALen - srcBLen) zeroes has to included in the starting of the output buffer */
;;;113      /* If srcALen < srcBLen,    
;;;114       * (srcALen - srcBLen) zeroes has to included in the ending of the output buffer */
;;;115      if(srcALen >= srcBLen)
;;;116      {
;;;117        /* Initialization of inputA pointer */
;;;118        pIn1 = (pSrcA);
;;;119    
;;;120        /* Initialization of inputB pointer */
;;;121        pIn2 = (pSrcB);
;;;122    
;;;123        /* Number of output samples is calculated */
;;;124        outBlockSize = (2u * srcALen) - 1u;
00000c  1ead              SUBS     r5,r5,#2
00000e  4299              CMP      r1,r3                 ;115
000010  d309              BCC      |L1.38|
000012  9007              STR      r0,[sp,#0x1c]         ;118
000014  9206              STR      r2,[sp,#0x18]         ;121
000016  eb050041          ADD      r0,r5,r1,LSL #1
;;;125    
;;;126        /* When srcALen > srcBLen, zero padding is done to srcB    
;;;127         * to make their lengths equal.    
;;;128         * Instead, (outBlockSize - (srcALen + srcBLen - 1))    
;;;129         * number of output samples are made zero */
;;;130        j = outBlockSize - (srcALen + (srcBLen - 1u));
00001a  18ca              ADDS     r2,r1,r3
00001c  1a80              SUBS     r0,r0,r2
00001e  1c40              ADDS     r0,r0,#1
;;;131    
;;;132        /* Updating the pointer position to non zero value */
;;;133        pOut += j;
000020  eb040280          ADD      r2,r4,r0,LSL #2
000024  e009              B        |L1.58|
                  |L1.38|
;;;134    
;;;135      }
;;;136      else
;;;137      {
;;;138        /* Initialization of inputA pointer */
;;;139        pIn1 = (pSrcB);
000026  9207              STR      r2,[sp,#0x1c]
;;;140    
;;;141        /* Initialization of inputB pointer */
;;;142        pIn2 = (pSrcA);
000028  9006              STR      r0,[sp,#0x18]
;;;143    
;;;144        /* srcBLen is always considered as shorter or equal to srcALen */
;;;145        j = srcBLen;
00002a  4618              MOV      r0,r3
;;;146        srcBLen = srcALen;
00002c  460b              MOV      r3,r1
;;;147        srcALen = j;
00002e  4601              MOV      r1,r0
;;;148    
;;;149        /* CORR(x, y) = Reverse order(CORR(y, x)) */
;;;150        /* Hence set the destination pointer to point to the last output sample */
;;;151        pOut = pDst + ((srcALen + srcBLen) - 2u);
000030  18c8              ADDS     r0,r1,r3
000032  1e80              SUBS     r0,r0,#2
000034  eb040280          ADD      r2,r4,r0,LSL #2
;;;152    
;;;153        /* Destination address modifier is set to -1 */
;;;154        inc = -1;
000038  9500              STR      r5,[sp,#0]
                  |L1.58|
;;;155    
;;;156      }
;;;157    
;;;158      /* The function is internally    
;;;159       * divided into three parts according to the number of multiplications that has to be    
;;;160       * taken place between inputA samples and inputB samples. In the first part of the    
;;;161       * algorithm, the multiplications increase by one for every iteration.    
;;;162       * In the second part of the algorithm, srcBLen number of multiplications are done.    
;;;163       * In the third part of the algorithm, the multiplications decrease by one    
;;;164       * for every iteration.*/
;;;165      /* The algorithm is implemented in three stages.    
;;;166       * The loop counters of each stage is initiated here. */
;;;167      blockSize1 = srcBLen - 1u;
00003a  1e5f              SUBS     r7,r3,#1
;;;168      blockSize2 = srcALen - (srcBLen - 1u);
00003c  1ac8              SUBS     r0,r1,r3
00003e  9008              STR      r0,[sp,#0x20]
000040  1c40              ADDS     r0,r0,#1
000042  9002              STR      r0,[sp,#8]
;;;169      blockSize3 = blockSize1;
000044  9701              STR      r7,[sp,#4]
;;;170    
;;;171      /* --------------------------    
;;;172       * Initializations of stage1    
;;;173       * -------------------------*/
;;;174    
;;;175      /* sum = x[0] * y[srcBlen - 1]    
;;;176       * sum = x[0] * y[srcBlen - 2] + x[1] * y[srcBlen - 1]    
;;;177       * ....    
;;;178       * sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen - 1] * y[srcBLen - 1]    
;;;179       */
;;;180    
;;;181      /* In this stage the MAC operations are increased by 1 for every iteration.    
;;;182         The count variable holds the number of MAC operations performed */
;;;183      count = 1u;
000046  2001              MOVS     r0,#1
;;;184    
;;;185      /* Working pointer of inputA */
;;;186      px = pIn1;
000048  f8ddc01c          LDR      r12,[sp,#0x1c]
;;;187    
;;;188      /* Working pointer of inputB */
;;;189      pSrc1 = pIn2 + (srcBLen - 1u);
00004c  9906              LDR      r1,[sp,#0x18]
00004e  1e5c              SUBS     r4,r3,#1
000050  eb010884          ADD      r8,r1,r4,LSL #2
;;;190      py = pSrc1;
000054  4646              MOV      r6,r8
;;;191    
;;;192      /* ------------------------    
;;;193       * Stage1 process    
;;;194       * ----------------------*/
;;;195    
;;;196      /* The first stage starts here */
;;;197      while(blockSize1 > 0u)
000056  e04b              B        |L1.240|
                  |L1.88|
;;;198      {
;;;199        /* Accumulator is made zero for every iteration */
;;;200        sum = 0;
000058  2400              MOVS     r4,#0
00005a  4625              MOV      r5,r4
;;;201    
;;;202        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;203        k = count >> 2;
00005c  0881              LSRS     r1,r0,#2
;;;204    
;;;205        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;206         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;207        while(k > 0u)
00005e  e028              B        |L1.178|
                  |L1.96|
;;;208        {
;;;209          /* x[0] * y[srcBLen - 4] */
;;;210          sum += (q63_t) * px++ * (*py++);
000060  f85c9b04          LDR      r9,[r12],#4
000064  f856ab04          LDR      r10,[r6],#4
000068  fb89a90a          SMULL    r10,r9,r9,r10
00006c  eb1a0404          ADDS     r4,r10,r4
000070  eb490505          ADC      r5,r9,r5
;;;211          /* x[1] * y[srcBLen - 3] */
;;;212          sum += (q63_t) * px++ * (*py++);
000074  f85c9b04          LDR      r9,[r12],#4
000078  f856ab04          LDR      r10,[r6],#4
00007c  fb89a90a          SMULL    r10,r9,r9,r10
000080  eb1a0404          ADDS     r4,r10,r4
000084  eb490505          ADC      r5,r9,r5
;;;213          /* x[2] * y[srcBLen - 2] */
;;;214          sum += (q63_t) * px++ * (*py++);
000088  f85c9b04          LDR      r9,[r12],#4
00008c  f856ab04          LDR      r10,[r6],#4
000090  fb89a90a          SMULL    r10,r9,r9,r10
000094  eb1a0404          ADDS     r4,r10,r4
000098  eb490505          ADC      r5,r9,r5
;;;215          /* x[3] * y[srcBLen - 1] */
;;;216          sum += (q63_t) * px++ * (*py++);
00009c  f85c9b04          LDR      r9,[r12],#4
0000a0  f856ab04          LDR      r10,[r6],#4
0000a4  fb89a90a          SMULL    r10,r9,r9,r10
0000a8  eb1a0404          ADDS     r4,r10,r4
0000ac  eb490505          ADC      r5,r9,r5
;;;217    
;;;218          /* Decrement the loop counter */
;;;219          k--;
0000b0  1e49              SUBS     r1,r1,#1
                  |L1.178|
0000b2  2900              CMP      r1,#0                 ;207
0000b4  d1d4              BNE      |L1.96|
;;;220        }
;;;221    
;;;222        /* If the count is not a multiple of 4, compute any remaining MACs here.    
;;;223         ** No loop unrolling is used. */
;;;224        k = count % 0x4u;
0000b6  f0000103          AND      r1,r0,#3
;;;225    
;;;226        while(k > 0u)
0000ba  e00a              B        |L1.210|
                  |L1.188|
;;;227        {
;;;228          /* Perform the multiply-accumulates */
;;;229          /* x[0] * y[srcBLen - 1] */
;;;230          sum += (q63_t) * px++ * (*py++);
0000bc  f85c9b04          LDR      r9,[r12],#4
0000c0  f856ab04          LDR      r10,[r6],#4
0000c4  fb89a90a          SMULL    r10,r9,r9,r10
0000c8  eb1a0404          ADDS     r4,r10,r4
0000cc  eb490505          ADC      r5,r9,r5
;;;231    
;;;232          /* Decrement the loop counter */
;;;233          k--;
0000d0  1e49              SUBS     r1,r1,#1
                  |L1.210|
0000d2  2900              CMP      r1,#0                 ;226
0000d4  d1f2              BNE      |L1.188|
;;;234        }
;;;235    
;;;236        /* Store the result in the accumulator in the destination buffer. */
;;;237        *pOut = (q31_t) (sum >> 31);
0000d6  0fe1              LSRS     r1,r4,#31
0000d8  ea410145          ORR      r1,r1,r5,LSL #1
0000dc  6011              STR      r1,[r2,#0]
;;;238        /* Destination pointer is updated according to the address modifier, inc */
;;;239        pOut += inc;
0000de  9900              LDR      r1,[sp,#0]
0000e0  eb020281          ADD      r2,r2,r1,LSL #2
;;;240    
;;;241        /* Update the inputA and inputB pointers for next MAC calculation */
;;;242        py = pSrc1 - count;
0000e4  eba80680          SUB      r6,r8,r0,LSL #2
;;;243        px = pIn1;
0000e8  f8ddc01c          LDR      r12,[sp,#0x1c]
;;;244    
;;;245        /* Increment the MAC count */
;;;246        count++;
0000ec  1c40              ADDS     r0,r0,#1
;;;247    
;;;248        /* Decrement the loop counter */
;;;249        blockSize1--;
0000ee  1e7f              SUBS     r7,r7,#1
                  |L1.240|
0000f0  2f00              CMP      r7,#0                 ;197
0000f2  d1b1              BNE      |L1.88|
;;;250      }
;;;251    
;;;252      /* --------------------------    
;;;253       * Initializations of stage2    
;;;254       * ------------------------*/
;;;255    
;;;256      /* sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen-1] * y[srcBLen-1]    
;;;257       * sum = x[1] * y[0] + x[2] * y[1] +...+ x[srcBLen] * y[srcBLen-1]    
;;;258       * ....    
;;;259       * sum = x[srcALen-srcBLen-2] * y[0] + x[srcALen-srcBLen-1] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]    
;;;260       */
;;;261    
;;;262      /* Working pointer of inputA */
;;;263      px = pIn1;
;;;264    
;;;265      /* Working pointer of inputB */
;;;266      py = pIn2;
0000f4  9806              LDR      r0,[sp,#0x18]
;;;267    
;;;268      /* count is index by which the pointer pIn1 to be incremented */
;;;269      count = 0u;
0000f6  2100              MOVS     r1,#0
0000f8  9104              STR      r1,[sp,#0x10]
;;;270    
;;;271      /* -------------------    
;;;272       * Stage2 process    
;;;273       * ------------------*/
;;;274    
;;;275      /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.    
;;;276       * So, to loop unroll over blockSize2,    
;;;277       * srcBLen should be greater than or equal to 4 */
;;;278      if(srcBLen >= 4u)
0000fa  2b04              CMP      r3,#4
0000fc  d37e              BCC      |L1.508|
;;;279      {
;;;280        /* Loop unroll by 3 */
;;;281        blkCnt = blockSize2 / 3;
0000fe  9c02              LDR      r4,[sp,#8]
000100  2103              MOVS     r1,#3
000102  fbb4f4f1          UDIV     r4,r4,r1
000106  9403              STR      r4,[sp,#0xc]
;;;282    
;;;283        while(blkCnt > 0u)
000108  e07b              B        |L1.514|
                  |L1.266|
;;;284        {
;;;285          /* Set all accumulators to zero */
;;;286          acc0 = 0;
00010a  2400              MOVS     r4,#0
00010c  4625              MOV      r5,r4
;;;287          acc1 = 0;
00010e  2600              MOVS     r6,#0
000110  4637              MOV      r7,r6
;;;288          acc2 = 0;
000112  46a0              MOV      r8,r4
000114  46c1              MOV      r9,r8
;;;289    
;;;290          /* read x[0], x[1] samples */
;;;291          x0 = *(px++);
000116  f85cab04          LDR      r10,[r12],#4
;;;292          x1 = *(px++);
00011a  f85c1b04          LDR      r1,[r12],#4
;;;293    
;;;294          /* Apply loop unrolling and compute 3 MACs simultaneously. */
;;;295          k = srcBLen / 3;
00011e  f04f0b03          MOV      r11,#3
000122  fbb3fbfb          UDIV     r11,r3,r11
000126  f8cdb014          STR      r11,[sp,#0x14]
                  |L1.298|
;;;296    
;;;297          /* First part of the processing with loop unrolling.  Compute 3 MACs at a time.        
;;;298           ** a second loop below computes MACs for the remaining 1 to 2 samples. */
;;;299          do
;;;300          {
;;;301            /* Read y[0] sample */
;;;302            c0 = *(py);
00012a  f8d0e000          LDR      lr,[r0,#0]
;;;303    
;;;304            /* Read x[2] sample */
;;;305            x2 = *(px);
00012e  f8dcb000          LDR      r11,[r12,#0]
;;;306    
;;;307            /* Perform the multiply-accumulate */
;;;308            /* acc0 +=  x[0] * y[0] */
;;;309            acc0 += ((q63_t) x0 * c0);
000132  fbca450e          SMLAL    r4,r5,r10,lr
;;;310            /* acc1 +=  x[1] * y[0] */
;;;311            acc1 += ((q63_t) x1 * c0);
000136  fbc1670e          SMLAL    r6,r7,r1,lr
;;;312            /* acc2 +=  x[2] * y[0] */
;;;313            acc2 += ((q63_t) x2 * c0);
00013a  fbcb890e          SMLAL    r8,r9,r11,lr
;;;314    
;;;315            /* Read y[1] sample */
;;;316            c0 = *(py + 1u);
00013e  f8d0e004          LDR      lr,[r0,#4]
;;;317    
;;;318            /* Read x[3] sample */
;;;319            x0 = *(px + 1u);
000142  f8dca004          LDR      r10,[r12,#4]
;;;320    
;;;321            /* Perform the multiply-accumulates */
;;;322            /* acc0 +=  x[1] * y[1] */
;;;323            acc0 += ((q63_t) x1 * c0);
000146  fbc1450e          SMLAL    r4,r5,r1,lr
;;;324            /* acc1 +=  x[2] * y[1] */
;;;325            acc1 += ((q63_t) x2 * c0);
00014a  fbcb670e          SMLAL    r6,r7,r11,lr
;;;326            /* acc2 +=  x[3] * y[1] */
;;;327            acc2 += ((q63_t) x0 * c0);
00014e  fbca890e          SMLAL    r8,r9,r10,lr
;;;328    
;;;329            /* Read y[2] sample */
;;;330            c0 = *(py + 2u);
000152  f8d0e008          LDR      lr,[r0,#8]
;;;331    
;;;332            /* Read x[4] sample */
;;;333            x1 = *(px + 2u);
000156  f8dc1008          LDR      r1,[r12,#8]
;;;334    
;;;335            /* Perform the multiply-accumulates */
;;;336            /* acc0 +=  x[2] * y[2] */
;;;337            acc0 += ((q63_t) x2 * c0);
00015a  fbcb450e          SMLAL    r4,r5,r11,lr
;;;338            /* acc1 +=  x[3] * y[2] */
;;;339            acc1 += ((q63_t) x0 * c0);
00015e  fbca670e          SMLAL    r6,r7,r10,lr
;;;340            /* acc2 +=  x[4] * y[2] */
;;;341            acc2 += ((q63_t) x1 * c0);
000162  fbc1890e          SMLAL    r8,r9,r1,lr
;;;342    
;;;343            /* update scratch pointers */
;;;344            px += 3u;
000166  f10c0c0c          ADD      r12,r12,#0xc
;;;345            py += 3u;
00016a  300c              ADDS     r0,r0,#0xc
;;;346    
;;;347          } while(--k);
00016c  f8ddb014          LDR      r11,[sp,#0x14]
000170  f1bb0b01          SUBS     r11,r11,#1
000174  f8cdb014          STR      r11,[sp,#0x14]
000178  d1d7              BNE      |L1.298|
;;;348    
;;;349          /* If the srcBLen is not a multiple of 3, compute any remaining MACs here.        
;;;350           ** No loop unrolling is used. */
;;;351          k = srcBLen - (3 * (srcBLen / 3));
00017a  f04f0b03          MOV      r11,#3
00017e  fbb3fbfb          UDIV     r11,r3,r11
000182  ebab0b8b          SUB      r11,r11,r11,LSL #2
000186  449b              ADD      r11,r11,r3
000188  f8cdb014          STR      r11,[sp,#0x14]
;;;352    
;;;353          while(k > 0u)
00018c  e011              B        |L1.434|
                  |L1.398|
;;;354          {
;;;355            /* Read y[4] sample */
;;;356            c0 = *(py++);
00018e  f850eb04          LDR      lr,[r0],#4
;;;357    
;;;358            /* Read x[7] sample */
;;;359            x2 = *(px++);
000192  f85cbb04          LDR      r11,[r12],#4
;;;360    
;;;361            /* Perform the multiply-accumulates */
;;;362            /* acc0 +=  x[4] * y[4] */
;;;363            acc0 += ((q63_t) x0 * c0);
000196  fbca450e          SMLAL    r4,r5,r10,lr
;;;364            /* acc1 +=  x[5] * y[4] */
;;;365            acc1 += ((q63_t) x1 * c0);
00019a  fbc1670e          SMLAL    r6,r7,r1,lr
;;;366            /* acc2 +=  x[6] * y[4] */
;;;367            acc2 += ((q63_t) x2 * c0);
00019e  fbcb890e          SMLAL    r8,r9,r11,lr
;;;368    
;;;369            /* Reuse the present samples for the next MAC */
;;;370            x0 = x1;
0001a2  468a              MOV      r10,r1
;;;371            x1 = x2;
0001a4  4659              MOV      r1,r11
;;;372    
;;;373            /* Decrement the loop counter */
;;;374            k--;
0001a6  f8ddb014          LDR      r11,[sp,#0x14]
0001aa  f1ab0b01          SUB      r11,r11,#1
0001ae  f8cdb014          STR      r11,[sp,#0x14]
                  |L1.434|
0001b2  f8ddb014          LDR      r11,[sp,#0x14]        ;353
0001b6  f1bb0f00          CMP      r11,#0                ;353
0001ba  d1e8              BNE      |L1.398|
;;;375          }
;;;376    
;;;377          /* Store the result in the accumulator in the destination buffer. */
;;;378          *pOut = (q31_t) (acc0 >> 31);
0001bc  0fe0              LSRS     r0,r4,#31
0001be  ea400045          ORR      r0,r0,r5,LSL #1
0001c2  6010              STR      r0,[r2,#0]
;;;379          /* Destination pointer is updated according to the address modifier, inc */
;;;380          pOut += inc;
0001c4  9800              LDR      r0,[sp,#0]
0001c6  eb020080          ADD      r0,r2,r0,LSL #2
;;;381    
;;;382          *pOut = (q31_t) (acc1 >> 31);
0001ca  0ff1              LSRS     r1,r6,#31
0001cc  ea410147          ORR      r1,r1,r7,LSL #1
0001d0  6001              STR      r1,[r0,#0]
;;;383          pOut += inc;
0001d2  9900              LDR      r1,[sp,#0]
0001d4  eb000081          ADD      r0,r0,r1,LSL #2
;;;384    
;;;385          *pOut = (q31_t) (acc2 >> 31);
0001d8  ea4f71d8          LSR      r1,r8,#31
0001dc  ea410149          ORR      r1,r1,r9,LSL #1
0001e0  6001              STR      r1,[r0,#0]
;;;386          pOut += inc;
0001e2  9900              LDR      r1,[sp,#0]
0001e4  eb000281          ADD      r2,r0,r1,LSL #2
;;;387    
;;;388          /* Increment the pointer pIn1 index, count by 3 */
;;;389          count += 3u;
0001e8  9804              LDR      r0,[sp,#0x10]
0001ea  1cc0              ADDS     r0,r0,#3
0001ec  9004              STR      r0,[sp,#0x10]
;;;390    
;;;391          /* Update the inputA and inputB pointers for next MAC calculation */
;;;392          px = pIn1 + count;
0001ee  9904              LDR      r1,[sp,#0x10]
0001f0  9807              LDR      r0,[sp,#0x1c]
0001f2  eb000c81          ADD      r12,r0,r1,LSL #2
;;;393          py = pIn2;
0001f6  9806              LDR      r0,[sp,#0x18]
;;;394    
;;;395    
;;;396          /* Decrement the loop counter */
;;;397          blkCnt--;
0001f8  9903              LDR      r1,[sp,#0xc]
0001fa  e000              B        |L1.510|
                  |L1.508|
0001fc  e05a              B        |L1.692|
                  |L1.510|
0001fe  1e49              SUBS     r1,r1,#1
000200  9103              STR      r1,[sp,#0xc]
                  |L1.514|
000202  9903              LDR      r1,[sp,#0xc]          ;283
000204  2900              CMP      r1,#0                 ;283
000206  d180              BNE      |L1.266|
;;;398        }
;;;399    
;;;400        /* If the blockSize2 is not a multiple of 3, compute any remaining output samples here.        
;;;401         ** No loop unrolling is used. */
;;;402        blkCnt = blockSize2 - 3 * (blockSize2 / 3);
000208  9902              LDR      r1,[sp,#8]
00020a  2403              MOVS     r4,#3
00020c  fbb1f1f4          UDIV     r1,r1,r4
000210  eba10481          SUB      r4,r1,r1,LSL #2
000214  9902              LDR      r1,[sp,#8]
000216  1866              ADDS     r6,r4,r1
;;;403    
;;;404        while(blkCnt > 0u)
000218  e049              B        |L1.686|
                  |L1.538|
;;;405        {
;;;406          /* Accumulator is made zero for every iteration */
;;;407          sum = 0;
00021a  2400              MOVS     r4,#0
00021c  4625              MOV      r5,r4
;;;408    
;;;409          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;410          k = srcBLen >> 2u;
00021e  0899              LSRS     r1,r3,#2
;;;411    
;;;412          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;413           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;414          while(k > 0u)
000220  e024              B        |L1.620|
                  |L1.546|
;;;415          {
;;;416            /* Perform the multiply-accumulates */
;;;417            sum += (q63_t) * px++ * (*py++);
000222  f85c7b04          LDR      r7,[r12],#4
000226  f8508b04          LDR      r8,[r0],#4
00022a  fb878708          SMULL    r8,r7,r7,r8
00022e  eb180404          ADDS     r4,r8,r4
000232  417d              ADCS     r5,r5,r7
;;;418            sum += (q63_t) * px++ * (*py++);
000234  f85c7b04          LDR      r7,[r12],#4
000238  f8508b04          LDR      r8,[r0],#4
00023c  fb878708          SMULL    r8,r7,r7,r8
000240  eb180404          ADDS     r4,r8,r4
000244  417d              ADCS     r5,r5,r7
;;;419            sum += (q63_t) * px++ * (*py++);
000246  f85c7b04          LDR      r7,[r12],#4
00024a  f8508b04          LDR      r8,[r0],#4
00024e  fb878708          SMULL    r8,r7,r7,r8
000252  eb180404          ADDS     r4,r8,r4
000256  417d              ADCS     r5,r5,r7
;;;420            sum += (q63_t) * px++ * (*py++);
000258  f85c7b04          LDR      r7,[r12],#4
00025c  f8508b04          LDR      r8,[r0],#4
000260  fb878708          SMULL    r8,r7,r7,r8
000264  eb180404          ADDS     r4,r8,r4
000268  417d              ADCS     r5,r5,r7
;;;421    
;;;422            /* Decrement the loop counter */
;;;423            k--;
00026a  1e49              SUBS     r1,r1,#1
                  |L1.620|
00026c  2900              CMP      r1,#0                 ;414
00026e  d1d8              BNE      |L1.546|
;;;424          }
;;;425    
;;;426          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.    
;;;427           ** No loop unrolling is used. */
;;;428          k = srcBLen % 0x4u;
000270  f0030103          AND      r1,r3,#3
;;;429    
;;;430          while(k > 0u)
000274  e009              B        |L1.650|
                  |L1.630|
;;;431          {
;;;432            /* Perform the multiply-accumulate */
;;;433            sum += (q63_t) * px++ * (*py++);
000276  f85c7b04          LDR      r7,[r12],#4
00027a  f8508b04          LDR      r8,[r0],#4
00027e  fb878708          SMULL    r8,r7,r7,r8
000282  eb180404          ADDS     r4,r8,r4
000286  417d              ADCS     r5,r5,r7
;;;434    
;;;435            /* Decrement the loop counter */
;;;436            k--;
000288  1e49              SUBS     r1,r1,#1
                  |L1.650|
00028a  2900              CMP      r1,#0                 ;430
00028c  d1f3              BNE      |L1.630|
;;;437          }
;;;438    
;;;439          /* Store the result in the accumulator in the destination buffer. */
;;;440          *pOut = (q31_t) (sum >> 31);
00028e  0fe0              LSRS     r0,r4,#31
000290  ea400045          ORR      r0,r0,r5,LSL #1
000294  6010              STR      r0,[r2,#0]
;;;441          /* Destination pointer is updated according to the address modifier, inc */
;;;442          pOut += inc;
000296  9800              LDR      r0,[sp,#0]
000298  eb020280          ADD      r2,r2,r0,LSL #2
;;;443    
;;;444          /* Increment the MAC count */
;;;445          count++;
00029c  9804              LDR      r0,[sp,#0x10]
00029e  1c40              ADDS     r0,r0,#1
0002a0  9004              STR      r0,[sp,#0x10]
;;;446    
;;;447          /* Update the inputA and inputB pointers for next MAC calculation */
;;;448          px = pIn1 + count;
0002a2  9904              LDR      r1,[sp,#0x10]
0002a4  9807              LDR      r0,[sp,#0x1c]
0002a6  eb000c81          ADD      r12,r0,r1,LSL #2
;;;449          py = pIn2;
0002aa  9806              LDR      r0,[sp,#0x18]
;;;450    
;;;451          /* Decrement the loop counter */
;;;452          blkCnt--;
0002ac  1e76              SUBS     r6,r6,#1
                  |L1.686|
0002ae  2e00              CMP      r6,#0                 ;404
0002b0  d1b3              BNE      |L1.538|
0002b2  e023              B        |L1.764|
                  |L1.692|
;;;453        }
;;;454      }
;;;455      else
;;;456      {
;;;457        /* If the srcBLen is not a multiple of 4,    
;;;458         * the blockSize2 loop cannot be unrolled by 4 */
;;;459        blkCnt = blockSize2;
0002b4  9e02              LDR      r6,[sp,#8]
;;;460    
;;;461        while(blkCnt > 0u)
0002b6  e01f              B        |L1.760|
                  |L1.696|
;;;462        {
;;;463          /* Accumulator is made zero for every iteration */
;;;464          sum = 0;
0002b8  2400              MOVS     r4,#0
0002ba  4625              MOV      r5,r4
;;;465    
;;;466          /* Loop over srcBLen */
;;;467          k = srcBLen;
0002bc  4619              MOV      r1,r3
;;;468    
;;;469          while(k > 0u)
0002be  e009              B        |L1.724|
                  |L1.704|
;;;470          {
;;;471            /* Perform the multiply-accumulate */
;;;472            sum += (q63_t) * px++ * (*py++);
0002c0  f85c7b04          LDR      r7,[r12],#4
0002c4  f8508b04          LDR      r8,[r0],#4
0002c8  fb878708          SMULL    r8,r7,r7,r8
0002cc  eb180404          ADDS     r4,r8,r4
0002d0  417d              ADCS     r5,r5,r7
;;;473    
;;;474            /* Decrement the loop counter */
;;;475            k--;
0002d2  1e49              SUBS     r1,r1,#1
                  |L1.724|
0002d4  2900              CMP      r1,#0                 ;469
0002d6  d1f3              BNE      |L1.704|
;;;476          }
;;;477    
;;;478          /* Store the result in the accumulator in the destination buffer. */
;;;479          *pOut = (q31_t) (sum >> 31);
0002d8  0fe0              LSRS     r0,r4,#31
0002da  ea400045          ORR      r0,r0,r5,LSL #1
0002de  6010              STR      r0,[r2,#0]
;;;480          /* Destination pointer is updated according to the address modifier, inc */
;;;481          pOut += inc;
0002e0  9800              LDR      r0,[sp,#0]
0002e2  eb020280          ADD      r2,r2,r0,LSL #2
;;;482    
;;;483          /* Increment the MAC count */
;;;484          count++;
0002e6  9804              LDR      r0,[sp,#0x10]
0002e8  1c40              ADDS     r0,r0,#1
0002ea  9004              STR      r0,[sp,#0x10]
;;;485    
;;;486          /* Update the inputA and inputB pointers for next MAC calculation */
;;;487          px = pIn1 + count;
0002ec  9904              LDR      r1,[sp,#0x10]
0002ee  9807              LDR      r0,[sp,#0x1c]
0002f0  eb000c81          ADD      r12,r0,r1,LSL #2
;;;488          py = pIn2;
0002f4  9806              LDR      r0,[sp,#0x18]
;;;489    
;;;490          /* Decrement the loop counter */
;;;491          blkCnt--;
0002f6  1e76              SUBS     r6,r6,#1
                  |L1.760|
0002f8  2e00              CMP      r6,#0                 ;461
0002fa  d1dd              BNE      |L1.696|
                  |L1.764|
;;;492        }
;;;493      }
;;;494    
;;;495      /* --------------------------    
;;;496       * Initializations of stage3    
;;;497       * -------------------------*/
;;;498    
;;;499      /* sum += x[srcALen-srcBLen+1] * y[0] + x[srcALen-srcBLen+2] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]    
;;;500       * sum += x[srcALen-srcBLen+2] * y[0] + x[srcALen-srcBLen+3] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]    
;;;501       * ....    
;;;502       * sum +=  x[srcALen-2] * y[0] + x[srcALen-1] * y[1]    
;;;503       * sum +=  x[srcALen-1] * y[0]    
;;;504       */
;;;505    
;;;506      /* In this stage the MAC operations are decreased by 1 for every iteration.    
;;;507         The count variable holds the number of MAC operations performed */
;;;508      count = srcBLen - 1u;
0002fc  1e5b              SUBS     r3,r3,#1
;;;509    
;;;510      /* Working pointer of inputA */
;;;511      pSrc1 = pIn1 + (srcALen - (srcBLen - 1u));
0002fe  9908              LDR      r1,[sp,#0x20]
000300  9c07              LDR      r4,[sp,#0x1c]
000302  1c49              ADDS     r1,r1,#1
000304  eb040781          ADD      r7,r4,r1,LSL #2
;;;512      px = pSrc1;
000308  4639              MOV      r1,r7
;;;513    
;;;514      /* Working pointer of inputB */
;;;515      py = pIn2;
;;;516    
;;;517      /* -------------------    
;;;518       * Stage3 process    
;;;519       * ------------------*/
;;;520    
;;;521      while(blockSize3 > 0u)
00030a  e04c              B        |L1.934|
                  |L1.780|
;;;522      {
;;;523        /* Accumulator is made zero for every iteration */
;;;524        sum = 0;
00030c  2400              MOVS     r4,#0
00030e  4625              MOV      r5,r4
;;;525    
;;;526        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;527        k = count >> 2u;
000310  089e              LSRS     r6,r3,#2
;;;528    
;;;529        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;530         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;531        while(k > 0u)
000312  e028              B        |L1.870|
                  |L1.788|
;;;532        {
;;;533          /* Perform the multiply-accumulates */
;;;534          /* sum += x[srcALen - srcBLen + 4] * y[3] */
;;;535          sum += (q63_t) * px++ * (*py++);
000314  f851cb04          LDR      r12,[r1],#4
000318  f8508b04          LDR      r8,[r0],#4
00031c  fb8c8c08          SMULL    r8,r12,r12,r8
000320  eb180404          ADDS     r4,r8,r4
000324  eb4c0505          ADC      r5,r12,r5
;;;536          /* sum += x[srcALen - srcBLen + 3] * y[2] */
;;;537          sum += (q63_t) * px++ * (*py++);
000328  f851cb04          LDR      r12,[r1],#4
00032c  f8508b04          LDR      r8,[r0],#4
000330  fb8c8c08          SMULL    r8,r12,r12,r8
000334  eb180404          ADDS     r4,r8,r4
000338  eb4c0505          ADC      r5,r12,r5
;;;538          /* sum += x[srcALen - srcBLen + 2] * y[1] */
;;;539          sum += (q63_t) * px++ * (*py++);
00033c  f851cb04          LDR      r12,[r1],#4
000340  f8508b04          LDR      r8,[r0],#4
000344  fb8c8c08          SMULL    r8,r12,r12,r8
000348  eb180404          ADDS     r4,r8,r4
00034c  eb4c0505          ADC      r5,r12,r5
;;;540          /* sum += x[srcALen - srcBLen + 1] * y[0] */
;;;541          sum += (q63_t) * px++ * (*py++);
000350  f851cb04          LDR      r12,[r1],#4
000354  f8508b04          LDR      r8,[r0],#4
000358  fb8c8c08          SMULL    r8,r12,r12,r8
00035c  eb180404          ADDS     r4,r8,r4
000360  eb4c0505          ADC      r5,r12,r5
;;;542    
;;;543          /* Decrement the loop counter */
;;;544          k--;
000364  1e76              SUBS     r6,r6,#1
                  |L1.870|
000366  2e00              CMP      r6,#0                 ;531
000368  d1d4              BNE      |L1.788|
;;;545        }
;;;546    
;;;547        /* If the count is not a multiple of 4, compute any remaining MACs here.    
;;;548         ** No loop unrolling is used. */
;;;549        k = count % 0x4u;
00036a  f0030603          AND      r6,r3,#3
;;;550    
;;;551        while(k > 0u)
00036e  e00a              B        |L1.902|
                  |L1.880|
;;;552        {
;;;553          /* Perform the multiply-accumulates */
;;;554          sum += (q63_t) * px++ * (*py++);
000370  f851cb04          LDR      r12,[r1],#4
000374  f8508b04          LDR      r8,[r0],#4
000378  fb8c8c08          SMULL    r8,r12,r12,r8
00037c  eb180404          ADDS     r4,r8,r4
000380  eb4c0505          ADC      r5,r12,r5
;;;555    
;;;556          /* Decrement the loop counter */
;;;557          k--;
000384  1e76              SUBS     r6,r6,#1
                  |L1.902|
000386  2e00              CMP      r6,#0                 ;551
000388  d1f2              BNE      |L1.880|
;;;558        }
;;;559    
;;;560        /* Store the result in the accumulator in the destination buffer. */
;;;561        *pOut = (q31_t) (sum >> 31);
00038a  0fe0              LSRS     r0,r4,#31
00038c  ea400045          ORR      r0,r0,r5,LSL #1
000390  6010              STR      r0,[r2,#0]
;;;562        /* Destination pointer is updated according to the address modifier, inc */
;;;563        pOut += inc;
000392  9800              LDR      r0,[sp,#0]
000394  eb020280          ADD      r2,r2,r0,LSL #2
;;;564    
;;;565        /* Update the inputA and inputB pointers for next MAC calculation */
;;;566        px = ++pSrc1;
000398  1d39              ADDS     r1,r7,#4
00039a  460f              MOV      r7,r1
;;;567        py = pIn2;
00039c  9806              LDR      r0,[sp,#0x18]
;;;568    
;;;569        /* Decrement the MAC count */
;;;570        count--;
00039e  1e5b              SUBS     r3,r3,#1
;;;571    
;;;572        /* Decrement the loop counter */
;;;573        blockSize3--;
0003a0  9c01              LDR      r4,[sp,#4]
0003a2  1e64              SUBS     r4,r4,#1
0003a4  9401              STR      r4,[sp,#4]
                  |L1.934|
0003a6  9c01              LDR      r4,[sp,#4]            ;521
0003a8  2c00              CMP      r4,#0                 ;521
0003aa  d1af              BNE      |L1.780|
;;;574      }
;;;575    
;;;576    #else
;;;577    
;;;578      /* Run the below code for Cortex-M0 */
;;;579    
;;;580      q31_t *pIn1 = pSrcA;                           /* inputA pointer               */
;;;581      q31_t *pIn2 = pSrcB + (srcBLen - 1u);          /* inputB pointer               */
;;;582      q63_t sum;                                     /* Accumulators                  */
;;;583      uint32_t i = 0u, j;                            /* loop counters */
;;;584      uint32_t inv = 0u;                             /* Reverse order flag */
;;;585      uint32_t tot = 0u;                             /* Length */
;;;586    
;;;587      /* The algorithm implementation is based on the lengths of the inputs. */
;;;588      /* srcB is always made to slide across srcA. */
;;;589      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;590      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;591      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;592      /* and a varaible, inv is set to 1 */
;;;593      /* If lengths are not equal then zero pad has to be done to  make the two    
;;;594       * inputs of same length. But to improve the performance, we include zeroes    
;;;595       * in the output instead of zero padding either of the the inputs*/
;;;596      /* If srcALen > srcBLen, (srcALen - srcBLen) zeroes has to included in the    
;;;597       * starting of the output buffer */
;;;598      /* If srcALen < srcBLen, (srcALen - srcBLen) zeroes has to included in the   
;;;599       * ending of the output buffer */
;;;600      /* Once the zero padding is done the remaining of the output is calcualted   
;;;601       * using correlation but with the shorter signal time shifted. */
;;;602    
;;;603      /* Calculate the length of the remaining sequence */
;;;604      tot = ((srcALen + srcBLen) - 2u);
;;;605    
;;;606      if(srcALen > srcBLen)
;;;607      {
;;;608        /* Calculating the number of zeros to be padded to the output */
;;;609        j = srcALen - srcBLen;
;;;610    
;;;611        /* Initialise the pointer after zero padding */
;;;612        pDst += j;
;;;613      }
;;;614    
;;;615      else if(srcALen < srcBLen)
;;;616      {
;;;617        /* Initialization to inputB pointer */
;;;618        pIn1 = pSrcB;
;;;619    
;;;620        /* Initialization to the end of inputA pointer */
;;;621        pIn2 = pSrcA + (srcALen - 1u);
;;;622    
;;;623        /* Initialisation of the pointer after zero padding */
;;;624        pDst = pDst + tot;
;;;625    
;;;626        /* Swapping the lengths */
;;;627        j = srcALen;
;;;628        srcALen = srcBLen;
;;;629        srcBLen = j;
;;;630    
;;;631        /* Setting the reverse flag */
;;;632        inv = 1;
;;;633    
;;;634      }
;;;635    
;;;636      /* Loop to calculate correlation for output length number of times */
;;;637      for (i = 0u; i <= tot; i++)
;;;638      {
;;;639        /* Initialize sum with zero to carry on MAC operations */
;;;640        sum = 0;
;;;641    
;;;642        /* Loop to perform MAC operations according to correlation equation */
;;;643        for (j = 0u; j <= i; j++)
;;;644        {
;;;645          /* Check the array limitations */
;;;646          if((((i - j) < srcBLen) && (j < srcALen)))
;;;647          {
;;;648            /* z[i] += x[i-j] * y[j] */
;;;649            sum += ((q63_t) pIn1[j] * pIn2[-((int32_t) i - j)]);
;;;650          }
;;;651        }
;;;652        /* Store the output in the destination buffer */
;;;653        if(inv == 1)
;;;654          *pDst-- = (q31_t) (sum >> 31u);
;;;655        else
;;;656          *pDst++ = (q31_t) (sum >> 31u);
;;;657      }
;;;658    
;;;659    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;660    
;;;661    }
0003ac  b009              ADD      sp,sp,#0x24
0003ae  e8bd8ff0          POP      {r4-r11,pc}
;;;662    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_correlate_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_correlate_q31_c_0930b14d____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___19_arm_correlate_q31_c_0930b14d____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_correlate_q31_c_0930b14d____REVSH|
#line 144
|__asm___19_arm_correlate_q31_c_0930b14d____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_correlate_q31_c_0930b14d____RRX|
#line 300
|__asm___19_arm_correlate_q31_c_0930b14d____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
