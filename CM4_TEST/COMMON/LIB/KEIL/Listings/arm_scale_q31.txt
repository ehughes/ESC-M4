; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_scale_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_scale_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_scale_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\BasicMathFunctions\arm_scale_q31.c]
                          THUMB

                          AREA ||i.arm_scale_q31||, CODE, READONLY, ALIGN=1

                  arm_scale_q31 PROC
;;;66     
;;;67     void arm_scale_q31(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;68       q31_t * pSrc,
;;;69       q31_t scaleFract,
;;;70       int8_t shift,
;;;71       q31_t * pDst,
;;;72       uint32_t blockSize)
;;;73     {
;;;74       int8_t kShift = shift + 1;                     /* Shift to apply after scaling */
000004  1c52              ADDS     r2,r2,#1
000006  b252              SXTB     r2,r2
;;;75       int8_t sign = (kShift & 0x80);
000008  f0020480          AND      r4,r2,#0x80
00000c  fa4ffa84          SXTB     r10,r4
;;;76       uint32_t blkCnt;                               /* loop counter */
;;;77       q31_t in, out;
;;;78     
;;;79     #ifndef ARM_MATH_CM0_FAMILY
;;;80     
;;;81     /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;82     
;;;83       q31_t in1, in2, in3, in4;                      /* temporary input variables */
;;;84       q31_t out1, out2, out3, out4;                  /* temporary output variabels */
;;;85     
;;;86     
;;;87       /*loop Unrolling */
;;;88       blkCnt = blockSize >> 2u;
000010  9c09              LDR      r4,[sp,#0x24]
000012  08a4              LSRS     r4,r4,#2
;;;89     
;;;90       if(sign == 0u)
;;;91       {
;;;92         /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.       
;;;93          ** a second loop below computes the remaining 1 to 3 samples. */
;;;94         while(blkCnt > 0u)
;;;95         {
;;;96           /* read four inputs from source */
;;;97           in1 = *pSrc;
;;;98           in2 = *(pSrc + 1);
;;;99           in3 = *(pSrc + 2);
;;;100          in4 = *(pSrc + 3);
;;;101    
;;;102          /* multiply input with scaler value */
;;;103          in1 = ((q63_t) in1 * scaleFract) >> 32;
;;;104          in2 = ((q63_t) in2 * scaleFract) >> 32;
;;;105          in3 = ((q63_t) in3 * scaleFract) >> 32;
;;;106          in4 = ((q63_t) in4 * scaleFract) >> 32;
;;;107    
;;;108          /* apply shifting */
;;;109          out1 = in1 << kShift;
;;;110          out2 = in2 << kShift;
;;;111    
;;;112          /* saturate the results. */
;;;113          if(in1 != (out1 >> kShift))
;;;114            out1 = 0x7FFFFFFF ^ (in1 >> 31);
000014  f06f4600          MVN      r6,#0x80000000
000018  f1ba0f00          CMP      r10,#0                ;90
00001c  d038              BEQ      |L1.144|
00001e  e05a              B        |L1.214|
                  |L1.32|
000020  f8d08000          LDR      r8,[r0,#0]            ;97
000024  f8d0c004          LDR      r12,[r0,#4]           ;98
000028  6885              LDR      r5,[r0,#8]            ;99
00002a  68c7              LDR      r7,[r0,#0xc]          ;100
00002c  fb58f801          SMMUL    r8,r8,r1              ;103
000030  fb5cf901          SMMUL    r9,r12,r1             ;104
000034  fb55f501          SMMUL    r5,r5,r1              ;105
000038  fb57fb01          SMMUL    r11,r7,r1             ;106
00003c  fa08f702          LSL      r7,r8,r2              ;109
000040  fa09fc02          LSL      r12,r9,r2             ;110
000044  fa47fe02          ASR      lr,r7,r2              ;113
000048  45c6              CMP      lr,r8                 ;113
00004a  d001              BEQ      |L1.80|
00004c  ea8677e8          EOR      r7,r6,r8,ASR #31
                  |L1.80|
;;;115    
;;;116          if(in2 != (out2 >> kShift))
000050  fa4cf802          ASR      r8,r12,r2
000054  45c8              CMP      r8,r9
000056  d001              BEQ      |L1.92|
;;;117            out2 = 0x7FFFFFFF ^ (in2 >> 31);
000058  ea867ce9          EOR      r12,r6,r9,ASR #31
                  |L1.92|
;;;118    
;;;119          out3 = in3 << kShift;
00005c  fa05f802          LSL      r8,r5,r2
;;;120          out4 = in4 << kShift;
000060  fa0bf902          LSL      r9,r11,r2
;;;121    
;;;122          *pDst = out1;
000064  601f              STR      r7,[r3,#0]
;;;123          *(pDst + 1) = out2;
000066  f8c3c004          STR      r12,[r3,#4]
;;;124    
;;;125          if(in3 != (out3 >> kShift))
00006a  fa48f702          ASR      r7,r8,r2
00006e  42af              CMP      r7,r5
000070  d001              BEQ      |L1.118|
;;;126            out3 = 0x7FFFFFFF ^ (in3 >> 31);
000072  ea8678e5          EOR      r8,r6,r5,ASR #31
                  |L1.118|
;;;127    
;;;128          if(in4 != (out4 >> kShift))
000076  fa49f502          ASR      r5,r9,r2
00007a  455d              CMP      r5,r11
00007c  d001              BEQ      |L1.130|
;;;129            out4 = 0x7FFFFFFF ^ (in4 >> 31);
00007e  ea8679eb          EOR      r9,r6,r11,ASR #31
                  |L1.130|
;;;130    
;;;131          /* Store result destination */
;;;132          *(pDst + 2) = out3;
000082  f8c38008          STR      r8,[r3,#8]
;;;133          *(pDst + 3) = out4;
000086  f8c3900c          STR      r9,[r3,#0xc]
;;;134    
;;;135          /* Update pointers to process next sampels */
;;;136          pSrc += 4u;
00008a  3010              ADDS     r0,r0,#0x10
;;;137          pDst += 4u;
00008c  3310              ADDS     r3,r3,#0x10
;;;138    
;;;139          /* Decrement the loop counter */
;;;140          blkCnt--;
00008e  1e64              SUBS     r4,r4,#1
                  |L1.144|
000090  2c00              CMP      r4,#0                 ;94
000092  d1c5              BNE      |L1.32|
000094  e021              B        |L1.218|
                  |L1.150|
;;;141        }
;;;142    
;;;143      }
;;;144      else
;;;145      {
;;;146        /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.       
;;;147         ** a second loop below computes the remaining 1 to 3 samples. */
;;;148        while(blkCnt > 0u)
;;;149        {
;;;150          /* read four inputs from source */
;;;151          in1 = *pSrc;
000096  f8d08000          LDR      r8,[r0,#0]
;;;152          in2 = *(pSrc + 1);
00009a  6847              LDR      r7,[r0,#4]
;;;153          in3 = *(pSrc + 2);
00009c  f8d0c008          LDR      r12,[r0,#8]
;;;154          in4 = *(pSrc + 3);
0000a0  68c5              LDR      r5,[r0,#0xc]
;;;155    
;;;156          /* multiply input with scaler value */
;;;157          in1 = ((q63_t) in1 * scaleFract) >> 32;
0000a2  fb58f901          SMMUL    r9,r8,r1
;;;158          in2 = ((q63_t) in2 * scaleFract) >> 32;
0000a6  fb57f701          SMMUL    r7,r7,r1
;;;159          in3 = ((q63_t) in3 * scaleFract) >> 32;
0000aa  fb5cfc01          SMMUL    r12,r12,r1
;;;160          in4 = ((q63_t) in4 * scaleFract) >> 32;
0000ae  fb55f801          SMMUL    r8,r5,r1
;;;161    
;;;162          /* apply shifting */
;;;163          out1 = in1 >> -kShift;
0000b2  4255              RSBS     r5,r2,#0
0000b4  fa49f905          ASR      r9,r9,r5
;;;164          out2 = in2 >> -kShift;
0000b8  412f              ASRS     r7,r7,r5
;;;165    
;;;166          out3 = in3 >> -kShift;
0000ba  fa4cfc05          ASR      r12,r12,r5
;;;167          out4 = in4 >> -kShift;
0000be  fa48f805          ASR      r8,r8,r5
;;;168    
;;;169          /* Store result destination */
;;;170          *pDst = out1;
0000c2  f8c39000          STR      r9,[r3,#0]
;;;171          *(pDst + 1) = out2;
0000c6  605f              STR      r7,[r3,#4]
;;;172    
;;;173          *(pDst + 2) = out3;
0000c8  f8c3c008          STR      r12,[r3,#8]
;;;174          *(pDst + 3) = out4;
0000cc  f8c3800c          STR      r8,[r3,#0xc]
;;;175    
;;;176          /* Update pointers to process next sampels */
;;;177          pSrc += 4u;
0000d0  3010              ADDS     r0,r0,#0x10
;;;178          pDst += 4u;
0000d2  3310              ADDS     r3,r3,#0x10
;;;179    
;;;180          /* Decrement the loop counter */
;;;181          blkCnt--;
0000d4  1e64              SUBS     r4,r4,#1
                  |L1.214|
0000d6  2c00              CMP      r4,#0                 ;148
0000d8  d1dd              BNE      |L1.150|
                  |L1.218|
;;;182        }
;;;183      }
;;;184      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.       
;;;185       ** No loop unrolling is used. */
;;;186      blkCnt = blockSize % 0x4u;
0000da  9c09              LDR      r4,[sp,#0x24]
0000dc  f0040403          AND      r4,r4,#3
;;;187    
;;;188    #else
;;;189    
;;;190      /* Run the below code for Cortex-M0 */
;;;191    
;;;192      /* Initialize blkCnt with number of samples */
;;;193      blkCnt = blockSize;
;;;194    
;;;195    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;196    
;;;197      if(sign == 0)
0000e0  f1ba0f00          CMP      r10,#0
0000e4  d00e              BEQ      |L1.260|
0000e6  4255              RSBS     r5,r2,#0              ;163
;;;198      {
;;;199    	  while(blkCnt > 0u)
;;;200    	  {
;;;201    		/* C = A * scale */
;;;202    		/* Scale the input and then store the result in the destination buffer. */
;;;203    		in = *pSrc++;
;;;204    		in = ((q63_t) in * scaleFract) >> 32;
;;;205    
;;;206    		out = in << kShift;
;;;207    		
;;;208    		if(in != (out >> kShift))
;;;209    			out = 0x7FFFFFFF ^ (in >> 31);
;;;210    
;;;211    		*pDst++ = out;
;;;212    
;;;213    		/* Decrement the loop counter */
;;;214    		blkCnt--;
;;;215    	  }
;;;216      }
;;;217      else
;;;218      {
;;;219    	  while(blkCnt > 0u)
0000e8  e016              B        |L1.280|
                  |L1.234|
0000ea  c820              LDM      r0!,{r5}              ;203
0000ec  fb55f701          SMMUL    r7,r5,r1              ;204
0000f0  fa07f502          LSL      r5,r7,r2              ;206
0000f4  fa45fc02          ASR      r12,r5,r2             ;208
0000f8  45bc              CMP      r12,r7                ;208
0000fa  d001              BEQ      |L1.256|
0000fc  ea8675e7          EOR      r5,r6,r7,ASR #31      ;209
                  |L1.256|
000100  c320              STM      r3!,{r5}              ;211
000102  1e64              SUBS     r4,r4,#1              ;214
                  |L1.260|
000104  2c00              CMP      r4,#0                 ;199
000106  d1f0              BNE      |L1.234|
                  |L1.264|
;;;220    	  {
;;;221    		/* C = A * scale */
;;;222    		/* Scale the input and then store the result in the destination buffer. */
;;;223    		in = *pSrc++;
;;;224    		in = ((q63_t) in * scaleFract) >> 32;
;;;225    
;;;226    		out = in >> -kShift;
;;;227    
;;;228    		*pDst++ = out;
;;;229    
;;;230    		/* Decrement the loop counter */
;;;231    		blkCnt--;
;;;232    	  }
;;;233      
;;;234      }
;;;235    }
000108  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.268|
00010c  c804              LDM      r0!,{r2}              ;223
00010e  fb52f201          SMMUL    r2,r2,r1              ;224
000112  412a              ASRS     r2,r2,r5              ;226
000114  c304              STM      r3!,{r2}              ;228
000116  1e64              SUBS     r4,r4,#1              ;231
                  |L1.280|
000118  2c00              CMP      r4,#0                 ;219
00011a  d1f7              BNE      |L1.268|
00011c  e7f4              B        |L1.264|
;;;236    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\BasicMathFunctions\\arm_scale_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_arm_scale_q31_c_30b80c54____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___15_arm_scale_q31_c_30b80c54____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_arm_scale_q31_c_30b80c54____REVSH|
#line 144
|__asm___15_arm_scale_q31_c_30b80c54____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_arm_scale_q31_c_30b80c54____RRX|
#line 300
|__asm___15_arm_scale_q31_c_30b80c54____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
