; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_decimate_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_decimate_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_fir_decimate_f32.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_fir_decimate_f32.c]
                          THUMB

                          AREA ||i.arm_fir_decimate_f32||, CODE, READONLY, ALIGN=2

                  arm_fir_decimate_f32 PROC
;;;140    
;;;141    void arm_fir_decimate_f32(
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;142      const arm_fir_decimate_instance_f32 * S,
;;;143      float32_t * pSrc,
;;;144      float32_t * pDst,
;;;145      uint32_t blockSize)
;;;146    {
;;;147      float32_t *pState = S->pState;                 /* State pointer */
000004  6884              LDR      r4,[r0,#8]
;;;148      float32_t *pCoeffs = S->pCoeffs;               /* Coefficient pointer */
000006  6845              LDR      r5,[r0,#4]
000008  9500              STR      r5,[sp,#0]
;;;149      float32_t *pStateCurnt;                        /* Points to the current sample of the state */
;;;150      float32_t *px, *pb;                            /* Temporary pointers for state and coefficient buffers */
;;;151      float32_t sum0;                                /* Accumulator */
;;;152      float32_t x0, c0;                              /* Temporary variables to hold state and coefficient values */
;;;153      uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
00000a  f8b0a002          LDRH     r10,[r0,#2]
;;;154      uint32_t i, tapCnt, blkCnt, outBlockSize = blockSize / S->M;  /* Loop counters */
00000e  7805              LDRB     r5,[r0,#0]
000010  fbb3f3f5          UDIV     r3,r3,r5
;;;155    
;;;156    #ifndef ARM_MATH_CM0_FAMILY
;;;157    
;;;158      uint32_t blkCntN4;
;;;159      float32_t *px0, *px1, *px2, *px3;
;;;160      float32_t acc0, acc1, acc2, acc3;
;;;161      float32_t x1, x2, x3;
;;;162    
;;;163      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;164    
;;;165      /* S->pState buffer contains previous frame (numTaps - 1) samples */
;;;166      /* pStateCurnt points to the location where the new input data should be written */
;;;167      pStateCurnt = S->pState + (numTaps - 1u);
000014  f1aa0501          SUB      r5,r10,#1
000018  eb040885          ADD      r8,r4,r5,LSL #2
00001c  9502              STR      r5,[sp,#8]
;;;168    
;;;169      /* Total number of output samples to be computed */
;;;170      blkCnt = outBlockSize / 4;
00001e  ea4f0b93          LSR      r11,r3,#2
;;;171      blkCntN4 = outBlockSize - (4 * blkCnt);
000022  f1cb0500          RSB      r5,r11,#0
000026  eb030e85          ADD      lr,r3,r5,LSL #2
;;;172    
;;;173      while(blkCnt > 0u)
;;;174      {
;;;175        /* Copy 4 * decimation factor number of new input samples into the state buffer */
;;;176        i = 4 * S->M;
;;;177    
;;;178        do
;;;179        {
;;;180          *pStateCurnt++ = *pSrc++;
;;;181    
;;;182        } while(--i);
;;;183    
;;;184        /* Set accumulators to zero */
;;;185        acc0 = 0.0f;
00002a  ed9f4a84          VLDR     s8,|L1.572|
00002e  e09c              B        |L1.362|
                  |L1.48|
000030  7803              LDRB     r3,[r0,#0]            ;176
000032  009b              LSLS     r3,r3,#2              ;176
                  |L1.52|
000034  ecb10a01          VLDM     r1!,{s0}              ;180
000038  eca80a01          VSTM     r8!,{s0}              ;180
00003c  1e5b              SUBS     r3,r3,#1              ;182
00003e  d1f9              BNE      |L1.52|
;;;186        acc1 = 0.0f;
000040  eeb00a44          VMOV.F32 s0,s8
000044  eef00a40          VMOV.F32 s1,s0
;;;187        acc2 = 0.0f;
000048  eeb00a44          VMOV.F32 s0,s8
00004c  eeb01a40          VMOV.F32 s2,s0
;;;188        acc3 = 0.0f;
000050  eef01a44          VMOV.F32 s3,s8
;;;189    
;;;190        /* Initialize state pointer for all the samples */
;;;191        px0 = pState;
;;;192        px1 = pState + S->M;
000054  7805              LDRB     r5,[r0,#0]
000056  9501              STR      r5,[sp,#4]
000058  eb040685          ADD      r6,r4,r5,LSL #2
;;;193        px2 = pState + 2 * S->M;
00005c  eb0407c5          ADD      r7,r4,r5,LSL #3
;;;194        px3 = pState + 3 * S->M;
000060  eb050545          ADD      r5,r5,r5,LSL #1
000064  4623              MOV      r3,r4
000066  eb040c85          ADD      r12,r4,r5,LSL #2
;;;195    
;;;196        /* Initialize coeff pointer */
;;;197        pb = pCoeffs;
00006a  9d00              LDR      r5,[sp,#0]
;;;198    
;;;199        /* Loop unrolling.  Process 4 taps at a time. */
;;;200        tapCnt = numTaps >> 2;
00006c  ea4f099a          LSR      r9,r10,#2
;;;201    
;;;202        /* Loop over the number of taps.  Unroll by a factor of 4.       
;;;203         ** Repeat until we've computed numTaps-4 coefficients. */
;;;204    
;;;205        while(tapCnt > 0u)
000070  e051              B        |L1.278|
                  |L1.114|
;;;206        {
;;;207          /* Read the b[numTaps-1] coefficient */
;;;208          c0 = *(pb++);
000072  ecb52a01          VLDM     r5!,{s4}
;;;209    
;;;210          /* Read x[n-numTaps-1] sample for acc0 */
;;;211          x0 = *(px0++);
000076  ecb35a01          VLDM     r3!,{s10}
;;;212          /* Read x[n-numTaps-1] sample for acc1 */
;;;213          x1 = *(px1++);
00007a  ecf64a01          VLDM     r6!,{s9}
;;;214          /* Read x[n-numTaps-1] sample for acc2 */
;;;215          x2 = *(px2++);
00007e  ecb73a01          VLDM     r7!,{s6}
;;;216          /* Read x[n-numTaps-1] sample for acc3 */
;;;217          x3 = *(px3++);
000082  ecfc3a01          VLDM     r12!,{s7}
;;;218    
;;;219          /* Perform the multiply-accumulate */
;;;220          acc0 += x0 * c0;
000086  eef02a40          VMOV.F32 s5,s0
00008a  ee452a02          VMLA.F32 s5,s10,s4
;;;221          acc1 += x1 * c0;
00008e  ee440a82          VMLA.F32 s1,s9,s4
;;;222          acc2 += x2 * c0;
000092  ee031a02          VMLA.F32 s2,s6,s4
;;;223          acc3 += x3 * c0;
000096  eeb03a61          VMOV.F32 s6,s3
00009a  ee033a82          VMLA.F32 s6,s7,s4
;;;224    
;;;225          /* Read the b[numTaps-2] coefficient */
;;;226          c0 = *(pb++);
00009e  ecb50a01          VLDM     r5!,{s0}
;;;227    
;;;228          /* Read x[n-numTaps-2] sample for acc0, acc1, acc2, acc3 */
;;;229          x0 = *(px0++);
0000a2  ecf34a01          VLDM     r3!,{s9}
;;;230          x1 = *(px1++);
0000a6  ecf63a01          VLDM     r6!,{s7}
;;;231          x2 = *(px2++);
0000aa  ecb72a01          VLDM     r7!,{s4}
;;;232          x3 = *(px3++);
0000ae  ecfc1a01          VLDM     r12!,{s3}
;;;233    
;;;234          /* Perform the multiply-accumulate */
;;;235          acc0 += x0 * c0;
0000b2  ee442a80          VMLA.F32 s5,s9,s0
;;;236          acc1 += x1 * c0;
0000b6  ee430a80          VMLA.F32 s1,s7,s0
;;;237          acc2 += x2 * c0;
0000ba  ee021a00          VMLA.F32 s2,s4,s0
;;;238          acc3 += x3 * c0;
0000be  ee013a80          VMLA.F32 s6,s3,s0
;;;239    
;;;240          /* Read the b[numTaps-3] coefficient */
;;;241          c0 = *(pb++);
0000c2  ecb50a01          VLDM     r5!,{s0}
;;;242    
;;;243          /* Read x[n-numTaps-3] sample acc0, acc1, acc2, acc3 */
;;;244          x0 = *(px0++);
0000c6  ecf34a01          VLDM     r3!,{s9}
;;;245          x1 = *(px1++);
0000ca  ecf63a01          VLDM     r6!,{s7}
;;;246          x2 = *(px2++);
0000ce  ecb72a01          VLDM     r7!,{s4}
;;;247          x3 = *(px3++);
0000d2  ecfc1a01          VLDM     r12!,{s3}
;;;248    
;;;249          /* Perform the multiply-accumulate */
;;;250          acc0 += x0 * c0;
0000d6  ee442a80          VMLA.F32 s5,s9,s0
;;;251          acc1 += x1 * c0;
0000da  ee430a80          VMLA.F32 s1,s7,s0
;;;252          acc2 += x2 * c0;
0000de  ee021a00          VMLA.F32 s2,s4,s0
;;;253          acc3 += x3 * c0;
0000e2  ee013a80          VMLA.F32 s6,s3,s0
;;;254    
;;;255          /* Read the b[numTaps-4] coefficient */
;;;256          c0 = *(pb++);
0000e6  ecf51a01          VLDM     r5!,{s3}
;;;257    
;;;258          /* Read x[n-numTaps-4] sample acc0, acc1, acc2, acc3 */
;;;259          x0 = *(px0++);
0000ea  ecb30a01          VLDM     r3!,{s0}
;;;260          x1 = *(px1++);
0000ee  ecf64a01          VLDM     r6!,{s9}
;;;261          x2 = *(px2++);
0000f2  ecf73a01          VLDM     r7!,{s7}
;;;262          x3 = *(px3++);
0000f6  ecbc2a01          VLDM     r12!,{s4}
;;;263    
;;;264          /* Perform the multiply-accumulate */
;;;265          acc0 += x0 * c0;
0000fa  ee402a21          VMLA.F32 s5,s0,s3
0000fe  eeb00a62          VMOV.F32 s0,s5
;;;266          acc1 += x1 * c0;
000102  ee440aa1          VMLA.F32 s1,s9,s3
;;;267          acc2 += x2 * c0;
000106  ee031aa1          VMLA.F32 s2,s7,s3
;;;268          acc3 += x3 * c0;
00010a  ee023a21          VMLA.F32 s6,s4,s3
00010e  eef01a43          VMOV.F32 s3,s6
;;;269    
;;;270          /* Decrement the loop counter */
;;;271          tapCnt--;
000112  f1a90901          SUB      r9,r9,#1
                  |L1.278|
000116  f1b90f00          CMP      r9,#0                 ;205
00011a  d1aa              BNE      |L1.114|
;;;272        }
;;;273    
;;;274        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;275        tapCnt = numTaps % 0x4u;
00011c  f00a0903          AND      r9,r10,#3
;;;276    
;;;277        while(tapCnt > 0u)
000120  e013              B        |L1.330|
                  |L1.290|
;;;278        {
;;;279          /* Read coefficients */
;;;280          c0 = *(pb++);
000122  ecb52a01          VLDM     r5!,{s4}
;;;281    
;;;282          /* Fetch  state variables for acc0, acc1, acc2, acc3 */
;;;283          x0 = *(px0++);
000126  ecf32a01          VLDM     r3!,{s5}
;;;284          x1 = *(px1++);
00012a  ecb63a01          VLDM     r6!,{s6}
;;;285          x2 = *(px2++);
00012e  ecf73a01          VLDM     r7!,{s7}
;;;286          x3 = *(px3++);
000132  ecfc4a01          VLDM     r12!,{s9}
;;;287    
;;;288          /* Perform the multiply-accumulate */
;;;289          acc0 += x0 * c0;
000136  ee020a82          VMLA.F32 s0,s5,s4
;;;290          acc1 += x1 * c0;
00013a  ee430a02          VMLA.F32 s1,s6,s4
;;;291          acc2 += x2 * c0;
00013e  ee031a82          VMLA.F32 s2,s7,s4
;;;292          acc3 += x3 * c0;
000142  ee441a82          VMLA.F32 s3,s9,s4
;;;293    
;;;294          /* Decrement the loop counter */
;;;295          tapCnt--;
000146  f1a90901          SUB      r9,r9,#1
                  |L1.330|
00014a  f1b90f00          CMP      r9,#0                 ;277
00014e  d1e8              BNE      |L1.290|
;;;296        }
;;;297    
;;;298        /* Advance the state pointer by the decimation factor       
;;;299         * to process the next group of decimation factor number samples */
;;;300        pState = pState + 4 * S->M;
000150  9b01              LDR      r3,[sp,#4]
000152  eb041403          ADD      r4,r4,r3,LSL #4
;;;301    
;;;302        /* The result is in the accumulator, store in the destination buffer. */
;;;303        *pDst++ = acc0;
000156  eca20a01          VSTM     r2!,{s0}
;;;304        *pDst++ = acc1;
00015a  ece20a01          VSTM     r2!,{s1}
;;;305        *pDst++ = acc2;
00015e  eca21a01          VSTM     r2!,{s2}
;;;306        *pDst++ = acc3;
000162  ece21a01          VSTM     r2!,{s3}
;;;307    
;;;308        /* Decrement the loop counter */
;;;309        blkCnt--;
000166  f1ab0b01          SUB      r11,r11,#1
                  |L1.362|
00016a  f1bb0f00          CMP      r11,#0                ;173
00016e  f47faf5f          BNE      |L1.48|
000172  e03b              B        |L1.492|
                  |L1.372|
;;;310      }
;;;311    
;;;312      while(blkCntN4 > 0u)
;;;313      {
;;;314        /* Copy decimation factor number of new input samples into the state buffer */
;;;315        i = S->M;
000174  7803              LDRB     r3,[r0,#0]
                  |L1.374|
;;;316    
;;;317        do
;;;318        {
;;;319          *pStateCurnt++ = *pSrc++;
000176  ecb10a01          VLDM     r1!,{s0}
00017a  eca80a01          VSTM     r8!,{s0}
;;;320    
;;;321        } while(--i);
00017e  1e5b              SUBS     r3,r3,#1
000180  d1f9              BNE      |L1.374|
;;;322    
;;;323        /* Set accumulator to zero */
;;;324        sum0 = 0.0f;
000182  eeb00a44          VMOV.F32 s0,s8
;;;325    
;;;326        /* Initialize state pointer */
;;;327        px = pState;
000186  4623              MOV      r3,r4
;;;328    
;;;329        /* Initialize coeff pointer */
;;;330        pb = pCoeffs;
000188  9d00              LDR      r5,[sp,#0]
;;;331    
;;;332        /* Loop unrolling.  Process 4 taps at a time. */
;;;333        tapCnt = numTaps >> 2;
00018a  ea4f069a          LSR      r6,r10,#2
;;;334    
;;;335        /* Loop over the number of taps.  Unroll by a factor of 4.       
;;;336         ** Repeat until we've computed numTaps-4 coefficients. */
;;;337        while(tapCnt > 0u)
00018e  e018              B        |L1.450|
                  |L1.400|
;;;338        {
;;;339          /* Read the b[numTaps-1] coefficient */
;;;340          c0 = *(pb++);
000190  ecb51a01          VLDM     r5!,{s2}
;;;341    
;;;342          /* Read x[n-numTaps-1] sample */
;;;343          x0 = *(px++);
000194  ecf30a01          VLDM     r3!,{s1}
;;;344    
;;;345          /* Perform the multiply-accumulate */
;;;346          sum0 += x0 * c0;
000198  ee000a81          VMLA.F32 s0,s1,s2
;;;347    
;;;348          /* Read the b[numTaps-2] coefficient */
;;;349          c0 = *(pb++);
00019c  ecb51a01          VLDM     r5!,{s2}
;;;350    
;;;351          /* Read x[n-numTaps-2] sample */
;;;352          x0 = *(px++);
0001a0  ecf30a01          VLDM     r3!,{s1}
;;;353    
;;;354          /* Perform the multiply-accumulate */
;;;355          sum0 += x0 * c0;
0001a4  ee000a81          VMLA.F32 s0,s1,s2
;;;356    
;;;357          /* Read the b[numTaps-3] coefficient */
;;;358          c0 = *(pb++);
0001a8  ecb51a01          VLDM     r5!,{s2}
;;;359    
;;;360          /* Read x[n-numTaps-3] sample */
;;;361          x0 = *(px++);
0001ac  ecf30a01          VLDM     r3!,{s1}
;;;362    
;;;363          /* Perform the multiply-accumulate */
;;;364          sum0 += x0 * c0;
0001b0  ee000a81          VMLA.F32 s0,s1,s2
;;;365    
;;;366          /* Read the b[numTaps-4] coefficient */
;;;367          c0 = *(pb++);
0001b4  ecb51a01          VLDM     r5!,{s2}
;;;368    
;;;369          /* Read x[n-numTaps-4] sample */
;;;370          x0 = *(px++);
0001b8  ecf30a01          VLDM     r3!,{s1}
;;;371    
;;;372          /* Perform the multiply-accumulate */
;;;373          sum0 += x0 * c0;
0001bc  ee000a81          VMLA.F32 s0,s1,s2
;;;374    
;;;375          /* Decrement the loop counter */
;;;376          tapCnt--;
0001c0  1e76              SUBS     r6,r6,#1
                  |L1.450|
0001c2  2e00              CMP      r6,#0                 ;337
0001c4  d1e4              BNE      |L1.400|
;;;377        }
;;;378    
;;;379        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;380        tapCnt = numTaps % 0x4u;
0001c6  f00a0603          AND      r6,r10,#3
;;;381    
;;;382        while(tapCnt > 0u)
0001ca  e006              B        |L1.474|
                  |L1.460|
;;;383        {
;;;384          /* Read coefficients */
;;;385          c0 = *(pb++);
0001cc  ecb51a01          VLDM     r5!,{s2}
;;;386    
;;;387          /* Fetch 1 state variable */
;;;388          x0 = *(px++);
0001d0  ecf30a01          VLDM     r3!,{s1}
;;;389    
;;;390          /* Perform the multiply-accumulate */
;;;391          sum0 += x0 * c0;
0001d4  ee000a81          VMLA.F32 s0,s1,s2
;;;392    
;;;393          /* Decrement the loop counter */
;;;394          tapCnt--;
0001d8  1e76              SUBS     r6,r6,#1
                  |L1.474|
0001da  2e00              CMP      r6,#0                 ;382
0001dc  d1f6              BNE      |L1.460|
;;;395        }
;;;396    
;;;397        /* Advance the state pointer by the decimation factor       
;;;398         * to process the next group of decimation factor number samples */
;;;399        pState = pState + S->M;
0001de  7803              LDRB     r3,[r0,#0]
0001e0  eb040483          ADD      r4,r4,r3,LSL #2
;;;400    
;;;401        /* The result is in the accumulator, store in the destination buffer. */
;;;402        *pDst++ = sum0;
0001e4  eca20a01          VSTM     r2!,{s0}
;;;403    
;;;404        /* Decrement the loop counter */
;;;405        blkCntN4--;
0001e8  f1ae0e01          SUB      lr,lr,#1
                  |L1.492|
0001ec  f1be0f00          CMP      lr,#0                 ;312
0001f0  d1c0              BNE      |L1.372|
;;;406      }
;;;407    
;;;408      /* Processing is complete.    
;;;409       ** Now copy the last numTaps - 1 samples to the satrt of the state buffer.    
;;;410       ** This prepares the state buffer for the next function call. */
;;;411    
;;;412      /* Points to the start of the state buffer */
;;;413      pStateCurnt = S->pState;
0001f2  6880              LDR      r0,[r0,#8]
;;;414    
;;;415      i = (numTaps - 1u) >> 2;
0001f4  9902              LDR      r1,[sp,#8]
0001f6  0889              LSRS     r1,r1,#2
;;;416    
;;;417      /* copy data */
;;;418      while(i > 0u)
0001f8  e010              B        |L1.540|
                  |L1.506|
;;;419      {
;;;420        *pStateCurnt++ = *pState++;
0001fa  ecb40a01          VLDM     r4!,{s0}
0001fe  eca00a01          VSTM     r0!,{s0}
;;;421        *pStateCurnt++ = *pState++;
000202  ecb40a01          VLDM     r4!,{s0}
000206  eca00a01          VSTM     r0!,{s0}
;;;422        *pStateCurnt++ = *pState++;
00020a  ecb40a01          VLDM     r4!,{s0}
00020e  eca00a01          VSTM     r0!,{s0}
;;;423        *pStateCurnt++ = *pState++;
000212  ecb40a01          VLDM     r4!,{s0}
000216  eca00a01          VSTM     r0!,{s0}
;;;424    
;;;425        /* Decrement the loop counter */
;;;426        i--;
00021a  1e49              SUBS     r1,r1,#1
                  |L1.540|
00021c  2900              CMP      r1,#0                 ;418
00021e  d1ec              BNE      |L1.506|
;;;427      }
;;;428    
;;;429      i = (numTaps - 1u) % 0x04u;
000220  9902              LDR      r1,[sp,#8]
000222  f0010103          AND      r1,r1,#3
;;;430    
;;;431      /* copy data */
;;;432      while(i > 0u)
000226  e004              B        |L1.562|
                  |L1.552|
;;;433      {
;;;434        *pStateCurnt++ = *pState++;
000228  ecb40a01          VLDM     r4!,{s0}
00022c  eca00a01          VSTM     r0!,{s0}
;;;435    
;;;436        /* Decrement the loop counter */
;;;437        i--;
000230  1e49              SUBS     r1,r1,#1
                  |L1.562|
000232  2900              CMP      r1,#0                 ;432
000234  d1f8              BNE      |L1.552|
;;;438      }
;;;439    
;;;440    #else
;;;441    
;;;442    /* Run the below code for Cortex-M0 */
;;;443    
;;;444      /* S->pState buffer contains previous frame (numTaps - 1) samples */
;;;445      /* pStateCurnt points to the location where the new input data should be written */
;;;446      pStateCurnt = S->pState + (numTaps - 1u);
;;;447    
;;;448      /* Total number of output samples to be computed */
;;;449      blkCnt = outBlockSize;
;;;450    
;;;451      while(blkCnt > 0u)
;;;452      {
;;;453        /* Copy decimation factor number of new input samples into the state buffer */
;;;454        i = S->M;
;;;455    
;;;456        do
;;;457        {
;;;458          *pStateCurnt++ = *pSrc++;
;;;459    
;;;460        } while(--i);
;;;461    
;;;462        /* Set accumulator to zero */
;;;463        sum0 = 0.0f;
;;;464    
;;;465        /* Initialize state pointer */
;;;466        px = pState;
;;;467    
;;;468        /* Initialize coeff pointer */
;;;469        pb = pCoeffs;
;;;470    
;;;471        tapCnt = numTaps;
;;;472    
;;;473        while(tapCnt > 0u)
;;;474        {
;;;475          /* Read coefficients */
;;;476          c0 = *pb++;
;;;477    
;;;478          /* Fetch 1 state variable */
;;;479          x0 = *px++;
;;;480    
;;;481          /* Perform the multiply-accumulate */
;;;482          sum0 += x0 * c0;
;;;483    
;;;484          /* Decrement the loop counter */
;;;485          tapCnt--;
;;;486        }
;;;487    
;;;488        /* Advance the state pointer by the decimation factor           
;;;489         * to process the next group of decimation factor number samples */
;;;490        pState = pState + S->M;
;;;491    
;;;492        /* The result is in the accumulator, store in the destination buffer. */
;;;493        *pDst++ = sum0;
;;;494    
;;;495        /* Decrement the loop counter */
;;;496        blkCnt--;
;;;497      }
;;;498    
;;;499      /* Processing is complete.         
;;;500       ** Now copy the last numTaps - 1 samples to the start of the state buffer.       
;;;501       ** This prepares the state buffer for the next function call. */
;;;502    
;;;503      /* Points to the start of the state buffer */
;;;504      pStateCurnt = S->pState;
;;;505    
;;;506      /* Copy numTaps number of values */
;;;507      i = (numTaps - 1u);
;;;508    
;;;509      /* copy data */
;;;510      while(i > 0u)
;;;511      {
;;;512        *pStateCurnt++ = *pState++;
;;;513    
;;;514        /* Decrement the loop counter */
;;;515        i--;
;;;516      }
;;;517    
;;;518    #endif /*   #ifndef ARM_MATH_CM0_FAMILY        */
;;;519    
;;;520    }
000236  e8bd8ffe          POP      {r1-r11,pc}
;;;521    
                          ENDP

00023a  0000              DCW      0x0000
                  |L1.572|
00023c  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_fir_decimate_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_fir_decimate_f32_c_2e5f2033____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___22_arm_fir_decimate_f32_c_2e5f2033____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_fir_decimate_f32_c_2e5f2033____REVSH|
#line 144
|__asm___22_arm_fir_decimate_f32_c_2e5f2033____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_fir_decimate_f32_c_2e5f2033____RRX|
#line 300
|__asm___22_arm_fir_decimate_f32_c_2e5f2033____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
