; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_cmplx_mult_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_cmplx_mult_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_mat_cmplx_mult_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\MatrixFunctions\arm_mat_cmplx_mult_q31.c]
                          THUMB

                          AREA ||i.arm_mat_cmplx_mult_q31||, CODE, READONLY, ALIGN=1

                  arm_mat_cmplx_mult_q31 PROC
;;;74     
;;;75     arm_status arm_mat_cmplx_mult_q31(
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;76       const arm_matrix_instance_q31 * pSrcA,
;;;77       const arm_matrix_instance_q31 * pSrcB,
;;;78       arm_matrix_instance_q31 * pDst)
;;;79     {
000004  b088              SUB      sp,sp,#0x20
;;;80       q31_t *pIn1 = pSrcA->pData;                    /* input data matrix pointer A */
000006  6841              LDR      r1,[r0,#4]
;;;81       q31_t *pIn2 = pSrcB->pData;                    /* input data matrix pointer B */
;;;82       q31_t *pInA = pSrcA->pData;                    /* input data matrix pointer A  */
000008  9106              STR      r1,[sp,#0x18]
;;;83       q31_t *pOut = pDst->pData;                     /* output data matrix pointer */
00000a  6851              LDR      r1,[r2,#4]
00000c  9105              STR      r1,[sp,#0x14]
;;;84       q31_t *px;                                     /* Temporary output data matrix pointer */
;;;85       uint16_t numRowsA = pSrcA->numRows;            /* number of rows of input matrix A */
00000e  8801              LDRH     r1,[r0,#0]
;;;86       uint16_t numColsB = pSrcB->numCols;            /* number of columns of input matrix B */
000010  9a09              LDR      r2,[sp,#0x24]
000012  8856              LDRH     r6,[r2,#2]
;;;87       uint16_t numColsA = pSrcA->numCols;            /* number of columns of input matrix A */
000014  8840              LDRH     r0,[r0,#2]
000016  9004              STR      r0,[sp,#0x10]
;;;88       q63_t sumReal1, sumImag1;                      /* accumulator */
;;;89       q31_t a0, b0, c0, d0;
;;;90       q31_t a1, b1, c1, d1;
;;;91     
;;;92     
;;;93       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;94     
;;;95       uint16_t col, i = 0u, j, row = numRowsA, colCnt;      /* loop counters */
000018  2000              MOVS     r0,#0
00001a  9002              STR      r0,[sp,#8]
00001c  9100              STR      r1,[sp,#0]
;;;96       arm_status status;                             /* status of matrix multiplication */
;;;97     
;;;98     #ifdef ARM_MATH_MATRIX_CHECK
;;;99     
;;;100    
;;;101      /* Check for matrix mismatch condition */
;;;102      if((pSrcA->numCols != pSrcB->numRows) ||
;;;103         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;104      {
;;;105    
;;;106        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;107        status = ARM_MATH_SIZE_MISMATCH;
;;;108      }
;;;109      else
;;;110    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;111    
;;;112      {
;;;113        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;114        /* row loop */
;;;115        do
;;;116        {
;;;117          /* Output pointer is set to starting address of the row being processed */
;;;118          px = pOut + 2 * i;
;;;119    
;;;120          /* For every row wise process, the column loop counter is to be initiated */
;;;121          col = numColsB;
;;;122    
;;;123          /* For every row wise process, the pIn2 pointer is set     
;;;124           ** to the starting address of the pSrcB data */
;;;125          pIn2 = pSrcB->pData;
;;;126    
;;;127          j = 0u;
;;;128    
;;;129          /* column loop */
;;;130          do
;;;131          {
;;;132            /* Set the variable sum, that acts as accumulator, to zero */
;;;133            sumReal1 = 0.0;
;;;134            sumImag1 = 0.0;
;;;135    
;;;136            /* Initiate the pointer pIn1 to point to the starting address of the column being processed */
;;;137            pIn1 = pInA;
;;;138    
;;;139            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;140            colCnt = numColsA >> 2;
00001e  9804              LDR      r0,[sp,#0x10]
000020  0880              LSRS     r0,r0,#2
000022  9007              STR      r0,[sp,#0x1c]
                  |L1.36|
000024  9902              LDR      r1,[sp,#8]            ;118
000026  9805              LDR      r0,[sp,#0x14]         ;118
000028  eb000bc1          ADD      r11,r0,r1,LSL #3      ;118
00002c  9603              STR      r6,[sp,#0xc]          ;121
00002e  9809              LDR      r0,[sp,#0x24]         ;125
000030  6842              LDR      r2,[r0,#4]            ;125
000032  2000              MOVS     r0,#0                 ;127
000034  9001              STR      r0,[sp,#4]            ;127
                  |L1.54|
000036  2000              MOVS     r0,#0                 ;133
000038  4601              MOV      r1,r0                 ;133
00003a  2400              MOVS     r4,#0                 ;134
00003c  4625              MOV      r5,r4                 ;134
00003e  9b06              LDR      r3,[sp,#0x18]         ;137
000040  9f07              LDR      r7,[sp,#0x1c]
;;;141    
;;;142            /* matrix multiplication        */
;;;143            while(colCnt > 0u)
000042  e05d              B        |L1.256|
                  |L1.68|
;;;144            {
;;;145    
;;;146              /* Reading real part of complex matrix A */
;;;147              a0 = *pIn1;
000044  f8d3c000          LDR      r12,[r3,#0]
;;;148    
;;;149              /* Reading real part of complex matrix B */
;;;150              c0 = *pIn2;
000048  f8d2a000          LDR      r10,[r2,#0]
;;;151    
;;;152              /* Reading imaginary part of complex matrix A */
;;;153              b0 = *(pIn1 + 1u);
00004c  f8d38004          LDR      r8,[r3,#4]
;;;154    
;;;155              /* Reading imaginary part of complex matrix B */
;;;156              d0 = *(pIn2 + 1u);
000050  f8d29004          LDR      r9,[r2,#4]
;;;157    
;;;158              /* Multiply and Accumlates */
;;;159              sumReal1 += (q63_t) a0 *c0;
000054  fbcc010a          SMLAL    r0,r1,r12,r10
;;;160              sumImag1 += (q63_t) b0 *c0;
000058  fbc8450a          SMLAL    r4,r5,r8,r10
;;;161    
;;;162              /* update pointers */
;;;163              pIn1 += 2u;
00005c  3308              ADDS     r3,r3,#8
;;;164              pIn2 += 2 * numColsB;
00005e  eb0202c6          ADD      r2,r2,r6,LSL #3
;;;165    
;;;166              /* Multiply and Accumlates */
;;;167              sumReal1 -= (q63_t) b0 *d0;
000062  fb88a809          SMULL    r10,r8,r8,r9
000066  ebb0000a          SUBS     r0,r0,r10
00006a  eb610108          SBC      r1,r1,r8
;;;168              sumImag1 += (q63_t) a0 *d0;
00006e  fbcc4509          SMLAL    r4,r5,r12,r9
;;;169    
;;;170              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;171    
;;;172              /* read real and imag values from pSrcA and pSrcB buffer */
;;;173              a1 = *pIn1;
000072  f8d3c000          LDR      r12,[r3,#0]
;;;174              c1 = *pIn2;
000076  f8d2a000          LDR      r10,[r2,#0]
;;;175              b1 = *(pIn1 + 1u);
00007a  f8d38004          LDR      r8,[r3,#4]
;;;176              d1 = *(pIn2 + 1u);
00007e  f8d29004          LDR      r9,[r2,#4]
;;;177    
;;;178              /* Multiply and Accumlates */
;;;179              sumReal1 += (q63_t) a1 *c1;
000082  fbcc010a          SMLAL    r0,r1,r12,r10
;;;180              sumImag1 += (q63_t) b1 *c1;
000086  fbc8450a          SMLAL    r4,r5,r8,r10
;;;181    
;;;182              /* update pointers */
;;;183              pIn1 += 2u;
00008a  3308              ADDS     r3,r3,#8
;;;184              pIn2 += 2 * numColsB;
00008c  eb0202c6          ADD      r2,r2,r6,LSL #3
;;;185    
;;;186              /* Multiply and Accumlates */
;;;187              sumReal1 -= (q63_t) b1 *d1;
000090  fb888a09          SMULL    r8,r10,r8,r9
000094  ebb00008          SUBS     r0,r0,r8
000098  eb61010a          SBC      r1,r1,r10
;;;188              sumImag1 += (q63_t) a1 *d1;
00009c  fbcc4509          SMLAL    r4,r5,r12,r9
;;;189    
;;;190              a0 = *pIn1;
0000a0  f8d3c000          LDR      r12,[r3,#0]
;;;191              c0 = *pIn2;
0000a4  f8d2a000          LDR      r10,[r2,#0]
;;;192    
;;;193              b0 = *(pIn1 + 1u);
0000a8  f8d38004          LDR      r8,[r3,#4]
;;;194              d0 = *(pIn2 + 1u);
0000ac  f8d29004          LDR      r9,[r2,#4]
;;;195    
;;;196              /* Multiply and Accumlates */
;;;197              sumReal1 += (q63_t) a0 *c0;
0000b0  fbcc010a          SMLAL    r0,r1,r12,r10
;;;198              sumImag1 += (q63_t) b0 *c0;
0000b4  fbc8450a          SMLAL    r4,r5,r8,r10
;;;199    
;;;200              /* update pointers */
;;;201              pIn1 += 2u;
0000b8  3308              ADDS     r3,r3,#8
;;;202              pIn2 += 2 * numColsB;
0000ba  eb0202c6          ADD      r2,r2,r6,LSL #3
;;;203    
;;;204              /* Multiply and Accumlates */
;;;205              sumReal1 -= (q63_t) b0 *d0;
0000be  fb88a809          SMULL    r10,r8,r8,r9
0000c2  ebb0000a          SUBS     r0,r0,r10
0000c6  eb610108          SBC      r1,r1,r8
;;;206              sumImag1 += (q63_t) a0 *d0;
0000ca  fbcc4509          SMLAL    r4,r5,r12,r9
;;;207    
;;;208              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;209    
;;;210              a1 = *pIn1;
0000ce  f8d3c000          LDR      r12,[r3,#0]
;;;211              c1 = *pIn2;
0000d2  f8d2a000          LDR      r10,[r2,#0]
;;;212    
;;;213              b1 = *(pIn1 + 1u);
0000d6  f8d38004          LDR      r8,[r3,#4]
;;;214              d1 = *(pIn2 + 1u);
0000da  f8d29004          LDR      r9,[r2,#4]
;;;215    
;;;216              /* Multiply and Accumlates */
;;;217              sumReal1 += (q63_t) a1 *c1;
0000de  fbcc010a          SMLAL    r0,r1,r12,r10
;;;218              sumImag1 += (q63_t) b1 *c1;
0000e2  fbc8450a          SMLAL    r4,r5,r8,r10
;;;219    
;;;220              /* update pointers */
;;;221              pIn1 += 2u;
0000e6  3308              ADDS     r3,r3,#8
;;;222              pIn2 += 2 * numColsB;
0000e8  eb0202c6          ADD      r2,r2,r6,LSL #3
;;;223    
;;;224              /* Multiply and Accumlates */
;;;225              sumReal1 -= (q63_t) b1 *d1;
0000ec  fb888a09          SMULL    r8,r10,r8,r9
0000f0  ebb00008          SUBS     r0,r0,r8
0000f4  eb61010a          SBC      r1,r1,r10
;;;226              sumImag1 += (q63_t) a1 *d1;
0000f8  fbcc4509          SMLAL    r4,r5,r12,r9
;;;227    
;;;228              /* Decrement the loop count */
;;;229              colCnt--;
0000fc  1e7f              SUBS     r7,r7,#1
0000fe  b2bf              UXTH     r7,r7
                  |L1.256|
000100  2f00              CMP      r7,#0                 ;143
000102  d19f              BNE      |L1.68|
;;;230            }
;;;231    
;;;232            /* If the columns of pSrcA is not a multiple of 4, compute any remaining MACs here.     
;;;233             ** No loop unrolling is used. */
;;;234            colCnt = numColsA % 0x4u;
000104  9f04              LDR      r7,[sp,#0x10]
000106  f0070703          AND      r7,r7,#3
;;;235    
;;;236            while(colCnt > 0u)
00010a  e018              B        |L1.318|
                  |L1.268|
;;;237            {
;;;238              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;239              a1 = *pIn1;
00010c  f8d3a000          LDR      r10,[r3,#0]
;;;240              c1 = *pIn2;
000110  f8d28000          LDR      r8,[r2,#0]
;;;241    
;;;242              b1 = *(pIn1 + 1u);
000114  f8d3c004          LDR      r12,[r3,#4]
;;;243              d1 = *(pIn2 + 1u);
000118  f8d29004          LDR      r9,[r2,#4]
;;;244    
;;;245              /* Multiply and Accumlates */
;;;246              sumReal1 += (q63_t) a1 *c1;
00011c  fbca0108          SMLAL    r0,r1,r10,r8
;;;247              sumImag1 += (q63_t) b1 *c1;
000120  fbcc4508          SMLAL    r4,r5,r12,r8
;;;248    
;;;249              /* update pointers */
;;;250              pIn1 += 2u;
000124  3308              ADDS     r3,r3,#8
;;;251              pIn2 += 2 * numColsB;
000126  eb0202c6          ADD      r2,r2,r6,LSL #3
;;;252    
;;;253              /* Multiply and Accumlates */
;;;254              sumReal1 -= (q63_t) b1 *d1;
00012a  fb8cc809          SMULL    r12,r8,r12,r9
00012e  ebb0000c          SUBS     r0,r0,r12
000132  eb610108          SBC      r1,r1,r8
;;;255              sumImag1 += (q63_t) a1 *d1;
000136  fbca4509          SMLAL    r4,r5,r10,r9
;;;256    
;;;257              /* Decrement the loop counter */
;;;258              colCnt--;
00013a  1e7f              SUBS     r7,r7,#1
00013c  b2bf              UXTH     r7,r7
                  |L1.318|
00013e  2f00              CMP      r7,#0                 ;236
000140  d1e4              BNE      |L1.268|
;;;259            }
;;;260    
;;;261            /* Store the result in the destination buffer */
;;;262            *px++ = (q31_t) clip_q63_to_q31(sumReal1 >> 31);
000142  0fc0              LSRS     r0,r0,#31
000144  ea400041          ORR      r0,r0,r1,LSL #1
000148  17c9              ASRS     r1,r1,#31
00014a  f7fffffe          BL       clip_q63_to_q31
00014e  f84b0b04          STR      r0,[r11],#4
;;;263            *px++ = (q31_t) clip_q63_to_q31(sumImag1 >> 31);
000152  0fe0              LSRS     r0,r4,#31
000154  ea400045          ORR      r0,r0,r5,LSL #1
000158  17e9              ASRS     r1,r5,#31
00015a  f7fffffe          BL       clip_q63_to_q31
00015e  f84b0b04          STR      r0,[r11],#4
;;;264            
;;;265            /* Update the pointer pIn2 to point to the  starting address of the next column */
;;;266            j++;
000162  9801              LDR      r0,[sp,#4]
000164  1c40              ADDS     r0,r0,#1
000166  b280              UXTH     r0,r0
000168  9001              STR      r0,[sp,#4]
;;;267            pIn2 = pSrcB->pData + 2u * j;
00016a  9809              LDR      r0,[sp,#0x24]
00016c  6841              LDR      r1,[r0,#4]
00016e  9801              LDR      r0,[sp,#4]
000170  eb0102c0          ADD      r2,r1,r0,LSL #3
;;;268    
;;;269            /* Decrement the column loop counter */
;;;270            col--;
000174  9803              LDR      r0,[sp,#0xc]
000176  1e40              SUBS     r0,r0,#1
000178  b280              UXTH     r0,r0
00017a  9003              STR      r0,[sp,#0xc]
;;;271    
;;;272          } while(col > 0u);
00017c  9803              LDR      r0,[sp,#0xc]
00017e  2800              CMP      r0,#0
000180  f47faf59          BNE      |L1.54|
;;;273    
;;;274          /* Update the pointer pInA to point to the  starting address of the next row */
;;;275          i = i + numColsB;
000184  9802              LDR      r0,[sp,#8]
000186  4430              ADD      r0,r0,r6
000188  b280              UXTH     r0,r0
00018a  9002              STR      r0,[sp,#8]
;;;276          pInA = pInA + 2 * numColsA;
00018c  9904              LDR      r1,[sp,#0x10]
00018e  9806              LDR      r0,[sp,#0x18]
000190  eb0000c1          ADD      r0,r0,r1,LSL #3
000194  9006              STR      r0,[sp,#0x18]
;;;277    
;;;278          /* Decrement the row loop counter */
;;;279          row--;
000196  9800              LDR      r0,[sp,#0]
000198  1e40              SUBS     r0,r0,#1
00019a  b280              UXTH     r0,r0
00019c  9000              STR      r0,[sp,#0]
;;;280    
;;;281        } while(row > 0u);
00019e  9800              LDR      r0,[sp,#0]
0001a0  2800              CMP      r0,#0
0001a2  f47faf3f          BNE      |L1.36|
;;;282    
;;;283        /* Set status as ARM_MATH_SUCCESS */
;;;284        status = ARM_MATH_SUCCESS;
;;;285      }
;;;286    
;;;287      /* Return to application */
;;;288      return (status);
;;;289    }
0001a6  b00b              ADD      sp,sp,#0x2c
0001a8  e8bd8ff0          POP      {r4-r11,pc}
;;;290    
                          ENDP


                          AREA ||i.clip_q63_to_q31||, CODE, READONLY, ALIGN=1

                  clip_q63_to_q31 PROC
;;;458       */
;;;459      static __INLINE q31_t clip_q63_to_q31(
000000  17ca              ASRS     r2,r1,#31
;;;460      q63_t x)
;;;461      {
;;;462        return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
000002  ebb17fe0          CMP      r1,r0,ASR #31
000006  d002              BEQ      |L2.14|
;;;463          ((0x7FFFFFFF ^ ((q31_t) (x >> 63)))) : (q31_t) x;
000008  f06f4000          MVN      r0,#0x80000000
00000c  4050              EORS     r0,r0,r2
                  |L2.14|
;;;464      }
00000e  4770              BX       lr
;;;465    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\MatrixFunctions\\arm_mat_cmplx_mult_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_mat_cmplx_mult_q31_c_ee9c8e44____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___24_arm_mat_cmplx_mult_q31_c_ee9c8e44____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_mat_cmplx_mult_q31_c_ee9c8e44____REVSH|
#line 144
|__asm___24_arm_mat_cmplx_mult_q31_c_ee9c8e44____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_mat_cmplx_mult_q31_c_ee9c8e44____RRX|
#line 300
|__asm___24_arm_mat_cmplx_mult_q31_c_ee9c8e44____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
