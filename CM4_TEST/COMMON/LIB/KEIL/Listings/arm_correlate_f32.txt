; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_correlate_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_correlate_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_correlate_f32.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_correlate_f32.c]
                          THUMB

                          AREA ||i.arm_correlate_f32||, CODE, READONLY, ALIGN=2

                  arm_correlate_f32 PROC
;;;115    
;;;116    void arm_correlate_f32(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;117      float32_t * pSrcA,
;;;118      uint32_t srcALen,
;;;119      float32_t * pSrcB,
;;;120      uint32_t srcBLen,
;;;121      float32_t * pDst)
;;;122    {
000004  9c09              LDR      r4,[sp,#0x24]
;;;123    
;;;124    
;;;125    #ifndef ARM_MATH_CM0_FAMILY
;;;126    
;;;127      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;128    
;;;129      float32_t *pIn1;                               /* inputA pointer */
;;;130      float32_t *pIn2;                               /* inputB pointer */
;;;131      float32_t *pOut = pDst;                        /* output pointer */
;;;132      float32_t *px;                                 /* Intermediate inputA pointer */
;;;133      float32_t *py;                                 /* Intermediate inputB pointer */
;;;134      float32_t *pSrc1;                              /* Intermediate pointers */
;;;135      float32_t sum, acc0, acc1, acc2, acc3;         /* Accumulators */
;;;136      float32_t x0, x1, x2, x3, c0;                  /* temporary variables for holding input and coefficient values */
;;;137      uint32_t j, k = 0u, count, blkCnt, outBlockSize, blockSize1, blockSize2, blockSize3;  /* loop counters */
;;;138      int32_t inc = 1;                               /* Destination address modifier */
000006  2501              MOVS     r5,#1
;;;139    
;;;140    
;;;141      /* The algorithm implementation is based on the lengths of the inputs. */
;;;142      /* srcB is always made to slide across srcA. */
;;;143      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;144      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;145      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;146      /* and the destination pointer modifier, inc is set to -1 */
;;;147      /* If srcALen > srcBLen, zero pad has to be done to srcB to make the two inputs of same length */
;;;148      /* But to improve the performance,    
;;;149       * we assume zeroes in the output instead of zero padding either of the the inputs*/
;;;150      /* If srcALen > srcBLen,    
;;;151       * (srcALen - srcBLen) zeroes has to included in the starting of the output buffer */
;;;152      /* If srcALen < srcBLen,    
;;;153       * (srcALen - srcBLen) zeroes has to included in the ending of the output buffer */
;;;154      if(srcALen >= srcBLen)
;;;155      {
;;;156        /* Initialization of inputA pointer */
;;;157        pIn1 = pSrcA;
;;;158    
;;;159        /* Initialization of inputB pointer */
;;;160        pIn2 = pSrcB;
;;;161    
;;;162        /* Number of output samples is calculated */
;;;163        outBlockSize = (2u * srcALen) - 1u;
000008  f04f3cff          MOV      r12,#0xffffffff
00000c  4299              CMP      r1,r3                 ;154
00000e  d309              BCC      |L1.36|
000010  4607              MOV      r7,r0                 ;157
000012  4616              MOV      r6,r2                 ;160
000014  eb0c0041          ADD      r0,r12,r1,LSL #1
;;;164    
;;;165        /* When srcALen > srcBLen, zero padding has to be done to srcB    
;;;166         * to make their lengths equal.    
;;;167         * Instead, (outBlockSize - (srcALen + srcBLen - 1))    
;;;168         * number of output samples are made zero */
;;;169        j = outBlockSize - (srcALen + (srcBLen - 1u));
000018  18ca              ADDS     r2,r1,r3
00001a  1a80              SUBS     r0,r0,r2
00001c  1c40              ADDS     r0,r0,#1
;;;170    
;;;171        /* Updating the pointer position to non zero value */
;;;172        pOut += j;
00001e  eb040080          ADD      r0,r4,r0,LSL #2
000022  e009              B        |L1.56|
                  |L1.36|
;;;173    
;;;174        //while(j > 0u)   
;;;175        //{   
;;;176        //  /* Zero is stored in the destination buffer */   
;;;177        //  *pOut++ = 0.0f;   
;;;178    
;;;179        //  /* Decrement the loop counter */   
;;;180        //  j--;   
;;;181        //}   
;;;182    
;;;183      }
;;;184      else
;;;185      {
;;;186        /* Initialization of inputA pointer */
;;;187        pIn1 = pSrcB;
000024  4617              MOV      r7,r2
;;;188    
;;;189        /* Initialization of inputB pointer */
;;;190        pIn2 = pSrcA;
000026  4606              MOV      r6,r0
;;;191    
;;;192        /* srcBLen is always considered as shorter or equal to srcALen */
;;;193        j = srcBLen;
000028  4618              MOV      r0,r3
;;;194        srcBLen = srcALen;
00002a  460b              MOV      r3,r1
;;;195        srcALen = j;
00002c  4601              MOV      r1,r0
;;;196    
;;;197        /* CORR(x, y) = Reverse order(CORR(y, x)) */
;;;198        /* Hence set the destination pointer to point to the last output sample */
;;;199        pOut = pDst + ((srcALen + srcBLen) - 2u);
00002e  18c8              ADDS     r0,r1,r3
000030  1e80              SUBS     r0,r0,#2
000032  eb040080          ADD      r0,r4,r0,LSL #2
;;;200    
;;;201        /* Destination address modifier is set to -1 */
;;;202        inc = -1;
000036  4665              MOV      r5,r12
                  |L1.56|
;;;203    
;;;204      }
;;;205    
;;;206      /* The function is internally    
;;;207       * divided into three parts according to the number of multiplications that has to be    
;;;208       * taken place between inputA samples and inputB samples. In the first part of the    
;;;209       * algorithm, the multiplications increase by one for every iteration.    
;;;210       * In the second part of the algorithm, srcBLen number of multiplications are done.    
;;;211       * In the third part of the algorithm, the multiplications decrease by one    
;;;212       * for every iteration.*/
;;;213      /* The algorithm is implemented in three stages.    
;;;214       * The loop counters of each stage is initiated here. */
;;;215      blockSize1 = srcBLen - 1u;
000038  f1a30801          SUB      r8,r3,#1
;;;216      blockSize2 = srcALen - (srcBLen - 1u);
00003c  eba10e03          SUB      lr,r1,r3
000040  f10e0a01          ADD      r10,lr,#1
;;;217      blockSize3 = blockSize1;
000044  46c1              MOV      r9,r8
;;;218    
;;;219      /* --------------------------    
;;;220       * Initializations of stage1    
;;;221       * -------------------------*/
;;;222    
;;;223      /* sum = x[0] * y[srcBlen - 1]    
;;;224       * sum = x[0] * y[srcBlen-2] + x[1] * y[srcBlen - 1]    
;;;225       * ....    
;;;226       * sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen - 1] * y[srcBLen - 1]    
;;;227       */
;;;228    
;;;229      /* In this stage the MAC operations are increased by 1 for every iteration.    
;;;230         The count variable holds the number of MAC operations performed */
;;;231      count = 1u;
000046  2101              MOVS     r1,#1
;;;232    
;;;233      /* Working pointer of inputA */
;;;234      px = pIn1;
000048  463c              MOV      r4,r7
;;;235    
;;;236      /* Working pointer of inputB */
;;;237      pSrc1 = pIn2 + (srcBLen - 1u);
00004a  1e5a              SUBS     r2,r3,#1
00004c  eb060b82          ADD      r11,r6,r2,LSL #2
;;;238      py = pSrc1;
000050  465a              MOV      r2,r11
;;;239    
;;;240      /* ------------------------    
;;;241       * Stage1 process    
;;;242       * ----------------------*/
;;;243    
;;;244      /* The first stage starts here */
;;;245      while(blockSize1 > 0u)
;;;246      {
;;;247        /* Accumulator is made zero for every iteration */
;;;248        sum = 0.0f;
000052  ed9f6ab5          VLDR     s12,|L1.808|
000056  e039              B        |L1.204|
                  |L1.88|
000058  eef01a46          VMOV.F32 s3,s12
;;;249    
;;;250        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;251        k = count >> 2u;
00005c  ea4f0c91          LSR      r12,r1,#2
;;;252    
;;;253        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;254         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;255        while(k > 0u)
000060  e019              B        |L1.150|
                  |L1.98|
;;;256        {
;;;257          /* x[0] * y[srcBLen - 4] */
;;;258          sum += *px++ * *py++;
000062  ecb40a01          VLDM     r4!,{s0}
000066  ecf20a01          VLDM     r2!,{s1}
00006a  ee401a20          VMLA.F32 s3,s0,s1
;;;259          /* x[1] * y[srcBLen - 3] */
;;;260          sum += *px++ * *py++;
00006e  ecb40a01          VLDM     r4!,{s0}
000072  ecf20a01          VLDM     r2!,{s1}
000076  ee401a20          VMLA.F32 s3,s0,s1
;;;261          /* x[2] * y[srcBLen - 2] */
;;;262          sum += *px++ * *py++;
00007a  ecb40a01          VLDM     r4!,{s0}
00007e  ecf20a01          VLDM     r2!,{s1}
000082  ee401a20          VMLA.F32 s3,s0,s1
;;;263          /* x[3] * y[srcBLen - 1] */
;;;264          sum += *px++ * *py++;
000086  ecb40a01          VLDM     r4!,{s0}
00008a  ecf20a01          VLDM     r2!,{s1}
00008e  ee401a20          VMLA.F32 s3,s0,s1
;;;265    
;;;266          /* Decrement the loop counter */
;;;267          k--;
000092  f1ac0c01          SUB      r12,r12,#1
                  |L1.150|
000096  f1bc0f00          CMP      r12,#0                ;255
00009a  d1e2              BNE      |L1.98|
;;;268        }
;;;269    
;;;270        /* If the count is not a multiple of 4, compute any remaining MACs here.    
;;;271         ** No loop unrolling is used. */
;;;272        k = count % 0x4u;
00009c  f0010c03          AND      r12,r1,#3
;;;273    
;;;274        while(k > 0u)
0000a0  e007              B        |L1.178|
                  |L1.162|
;;;275        {
;;;276          /* Perform the multiply-accumulate */
;;;277          /* x[0] * y[srcBLen - 1] */
;;;278          sum += *px++ * *py++;
0000a2  ecb40a01          VLDM     r4!,{s0}
0000a6  ecf20a01          VLDM     r2!,{s1}
0000aa  ee401a20          VMLA.F32 s3,s0,s1
;;;279    
;;;280          /* Decrement the loop counter */
;;;281          k--;
0000ae  f1ac0c01          SUB      r12,r12,#1
                  |L1.178|
0000b2  f1bc0f00          CMP      r12,#0                ;274
0000b6  d1f4              BNE      |L1.162|
;;;282        }
;;;283    
;;;284        /* Store the result in the accumulator in the destination buffer. */
;;;285        *pOut = sum;
0000b8  edc01a00          VSTR     s3,[r0,#0]
;;;286        /* Destination pointer is updated according to the address modifier, inc */
;;;287        pOut += inc;
0000bc  eb000085          ADD      r0,r0,r5,LSL #2
;;;288    
;;;289        /* Update the inputA and inputB pointers for next MAC calculation */
;;;290        py = pSrc1 - count;
0000c0  ebab0281          SUB      r2,r11,r1,LSL #2
;;;291        px = pIn1;
0000c4  463c              MOV      r4,r7
;;;292    
;;;293        /* Increment the MAC count */
;;;294        count++;
0000c6  1c49              ADDS     r1,r1,#1
;;;295    
;;;296        /* Decrement the loop counter */
;;;297        blockSize1--;
0000c8  f1a80801          SUB      r8,r8,#1
                  |L1.204|
0000cc  f1b80f00          CMP      r8,#0                 ;245
0000d0  d1c2              BNE      |L1.88|
;;;298      }
;;;299    
;;;300      /* --------------------------    
;;;301       * Initializations of stage2    
;;;302       * ------------------------*/
;;;303    
;;;304      /* sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen-1] * y[srcBLen-1]    
;;;305       * sum = x[1] * y[0] + x[2] * y[1] +...+ x[srcBLen] * y[srcBLen-1]    
;;;306       * ....    
;;;307       * sum = x[srcALen-srcBLen-2] * y[0] + x[srcALen-srcBLen-1] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]    
;;;308       */
;;;309    
;;;310      /* Working pointer of inputA */
;;;311      px = pIn1;
;;;312    
;;;313      /* Working pointer of inputB */
;;;314      py = pIn2;
0000d2  4631              MOV      r1,r6
;;;315    
;;;316      /* count is index by which the pointer pIn1 to be incremented */
;;;317      count = 0u;
0000d4  2200              MOVS     r2,#0
;;;318    
;;;319      /* -------------------    
;;;320       * Stage2 process    
;;;321       * ------------------*/
;;;322    
;;;323      /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.    
;;;324       * So, to loop unroll over blockSize2,    
;;;325       * srcBLen should be greater than or equal to 4, to loop unroll the srcBLen loop */
;;;326      if(srcBLen >= 4u)
0000d6  2b04              CMP      r3,#4
0000d8  d37d              BCC      |L1.470|
;;;327      {
;;;328        /* Loop unroll over blockSize2, by 4 */
;;;329        blkCnt = blockSize2 >> 2u;
0000da  ea4f0c9a          LSR      r12,r10,#2
;;;330    
;;;331        while(blkCnt > 0u)
0000de  e080              B        |L1.482|
                  |L1.224|
;;;332        {
;;;333          /* Set all accumulators to zero */
;;;334          acc0 = 0.0f;
;;;335          acc1 = 0.0f;
0000e0  eef01a46          VMOV.F32 s3,s12
0000e4  eeb02a61          VMOV.F32 s4,s3
;;;336          acc2 = 0.0f;
0000e8  eef01a46          VMOV.F32 s3,s12
0000ec  eef02a61          VMOV.F32 s5,s3
;;;337          acc3 = 0.0f;
0000f0  eef01a46          VMOV.F32 s3,s12
0000f4  eeb03a61          VMOV.F32 s6,s3
;;;338    
;;;339          /* read x[0], x[1], x[2] samples */
;;;340          x0 = *(px++);
0000f8  ecb41a01          VLDM     r4!,{s2}
;;;341          x1 = *(px++);
0000fc  ecf40a01          VLDM     r4!,{s1}
;;;342          x2 = *(px++);
000100  ecb40a01          VLDM     r4!,{s0}
;;;343    
;;;344          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;345          k = srcBLen >> 2u;
000104  ea4f0893          LSR      r8,r3,#2
                  |L1.264|
;;;346    
;;;347          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;348           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;349          do
;;;350          {
;;;351            /* Read y[0] sample */
;;;352            c0 = *(py++);
000108  ecb14a01          VLDM     r1!,{s8}
;;;353    
;;;354            /* Read x[3] sample */
;;;355            x3 = *(px++);
00010c  ecf43a01          VLDM     r4!,{s7}
;;;356    
;;;357            /* Perform the multiply-accumulate */
;;;358            /* acc0 +=  x[0] * y[0] */
;;;359            acc0 += x0 * c0;
000110  eef05a61          VMOV.F32 s11,s3
000114  ee415a04          VMLA.F32 s11,s2,s8
;;;360            /* acc1 +=  x[1] * y[0] */
;;;361            acc1 += x1 * c0;
000118  ee002a84          VMLA.F32 s4,s1,s8
;;;362            /* acc2 +=  x[2] * y[0] */
;;;363            acc2 += x2 * c0;
00011c  ee402a04          VMLA.F32 s5,s0,s8
;;;364            /* acc3 +=  x[3] * y[0] */
;;;365            acc3 += x3 * c0;
000120  eeb05a43          VMOV.F32 s10,s6
000124  ee035a84          VMLA.F32 s10,s7,s8
;;;366    
;;;367            /* Read y[1] sample */
;;;368            c0 = *(py++);
000128  ecf11a01          VLDM     r1!,{s3}
;;;369    
;;;370            /* Read x[4] sample */
;;;371            x0 = *(px++);
00012c  ecb41a01          VLDM     r4!,{s2}
;;;372    
;;;373            /* Perform the multiply-accumulate */
;;;374            /* acc0 +=  x[1] * y[1] */
;;;375            acc0 += x1 * c0;
000130  ee405aa1          VMLA.F32 s11,s1,s3
;;;376            /* acc1 +=  x[2] * y[1] */
;;;377            acc1 += x2 * c0;
000134  ee002a21          VMLA.F32 s4,s0,s3
;;;378            /* acc2 +=  x[3] * y[1] */
;;;379            acc2 += x3 * c0;
000138  ee432aa1          VMLA.F32 s5,s7,s3
;;;380            /* acc3 +=  x[4] * y[1] */
;;;381            acc3 += x0 * c0;
00013c  ee015a21          VMLA.F32 s10,s2,s3
;;;382    
;;;383            /* Read y[2] sample */
;;;384            c0 = *(py++);
000140  ecf11a01          VLDM     r1!,{s3}
;;;385    
;;;386            /* Read x[5] sample */
;;;387            x1 = *(px++);
000144  ecf40a01          VLDM     r4!,{s1}
;;;388    
;;;389            /* Perform the multiply-accumulates */
;;;390            /* acc0 +=  x[2] * y[2] */
;;;391            acc0 += x2 * c0;
000148  ee405a21          VMLA.F32 s11,s0,s3
;;;392            /* acc1 +=  x[3] * y[2] */
;;;393            acc1 += x3 * c0;
00014c  ee032aa1          VMLA.F32 s4,s7,s3
;;;394            /* acc2 +=  x[4] * y[2] */
;;;395            acc2 += x0 * c0;
000150  ee412a21          VMLA.F32 s5,s2,s3
;;;396            /* acc3 +=  x[5] * y[2] */
;;;397            acc3 += x1 * c0;
000154  ee005aa1          VMLA.F32 s10,s1,s3
;;;398    
;;;399            /* Read y[3] sample */
;;;400            c0 = *(py++);
000158  ecb13a01          VLDM     r1!,{s6}
;;;401    
;;;402            /* Read x[6] sample */
;;;403            x2 = *(px++);
00015c  ecb40a01          VLDM     r4!,{s0}
;;;404    
;;;405            /* Perform the multiply-accumulates */
;;;406            /* acc0 +=  x[3] * y[3] */
;;;407            acc0 += x3 * c0;
000160  eef01a65          VMOV.F32 s3,s11
000164  ee431a83          VMLA.F32 s3,s7,s6
;;;408            /* acc1 +=  x[4] * y[3] */
;;;409            acc1 += x0 * c0;
000168  ee012a03          VMLA.F32 s4,s2,s6
;;;410            /* acc2 +=  x[5] * y[3] */
;;;411            acc2 += x1 * c0;
00016c  ee402a83          VMLA.F32 s5,s1,s6
;;;412            /* acc3 +=  x[6] * y[3] */
;;;413            acc3 += x2 * c0;
000170  ee005a03          VMLA.F32 s10,s0,s6
000174  eeb03a45          VMOV.F32 s6,s10
;;;414    
;;;415    
;;;416          } while(--k);
000178  f1b80801          SUBS     r8,r8,#1
00017c  d1c4              BNE      |L1.264|
;;;417    
;;;418          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.    
;;;419           ** No loop unrolling is used. */
;;;420          k = srcBLen % 0x4u;
00017e  f0030803          AND      r8,r3,#3
;;;421    
;;;422          while(k > 0u)
000182  e013              B        |L1.428|
                  |L1.388|
;;;423          {
;;;424            /* Read y[4] sample */
;;;425            c0 = *(py++);
000184  ecf13a01          VLDM     r1!,{s7}
;;;426    
;;;427            /* Read x[7] sample */
;;;428            x3 = *(px++);
000188  ecb44a01          VLDM     r4!,{s8}
;;;429    
;;;430            /* Perform the multiply-accumulates */
;;;431            /* acc0 +=  x[4] * y[4] */
;;;432            acc0 += x0 * c0;
00018c  ee411a23          VMLA.F32 s3,s2,s7
;;;433            /* acc1 +=  x[5] * y[4] */
;;;434            acc1 += x1 * c0;
000190  ee002aa3          VMLA.F32 s4,s1,s7
;;;435            /* acc2 +=  x[6] * y[4] */
;;;436            acc2 += x2 * c0;
000194  ee402a23          VMLA.F32 s5,s0,s7
;;;437            /* acc3 +=  x[7] * y[4] */
;;;438            acc3 += x3 * c0;
000198  ee043a23          VMLA.F32 s6,s8,s7
;;;439    
;;;440            /* Reuse the present samples for the next MAC */
;;;441            x0 = x1;
00019c  eeb01a60          VMOV.F32 s2,s1
;;;442            x1 = x2;
0001a0  eef00a40          VMOV.F32 s1,s0
;;;443            x2 = x3;
0001a4  eeb00a44          VMOV.F32 s0,s8
;;;444    
;;;445            /* Decrement the loop counter */
;;;446            k--;
0001a8  f1a80801          SUB      r8,r8,#1
                  |L1.428|
0001ac  f1b80f00          CMP      r8,#0                 ;422
0001b0  d1e8              BNE      |L1.388|
;;;447          }
;;;448    
;;;449          /* Store the result in the accumulator in the destination buffer. */
;;;450          *pOut = acc0;
0001b2  edc01a00          VSTR     s3,[r0,#0]
;;;451          /* Destination pointer is updated according to the address modifier, inc */
;;;452          pOut += inc;
0001b6  eb000085          ADD      r0,r0,r5,LSL #2
;;;453    
;;;454          *pOut = acc1;
0001ba  ed802a00          VSTR     s4,[r0,#0]
;;;455          pOut += inc;
0001be  eb000085          ADD      r0,r0,r5,LSL #2
;;;456    
;;;457          *pOut = acc2;
0001c2  edc02a00          VSTR     s5,[r0,#0]
;;;458          pOut += inc;
0001c6  eb000085          ADD      r0,r0,r5,LSL #2
;;;459    
;;;460          *pOut = acc3;
0001ca  ed803a00          VSTR     s6,[r0,#0]
;;;461          pOut += inc;
0001ce  eb000085          ADD      r0,r0,r5,LSL #2
;;;462    
;;;463          /* Increment the pointer pIn1 index, count by 4 */
;;;464          count += 4u;
0001d2  1d12              ADDS     r2,r2,#4
;;;465    
;;;466          /* Update the inputA and inputB pointers for next MAC calculation */
;;;467          px = pIn1 + count;
0001d4  e000              B        |L1.472|
                  |L1.470|
0001d6  e062              B        |L1.670|
                  |L1.472|
0001d8  eb070482          ADD      r4,r7,r2,LSL #2
;;;468          py = pIn2;
0001dc  4631              MOV      r1,r6
;;;469    
;;;470          /* Decrement the loop counter */
;;;471          blkCnt--;
0001de  f1ac0c01          SUB      r12,r12,#1
                  |L1.482|
0001e2  f1bc0f00          CMP      r12,#0                ;331
0001e6  f47faf7b          BNE      |L1.224|
;;;472        }
;;;473    
;;;474        /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.    
;;;475         ** No loop unrolling is used. */
;;;476        blkCnt = blockSize2 % 0x4u;
0001ea  f00a0803          AND      r8,r10,#3
;;;477    
;;;478        while(blkCnt > 0u)
0001ee  e039              B        |L1.612|
                  |L1.496|
;;;479        {
;;;480          /* Accumulator is made zero for every iteration */
;;;481          sum = 0.0f;
0001f0  eef01a46          VMOV.F32 s3,s12
;;;482    
;;;483          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;484          k = srcBLen >> 2u;
0001f4  ea4f0c93          LSR      r12,r3,#2
;;;485    
;;;486          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;487           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;488          while(k > 0u)
0001f8  e019              B        |L1.558|
                  |L1.506|
;;;489          {
;;;490            /* Perform the multiply-accumulates */
;;;491            sum += *px++ * *py++;
0001fa  ecb40a01          VLDM     r4!,{s0}
0001fe  ecf10a01          VLDM     r1!,{s1}
000202  ee401a20          VMLA.F32 s3,s0,s1
;;;492            sum += *px++ * *py++;
000206  ecb40a01          VLDM     r4!,{s0}
00020a  ecf10a01          VLDM     r1!,{s1}
00020e  ee401a20          VMLA.F32 s3,s0,s1
;;;493            sum += *px++ * *py++;
000212  ecb40a01          VLDM     r4!,{s0}
000216  ecf10a01          VLDM     r1!,{s1}
00021a  ee401a20          VMLA.F32 s3,s0,s1
;;;494            sum += *px++ * *py++;
00021e  ecb40a01          VLDM     r4!,{s0}
000222  ecf10a01          VLDM     r1!,{s1}
000226  ee401a20          VMLA.F32 s3,s0,s1
;;;495    
;;;496            /* Decrement the loop counter */
;;;497            k--;
00022a  f1ac0c01          SUB      r12,r12,#1
                  |L1.558|
00022e  f1bc0f00          CMP      r12,#0                ;488
000232  d1e2              BNE      |L1.506|
;;;498          }
;;;499    
;;;500          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.    
;;;501           ** No loop unrolling is used. */
;;;502          k = srcBLen % 0x4u;
000234  f0030c03          AND      r12,r3,#3
;;;503    
;;;504          while(k > 0u)
000238  e007              B        |L1.586|
                  |L1.570|
;;;505          {
;;;506            /* Perform the multiply-accumulate */
;;;507            sum += *px++ * *py++;
00023a  ecb40a01          VLDM     r4!,{s0}
00023e  ecf10a01          VLDM     r1!,{s1}
000242  ee401a20          VMLA.F32 s3,s0,s1
;;;508    
;;;509            /* Decrement the loop counter */
;;;510            k--;
000246  f1ac0c01          SUB      r12,r12,#1
                  |L1.586|
00024a  f1bc0f00          CMP      r12,#0                ;504
00024e  d1f4              BNE      |L1.570|
;;;511          }
;;;512    
;;;513          /* Store the result in the accumulator in the destination buffer. */
;;;514          *pOut = sum;
000250  edc01a00          VSTR     s3,[r0,#0]
;;;515          /* Destination pointer is updated according to the address modifier, inc */
;;;516          pOut += inc;
000254  eb000085          ADD      r0,r0,r5,LSL #2
;;;517    
;;;518          /* Increment the pointer pIn1 index, count by 1 */
;;;519          count++;
000258  1c52              ADDS     r2,r2,#1
;;;520    
;;;521          /* Update the inputA and inputB pointers for next MAC calculation */
;;;522          px = pIn1 + count;
00025a  eb070482          ADD      r4,r7,r2,LSL #2
;;;523          py = pIn2;
00025e  4631              MOV      r1,r6
;;;524    
;;;525          /* Decrement the loop counter */
;;;526          blkCnt--;
000260  f1a80801          SUB      r8,r8,#1
                  |L1.612|
000264  f1b80f00          CMP      r8,#0                 ;478
000268  d1c2              BNE      |L1.496|
00026a  e01b              B        |L1.676|
                  |L1.620|
;;;527        }
;;;528      }
;;;529      else
;;;530      {
;;;531        /* If the srcBLen is not a multiple of 4,    
;;;532         * the blockSize2 loop cannot be unrolled by 4 */
;;;533        blkCnt = blockSize2;
;;;534    
;;;535        while(blkCnt > 0u)
;;;536        {
;;;537          /* Accumulator is made zero for every iteration */
;;;538          sum = 0.0f;
00026c  eef04a46          VMOV.F32 s9,s12
;;;539    
;;;540          /* Loop over srcBLen */
;;;541          k = srcBLen;
000270  469c              MOV      r12,r3
;;;542    
;;;543          while(k > 0u)
000272  e007              B        |L1.644|
                  |L1.628|
;;;544          {
;;;545            /* Perform the multiply-accumulate */
;;;546            sum += *px++ * *py++;
000274  ecb40a01          VLDM     r4!,{s0}
000278  ecf10a01          VLDM     r1!,{s1}
00027c  ee404a20          VMLA.F32 s9,s0,s1
;;;547    
;;;548            /* Decrement the loop counter */
;;;549            k--;
000280  f1ac0c01          SUB      r12,r12,#1
                  |L1.644|
000284  f1bc0f00          CMP      r12,#0                ;543
000288  d1f4              BNE      |L1.628|
;;;550          }
;;;551    
;;;552          /* Store the result in the accumulator in the destination buffer. */
;;;553          *pOut = sum;
00028a  edc04a00          VSTR     s9,[r0,#0]
;;;554          /* Destination pointer is updated according to the address modifier, inc */
;;;555          pOut += inc;
00028e  eb000085          ADD      r0,r0,r5,LSL #2
;;;556    
;;;557          /* Increment the pointer pIn1 index, count by 1 */
;;;558          count++;
000292  1c52              ADDS     r2,r2,#1
;;;559    
;;;560          /* Update the inputA and inputB pointers for next MAC calculation */
;;;561          px = pIn1 + count;
000294  eb070482          ADD      r4,r7,r2,LSL #2
;;;562          py = pIn2;
000298  4631              MOV      r1,r6
;;;563    
;;;564          /* Decrement the loop counter */
;;;565          blkCnt--;
00029a  f1aa0a01          SUB      r10,r10,#1
                  |L1.670|
00029e  f1ba0f00          CMP      r10,#0                ;535
0002a2  d1e3              BNE      |L1.620|
                  |L1.676|
;;;566        }
;;;567      }
;;;568    
;;;569      /* --------------------------    
;;;570       * Initializations of stage3    
;;;571       * -------------------------*/
;;;572    
;;;573      /* sum += x[srcALen-srcBLen+1] * y[0] + x[srcALen-srcBLen+2] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]    
;;;574       * sum += x[srcALen-srcBLen+2] * y[0] + x[srcALen-srcBLen+3] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]    
;;;575       * ....    
;;;576       * sum +=  x[srcALen-2] * y[0] + x[srcALen-1] * y[1]    
;;;577       * sum +=  x[srcALen-1] * y[0]    
;;;578       */
;;;579    
;;;580      /* In this stage the MAC operations are decreased by 1 for every iteration.    
;;;581         The count variable holds the number of MAC operations performed */
;;;582      count = srcBLen - 1u;
0002a4  1e5c              SUBS     r4,r3,#1
;;;583    
;;;584      /* Working pointer of inputA */
;;;585      pSrc1 = pIn1 + (srcALen - (srcBLen - 1u));
0002a6  f10e0e01          ADD      lr,lr,#1
0002aa  eb07078e          ADD      r7,r7,lr,LSL #2
;;;586      px = pSrc1;
0002ae  463a              MOV      r2,r7
;;;587    
;;;588      /* Working pointer of inputB */
;;;589      py = pIn2;
;;;590    
;;;591      /* -------------------    
;;;592       * Stage3 process    
;;;593       * ------------------*/
;;;594    
;;;595      while(blockSize3 > 0u)
0002b0  e034              B        |L1.796|
                  |L1.690|
;;;596      {
;;;597        /* Accumulator is made zero for every iteration */
;;;598        sum = 0.0f;
0002b2  eef01a46          VMOV.F32 s3,s12
;;;599    
;;;600        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;601        k = count >> 2u;
0002b6  08a3              LSRS     r3,r4,#2
;;;602    
;;;603        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;604         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;605        while(k > 0u)
0002b8  e018              B        |L1.748|
                  |L1.698|
;;;606        {
;;;607          /* Perform the multiply-accumulates */
;;;608          /* sum += x[srcALen - srcBLen + 4] * y[3] */
;;;609          sum += *px++ * *py++;
0002ba  ecb20a01          VLDM     r2!,{s0}
0002be  ecf10a01          VLDM     r1!,{s1}
0002c2  ee401a20          VMLA.F32 s3,s0,s1
;;;610          /* sum += x[srcALen - srcBLen + 3] * y[2] */
;;;611          sum += *px++ * *py++;
0002c6  ecb20a01          VLDM     r2!,{s0}
0002ca  ecf10a01          VLDM     r1!,{s1}
0002ce  ee401a20          VMLA.F32 s3,s0,s1
;;;612          /* sum += x[srcALen - srcBLen + 2] * y[1] */
;;;613          sum += *px++ * *py++;
0002d2  ecb20a01          VLDM     r2!,{s0}
0002d6  ecf10a01          VLDM     r1!,{s1}
0002da  ee401a20          VMLA.F32 s3,s0,s1
;;;614          /* sum += x[srcALen - srcBLen + 1] * y[0] */
;;;615          sum += *px++ * *py++;
0002de  ecb20a01          VLDM     r2!,{s0}
0002e2  ecf10a01          VLDM     r1!,{s1}
0002e6  ee401a20          VMLA.F32 s3,s0,s1
;;;616    
;;;617          /* Decrement the loop counter */
;;;618          k--;
0002ea  1e5b              SUBS     r3,r3,#1
                  |L1.748|
0002ec  2b00              CMP      r3,#0                 ;605
0002ee  d1e4              BNE      |L1.698|
;;;619        }
;;;620    
;;;621        /* If the count is not a multiple of 4, compute any remaining MACs here.    
;;;622         ** No loop unrolling is used. */
;;;623        k = count % 0x4u;
0002f0  f0040303          AND      r3,r4,#3
;;;624    
;;;625        while(k > 0u)
0002f4  e006              B        |L1.772|
                  |L1.758|
;;;626        {
;;;627          /* Perform the multiply-accumulates */
;;;628          sum += *px++ * *py++;
0002f6  ecb20a01          VLDM     r2!,{s0}
0002fa  ecf10a01          VLDM     r1!,{s1}
0002fe  ee401a20          VMLA.F32 s3,s0,s1
;;;629    
;;;630          /* Decrement the loop counter */
;;;631          k--;
000302  1e5b              SUBS     r3,r3,#1
                  |L1.772|
000304  2b00              CMP      r3,#0                 ;625
000306  d1f6              BNE      |L1.758|
;;;632        }
;;;633    
;;;634        /* Store the result in the accumulator in the destination buffer. */
;;;635        *pOut = sum;
000308  edc01a00          VSTR     s3,[r0,#0]
;;;636        /* Destination pointer is updated according to the address modifier, inc */
;;;637        pOut += inc;
00030c  eb000085          ADD      r0,r0,r5,LSL #2
;;;638    
;;;639        /* Update the inputA and inputB pointers for next MAC calculation */
;;;640        px = ++pSrc1;
000310  1d3a              ADDS     r2,r7,#4
000312  4617              MOV      r7,r2
;;;641        py = pIn2;
000314  4631              MOV      r1,r6
;;;642    
;;;643        /* Decrement the MAC count */
;;;644        count--;
000316  1e64              SUBS     r4,r4,#1
;;;645    
;;;646        /* Decrement the loop counter */
;;;647        blockSize3--;
000318  f1a90901          SUB      r9,r9,#1
                  |L1.796|
00031c  f1b90f00          CMP      r9,#0                 ;595
000320  d1c7              BNE      |L1.690|
;;;648      }
;;;649    
;;;650    #else
;;;651    
;;;652      /* Run the below code for Cortex-M0 */
;;;653    
;;;654      float32_t *pIn1 = pSrcA;                       /* inputA pointer */
;;;655      float32_t *pIn2 = pSrcB + (srcBLen - 1u);      /* inputB pointer */
;;;656      float32_t sum;                                 /* Accumulator */
;;;657      uint32_t i = 0u, j;                            /* loop counters */
;;;658      uint32_t inv = 0u;                             /* Reverse order flag */
;;;659      uint32_t tot = 0u;                             /* Length */
;;;660    
;;;661      /* The algorithm implementation is based on the lengths of the inputs. */
;;;662      /* srcB is always made to slide across srcA. */
;;;663      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;664      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;665      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;666      /* and a varaible, inv is set to 1 */
;;;667      /* If lengths are not equal then zero pad has to be done to  make the two    
;;;668       * inputs of same length. But to improve the performance, we assume zeroes    
;;;669       * in the output instead of zero padding either of the the inputs*/
;;;670      /* If srcALen > srcBLen, (srcALen - srcBLen) zeroes has to included in the    
;;;671       * starting of the output buffer */
;;;672      /* If srcALen < srcBLen, (srcALen - srcBLen) zeroes has to included in the   
;;;673       * ending of the output buffer */
;;;674      /* Once the zero padding is done the remaining of the output is calcualted   
;;;675       * using convolution but with the shorter signal time shifted. */
;;;676    
;;;677      /* Calculate the length of the remaining sequence */
;;;678      tot = ((srcALen + srcBLen) - 2u);
;;;679    
;;;680      if(srcALen > srcBLen)
;;;681      {
;;;682        /* Calculating the number of zeros to be padded to the output */
;;;683        j = srcALen - srcBLen;
;;;684    
;;;685        /* Initialise the pointer after zero padding */
;;;686        pDst += j;
;;;687      }
;;;688    
;;;689      else if(srcALen < srcBLen)
;;;690      {
;;;691        /* Initialization to inputB pointer */
;;;692        pIn1 = pSrcB;
;;;693    
;;;694        /* Initialization to the end of inputA pointer */
;;;695        pIn2 = pSrcA + (srcALen - 1u);
;;;696    
;;;697        /* Initialisation of the pointer after zero padding */
;;;698        pDst = pDst + tot;
;;;699    
;;;700        /* Swapping the lengths */
;;;701        j = srcALen;
;;;702        srcALen = srcBLen;
;;;703        srcBLen = j;
;;;704    
;;;705        /* Setting the reverse flag */
;;;706        inv = 1;
;;;707    
;;;708      }
;;;709    
;;;710      /* Loop to calculate convolution for output length number of times */
;;;711      for (i = 0u; i <= tot; i++)
;;;712      {
;;;713        /* Initialize sum with zero to carry on MAC operations */
;;;714        sum = 0.0f;
;;;715    
;;;716        /* Loop to perform MAC operations according to convolution equation */
;;;717        for (j = 0u; j <= i; j++)
;;;718        {
;;;719          /* Check the array limitations */
;;;720          if((((i - j) < srcBLen) && (j < srcALen)))
;;;721          {
;;;722            /* z[i] += x[i-j] * y[j] */
;;;723            sum += pIn1[j] * pIn2[-((int32_t) i - j)];
;;;724          }
;;;725        }
;;;726        /* Store the output in the destination buffer */
;;;727        if(inv == 1)
;;;728          *pDst-- = sum;
;;;729        else
;;;730          *pDst++ = sum;
;;;731      }
;;;732    
;;;733    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;734    
;;;735    }
000322  e8bd8ff0          POP      {r4-r11,pc}
;;;736    
                          ENDP

000326  0000              DCW      0x0000
                  |L1.808|
000328  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_correlate_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_correlate_f32_c_89505502____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___19_arm_correlate_f32_c_89505502____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_correlate_f32_c_89505502____REVSH|
#line 144
|__asm___19_arm_correlate_f32_c_89505502____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_correlate_f32_c_89505502____RRX|
#line 300
|__asm___19_arm_correlate_f32_c_89505502____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
