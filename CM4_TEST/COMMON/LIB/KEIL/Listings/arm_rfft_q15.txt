; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_rfft_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_rfft_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_rfft_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\TransformFunctions\arm_rfft_q15.c]
                          THUMB

                          AREA ||i.arm_rfft_q15||, CODE, READONLY, ALIGN=1

                  arm_rfft_q15 PROC
;;;86     
;;;87     void arm_rfft_q15(
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;88         const arm_rfft_instance_q15 * S,
;;;89         q15_t * pSrc,
;;;90         q15_t * pDst)
;;;91     {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;92         const arm_cfft_instance_q15 *S_CFFT = S->pCfft;
00000a  f8d48014          LDR      r8,[r4,#0x14]
;;;93         uint32_t i;
;;;94         uint32_t L2 = S->fftLenReal >> 1;
00000e  6820              LDR      r0,[r4,#0]
000010  0846              LSRS     r6,r0,#1
;;;95     
;;;96         /* Calculation of RIFFT of input */
;;;97         if(S->ifftFlagR == 1u)
000012  7922              LDRB     r2,[r4,#4]
000014  2a01              CMP      r2,#1
000016  d00f              BEQ      |L1.56|
;;;98         {
;;;99             /*  Real IFFT core process */
;;;100            arm_split_rifft_q15(pSrc, L2, S->pTwiddleAReal,
;;;101                                S->pTwiddleBReal, pDst, S->twidCoefRModifier);
;;;102            
;;;103            /* Complex IFFT process */
;;;104            arm_cfft_q15(S_CFFT, pDst, S->ifftFlagR, S->bitReverseFlagR);
;;;105            
;;;106            for(i=0;i<S->fftLenReal;i++)
;;;107            {
;;;108                pDst[i] = pDst[i] << 1;
;;;109            }
;;;110        }
;;;111        else
;;;112        {
;;;113            /* Calculation of RFFT of input */
;;;114            
;;;115            /* Complex FFT process */
;;;116            arm_cfft_q15(S_CFFT, pSrc, S->ifftFlagR, S->bitReverseFlagR);
000018  7963              LDRB     r3,[r4,#5]
00001a  4639              MOV      r1,r7
00001c  4640              MOV      r0,r8
00001e  f7fffffe          BL       arm_cfft_q15
;;;117    
;;;118            /*  Real FFT core process */
;;;119            arm_split_rfft_q15(pSrc, L2, S->pTwiddleAReal,
000022  68a0              LDR      r0,[r4,#8]
000024  4631              MOV      r1,r6
000026  e9cd5000          STRD     r5,r0,[sp,#0]
00002a  e9d42303          LDRD     r2,r3,[r4,#0xc]
00002e  4638              MOV      r0,r7
000030  f7fffffe          BL       arm_split_rfft_q15
                  |L1.52|
;;;120                                S->pTwiddleBReal, pDst, S->twidCoefRModifier);
;;;121        }
;;;122    }
000034  e8bd81fc          POP      {r2-r8,pc}
                  |L1.56|
000038  68a0              LDR      r0,[r4,#8]            ;100
00003a  4631              MOV      r1,r6                 ;100
00003c  e9cd5000          STRD     r5,r0,[sp,#0]         ;100
000040  e9d42303          LDRD     r2,r3,[r4,#0xc]       ;100
000044  4638              MOV      r0,r7                 ;100
000046  f7fffffe          BL       arm_split_rifft_q15
00004a  7963              LDRB     r3,[r4,#5]            ;104
00004c  7922              LDRB     r2,[r4,#4]            ;104
00004e  4629              MOV      r1,r5                 ;104
000050  4640              MOV      r0,r8                 ;104
000052  f7fffffe          BL       arm_cfft_q15
000056  2000              MOVS     r0,#0                 ;106
000058  e005              B        |L1.102|
                  |L1.90|
00005a  f8351010          LDRH     r1,[r5,r0,LSL #1]     ;108
00005e  0049              LSLS     r1,r1,#1              ;108
000060  f8251010          STRH     r1,[r5,r0,LSL #1]     ;108
000064  1c40              ADDS     r0,r0,#1              ;106
                  |L1.102|
000066  6821              LDR      r1,[r4,#0]            ;106
000068  4281              CMP      r1,r0                 ;106
00006a  d8f6              BHI      |L1.90|
00006c  e7e2              B        |L1.52|
;;;123    
                          ENDP


                          AREA ||i.arm_split_rfft_q15||, CODE, READONLY, ALIGN=1

                  arm_split_rfft_q15 PROC
;;;139    
;;;140    void arm_split_rfft_q15(
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;141        q15_t * pSrc,
;;;142        uint32_t fftLen,
;;;143        q15_t * pATable,
;;;144        q15_t * pBTable,
;;;145        q15_t * pDst,
;;;146        uint32_t modifier)
;;;147    {
000004  e9dd890c          LDRD     r8,r9,[sp,#0x30]
;;;148        uint32_t i;                                    /* Loop Counter */
;;;149        q31_t outR, outI;                              /* Temporary variables for output */
;;;150        q15_t *pCoefA, *pCoefB;                        /* Temporary pointers for twiddle factors */
;;;151        q15_t *pSrc1, *pSrc2;
;;;152    #ifndef ARM_MATH_CM0_FAMILY
;;;153        q15_t *pD1, *pD2;
;;;154    #endif
;;;155    
;;;156        //  pSrc[2u * fftLen] = pSrc[0]; 
;;;157        //  pSrc[(2u * fftLen) + 1u] = pSrc[1]; 
;;;158    
;;;159        pCoefA = &pATable[modifier * 2u];
000008  eb020789          ADD      r7,r2,r9,LSL #2
;;;160        pCoefB = &pBTable[modifier * 2u];
00000c  eb030389          ADD      r3,r3,r9,LSL #2
;;;161    
;;;162        pSrc1 = &pSrc[2];
000010  1d06              ADDS     r6,r0,#4
;;;163        pSrc2 = &pSrc[(2u * fftLen) - 2u];
000012  f06f0201          MVN      r2,#1
000016  eb020241          ADD      r2,r2,r1,LSL #1
00001a  eb000c42          ADD      r12,r0,r2,LSL #1
;;;164    
;;;165    #ifndef ARM_MATH_CM0_FAMILY
;;;166    
;;;167        /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;168        i = 1u;
;;;169        pD1 = pDst + 2;
00001e  f1080504          ADD      r5,r8,#4
;;;170        pD2 = pDst + (4u * fftLen) - 2;
000022  eb0802c1          ADD      r2,r8,r1,LSL #3
000026  1f12              SUBS     r2,r2,#4
;;;171    
;;;172        for(i = fftLen - 1; i > 0; i--)
000028  1e4c              SUBS     r4,r1,#1
00002a  2c00              CMP      r4,#0
00002c  d032              BEQ      |L2.148|
                  |L2.46|
;;;173        {
;;;174            /*    
;;;175            outR = (pSrc[2 * i] * pATable[2 * i] - pSrc[2 * i + 1] * pATable[2 * i + 1]    
;;;176            + pSrc[2 * n - 2 * i] * pBTable[2 * i] +    
;;;177            pSrc[2 * n - 2 * i + 1] * pBTable[2 * i + 1]);    
;;;178            */
;;;179    
;;;180            /* outI = (pIn[2 * i + 1] * pATable[2 * i] + pIn[2 * i] * pATable[2 * i + 1] +    
;;;181            pIn[2 * n - 2 * i] * pBTable[2 * i + 1] -    
;;;182            pIn[2 * n - 2 * i + 1] * pBTable[2 * i]); */
;;;183    
;;;184    
;;;185    #ifndef ARM_MATH_BIG_ENDIAN
;;;186    
;;;187            /* pSrc[2 * i] * pATable[2 * i] - pSrc[2 * i + 1] * pATable[2 * i + 1] */
;;;188            outR = __SMUSD(*__SIMD32(pSrc1), *__SIMD32(pCoefA));
00002e  f8d6a000          LDR      r10,[r6,#0]
000032  f8cda008          STR      r10,[sp,#8]
000036  f8d7b000          LDR      r11,[r7,#0]
00003a  fb4afe0b          SMUSD    lr,r10,r11
00003e  f8cdb004          STR      r11,[sp,#4]
;;;189    
;;;190    #else
;;;191    
;;;192            /* -(pSrc[2 * i + 1] * pATable[2 * i + 1] - pSrc[2 * i] * pATable[2 * i]) */
;;;193            outR = -(__SMUSD(*__SIMD32(pSrc1), *__SIMD32(pCoefA)));
;;;194    
;;;195    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;196    
;;;197            /* pSrc[2 * n - 2 * i] * pBTable[2 * i] +    
;;;198            pSrc[2 * n - 2 * i + 1] * pBTable[2 * i + 1]) */
;;;199            outR = __SMLAD(*__SIMD32(pSrc2), *__SIMD32(pCoefB), outR) >> 16u;
000042  f8dca000          LDR      r10,[r12,#0]
000046  f8d3b000          LDR      r11,[r3,#0]
00004a  fb2aee0b          SMLAD    lr,r10,r11,lr
00004e  ea4f4e1e          LSR      lr,lr,#16
000052  f8cde000          STR      lr,[sp,#0]
;;;200    
;;;201            /* pIn[2 * n - 2 * i] * pBTable[2 * i + 1] -    
;;;202            pIn[2 * n - 2 * i + 1] * pBTable[2 * i] */
;;;203    
;;;204    #ifndef ARM_MATH_BIG_ENDIAN
;;;205    
;;;206            outI = __SMUSDX(*__SIMD32(pSrc2)--, *__SIMD32(pCoefB));
000056  f1ac0c04          SUB      r12,r12,#4
00005a  fb4afe1b          SMUSDX   lr,r10,r11
;;;207    
;;;208    #else
;;;209    
;;;210            outI = __SMUSDX(*__SIMD32(pCoefB), *__SIMD32(pSrc2)--);
;;;211    
;;;212    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;213    
;;;214            /* (pIn[2 * i + 1] * pATable[2 * i] + pIn[2 * i] * pATable[2 * i + 1] */
;;;215            outI = __SMLADX(*__SIMD32(pSrc1)++, *__SIMD32(pCoefA), outI);
00005e  e9ddba01          LDRD     r11,r10,[sp,#4]
000062  1d36              ADDS     r6,r6,#4
000064  fb2aea1b          SMLADX   r10,r10,r11,lr
;;;216    
;;;217            /* write output */
;;;218            *pD1++ = (q15_t) outR;
000068  f8dde000          LDR      lr,[sp,#0]
00006c  f825eb02          STRH     lr,[r5],#2
;;;219            *pD1++ = outI >> 16u;
000070  ea4f4a2a          ASR      r10,r10,#16
000074  f825ab02          STRH     r10,[r5],#2
;;;220    
;;;221            /* write complex conjugate output */
;;;222            pD2[0] = (q15_t) outR;
000078  f8a2e000          STRH     lr,[r2,#0]
;;;223            pD2[1] = -(outI >> 16u);
00007c  f1ca0a00          RSB      r10,r10,#0
000080  f8a2a002          STRH     r10,[r2,#2]
;;;224            pD2 -= 2;
000084  1f12              SUBS     r2,r2,#4
;;;225    
;;;226            /* update coefficient pointer */
;;;227            pCoefB = pCoefB + (2u * modifier);
000086  eb030389          ADD      r3,r3,r9,LSL #2
;;;228            pCoefA = pCoefA + (2u * modifier);
00008a  eb070789          ADD      r7,r7,r9,LSL #2
00008e  1e64              SUBS     r4,r4,#1              ;172
000090  2c00              CMP      r4,#0                 ;172
000092  d1cc              BNE      |L2.46|
                  |L2.148|
;;;229        }
;;;230    
;;;231        pDst[2u * fftLen] = (pSrc[0] - pSrc[1]) >> 1;
000094  f9b02000          LDRSH    r2,[r0,#0]
000098  f9b03002          LDRSH    r3,[r0,#2]
00009c  1ad2              SUBS     r2,r2,r3
00009e  1052              ASRS     r2,r2,#1
0000a0  f8282021          STRH     r2,[r8,r1,LSL #2]
;;;232        pDst[(2u * fftLen) + 1u] = 0;
0000a4  2200              MOVS     r2,#0
0000a6  2301              MOVS     r3,#1
0000a8  eb030141          ADD      r1,r3,r1,LSL #1
0000ac  f8282011          STRH     r2,[r8,r1,LSL #1]
;;;233    
;;;234        pDst[0] = (pSrc[0] + pSrc[1]) >> 1;
0000b0  f9b01000          LDRSH    r1,[r0,#0]
0000b4  f9b00002          LDRSH    r0,[r0,#2]
0000b8  4408              ADD      r0,r0,r1
0000ba  1040              ASRS     r0,r0,#1
0000bc  f8a80000          STRH     r0,[r8,#0]
;;;235        pDst[1] = 0;
0000c0  f8a82002          STRH     r2,[r8,#2]
;;;236    
;;;237    #else
;;;238    
;;;239        /* Run the below code for Cortex-M0 */
;;;240        i = 1u;
;;;241    
;;;242        while(i < fftLen)
;;;243        {
;;;244            /*    
;;;245            outR = (pSrc[2 * i] * pATable[2 * i] - pSrc[2 * i + 1] * pATable[2 * i + 1]    
;;;246            + pSrc[2 * n - 2 * i] * pBTable[2 * i] +    
;;;247            pSrc[2 * n - 2 * i + 1] * pBTable[2 * i + 1]);    
;;;248            */
;;;249    
;;;250            outR = *pSrc1 * *pCoefA;
;;;251            outR = outR - (*(pSrc1 + 1) * *(pCoefA + 1));
;;;252            outR = outR + (*pSrc2 * *pCoefB);
;;;253            outR = (outR + (*(pSrc2 + 1) * *(pCoefB + 1))) >> 16;
;;;254    
;;;255    
;;;256            /* outI = (pIn[2 * i + 1] * pATable[2 * i] + pIn[2 * i] * pATable[2 * i + 1] +    
;;;257            pIn[2 * n - 2 * i] * pBTable[2 * i + 1] -    
;;;258            pIn[2 * n - 2 * i + 1] * pBTable[2 * i]);   
;;;259            */
;;;260    
;;;261            outI = *pSrc2 * *(pCoefB + 1);
;;;262            outI = outI - (*(pSrc2 + 1) * *pCoefB);
;;;263            outI = outI + (*(pSrc1 + 1) * *pCoefA);
;;;264            outI = outI + (*pSrc1 * *(pCoefA + 1));
;;;265    
;;;266            /* update input pointers */
;;;267            pSrc1 += 2u;
;;;268            pSrc2 -= 2u;
;;;269    
;;;270            /* write output */
;;;271            pDst[2u * i] = (q15_t) outR;
;;;272            pDst[(2u * i) + 1u] = outI >> 16u;
;;;273    
;;;274            /* write complex conjugate output */
;;;275            pDst[(4u * fftLen) - (2u * i)] = (q15_t) outR;
;;;276            pDst[((4u * fftLen) - (2u * i)) + 1u] = -(outI >> 16u);
;;;277    
;;;278            /* update coefficient pointer */
;;;279            pCoefB = pCoefB + (2u * modifier);
;;;280            pCoefA = pCoefA + (2u * modifier);
;;;281    
;;;282            i++;
;;;283        }
;;;284    
;;;285        pDst[2u * fftLen] = (pSrc[0] - pSrc[1]) >> 1;
;;;286        pDst[(2u * fftLen) + 1u] = 0;
;;;287    
;;;288        pDst[0] = (pSrc[0] + pSrc[1]) >> 1;
;;;289        pDst[1] = 0;
;;;290    
;;;291    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;292    }
0000c4  e8bd8ffe          POP      {r1-r11,pc}
;;;293    
                          ENDP


                          AREA ||i.arm_split_rifft_q15||, CODE, READONLY, ALIGN=1

                  arm_split_rifft_q15 PROC
;;;305    */
;;;306    void arm_split_rifft_q15(
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;307        q15_t * pSrc,
;;;308        uint32_t fftLen,
;;;309        q15_t * pATable,
;;;310        q15_t * pBTable,
;;;311        q15_t * pDst,
;;;312        uint32_t modifier)
;;;313    {
000004  e9dd4808          LDRD     r4,r8,[sp,#0x20]
;;;314        uint32_t i;                                    /* Loop Counter */
;;;315        q31_t outR, outI;                              /* Temporary variables for output */
;;;316        q15_t *pCoefA, *pCoefB;                        /* Temporary pointers for twiddle factors */
;;;317        q15_t *pSrc1, *pSrc2;
;;;318        q15_t *pDst1 = &pDst[0];
;;;319    
;;;320        pCoefA = &pATable[0];
;;;321        pCoefB = &pBTable[0];
;;;322    
;;;323        pSrc1 = &pSrc[0];
;;;324        pSrc2 = &pSrc[2u * fftLen];
000008  eb000581          ADD      r5,r0,r1,LSL #2
00000c  e01e              B        |L3.76|
                  |L3.14|
;;;325    
;;;326    #ifndef ARM_MATH_CM0_FAMILY
;;;327    
;;;328        /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;329        i = fftLen;
;;;330    
;;;331        while(i > 0u)
;;;332        {
;;;333            /*    
;;;334            outR = (pIn[2 * i] * pATable[2 * i] + pIn[2 * i + 1] * pATable[2 * i + 1] +    
;;;335            pIn[2 * n - 2 * i] * pBTable[2 * i] -    
;;;336            pIn[2 * n - 2 * i + 1] * pBTable[2 * i + 1]);    
;;;337    
;;;338            outI = (pIn[2 * i + 1] * pATable[2 * i] - pIn[2 * i] * pATable[2 * i + 1] -    
;;;339            pIn[2 * n - 2 * i] * pBTable[2 * i + 1] -    
;;;340            pIn[2 * n - 2 * i + 1] * pBTable[2 * i]);    
;;;341            */
;;;342    
;;;343    
;;;344    #ifndef ARM_MATH_BIG_ENDIAN
;;;345    
;;;346            /* pIn[2 * n - 2 * i] * pBTable[2 * i] -    
;;;347            pIn[2 * n - 2 * i + 1] * pBTable[2 * i + 1]) */
;;;348            outR = __SMUSD(*__SIMD32(pSrc2), *__SIMD32(pCoefB));
00000e  f8d5c000          LDR      r12,[r5,#0]
000012  f8d39000          LDR      r9,[r3,#0]
000016  fb4cfa09          SMUSD    r10,r12,r9
;;;349    
;;;350    #else
;;;351    
;;;352            /* -(-pIn[2 * n - 2 * i] * pBTable[2 * i] +  
;;;353            pIn[2 * n - 2 * i + 1] * pBTable[2 * i + 1])) */
;;;354            outR = -(__SMUSD(*__SIMD32(pSrc2), *__SIMD32(pCoefB)));
;;;355    
;;;356    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;357    
;;;358            /* pIn[2 * i] * pATable[2 * i] + pIn[2 * i + 1] * pATable[2 * i + 1] +    
;;;359            pIn[2 * n - 2 * i] * pBTable[2 * i] */
;;;360            outR = __SMLAD(*__SIMD32(pSrc1), *__SIMD32(pCoefA), outR) >> 16u;
00001a  f8506b04          LDR      r6,[r0],#4
00001e  6817              LDR      r7,[r2,#0]
000020  fb26aa07          SMLAD    r10,r6,r7,r10
000024  ea4f4a1a          LSR      r10,r10,#16
;;;361    
;;;362            /*    
;;;363            -pIn[2 * n - 2 * i] * pBTable[2 * i + 1] +    
;;;364            pIn[2 * n - 2 * i + 1] * pBTable[2 * i] */
;;;365            outI = __SMUADX(*__SIMD32(pSrc2)--, *__SIMD32(pCoefB));
000028  1f2d              SUBS     r5,r5,#4
00002a  fb2cfc19          SMUADX   r12,r12,r9
;;;366    
;;;367            /* pIn[2 * i + 1] * pATable[2 * i] - pIn[2 * i] * pATable[2 * i + 1] */
;;;368    
;;;369    #ifndef ARM_MATH_BIG_ENDIAN
;;;370    
;;;371            outI = __SMLSDX(*__SIMD32(pCoefA), *__SIMD32(pSrc1)++, -outI);
00002e  f1cc0c00          RSB      r12,r12,#0
000032  fb47c616          SMLSDX   r6,r7,r6,r12
;;;372    
;;;373    #else
;;;374    
;;;375            outI = __SMLSDX(*__SIMD32(pSrc1)++, *__SIMD32(pCoefA), -outI);
;;;376    
;;;377    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;378            /* write output */
;;;379    
;;;380    #ifndef ARM_MATH_BIG_ENDIAN
;;;381    
;;;382            *__SIMD32(pDst1)++ = __PKHBT(outR, (outI >> 16u), 16);
000036  f36f060f          BFC      r6,#0,#16
00003a  eaca0606          PKHBT    r6,r10,r6
00003e  f8446b04          STR      r6,[r4],#4
;;;383    
;;;384    #else
;;;385    
;;;386            *__SIMD32(pDst1)++ = __PKHBT((outI >> 16u), outR, 16);
;;;387    
;;;388    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;389    
;;;390            /* update coefficient pointer */
;;;391            pCoefB = pCoefB + (2u * modifier);
000042  eb030388          ADD      r3,r3,r8,LSL #2
;;;392            pCoefA = pCoefA + (2u * modifier);
000046  eb020288          ADD      r2,r2,r8,LSL #2
;;;393    
;;;394            i--;
00004a  1e49              SUBS     r1,r1,#1
                  |L3.76|
00004c  2900              CMP      r1,#0                 ;331
00004e  d1de              BNE      |L3.14|
;;;395        }
;;;396    #else
;;;397        /* Run the below code for Cortex-M0 */
;;;398        i = fftLen;
;;;399    
;;;400        while(i > 0u)
;;;401        {
;;;402            /*    
;;;403            outR = (pIn[2 * i] * pATable[2 * i] + pIn[2 * i + 1] * pATable[2 * i + 1] +    
;;;404            pIn[2 * n - 2 * i] * pBTable[2 * i] -    
;;;405            pIn[2 * n - 2 * i + 1] * pBTable[2 * i + 1]);    
;;;406            */
;;;407    
;;;408            outR = *pSrc2 * *pCoefB;
;;;409            outR = outR - (*(pSrc2 + 1) * *(pCoefB + 1));
;;;410            outR = outR + (*pSrc1 * *pCoefA);
;;;411            outR = (outR + (*(pSrc1 + 1) * *(pCoefA + 1))) >> 16;
;;;412    
;;;413            /*   
;;;414            outI = (pIn[2 * i + 1] * pATable[2 * i] - pIn[2 * i] * pATable[2 * i + 1] -   
;;;415            pIn[2 * n - 2 * i] * pBTable[2 * i + 1] -   
;;;416            pIn[2 * n - 2 * i + 1] * pBTable[2 * i]);   
;;;417            */
;;;418    
;;;419            outI = *(pSrc1 + 1) * *pCoefA;
;;;420            outI = outI - (*pSrc1 * *(pCoefA + 1));
;;;421            outI = outI - (*pSrc2 * *(pCoefB + 1));
;;;422            outI = outI - (*(pSrc2 + 1) * *(pCoefB));
;;;423    
;;;424            /* update input pointers */
;;;425            pSrc1 += 2u;
;;;426            pSrc2 -= 2u;
;;;427    
;;;428            /* write output */
;;;429            *pDst1++ = (q15_t) outR;
;;;430            *pDst1++ = (q15_t) (outI >> 16);
;;;431    
;;;432            /* update coefficient pointer */
;;;433            pCoefB = pCoefB + (2u * modifier);
;;;434            pCoefA = pCoefA + (2u * modifier);
;;;435    
;;;436            i--;
;;;437        }
;;;438    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;439    }
000050  e8bd87f0          POP      {r4-r10,pc}
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\TransformFunctions\\arm_rfft_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_rfft_q15_c_65c19725____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___14_arm_rfft_q15_c_65c19725____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_rfft_q15_c_65c19725____REVSH|
#line 144
|__asm___14_arm_rfft_q15_c_65c19725____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_rfft_q15_c_65c19725____RRX|
#line 300
|__asm___14_arm_rfft_q15_c_65c19725____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
