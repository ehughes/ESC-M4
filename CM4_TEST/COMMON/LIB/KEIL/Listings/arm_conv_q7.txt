; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_q7.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_q7.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_conv_q7.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_q7.c]
                          THUMB

                          AREA ||i.arm_conv_q7||, CODE, READONLY, ALIGN=1

                  arm_conv_q7 PROC
;;;75     
;;;76     void arm_conv_q7(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;77       q7_t * pSrcA,
;;;78       uint32_t srcALen,
;;;79       q7_t * pSrcB,
;;;80       uint32_t srcBLen,
;;;81       q7_t * pDst)
;;;82     {
000004  b08b              SUB      sp,sp,#0x2c
000006  9c14              LDR      r4,[sp,#0x50]
;;;83     
;;;84     
;;;85     #ifndef ARM_MATH_CM0_FAMILY
;;;86     
;;;87       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;88     
;;;89       q7_t *pIn1;                                    /* inputA pointer */
;;;90       q7_t *pIn2;                                    /* inputB pointer */
;;;91       q7_t *pOut = pDst;                             /* output pointer */
;;;92       q7_t *px;                                      /* Intermediate inputA pointer */
;;;93       q7_t *py;                                      /* Intermediate inputB pointer */
;;;94       q7_t *pSrc1, *pSrc2;                           /* Intermediate pointers */
;;;95       q7_t x0, x1, x2, x3, c0, c1;                   /* Temporary variables to hold state and coefficient values */
;;;96       q31_t sum, acc0, acc1, acc2, acc3;             /* Accumulator */
;;;97       q31_t input1, input2;                          /* Temporary input variables */
;;;98       q15_t in1, in2;                                /* Temporary input variables */
;;;99       uint32_t j, k, count, blkCnt, blockSize1, blockSize2, blockSize3;     /* loop counter */
;;;100    
;;;101      /* The algorithm implementation is based on the lengths of the inputs. */
;;;102      /* srcB is always made to slide across srcA. */
;;;103      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;104      if(srcALen >= srcBLen)
000008  4299              CMP      r1,r3
00000a  d302              BCC      |L1.18|
;;;105      {
;;;106        /* Initialization of inputA pointer */
;;;107        pIn1 = pSrcA;
00000c  9008              STR      r0,[sp,#0x20]
;;;108    
;;;109        /* Initialization of inputB pointer */
;;;110        pIn2 = pSrcB;
00000e  4610              MOV      r0,r2
000010  e003              B        |L1.26|
                  |L1.18|
;;;111      }
;;;112      else
;;;113      {
;;;114        /* Initialization of inputA pointer */
;;;115        pIn1 = pSrcB;
000012  9208              STR      r2,[sp,#0x20]
;;;116    
;;;117        /* Initialization of inputB pointer */
;;;118        pIn2 = pSrcA;
;;;119    
;;;120        /* srcBLen is always considered as shorter or equal to srcALen */
;;;121        j = srcBLen;
000014  461a              MOV      r2,r3
;;;122        srcBLen = srcALen;
000016  460b              MOV      r3,r1
;;;123        srcALen = j;
000018  4611              MOV      r1,r2
                  |L1.26|
;;;124      }
;;;125    
;;;126      /* conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1] */
;;;127      /* The function is internally   
;;;128       * divided into three stages according to the number of multiplications that has to be   
;;;129       * taken place between inputA samples and inputB samples. In the first stage of the   
;;;130       * algorithm, the multiplications increase by one for every iteration.   
;;;131       * In the second stage of the algorithm, srcBLen number of multiplications are done.   
;;;132       * In the third stage of the algorithm, the multiplications decrease by one   
;;;133       * for every iteration. */
;;;134    
;;;135      /* The algorithm is implemented in three stages.   
;;;136         The loop counters of each stage is initiated here. */
;;;137      blockSize1 = srcBLen - 1u;
00001a  f1a30801          SUB      r8,r3,#1
;;;138      blockSize2 = (srcALen - srcBLen) + 1u;
00001e  1ac9              SUBS     r1,r1,r3
000020  910a              STR      r1,[sp,#0x28]
000022  1c49              ADDS     r1,r1,#1
000024  9101              STR      r1,[sp,#4]
;;;139      blockSize3 = blockSize1;
000026  f8cd8000          STR      r8,[sp,#0]
;;;140    
;;;141      /* --------------------------   
;;;142       * Initializations of stage1   
;;;143       * -------------------------*/
;;;144    
;;;145      /* sum = x[0] * y[0]   
;;;146       * sum = x[0] * y[1] + x[1] * y[0]   
;;;147       * ....   
;;;148       * sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]   
;;;149       */
;;;150    
;;;151      /* In this stage the MAC operations are increased by 1 for every iteration.   
;;;152         The count variable holds the number of MAC operations performed */
;;;153      count = 1u;
00002a  2601              MOVS     r6,#1
;;;154    
;;;155      /* Working pointer of inputA */
;;;156      px = pIn1;
00002c  9f08              LDR      r7,[sp,#0x20]
;;;157    
;;;158      /* Working pointer of inputB */
;;;159      py = pIn2;
00002e  4601              MOV      r1,r0
;;;160    
;;;161    
;;;162      /* ------------------------   
;;;163       * Stage1 process   
;;;164       * ----------------------*/
;;;165    
;;;166      /* The first stage starts here */
;;;167      while(blockSize1 > 0u)
000030  e03c              B        |L1.172|
                  |L1.50|
;;;168      {
;;;169        /* Accumulator is made zero for every iteration */
;;;170        sum = 0;
000032  2500              MOVS     r5,#0
;;;171    
;;;172        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;173        k = count >> 2u;
000034  ea4f0c96          LSR      r12,r6,#2
;;;174    
;;;175        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;176         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;177        while(k > 0u)
000038  e01e              B        |L1.120|
                  |L1.58|
;;;178        {
;;;179          /* x[0] , x[1] */
;;;180          in1 = (q15_t) * px++;
00003a  f9972000          LDRSB    r2,[r7,#0]
;;;181          in2 = (q15_t) * px++;
00003e  f9979001          LDRSB    r9,[r7,#1]
;;;182          input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
000042  f369421f          BFI      r2,r9,#16,#16
;;;183    
;;;184          /* y[srcBLen - 1] , y[srcBLen - 2] */
;;;185          in1 = (q15_t) * py--;
000046  f9119901          LDRSB    r9,[r1],#-1
;;;186          in2 = (q15_t) * py--;
00004a  f911a901          LDRSB    r10,[r1],#-1
;;;187          input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
00004e  f36a491f          BFI      r9,r10,#16,#16
;;;188    
;;;189          /* x[0] * y[srcBLen - 1] */
;;;190          /* x[1] * y[srcBLen - 2] */
;;;191          sum = __SMLAD(input1, input2, sum);
000052  fb225509          SMLAD    r5,r2,r9,r5
;;;192    
;;;193          /* x[2] , x[3] */
;;;194          in1 = (q15_t) * px++;
000056  f9972002          LDRSB    r2,[r7,#2]
00005a  1cff              ADDS     r7,r7,#3
;;;195          in2 = (q15_t) * px++;
00005c  f9179b01          LDRSB    r9,[r7],#1
;;;196          input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
000060  f369421f          BFI      r2,r9,#16,#16
;;;197    
;;;198          /* y[srcBLen - 3] , y[srcBLen - 4] */
;;;199          in1 = (q15_t) * py--;
000064  f9119901          LDRSB    r9,[r1],#-1
;;;200          in2 = (q15_t) * py--;
000068  f911a901          LDRSB    r10,[r1],#-1
;;;201          input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
00006c  f36a491f          BFI      r9,r10,#16,#16
;;;202    
;;;203          /* x[2] * y[srcBLen - 3] */
;;;204          /* x[3] * y[srcBLen - 4] */
;;;205          sum = __SMLAD(input1, input2, sum);
000070  fb225509          SMLAD    r5,r2,r9,r5
;;;206    
;;;207          /* Decrement the loop counter */
;;;208          k--;
000074  f1ac0c01          SUB      r12,r12,#1
                  |L1.120|
000078  f1bc0f00          CMP      r12,#0                ;177
00007c  d1dd              BNE      |L1.58|
;;;209        }
;;;210    
;;;211        /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;212         ** No loop unrolling is used. */
;;;213        k = count % 0x4u;
00007e  f0060c03          AND      r12,r6,#3
;;;214    
;;;215        while(k > 0u)
000082  e007              B        |L1.148|
                  |L1.132|
;;;216        {
;;;217          /* Perform the multiply-accumulates */
;;;218          sum += ((q15_t) * px++ * *py--);
000084  f9172b01          LDRSB    r2,[r7],#1
000088  f9119901          LDRSB    r9,[r1],#-1
00008c  fb125509          SMLABB   r5,r2,r9,r5
;;;219    
;;;220          /* Decrement the loop counter */
;;;221          k--;
000090  f1ac0c01          SUB      r12,r12,#1
                  |L1.148|
000094  f1bc0f00          CMP      r12,#0                ;215
000098  d1f4              BNE      |L1.132|
;;;222        }
;;;223    
;;;224        /* Store the result in the accumulator in the destination buffer. */
;;;225        *pOut++ = (q7_t) (__SSAT(sum >> 7u, 8));
00009a  f32511c7          SSAT     r1,#8,r5,ASR #7
00009e  f8041b01          STRB     r1,[r4],#1
;;;226    
;;;227        /* Update the inputA and inputB pointers for next MAC calculation */
;;;228        py = pIn2 + count;
0000a2  1981              ADDS     r1,r0,r6
;;;229        px = pIn1;
0000a4  9f08              LDR      r7,[sp,#0x20]
;;;230    
;;;231        /* Increment the MAC count */
;;;232        count++;
0000a6  1c76              ADDS     r6,r6,#1
;;;233    
;;;234        /* Decrement the loop counter */
;;;235        blockSize1--;
0000a8  f1a80801          SUB      r8,r8,#1
                  |L1.172|
0000ac  f1b80f00          CMP      r8,#0                 ;167
0000b0  d1bf              BNE      |L1.50|
;;;236      }
;;;237    
;;;238      /* --------------------------   
;;;239       * Initializations of stage2   
;;;240       * ------------------------*/
;;;241    
;;;242      /* sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0]   
;;;243       * sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0]   
;;;244       * ....   
;;;245       * sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]   
;;;246       */
;;;247    
;;;248      /* Working pointer of inputA */
;;;249      px = pIn1;
;;;250    
;;;251      /* Working pointer of inputB */
;;;252      pSrc2 = pIn2 + (srcBLen - 1u);
0000b2  4418              ADD      r0,r0,r3
0000b4  9009              STR      r0,[sp,#0x24]
0000b6  1e40              SUBS     r0,r0,#1
0000b8  9006              STR      r0,[sp,#0x18]
;;;253      py = pSrc2;
0000ba  9806              LDR      r0,[sp,#0x18]
;;;254    
;;;255      /* count is index by which the pointer pIn1 to be incremented */
;;;256      count = 0u;
0000bc  f04f0c00          MOV      r12,#0
;;;257    
;;;258      /* -------------------   
;;;259       * Stage2 process   
;;;260       * ------------------*/
;;;261    
;;;262      /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.   
;;;263       * So, to loop unroll over blockSize2,   
;;;264       * srcBLen should be greater than or equal to 4 */
;;;265      if(srcBLen >= 4u)
0000c0  2b04              CMP      r3,#4
0000c2  d37c              BCC      |L1.446|
;;;266      {
;;;267        /* Loop unroll over blockSize2, by 4 */
;;;268        blkCnt = blockSize2 >> 2u;
0000c4  9901              LDR      r1,[sp,#4]
0000c6  0889              LSRS     r1,r1,#2
0000c8  9102              STR      r1,[sp,#8]
;;;269    
;;;270        while(blkCnt > 0u)
0000ca  e08f              B        |L1.492|
                  |L1.204|
;;;271        {
;;;272          /* Set all accumulators to zero */
;;;273          acc0 = 0;
0000cc  2100              MOVS     r1,#0
;;;274          acc1 = 0;
0000ce  4688              MOV      r8,r1
;;;275          acc2 = 0;
0000d0  4689              MOV      r9,r1
;;;276          acc3 = 0;
0000d2  468b              MOV      r11,r1
;;;277    
;;;278          /* read x[0], x[1], x[2] samples */
;;;279          x0 = *(px++);
0000d4  f9976000          LDRSB    r6,[r7,#0]
;;;280          x1 = *(px++);
0000d8  f9975001          LDRSB    r5,[r7,#1]
;;;281          x2 = *(px++);
0000dc  f9972002          LDRSB    r2,[r7,#2]
0000e0  1cff              ADDS     r7,r7,#3
;;;282    
;;;283          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;284          k = srcBLen >> 2u;
0000e2  ea4f0a93          LSR      r10,r3,#2
0000e6  f8cda00c          STR      r10,[sp,#0xc]
                  |L1.234|
;;;285    
;;;286          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;287           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;288          do
;;;289          {
;;;290            /* Read y[srcBLen - 1] sample */
;;;291            c0 = *(py--);
0000ea  f910e901          LDRSB    lr,[r0],#-1
0000ee  4682              MOV      r10,r0
;;;292            /* Read y[srcBLen - 2] sample */
;;;293            c1 = *(py--);
0000f0  f99a0000          LDRSB    r0,[r10,#0]
0000f4  9005              STR      r0,[sp,#0x14]
0000f6  f1aa0001          SUB      r0,r10,#1
0000fa  9007              STR      r0,[sp,#0x1c]
;;;294    
;;;295            /* Read x[3] sample */
;;;296            x3 = *(px++);
0000fc  f997a000          LDRSB    r10,[r7,#0]
;;;297    
;;;298            /* x[0] and x[1] are packed */
;;;299            in1 = (q15_t) x0;
;;;300            in2 = (q15_t) x1;
;;;301    
;;;302            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
000100  f365461f          BFI      r6,r5,#16,#16
;;;303    
;;;304            /* y[srcBLen - 1]   and y[srcBLen - 2] are packed */
;;;305            in1 = (q15_t) c0;
;;;306            in2 = (q15_t) c1;
000104  9805              LDR      r0,[sp,#0x14]
;;;307    
;;;308            input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
000106  f3604e1f          BFI      lr,r0,#16,#16
;;;309    
;;;310            /* acc0 += x[0] * y[srcBLen - 1] + x[1] * y[srcBLen - 2]  */
;;;311            acc0 = __SMLAD(input1, input2, acc0);
00010a  fb26110e          SMLAD    r1,r6,lr,r1
00010e  9104              STR      r1,[sp,#0x10]
;;;312    
;;;313            /* x[1] and x[2] are packed */
;;;314            in1 = (q15_t) x1;
;;;315            in2 = (q15_t) x2;
;;;316    
;;;317            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
000110  f362451f          BFI      r5,r2,#16,#16
;;;318    
;;;319            /* acc1 += x[1] * y[srcBLen - 1] + x[2] * y[srcBLen - 2]  */
;;;320            acc1 = __SMLAD(input1, input2, acc1);
000114  fb25880e          SMLAD    r8,r5,lr,r8
;;;321    
;;;322            /* x[2] and x[3] are packed */
;;;323            in1 = (q15_t) x2;
000118  4610              MOV      r0,r2
;;;324            in2 = (q15_t) x3;
;;;325    
;;;326            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
00011a  f36a401f          BFI      r0,r10,#16,#16
;;;327    
;;;328            /* acc2 += x[2] * y[srcBLen - 1] + x[3] * y[srcBLen - 2]  */
;;;329            acc2 = __SMLAD(input1, input2, acc2);
00011e  fb20990e          SMLAD    r9,r0,lr,r9
;;;330    
;;;331            /* Read x[4] sample */
;;;332            x0 = *(px++);
000122  f9976001          LDRSB    r6,[r7,#1]
;;;333    
;;;334            /* x[3] and x[4] are packed */
;;;335            in1 = (q15_t) x3;
;;;336            in2 = (q15_t) x0;
;;;337    
;;;338            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
000126  4650              MOV      r0,r10
000128  f366401f          BFI      r0,r6,#16,#16
;;;339    
;;;340            /* acc3 += x[3] * y[srcBLen - 1] + x[4] * y[srcBLen - 2]  */
;;;341            acc3 = __SMLAD(input1, input2, acc3);
00012c  fb20be0e          SMLAD    lr,r0,lr,r11
;;;342    
;;;343            /* Read y[srcBLen - 3] sample */
;;;344            c0 = *(py--);
000130  9807              LDR      r0,[sp,#0x1c]
000132  f990b000          LDRSB    r11,[r0,#0]
;;;345            /* Read y[srcBLen - 4] sample */
;;;346            c1 = *(py--);
000136  f9101c01          LDRSB    r1,[r0,#-1]
00013a  1e80              SUBS     r0,r0,#2
;;;347    
;;;348            /* Read x[5] sample */
;;;349            x1 = *(px++);
00013c  f9975002          LDRSB    r5,[r7,#2]
;;;350    
;;;351            /* x[2] and x[3] are packed */
;;;352            in1 = (q15_t) x2;
;;;353            in2 = (q15_t) x3;
;;;354    
;;;355            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
000140  f36a421f          BFI      r2,r10,#16,#16
;;;356    
;;;357            /* y[srcBLen - 3] and y[srcBLen - 4] are packed */
;;;358            in1 = (q15_t) c0;
;;;359            in2 = (q15_t) c1;
;;;360    
;;;361            input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
000144  f3614b1f          BFI      r11,r1,#16,#16
;;;362    
;;;363            /* acc0 += x[2] * y[srcBLen - 3] + x[3] * y[srcBLen - 4]  */
;;;364            acc0 = __SMLAD(input1, input2, acc0);
000148  9904              LDR      r1,[sp,#0x10]
00014a  fb22110b          SMLAD    r1,r2,r11,r1
;;;365    
;;;366            /* x[3] and x[4] are packed */
;;;367            in1 = (q15_t) x3;
;;;368            in2 = (q15_t) x0;
;;;369    
;;;370            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
00014e  f3664a1f          BFI      r10,r6,#16,#16
;;;371    
;;;372            /* acc1 += x[3] * y[srcBLen - 3] + x[4] * y[srcBLen - 4]  */
;;;373            acc1 = __SMLAD(input1, input2, acc1);
000152  fb2a880b          SMLAD    r8,r10,r11,r8
;;;374    
;;;375            /* x[4] and x[5] are packed */
;;;376            in1 = (q15_t) x0;
000156  4632              MOV      r2,r6
;;;377            in2 = (q15_t) x1;
;;;378    
;;;379            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
000158  f365421f          BFI      r2,r5,#16,#16
;;;380    
;;;381            /* acc2 += x[4] * y[srcBLen - 3] + x[5] * y[srcBLen - 4]  */
;;;382            acc2 = __SMLAD(input1, input2, acc2);
00015c  fb22990b          SMLAD    r9,r2,r11,r9
;;;383    
;;;384            /* Read x[6] sample */
;;;385            x2 = *(px++);
000160  f9972003          LDRSB    r2,[r7,#3]
000164  1d3f              ADDS     r7,r7,#4
;;;386    
;;;387            /* x[5] and x[6] are packed */
;;;388            in1 = (q15_t) x1;
;;;389            in2 = (q15_t) x2;
;;;390    
;;;391            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
000166  46aa              MOV      r10,r5
000168  f3624a1f          BFI      r10,r2,#16,#16
;;;392    
;;;393            /* acc3 += x[5] * y[srcBLen - 3] + x[6] * y[srcBLen - 4]  */
;;;394            acc3 = __SMLAD(input1, input2, acc3);
00016c  fb2aeb0b          SMLAD    r11,r10,r11,lr
;;;395    
;;;396          } while(--k);
000170  f8dda00c          LDR      r10,[sp,#0xc]
000174  f1ba0a01          SUBS     r10,r10,#1
000178  f8cda00c          STR      r10,[sp,#0xc]
00017c  d1b5              BNE      |L1.234|
;;;397    
;;;398          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;399           ** No loop unrolling is used. */
;;;400          k = srcBLen % 0x4u;
00017e  f0030a03          AND      r10,r3,#3
000182  f8cda00c          STR      r10,[sp,#0xc]
;;;401    
;;;402          while(k > 0u)
000186  e014              B        |L1.434|
                  |L1.392|
;;;403          {
;;;404            /* Read y[srcBLen - 5] sample */
;;;405            c0 = *(py--);
000188  f910a901          LDRSB    r10,[r0],#-1
;;;406    
;;;407            /* Read x[7] sample */
;;;408            x3 = *(px++);
00018c  f917eb01          LDRSB    lr,[r7],#1
;;;409    
;;;410            /* Perform the multiply-accumulates */
;;;411            /* acc0 +=  x[4] * y[srcBLen - 5] */
;;;412            acc0 += ((q15_t) x0 * c0);
000190  fb06110a          MLA      r1,r6,r10,r1
;;;413            /* acc1 +=  x[5] * y[srcBLen - 5] */
;;;414            acc1 += ((q15_t) x1 * c0);
000194  fb05880a          MLA      r8,r5,r10,r8
;;;415            /* acc2 +=  x[6] * y[srcBLen - 5] */
;;;416            acc2 += ((q15_t) x2 * c0);
000198  fb02990a          MLA      r9,r2,r10,r9
;;;417            /* acc3 +=  x[7] * y[srcBLen - 5] */
;;;418            acc3 += ((q15_t) x3 * c0);
00019c  fb1ebb0a          SMLABB   r11,lr,r10,r11
;;;419    
;;;420            /* Reuse the present samples for the next MAC */
;;;421            x0 = x1;
0001a0  462e              MOV      r6,r5
;;;422            x1 = x2;
0001a2  4615              MOV      r5,r2
;;;423            x2 = x3;
0001a4  4672              MOV      r2,lr
;;;424    
;;;425            /* Decrement the loop counter */
;;;426            k--;
0001a6  f8dda00c          LDR      r10,[sp,#0xc]
0001aa  f1aa0a01          SUB      r10,r10,#1
0001ae  f8cda00c          STR      r10,[sp,#0xc]
                  |L1.434|
0001b2  f8dda00c          LDR      r10,[sp,#0xc]         ;402
0001b6  f1ba0f00          CMP      r10,#0                ;402
0001ba  d1e5              BNE      |L1.392|
;;;427          }
;;;428    
;;;429    
;;;430          /* Store the result in the accumulator in the destination buffer. */
;;;431          *pOut++ = (q7_t) (__SSAT(acc0 >> 7u, 8));
0001bc  e000              B        |L1.448|
                  |L1.446|
0001be  e05a              B        |L1.630|
                  |L1.448|
0001c0  f32110c7          SSAT     r0,#8,r1,ASR #7
0001c4  7020              STRB     r0,[r4,#0]
;;;432          *pOut++ = (q7_t) (__SSAT(acc1 >> 7u, 8));
0001c6  f32810c7          SSAT     r0,#8,r8,ASR #7
0001ca  7060              STRB     r0,[r4,#1]
;;;433          *pOut++ = (q7_t) (__SSAT(acc2 >> 7u, 8));
0001cc  f32910c7          SSAT     r0,#8,r9,ASR #7
0001d0  70a0              STRB     r0,[r4,#2]
;;;434          *pOut++ = (q7_t) (__SSAT(acc3 >> 7u, 8));
0001d2  f32b10c7          SSAT     r0,#8,r11,ASR #7
0001d6  70e0              STRB     r0,[r4,#3]
0001d8  1d24              ADDS     r4,r4,#4
;;;435    
;;;436          /* Increment the pointer pIn1 index, count by 4 */
;;;437          count += 4u;
0001da  f10c0c04          ADD      r12,r12,#4
;;;438    
;;;439          /* Update the inputA and inputB pointers for next MAC calculation */
;;;440          px = pIn1 + count;
0001de  9808              LDR      r0,[sp,#0x20]
0001e0  eb00070c          ADD      r7,r0,r12
;;;441          py = pSrc2;
0001e4  9806              LDR      r0,[sp,#0x18]
;;;442    
;;;443          /* Decrement the loop counter */
;;;444          blkCnt--;
0001e6  9902              LDR      r1,[sp,#8]
0001e8  1e49              SUBS     r1,r1,#1
0001ea  9102              STR      r1,[sp,#8]
                  |L1.492|
0001ec  9902              LDR      r1,[sp,#8]            ;270
0001ee  2900              CMP      r1,#0                 ;270
0001f0  f47faf6c          BNE      |L1.204|
;;;445        }
;;;446    
;;;447        /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.   
;;;448         ** No loop unrolling is used. */
;;;449        blkCnt = blockSize2 % 0x4u;
0001f4  9901              LDR      r1,[sp,#4]
0001f6  f0010503          AND      r5,r1,#3
;;;450    
;;;451        while(blkCnt > 0u)
0001fa  e039              B        |L1.624|
                  |L1.508|
;;;452        {
;;;453          /* Accumulator is made zero for every iteration */
;;;454          sum = 0;
0001fc  2100              MOVS     r1,#0
;;;455    
;;;456          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;457          k = srcBLen >> 2u;
0001fe  089a              LSRS     r2,r3,#2
;;;458    
;;;459          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;460           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;461          while(k > 0u)
000200  e01d              B        |L1.574|
                  |L1.514|
;;;462          {
;;;463    
;;;464            /* Reading two inputs of SrcA buffer and packing */
;;;465            in1 = (q15_t) * px++;
000202  f9976000          LDRSB    r6,[r7,#0]
;;;466            in2 = (q15_t) * px++;
000206  f9978001          LDRSB    r8,[r7,#1]
;;;467            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
00020a  f368461f          BFI      r6,r8,#16,#16
;;;468    
;;;469            /* Reading two inputs of SrcB buffer and packing */
;;;470            in1 = (q15_t) * py--;
00020e  f9108901          LDRSB    r8,[r0],#-1
;;;471            in2 = (q15_t) * py--;
000212  f9109901          LDRSB    r9,[r0],#-1
;;;472            input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
000216  f369481f          BFI      r8,r9,#16,#16
;;;473    
;;;474            /* Perform the multiply-accumulates */
;;;475            sum = __SMLAD(input1, input2, sum);
00021a  fb261608          SMLAD    r6,r6,r8,r1
;;;476    
;;;477            /* Reading two inputs of SrcA buffer and packing */
;;;478            in1 = (q15_t) * px++;
00021e  f9971002          LDRSB    r1,[r7,#2]
000222  1cff              ADDS     r7,r7,#3
;;;479            in2 = (q15_t) * px++;
000224  f9178b01          LDRSB    r8,[r7],#1
;;;480            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
000228  f368411f          BFI      r1,r8,#16,#16
;;;481    
;;;482            /* Reading two inputs of SrcB buffer and packing */
;;;483            in1 = (q15_t) * py--;
00022c  f9108901          LDRSB    r8,[r0],#-1
;;;484            in2 = (q15_t) * py--;
000230  f9109901          LDRSB    r9,[r0],#-1
;;;485            input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
000234  f369481f          BFI      r8,r9,#16,#16
;;;486    
;;;487            /* Perform the multiply-accumulates */
;;;488            sum = __SMLAD(input1, input2, sum);
000238  fb216108          SMLAD    r1,r1,r8,r6
;;;489    
;;;490            /* Decrement the loop counter */
;;;491            k--;
00023c  1e52              SUBS     r2,r2,#1
                  |L1.574|
00023e  2a00              CMP      r2,#0                 ;461
000240  d1df              BNE      |L1.514|
;;;492          }
;;;493    
;;;494          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;495           ** No loop unrolling is used. */
;;;496          k = srcBLen % 0x4u;
000242  f0030203          AND      r2,r3,#3
;;;497    
;;;498          while(k > 0u)
000246  e006              B        |L1.598|
                  |L1.584|
;;;499          {
;;;500            /* Perform the multiply-accumulates */
;;;501            sum += ((q15_t) * px++ * *py--);
000248  f9176b01          LDRSB    r6,[r7],#1
00024c  f9108901          LDRSB    r8,[r0],#-1
000250  fb161108          SMLABB   r1,r6,r8,r1
;;;502    
;;;503            /* Decrement the loop counter */
;;;504            k--;
000254  1e52              SUBS     r2,r2,#1
                  |L1.598|
000256  2a00              CMP      r2,#0                 ;498
000258  d1f6              BNE      |L1.584|
;;;505          }
;;;506    
;;;507          /* Store the result in the accumulator in the destination buffer. */
;;;508          *pOut++ = (q7_t) (__SSAT(sum >> 7u, 8));
00025a  f32110c7          SSAT     r0,#8,r1,ASR #7
00025e  f8040b01          STRB     r0,[r4],#1
;;;509    
;;;510          /* Increment the pointer pIn1 index, count by 1 */
;;;511          count++;
000262  f10c0c01          ADD      r12,r12,#1
;;;512    
;;;513          /* Update the inputA and inputB pointers for next MAC calculation */
;;;514          px = pIn1 + count;
000266  9808              LDR      r0,[sp,#0x20]
000268  eb00070c          ADD      r7,r0,r12
;;;515          py = pSrc2;
00026c  9806              LDR      r0,[sp,#0x18]
;;;516    
;;;517          /* Decrement the loop counter */
;;;518          blkCnt--;
00026e  1e6d              SUBS     r5,r5,#1
                  |L1.624|
000270  2d00              CMP      r5,#0                 ;451
000272  d1c3              BNE      |L1.508|
000274  e01a              B        |L1.684|
                  |L1.630|
;;;519        }
;;;520      }
;;;521      else
;;;522      {
;;;523        /* If the srcBLen is not a multiple of 4,   
;;;524         * the blockSize2 loop cannot be unrolled by 4 */
;;;525        blkCnt = blockSize2;
000276  9d01              LDR      r5,[sp,#4]
;;;526    
;;;527        while(blkCnt > 0u)
000278  e016              B        |L1.680|
                  |L1.634|
;;;528        {
;;;529          /* Accumulator is made zero for every iteration */
;;;530          sum = 0;
00027a  2200              MOVS     r2,#0
;;;531    
;;;532          /* srcBLen number of MACS should be performed */
;;;533          k = srcBLen;
00027c  4619              MOV      r1,r3
;;;534    
;;;535          while(k > 0u)
00027e  e006              B        |L1.654|
                  |L1.640|
;;;536          {
;;;537            /* Perform the multiply-accumulate */
;;;538            sum += ((q15_t) * px++ * *py--);
000280  f9176b01          LDRSB    r6,[r7],#1
000284  f9108901          LDRSB    r8,[r0],#-1
000288  fb162208          SMLABB   r2,r6,r8,r2
;;;539    
;;;540            /* Decrement the loop counter */
;;;541            k--;
00028c  1e49              SUBS     r1,r1,#1
                  |L1.654|
00028e  2900              CMP      r1,#0                 ;535
000290  d1f6              BNE      |L1.640|
;;;542          }
;;;543    
;;;544          /* Store the result in the accumulator in the destination buffer. */
;;;545          *pOut++ = (q7_t) (__SSAT(sum >> 7u, 8));
000292  f32210c7          SSAT     r0,#8,r2,ASR #7
000296  f8040b01          STRB     r0,[r4],#1
;;;546    
;;;547          /* Increment the MAC count */
;;;548          count++;
00029a  f10c0c01          ADD      r12,r12,#1
;;;549    
;;;550          /* Update the inputA and inputB pointers for next MAC calculation */
;;;551          px = pIn1 + count;
00029e  9808              LDR      r0,[sp,#0x20]
0002a0  eb00070c          ADD      r7,r0,r12
;;;552          py = pSrc2;
0002a4  9806              LDR      r0,[sp,#0x18]
;;;553    
;;;554          /* Decrement the loop counter */
;;;555          blkCnt--;
0002a6  1e6d              SUBS     r5,r5,#1
                  |L1.680|
0002a8  2d00              CMP      r5,#0                 ;527
0002aa  d1e6              BNE      |L1.634|
                  |L1.684|
;;;556        }
;;;557      }
;;;558    
;;;559    
;;;560      /* --------------------------   
;;;561       * Initializations of stage3   
;;;562       * -------------------------*/
;;;563    
;;;564      /* sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1]   
;;;565       * sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2]   
;;;566       * ....   
;;;567       * sum +=  x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2]   
;;;568       * sum +=  x[srcALen-1] * y[srcBLen-1]   
;;;569       */
;;;570    
;;;571      /* In this stage the MAC operations are decreased by 1 for every iteration.   
;;;572         The blockSize3 variable holds the number of MAC operations performed */
;;;573    
;;;574      /* Working pointer of inputA */
;;;575      pSrc1 = pIn1 + (srcALen - (srcBLen - 1u));
0002ac  9908              LDR      r1,[sp,#0x20]
0002ae  980a              LDR      r0,[sp,#0x28]
0002b0  1845              ADDS     r5,r0,r1
0002b2  1c6d              ADDS     r5,r5,#1
;;;576      px = pSrc1;
0002b4  4628              MOV      r0,r5
;;;577    
;;;578      /* Working pointer of inputB */
;;;579      pSrc2 = pIn2 + (srcBLen - 1u);
0002b6  9e09              LDR      r6,[sp,#0x24]
0002b8  1e76              SUBS     r6,r6,#1
;;;580      py = pSrc2;
0002ba  4631              MOV      r1,r6
;;;581    
;;;582      /* -------------------   
;;;583       * Stage3 process   
;;;584       * ------------------*/
;;;585    
;;;586      while(blockSize3 > 0u)
0002bc  e03a              B        |L1.820|
                  |L1.702|
;;;587      {
;;;588        /* Accumulator is made zero for every iteration */
;;;589        sum = 0;
0002be  2200              MOVS     r2,#0
;;;590    
;;;591        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;592        k = blockSize3 >> 2u;
0002c0  9b00              LDR      r3,[sp,#0]
0002c2  089b              LSRS     r3,r3,#2
;;;593    
;;;594        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;595         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;596        while(k > 0u)
0002c4  e01d              B        |L1.770|
                  |L1.710|
;;;597        {
;;;598          /* Reading two inputs, x[srcALen - srcBLen + 1] and x[srcALen - srcBLen + 2] of SrcA buffer and packing */
;;;599          in1 = (q15_t) * px++;
0002c6  f9907000          LDRSB    r7,[r0,#0]
;;;600          in2 = (q15_t) * px++;
0002ca  f990c001          LDRSB    r12,[r0,#1]
;;;601          input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
0002ce  f36c471f          BFI      r7,r12,#16,#16
;;;602    
;;;603          /* Reading two inputs, y[srcBLen - 1] and y[srcBLen - 2] of SrcB buffer and packing */
;;;604          in1 = (q15_t) * py--;
0002d2  f911c901          LDRSB    r12,[r1],#-1
;;;605          in2 = (q15_t) * py--;
0002d6  f9118901          LDRSB    r8,[r1],#-1
;;;606          input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
0002da  f3684c1f          BFI      r12,r8,#16,#16
;;;607    
;;;608          /* sum += x[srcALen - srcBLen + 1] * y[srcBLen - 1] */
;;;609          /* sum += x[srcALen - srcBLen + 2] * y[srcBLen - 2] */
;;;610          sum = __SMLAD(input1, input2, sum);
0002de  fb27270c          SMLAD    r7,r7,r12,r2
;;;611    
;;;612          /* Reading two inputs, x[srcALen - srcBLen + 3] and x[srcALen - srcBLen + 4] of SrcA buffer and packing */
;;;613          in1 = (q15_t) * px++;
0002e2  f9902002          LDRSB    r2,[r0,#2]
0002e6  1cc0              ADDS     r0,r0,#3
;;;614          in2 = (q15_t) * px++;
0002e8  f910cb01          LDRSB    r12,[r0],#1
;;;615          input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
0002ec  f36c421f          BFI      r2,r12,#16,#16
;;;616    
;;;617          /* Reading two inputs, y[srcBLen - 3] and y[srcBLen - 4] of SrcB buffer and packing */
;;;618          in1 = (q15_t) * py--;
0002f0  f911c901          LDRSB    r12,[r1],#-1
;;;619          in2 = (q15_t) * py--;
0002f4  f9118901          LDRSB    r8,[r1],#-1
;;;620          input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
0002f8  f3684c1f          BFI      r12,r8,#16,#16
;;;621    
;;;622          /* sum += x[srcALen - srcBLen + 3] * y[srcBLen - 3] */
;;;623          /* sum += x[srcALen - srcBLen + 4] * y[srcBLen - 4] */
;;;624          sum = __SMLAD(input1, input2, sum);
0002fc  fb22720c          SMLAD    r2,r2,r12,r7
;;;625    
;;;626          /* Decrement the loop counter */
;;;627          k--;
000300  1e5b              SUBS     r3,r3,#1
                  |L1.770|
000302  2b00              CMP      r3,#0                 ;596
000304  d1df              BNE      |L1.710|
;;;628        }
;;;629    
;;;630        /* If the blockSize3 is not a multiple of 4, compute any remaining MACs here.   
;;;631         ** No loop unrolling is used. */
;;;632        k = blockSize3 % 0x4u;
000306  9b00              LDR      r3,[sp,#0]
000308  f0030303          AND      r3,r3,#3
;;;633    
;;;634        while(k > 0u)
00030c  e006              B        |L1.796|
                  |L1.782|
;;;635        {
;;;636          /* Perform the multiply-accumulates */
;;;637          sum += ((q15_t) * px++ * *py--);
00030e  f9107b01          LDRSB    r7,[r0],#1
000312  f911c901          LDRSB    r12,[r1],#-1
000316  fb17220c          SMLABB   r2,r7,r12,r2
;;;638    
;;;639          /* Decrement the loop counter */
;;;640          k--;
00031a  1e5b              SUBS     r3,r3,#1
                  |L1.796|
00031c  2b00              CMP      r3,#0                 ;634
00031e  d1f6              BNE      |L1.782|
;;;641        }
;;;642    
;;;643        /* Store the result in the accumulator in the destination buffer. */
;;;644        *pOut++ = (q7_t) (__SSAT(sum >> 7u, 8));
000320  f32210c7          SSAT     r0,#8,r2,ASR #7
000324  f8040b01          STRB     r0,[r4],#1
;;;645    
;;;646        /* Update the inputA and inputB pointers for next MAC calculation */
;;;647        px = ++pSrc1;
000328  1c68              ADDS     r0,r5,#1
00032a  4605              MOV      r5,r0
;;;648        py = pSrc2;
00032c  4631              MOV      r1,r6
;;;649    
;;;650        /* Decrement the loop counter */
;;;651        blockSize3--;
00032e  9a00              LDR      r2,[sp,#0]
000330  1e52              SUBS     r2,r2,#1
000332  9200              STR      r2,[sp,#0]
                  |L1.820|
000334  9a00              LDR      r2,[sp,#0]            ;586
000336  2a00              CMP      r2,#0                 ;586
000338  d1c1              BNE      |L1.702|
;;;652      }
;;;653    
;;;654    #else
;;;655    
;;;656      /* Run the below code for Cortex-M0 */
;;;657    
;;;658      q7_t *pIn1 = pSrcA;                            /* input pointer */
;;;659      q7_t *pIn2 = pSrcB;                            /* coefficient pointer */
;;;660      q31_t sum;                                     /* Accumulator */
;;;661      uint32_t i, j;                                 /* loop counter */
;;;662    
;;;663      /* Loop to calculate output of convolution for output length number of times */
;;;664      for (i = 0; i < (srcALen + srcBLen - 1); i++)
;;;665      {
;;;666        /* Initialize sum with zero to carry on MAC operations */
;;;667        sum = 0;
;;;668    
;;;669        /* Loop to perform MAC operations according to convolution equation */
;;;670        for (j = 0; j <= i; j++)
;;;671        {
;;;672          /* Check the array limitations */
;;;673          if(((i - j) < srcBLen) && (j < srcALen))
;;;674          {
;;;675            /* z[i] += x[i-j] * y[j] */
;;;676            sum += (q15_t) pIn1[j] * (pIn2[i - j]);
;;;677          }
;;;678        }
;;;679    
;;;680        /* Store the output in the destination buffer */
;;;681        pDst[i] = (q7_t) __SSAT((sum >> 7u), 8u);
;;;682      }
;;;683    
;;;684    #endif /*   #ifndef ARM_MATH_CM0_FAMILY        */
;;;685    
;;;686    }
00033a  b00b              ADD      sp,sp,#0x2c
00033c  e8bd8ff0          POP      {r4-r11,pc}
;;;687    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_q7.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_conv_q7_c_eb987386____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___13_arm_conv_q7_c_eb987386____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_conv_q7_c_eb987386____REVSH|
#line 144
|__asm___13_arm_conv_q7_c_eb987386____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_conv_q7_c_eb987386____RRX|
#line 300
|__asm___13_arm_conv_q7_c_eb987386____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
