; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_biquad_cascade_df1_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_biquad_cascade_df1_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_biquad_cascade_df1_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_biquad_cascade_df1_q15.c]
                          THUMB

                          AREA ||i.arm_biquad_cascade_df1_q15||, CODE, READONLY, ALIGN=1

                  arm_biquad_cascade_df1_q15 PROC
;;;74     
;;;75     void arm_biquad_cascade_df1_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;76       const arm_biquad_casd_df1_inst_q15 * S,
;;;77       q15_t * pSrc,
;;;78       q15_t * pDst,
;;;79       uint32_t blockSize)
;;;80     {
000004  b083              SUB      sp,sp,#0xc
;;;81     
;;;82     
;;;83     #ifndef ARM_MATH_CM0_FAMILY
;;;84     
;;;85       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;86     
;;;87       q15_t *pIn = pSrc;                             /*  Source pointer                               */
;;;88       q15_t *pOut = pDst;                            /*  Destination pointer                          */
000006  9c05              LDR      r4,[sp,#0x14]
;;;89       q31_t in;                                      /*  Temporary variable to hold input value       */
;;;90       q31_t out;                                     /*  Temporary variable to hold output value      */
;;;91       q31_t b0;                                      /*  Temporary variable to hold bo value          */
;;;92       q31_t b1, a1;                                  /*  Filter coefficients                          */
;;;93       q31_t state_in, state_out;                     /*  Filter state variables                       */
;;;94       q31_t acc_l, acc_h;
;;;95       q63_t acc;                                     /*  Accumulator                                  */
;;;96       int32_t lShift = (15 - (int32_t) S->postShift);       /*  Post shift                                   */
000008  f990200c          LDRSB    r2,[r0,#0xc]
00000c  f1c20c0f          RSB      r12,r2,#0xf
;;;97       q15_t *pState = S->pState;                     /*  State pointer                                */
000010  6842              LDR      r2,[r0,#4]
;;;98       q15_t *pCoeffs = S->pCoeffs;                   /*  Coefficient pointer                          */
000012  f8d0e008          LDR      lr,[r0,#8]
;;;99       uint32_t sample, stage = (uint32_t) S->numStages;     /*  Stage loop counter                           */
000016  f9900000          LDRSB    r0,[r0,#0]
00001a  9000              STR      r0,[sp,#0]
;;;100      int32_t uShift = (32 - lShift);
00001c  f1cc0b20          RSB      r11,r12,#0x20
;;;101    
;;;102      do
;;;103      {
;;;104        /* Read the b0 and 0 coefficients using SIMD  */
;;;105        b0 = *__SIMD32(pCoeffs)++;
;;;106    
;;;107        /* Read the b1 and b2 coefficients using SIMD */
;;;108        b1 = *__SIMD32(pCoeffs)++;
;;;109    
;;;110        /* Read the a1 and a2 coefficients using SIMD */
;;;111        a1 = *__SIMD32(pCoeffs)++;
;;;112    
;;;113        /* Read the input state values from the state buffer:  x[n-1], x[n-2] */
;;;114        state_in = *__SIMD32(pState)++;
;;;115    
;;;116        /* Read the output state values from the state buffer:  y[n-1], y[n-2] */
;;;117        state_out = *__SIMD32(pState)--;
;;;118    
;;;119        /* Apply loop unrolling and compute 2 output values simultaneously. */
;;;120        /*      The variable acc hold output values that are being computed:    
;;;121         *    
;;;122         *    acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2]    
;;;123         *    acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2]    
;;;124         */
;;;125        sample = blockSize >> 1u;
000020  9806              LDR      r0,[sp,#0x18]
000022  0840              LSRS     r0,r0,#1
000024  9002              STR      r0,[sp,#8]
                  |L1.38|
000026  f85eab04          LDR      r10,[lr],#4           ;105
00002a  f85e6b04          LDR      r6,[lr],#4            ;108
00002e  f85e7b04          LDR      r7,[lr],#4            ;111
000032  f8528b04          LDR      r8,[r2],#4            ;114
000036  f8529904          LDR      r9,[r2],#-4           ;117
00003a  9201              STR      r2,[sp,#4]            ;117
00003c  9d02              LDR      r5,[sp,#8]
;;;126    
;;;127        /* First part of the processing with loop unrolling.  Compute 2 outputs at a time.    
;;;128         ** a second loop below computes the remaining 1 sample. */
;;;129        while(sample > 0u)
00003e  e02b              B        |L1.152|
                  |L1.64|
;;;130        {
;;;131    
;;;132          /* Read the input */
;;;133          in = *__SIMD32(pIn)++;
000040  f8510b04          LDR      r0,[r1],#4
;;;134    
;;;135          /* out =  b0 * x[n] + 0 * 0 */
;;;136          out = __SMUAD(b0, in);
000044  fb2af200          SMUAD    r2,r10,r0
;;;137    
;;;138          /* acc +=  b1 * x[n-1] +  b2 * x[n-2] + out */
;;;139          acc = __SMLALD(b1, state_in, out);
000048  17d3              ASRS     r3,r2,#31
00004a  fbc623c8          SMLALD   r2,r3,r6,r8
;;;140          /* acc +=  a1 * y[n-1] +  a2 * y[n-2] */
;;;141          acc = __SMLALD(a1, state_out, acc);
00004e  fbc723c9          SMLALD   r2,r3,r7,r9
;;;142    
;;;143          /* The result is converted from 3.29 to 1.31 if postShift = 1, and then saturation is applied */
;;;144          /* Calc lower part of acc */
;;;145          acc_l = acc & 0xffffffff;
;;;146    
;;;147          /* Calc upper part of acc */
;;;148          acc_h = (acc >> 32) & 0xffffffff;
;;;149    
;;;150          /* Apply shift for lower part of acc and upper part of acc */
;;;151          out = (uint32_t) acc_l >> lShift | acc_h << uShift;
000052  fa22f20c          LSR      r2,r2,r12
000056  fa03f30b          LSL      r3,r3,r11
00005a  431a              ORRS     r2,r2,r3
;;;152    
;;;153          out = __SSAT(out, 16);
00005c  f302020f          SSAT     r2,#16,r2
;;;154    
;;;155          /* Every time after the output is computed state should be updated. */
;;;156          /* The states should be updated as:  */
;;;157          /* Xn2 = Xn1    */
;;;158          /* Xn1 = Xn     */
;;;159          /* Yn2 = Yn1    */
;;;160          /* Yn1 = acc   */
;;;161          /* x[n-N], x[n-N-1] are packed together to make state_in of type q31 */
;;;162          /* y[n-N], y[n-N-1] are packed together to make state_out of type q31 */
;;;163    
;;;164    #ifndef  ARM_MATH_BIG_ENDIAN
;;;165    
;;;166          state_in = __PKHBT(in, state_in, 16);
000060  eac04808          PKHBT    r8,r0,r8,LSL #16
;;;167          state_out = __PKHBT(out, state_out, 16);
000064  eac24909          PKHBT    r9,r2,r9,LSL #16
;;;168    
;;;169    #else
;;;170    
;;;171          state_in = __PKHBT(state_in >> 16, (in >> 16), 16);
;;;172          state_out = __PKHBT(state_out >> 16, (out), 16);
;;;173    
;;;174    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;175    
;;;176          /* out =  b0 * x[n] + 0 * 0 */
;;;177          out = __SMUADX(b0, in);
000068  fb2af210          SMUADX   r2,r10,r0
;;;178          /* acc +=  b1 * x[n-1] +  b2 * x[n-2] + out */
;;;179          acc = __SMLALD(b1, state_in, out);
00006c  17d3              ASRS     r3,r2,#31
00006e  fbc623c8          SMLALD   r2,r3,r6,r8
;;;180          /* acc +=  a1 * y[n-1] + a2 * y[n-2] */
;;;181          acc = __SMLALD(a1, state_out, acc);
000072  fbc723c9          SMLALD   r2,r3,r7,r9
;;;182    
;;;183          /* The result is converted from 3.29 to 1.31 if postShift = 1, and then saturation is applied */
;;;184          /* Calc lower part of acc */
;;;185          acc_l = acc & 0xffffffff;
;;;186    
;;;187          /* Calc upper part of acc */
;;;188          acc_h = (acc >> 32) & 0xffffffff;
;;;189    
;;;190          /* Apply shift for lower part of acc and upper part of acc */
;;;191          out = (uint32_t) acc_l >> lShift | acc_h << uShift;
000076  fa22f20c          LSR      r2,r2,r12
00007a  fa03f30b          LSL      r3,r3,r11
00007e  431a              ORRS     r2,r2,r3
;;;192    
;;;193          out = __SSAT(out, 16);
000080  f302020f          SSAT     r2,#16,r2
;;;194    
;;;195          /* Store the output in the destination buffer. */
;;;196    
;;;197    #ifndef  ARM_MATH_BIG_ENDIAN
;;;198    
;;;199          *__SIMD32(pOut)++ = __PKHBT(state_out, out, 16);
000084  eac94302          PKHBT    r3,r9,r2,LSL #16
000088  f8443b04          STR      r3,[r4],#4
;;;200    
;;;201    #else
;;;202    
;;;203          *__SIMD32(pOut)++ = __PKHBT(out, state_out >> 16, 16);
;;;204    
;;;205    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;206    
;;;207          /* Every time after the output is computed state should be updated. */
;;;208          /* The states should be updated as:  */
;;;209          /* Xn2 = Xn1    */
;;;210          /* Xn1 = Xn     */
;;;211          /* Yn2 = Yn1    */
;;;212          /* Yn1 = acc   */
;;;213          /* x[n-N], x[n-N-1] are packed together to make state_in of type q31 */
;;;214          /* y[n-N], y[n-N-1] are packed together to make state_out of type q31 */
;;;215    #ifndef  ARM_MATH_BIG_ENDIAN
;;;216    
;;;217          state_in = __PKHBT(in >> 16, state_in, 16);
00008c  1400              ASRS     r0,r0,#16
00008e  eac04808          PKHBT    r8,r0,r8,LSL #16
;;;218          state_out = __PKHBT(out, state_out, 16);
000092  eac24909          PKHBT    r9,r2,r9,LSL #16
;;;219    
;;;220    #else
;;;221    
;;;222          state_in = __PKHBT(state_in >> 16, in, 16);
;;;223          state_out = __PKHBT(state_out >> 16, out, 16);
;;;224    
;;;225    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;226    
;;;227    
;;;228          /* Decrement the loop counter */
;;;229          sample--;
000096  1e6d              SUBS     r5,r5,#1
                  |L1.152|
000098  2d00              CMP      r5,#0                 ;129
00009a  d1d1              BNE      |L1.64|
;;;230    
;;;231        }
;;;232    
;;;233        /* If the blockSize is not a multiple of 2, compute any remaining output samples here.    
;;;234         ** No loop unrolling is used. */
;;;235    
;;;236        if((blockSize & 0x1u) != 0u)
00009c  9806              LDR      r0,[sp,#0x18]
00009e  07c0              LSLS     r0,r0,#31
0000a0  d014              BEQ      |L1.204|
;;;237        {
;;;238          /* Read the input */
;;;239          in = *pIn++;
0000a2  f9b10000          LDRSH    r0,[r1,#0]
;;;240    
;;;241          /* out =  b0 * x[n] + 0 * 0 */
;;;242    
;;;243    #ifndef  ARM_MATH_BIG_ENDIAN
;;;244    
;;;245          out = __SMUAD(b0, in);
0000a6  fb2af200          SMUAD    r2,r10,r0
;;;246    
;;;247    #else
;;;248    
;;;249          out = __SMUADX(b0, in);
;;;250    
;;;251    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;252    
;;;253          /* acc =  b1 * x[n-1] + b2 * x[n-2] + out */
;;;254          acc = __SMLALD(b1, state_in, out);
0000aa  17d3              ASRS     r3,r2,#31
0000ac  fbc623c8          SMLALD   r2,r3,r6,r8
;;;255          /* acc +=  a1 * y[n-1] + a2 * y[n-2] */
;;;256          acc = __SMLALD(a1, state_out, acc);
0000b0  fbc723c9          SMLALD   r2,r3,r7,r9
;;;257    
;;;258          /* The result is converted from 3.29 to 1.31 if postShift = 1, and then saturation is applied */
;;;259          /* Calc lower part of acc */
;;;260          acc_l = acc & 0xffffffff;
;;;261    
;;;262          /* Calc upper part of acc */
;;;263          acc_h = (acc >> 32) & 0xffffffff;
;;;264    
;;;265          /* Apply shift for lower part of acc and upper part of acc */
;;;266          out = (uint32_t) acc_l >> lShift | acc_h << uShift;
0000b4  fa22f20c          LSR      r2,r2,r12
0000b8  fa03f30b          LSL      r3,r3,r11
0000bc  431a              ORRS     r2,r2,r3
;;;267    
;;;268          out = __SSAT(out, 16);
0000be  f302010f          SSAT     r1,#16,r2
;;;269    
;;;270          /* Store the output in the destination buffer. */
;;;271          *pOut++ = (q15_t) out;
0000c2  8021              STRH     r1,[r4,#0]
;;;272    
;;;273          /* Every time after the output is computed state should be updated. */
;;;274          /* The states should be updated as:  */
;;;275          /* Xn2 = Xn1    */
;;;276          /* Xn1 = Xn     */
;;;277          /* Yn2 = Yn1    */
;;;278          /* Yn1 = acc   */
;;;279          /* x[n-N], x[n-N-1] are packed together to make state_in of type q31 */
;;;280          /* y[n-N], y[n-N-1] are packed together to make state_out of type q31 */
;;;281    
;;;282    #ifndef  ARM_MATH_BIG_ENDIAN
;;;283    
;;;284          state_in = __PKHBT(in, state_in, 16);
0000c4  eac04808          PKHBT    r8,r0,r8,LSL #16
;;;285          state_out = __PKHBT(out, state_out, 16);
0000c8  eac14909          PKHBT    r9,r1,r9,LSL #16
                  |L1.204|
;;;286    
;;;287    #else
;;;288    
;;;289          state_in = __PKHBT(state_in >> 16, in, 16);
;;;290          state_out = __PKHBT(state_out >> 16, out, 16);
;;;291    
;;;292    #endif /*   #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;293    
;;;294        }
;;;295    
;;;296        /*  The first stage goes from the input wire to the output wire.  */
;;;297        /*  Subsequent numStages occur in-place in the output wire  */
;;;298        pIn = pDst;
;;;299    
;;;300        /* Reset the output pointer */
;;;301        pOut = pDst;
0000cc  9905              LDR      r1,[sp,#0x14]
0000ce  460c              MOV      r4,r1
;;;302    
;;;303        /*  Store the updated state variables back into the state array */
;;;304        *__SIMD32(pState)++ = state_in;
0000d0  9801              LDR      r0,[sp,#4]
0000d2  f8c08000          STR      r8,[r0,#0]
0000d6  9a01              LDR      r2,[sp,#4]
0000d8  1d12              ADDS     r2,r2,#4
;;;305        *__SIMD32(pState)++ = state_out;
0000da  f8429b04          STR      r9,[r2],#4
;;;306    
;;;307    
;;;308        /* Decrement the loop counter */
;;;309        stage--;
0000de  9800              LDR      r0,[sp,#0]
0000e0  1e40              SUBS     r0,r0,#1
0000e2  9000              STR      r0,[sp,#0]
;;;310    
;;;311      } while(stage > 0u);
0000e4  9800              LDR      r0,[sp,#0]
0000e6  2800              CMP      r0,#0
0000e8  d19d              BNE      |L1.38|
;;;312    
;;;313    #else
;;;314    
;;;315      /* Run the below code for Cortex-M0 */
;;;316    
;;;317      q15_t *pIn = pSrc;                             /*  Source pointer                               */
;;;318      q15_t *pOut = pDst;                            /*  Destination pointer                          */
;;;319      q15_t b0, b1, b2, a1, a2;                      /*  Filter coefficients           */
;;;320      q15_t Xn1, Xn2, Yn1, Yn2;                      /*  Filter state variables        */
;;;321      q15_t Xn;                                      /*  temporary input               */
;;;322      q63_t acc;                                     /*  Accumulator                                  */
;;;323      int32_t shift = (15 - (int32_t) S->postShift); /*  Post shift                                   */
;;;324      q15_t *pState = S->pState;                     /*  State pointer                                */
;;;325      q15_t *pCoeffs = S->pCoeffs;                   /*  Coefficient pointer                          */
;;;326      uint32_t sample, stage = (uint32_t) S->numStages;     /*  Stage loop counter                           */
;;;327    
;;;328      do
;;;329      {
;;;330        /* Reading the coefficients */
;;;331        b0 = *pCoeffs++;
;;;332        pCoeffs++;  // skip the 0 coefficient
;;;333        b1 = *pCoeffs++;
;;;334        b2 = *pCoeffs++;
;;;335        a1 = *pCoeffs++;
;;;336        a2 = *pCoeffs++;
;;;337    
;;;338        /* Reading the state values */
;;;339        Xn1 = pState[0];
;;;340        Xn2 = pState[1];
;;;341        Yn1 = pState[2];
;;;342        Yn2 = pState[3];
;;;343    
;;;344        /*      The variables acc holds the output value that is computed:         
;;;345         *    acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2]         
;;;346         */
;;;347    
;;;348        sample = blockSize;
;;;349    
;;;350        while(sample > 0u)
;;;351        {
;;;352          /* Read the input */
;;;353          Xn = *pIn++;
;;;354    
;;;355          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;356          /* acc =  b0 * x[n] */
;;;357          acc = (q31_t) b0 *Xn;
;;;358    
;;;359          /* acc +=  b1 * x[n-1] */
;;;360          acc += (q31_t) b1 *Xn1;
;;;361          /* acc +=  b[2] * x[n-2] */
;;;362          acc += (q31_t) b2 *Xn2;
;;;363          /* acc +=  a1 * y[n-1] */
;;;364          acc += (q31_t) a1 *Yn1;
;;;365          /* acc +=  a2 * y[n-2] */
;;;366          acc += (q31_t) a2 *Yn2;
;;;367    
;;;368          /* The result is converted to 1.31  */
;;;369          acc = __SSAT((acc >> shift), 16);
;;;370    
;;;371          /* Every time after the output is computed state should be updated. */
;;;372          /* The states should be updated as:  */
;;;373          /* Xn2 = Xn1    */
;;;374          /* Xn1 = Xn     */
;;;375          /* Yn2 = Yn1    */
;;;376          /* Yn1 = acc    */
;;;377          Xn2 = Xn1;
;;;378          Xn1 = Xn;
;;;379          Yn2 = Yn1;
;;;380          Yn1 = (q15_t) acc;
;;;381    
;;;382          /* Store the output in the destination buffer. */
;;;383          *pOut++ = (q15_t) acc;
;;;384    
;;;385          /* decrement the loop counter */
;;;386          sample--;
;;;387        }
;;;388    
;;;389        /*  The first stage goes from the input buffer to the output buffer. */
;;;390        /*  Subsequent stages occur in-place in the output buffer */
;;;391        pIn = pDst;
;;;392    
;;;393        /* Reset to destination pointer */
;;;394        pOut = pDst;
;;;395    
;;;396        /*  Store the updated state variables back into the pState array */
;;;397        *pState++ = Xn1;
;;;398        *pState++ = Xn2;
;;;399        *pState++ = Yn1;
;;;400        *pState++ = Yn2;
;;;401    
;;;402      } while(--stage);
;;;403    
;;;404    #endif /*     #ifndef ARM_MATH_CM0_FAMILY */
;;;405    
;;;406    }
0000ea  b007              ADD      sp,sp,#0x1c
0000ec  e8bd8ff0          POP      {r4-r11,pc}
;;;407    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_biquad_cascade_df1_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___28_arm_biquad_cascade_df1_q15_c_e5d707c4____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___28_arm_biquad_cascade_df1_q15_c_e5d707c4____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___28_arm_biquad_cascade_df1_q15_c_e5d707c4____REVSH|
#line 144
|__asm___28_arm_biquad_cascade_df1_q15_c_e5d707c4____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___28_arm_biquad_cascade_df1_q15_c_e5d707c4____RRX|
#line 300
|__asm___28_arm_biquad_cascade_df1_q15_c_e5d707c4____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
