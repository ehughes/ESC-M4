; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_mult_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_mult_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_mat_mult_f32.crf ..\..\SRC\CMSIS_DSP_4_5\src\MatrixFunctions\arm_mat_mult_f32.c]
                          THUMB

                          AREA ||i.arm_mat_mult_f32||, CODE, READONLY, ALIGN=2

                  arm_mat_mult_f32 PROC
;;;77     
;;;78     arm_status arm_mat_mult_f32(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;79       const arm_matrix_instance_f32 * pSrcA,
;;;80       const arm_matrix_instance_f32 * pSrcB,
;;;81       arm_matrix_instance_f32 * pDst)
;;;82     {
;;;83       float32_t *pIn1 = pSrcA->pData;                /* input data matrix pointer A */
000004  f8d0c004          LDR      r12,[r0,#4]
;;;84       float32_t *pIn2 = pSrcB->pData;                /* input data matrix pointer B */
;;;85       float32_t *pInA = pSrcA->pData;                /* input data matrix pointer A  */
;;;86       float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
000008  f8d2b004          LDR      r11,[r2,#4]
;;;87       float32_t *px;                                 /* Temporary output data matrix pointer */
;;;88       float32_t sum;                                 /* Accumulator */
;;;89       uint16_t numRowsA = pSrcA->numRows;            /* number of rows of input matrix A */
00000c  f8b08000          LDRH     r8,[r0,#0]
;;;90       uint16_t numColsB = pSrcB->numCols;            /* number of columns of input matrix B */
000010  884a              LDRH     r2,[r1,#2]
;;;91       uint16_t numColsA = pSrcA->numCols;            /* number of columns of input matrix A */
000012  f8b09002          LDRH     r9,[r0,#2]
;;;92     
;;;93     #ifndef ARM_MATH_CM0_FAMILY
;;;94     
;;;95       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;96     
;;;97       float32_t in1, in2, in3, in4;
;;;98       uint16_t col, i = 0u, j, row = numRowsA, colCnt;      /* loop counters */
000016  f04f0a00          MOV      r10,#0
;;;99       arm_status status;                             /* status of matrix multiplication */
;;;100    
;;;101    #ifdef ARM_MATH_MATRIX_CHECK
;;;102    
;;;103    
;;;104      /* Check for matrix mismatch condition */
;;;105      if((pSrcA->numCols != pSrcB->numRows) ||
;;;106         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;107      {
;;;108    
;;;109        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;110        status = ARM_MATH_SIZE_MISMATCH;
;;;111      }
;;;112      else
;;;113    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;114    
;;;115      {
;;;116        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;117        /* row loop */
;;;118        do
;;;119        {
;;;120          /* Output pointer is set to starting address of the row being processed */
;;;121          px = pOut + i;
;;;122    
;;;123          /* For every row wise process, the column loop counter is to be initiated */
;;;124          col = numColsB;
;;;125    
;;;126          /* For every row wise process, the pIn2 pointer is set    
;;;127           ** to the starting address of the pSrcB data */
;;;128          pIn2 = pSrcB->pData;
;;;129    
;;;130          j = 0u;
;;;131    
;;;132          /* column loop */
;;;133          do
;;;134          {
;;;135            /* Set the variable sum, that acts as accumulator, to zero */
;;;136            sum = 0.0f;
00001a  ed9f2a2e          VLDR     s4,|L1.212|
;;;137    
;;;138            /* Initiate the pointer pIn1 to point to the starting address of the column being processed */
;;;139            pIn1 = pInA;
;;;140    
;;;141            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;142            colCnt = numColsA >> 2u;
00001e  ea4f0e99          LSR      lr,r9,#2
                  |L1.34|
000022  eb0b078a          ADD      r7,r11,r10,LSL #2     ;121
000026  4615              MOV      r5,r2                 ;124
000028  6848              LDR      r0,[r1,#4]            ;128
00002a  2600              MOVS     r6,#0                 ;130
                  |L1.44|
00002c  eeb00a42          VMOV.F32 s0,s4                 ;136
000030  4663              MOV      r3,r12                ;139
000032  4674              MOV      r4,lr
;;;143    
;;;144            /* matrix multiplication        */
;;;145            while(colCnt > 0u)
000034  e022              B        |L1.124|
                  |L1.54|
;;;146            {
;;;147              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;148              in3 = *pIn2;
000036  edd01a00          VLDR     s3,[r0,#0]
;;;149              pIn2 += numColsB;
00003a  eb000082          ADD      r0,r0,r2,LSL #2
;;;150              in1 = pIn1[0];
00003e  edd30a00          VLDR     s1,[r3,#0]
;;;151              in2 = pIn1[1];
000042  ed931a01          VLDR     s2,[r3,#4]
;;;152              sum += in1 * in3;
000046  ee000aa1          VMLA.F32 s0,s1,s3
;;;153              in4 = *pIn2;
00004a  edd00a00          VLDR     s1,[r0,#0]
;;;154              pIn2 += numColsB;
00004e  eb000082          ADD      r0,r0,r2,LSL #2
;;;155              sum += in2 * in4;
000052  ee010a20          VMLA.F32 s0,s2,s1
;;;156    
;;;157              in3 = *pIn2;
000056  edd01a00          VLDR     s3,[r0,#0]
;;;158              pIn2 += numColsB;
00005a  eb000082          ADD      r0,r0,r2,LSL #2
;;;159              in1 = pIn1[2];
00005e  ed931a02          VLDR     s2,[r3,#8]
;;;160              in2 = pIn1[3];
000062  edd30a03          VLDR     s1,[r3,#0xc]
;;;161              sum += in1 * in3;
000066  ee010a21          VMLA.F32 s0,s2,s3
;;;162              in4 = *pIn2;
00006a  ed901a00          VLDR     s2,[r0,#0]
;;;163              pIn2 += numColsB;
00006e  eb000082          ADD      r0,r0,r2,LSL #2
;;;164              sum += in2 * in4;
000072  ee000a81          VMLA.F32 s0,s1,s2
;;;165              pIn1 += 4u;
000076  3310              ADDS     r3,r3,#0x10
;;;166    
;;;167              /* Decrement the loop count */
;;;168              colCnt--;
000078  1e64              SUBS     r4,r4,#1
00007a  b2a4              UXTH     r4,r4
                  |L1.124|
00007c  2c00              CMP      r4,#0                 ;145
00007e  d1da              BNE      |L1.54|
;;;169            }
;;;170    
;;;171            /* If the columns of pSrcA is not a multiple of 4, compute any remaining MACs here.    
;;;172             ** No loop unrolling is used. */
;;;173            colCnt = numColsA % 0x4u;
000080  f0090403          AND      r4,r9,#3
;;;174    
;;;175            while(colCnt > 0u)
000084  e009              B        |L1.154|
                  |L1.134|
;;;176            {
;;;177              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;178              sum += *pIn1++ * (*pIn2);
000086  ecf30a01          VLDM     r3!,{s1}
00008a  ed901a00          VLDR     s2,[r0,#0]
00008e  ee000a81          VMLA.F32 s0,s1,s2
;;;179              pIn2 += numColsB;
000092  eb000082          ADD      r0,r0,r2,LSL #2
;;;180    
;;;181              /* Decrement the loop counter */
;;;182              colCnt--;
000096  1e64              SUBS     r4,r4,#1
000098  b2a4              UXTH     r4,r4
                  |L1.154|
00009a  2c00              CMP      r4,#0                 ;175
00009c  d1f3              BNE      |L1.134|
;;;183            }
;;;184    
;;;185            /* Store the result in the destination buffer */
;;;186            *px++ = sum;
00009e  eca70a01          VSTM     r7!,{s0}
;;;187    
;;;188            /* Update the pointer pIn2 to point to the  starting address of the next column */
;;;189            j++;
0000a2  1c76              ADDS     r6,r6,#1
0000a4  b2b6              UXTH     r6,r6
;;;190            pIn2 = pSrcB->pData + j;
0000a6  6848              LDR      r0,[r1,#4]
0000a8  eb000086          ADD      r0,r0,r6,LSL #2
;;;191    
;;;192            /* Decrement the column loop counter */
;;;193            col--;
0000ac  1e6d              SUBS     r5,r5,#1
0000ae  b2ad              UXTH     r5,r5
;;;194    
;;;195          } while(col > 0u);
0000b0  2d00              CMP      r5,#0
0000b2  d1bb              BNE      |L1.44|
;;;196    
;;;197    #else
;;;198    
;;;199      /* Run the below code for Cortex-M0 */
;;;200    
;;;201      float32_t *pInB = pSrcB->pData;                /* input data matrix pointer B */
;;;202      uint16_t col, i = 0u, row = numRowsA, colCnt;  /* loop counters */
;;;203      arm_status status;                             /* status of matrix multiplication */
;;;204    
;;;205    #ifdef ARM_MATH_MATRIX_CHECK
;;;206    
;;;207      /* Check for matrix mismatch condition */
;;;208      if((pSrcA->numCols != pSrcB->numRows) ||
;;;209         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;210      {
;;;211    
;;;212        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;213        status = ARM_MATH_SIZE_MISMATCH;
;;;214      }
;;;215      else
;;;216    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;217    
;;;218      {
;;;219        /* The following loop performs the dot-product of each row in pInA with each column in pInB */
;;;220        /* row loop */
;;;221        do
;;;222        {
;;;223          /* Output pointer is set to starting address of the row being processed */
;;;224          px = pOut + i;
;;;225    
;;;226          /* For every row wise process, the column loop counter is to be initiated */
;;;227          col = numColsB;
;;;228    
;;;229          /* For every row wise process, the pIn2 pointer is set     
;;;230           ** to the starting address of the pSrcB data */
;;;231          pIn2 = pSrcB->pData;
;;;232    
;;;233          /* column loop */
;;;234          do
;;;235          {
;;;236            /* Set the variable sum, that acts as accumulator, to zero */
;;;237            sum = 0.0f;
;;;238    
;;;239            /* Initialize the pointer pIn1 to point to the starting address of the row being processed */
;;;240            pIn1 = pInA;
;;;241    
;;;242            /* Matrix A columns number of MAC operations are to be performed */
;;;243            colCnt = numColsA;
;;;244    
;;;245            while(colCnt > 0u)
;;;246            {
;;;247              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;248              sum += *pIn1++ * (*pIn2);
;;;249              pIn2 += numColsB;
;;;250    
;;;251              /* Decrement the loop counter */
;;;252              colCnt--;
;;;253            }
;;;254    
;;;255            /* Store the result in the destination buffer */
;;;256            *px++ = sum;
;;;257    
;;;258            /* Decrement the column loop counter */
;;;259            col--;
;;;260    
;;;261            /* Update the pointer pIn2 to point to the  starting address of the next column */
;;;262            pIn2 = pInB + (numColsB - col);
;;;263    
;;;264          } while(col > 0u);
;;;265    
;;;266    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;267    
;;;268          /* Update the pointer pInA to point to the  starting address of the next row */
;;;269          i = i + numColsB;
0000b4  eb0a0002          ADD      r0,r10,r2
0000b8  fa1ffa80          UXTH     r10,r0
;;;270          pInA = pInA + numColsA;
0000bc  eb0c0c89          ADD      r12,r12,r9,LSL #2
;;;271    
;;;272          /* Decrement the row loop counter */
;;;273          row--;
0000c0  f1a80801          SUB      r8,r8,#1
0000c4  fa1ff888          UXTH     r8,r8
;;;274    
;;;275        } while(row > 0u);
0000c8  f1b80f00          CMP      r8,#0
0000cc  d1a9              BNE      |L1.34|
;;;276        /* Set status as ARM_MATH_SUCCESS */
;;;277        status = ARM_MATH_SUCCESS;
0000ce  2000              MOVS     r0,#0
;;;278      }
;;;279    
;;;280      /* Return to application */
;;;281      return (status);
;;;282    }
0000d0  e8bd8ff0          POP      {r4-r11,pc}
;;;283    
                          ENDP

                  |L1.212|
0000d4  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\MatrixFunctions\\arm_mat_mult_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_mat_mult_f32_c_d029f10d____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___18_arm_mat_mult_f32_c_d029f10d____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_mat_mult_f32_c_d029f10d____REVSH|
#line 144
|__asm___18_arm_mat_mult_f32_c_d029f10d____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_mat_mult_f32_c_d029f10d____RRX|
#line 300
|__asm___18_arm_mat_mult_f32_c_d029f10d____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
