; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_lms_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_lms_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_lms_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_lms_q15.c]
                          THUMB

                          AREA ||i.arm_lms_q15||, CODE, READONLY, ALIGN=1

                  arm_lms_q15 PROC
;;;73     
;;;74     void arm_lms_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;75       const arm_lms_instance_q15 * S,
;;;76       q15_t * pSrc,
;;;77       q15_t * pRef,
;;;78       q15_t * pOut,
;;;79       q15_t * pErr,
;;;80       uint32_t blockSize)
;;;81     {
000004  b087              SUB      sp,sp,#0x1c
000006  9f15              LDR      r7,[sp,#0x54]
;;;82       q15_t *pState = S->pState;                     /* State pointer */
000008  6841              LDR      r1,[r0,#4]
;;;83       uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
00000a  f8b08000          LDRH     r8,[r0,#0]
;;;84       q15_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
00000e  6884              LDR      r4,[r0,#8]
000010  9403              STR      r4,[sp,#0xc]
;;;85       q15_t *pStateCurnt;                            /* Points to the current sample of the state */
;;;86       q15_t mu = S->mu;                              /* Adaptive factor */
000012  f9b0400c          LDRSH    r4,[r0,#0xc]
000016  9402              STR      r4,[sp,#8]
;;;87       q15_t *px;                                     /* Temporary pointer for state */
;;;88       q15_t *pb;                                     /* Temporary pointer for coefficient buffer */
;;;89       uint32_t tapCnt, blkCnt;                       /* Loop counters */
;;;90       q63_t acc;                                     /* Accumulator */
;;;91       q15_t e = 0;                                   /* error of data sample */
;;;92       q15_t alpha;                                   /* Intermediate constant for taps update */
;;;93       q31_t coef;                                    /* Teporary variable for coefficient */
;;;94       q31_t acc_l, acc_h;
;;;95       int32_t lShift = (15 - (int32_t) S->postShift);       /*  Post shift  */
000018  6904              LDR      r4,[r0,#0x10]
00001a  f1c4040f          RSB      r4,r4,#0xf
00001e  9401              STR      r4,[sp,#4]
;;;96       int32_t uShift = (32 - lShift);
000020  9c01              LDR      r4,[sp,#4]
000022  f1c40420          RSB      r4,r4,#0x20
000026  9400              STR      r4,[sp,#0]
;;;97     
;;;98     
;;;99     #ifndef ARM_MATH_CM0_FAMILY
;;;100    
;;;101      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;102    
;;;103    
;;;104      /* S->pState points to buffer which contains previous frame (numTaps - 1) samples */
;;;105      /* pStateCurnt points to the location where the new input data should be written */
;;;106      pStateCurnt = &(S->pState[(numTaps - 1u)]);
000028  f1a80401          SUB      r4,r8,#1
00002c  eb010c44          ADD      r12,r1,r4,LSL #1
000030  9406              STR      r4,[sp,#0x18]
000032  e096              B        |L1.354|
                  |L1.52|
;;;107    
;;;108      /* Initializing blkCnt with blockSize */
;;;109      blkCnt = blockSize;
;;;110    
;;;111      while(blkCnt > 0u)
;;;112      {
;;;113        /* Copy the new input sample into the state buffer */
;;;114        *pStateCurnt++ = *pSrc++;
000034  9c08              LDR      r4,[sp,#0x20]
000036  8824              LDRH     r4,[r4,#0]
000038  f82c4b02          STRH     r4,[r12],#2
00003c  9c08              LDR      r4,[sp,#0x20]
00003e  1ca4              ADDS     r4,r4,#2
000040  9408              STR      r4,[sp,#0x20]
;;;115    
;;;116        /* Initialize state pointer */
;;;117        px = pState;
000042  4689              MOV      r9,r1
;;;118    
;;;119        /* Initialize coefficient pointer */
;;;120        pb = pCoeffs;
000044  9e03              LDR      r6,[sp,#0xc]
;;;121    
;;;122        /* Set the accumulator to zero */
;;;123        acc = 0;
000046  2400              MOVS     r4,#0
000048  4625              MOV      r5,r4
;;;124    
;;;125        /* Loop unrolling.  Process 4 taps at a time. */
;;;126        tapCnt = numTaps >> 2u;
00004a  ea4f0a98          LSR      r10,r8,#2
00004e  f8cda014          STR      r10,[sp,#0x14]
;;;127    
;;;128        while(tapCnt > 0u)
000052  e00d              B        |L1.112|
                  |L1.84|
;;;129        {
;;;130          /* acc +=  b[N] * x[n-N] + b[N-1] * x[n-N-1] */
;;;131          /* Perform the multiply-accumulate */
;;;132    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;133    
;;;134          acc = __SMLALD(*__SIMD32(px)++, (*__SIMD32(pb)++), acc);
000054  f859eb04          LDR      lr,[r9],#4
000058  f856bb04          LDR      r11,[r6],#4
00005c  fbce45cb          SMLALD   r4,r5,lr,r11
;;;135          acc = __SMLALD(*__SIMD32(px)++, (*__SIMD32(pb)++), acc);
000060  f859eb04          LDR      lr,[r9],#4
000064  f856bb04          LDR      r11,[r6],#4
000068  fbce45cb          SMLALD   r4,r5,lr,r11
;;;136    
;;;137    #else
;;;138    
;;;139          acc += (q63_t) (((q31_t) (*px++) * (*pb++)));
;;;140          acc += (q63_t) (((q31_t) (*px++) * (*pb++)));
;;;141          acc += (q63_t) (((q31_t) (*px++) * (*pb++)));
;;;142          acc += (q63_t) (((q31_t) (*px++) * (*pb++)));
;;;143    
;;;144    
;;;145    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;146    
;;;147          /* Decrement the loop counter */
;;;148          tapCnt--;
00006c  f1aa0a01          SUB      r10,r10,#1
                  |L1.112|
000070  f1ba0f00          CMP      r10,#0                ;128
000074  d1ee              BNE      |L1.84|
;;;149        }
;;;150    
;;;151        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;152        tapCnt = numTaps % 0x4u;
000076  f0080a03          AND      r10,r8,#3
00007a  f8cda010          STR      r10,[sp,#0x10]
;;;153    
;;;154        while(tapCnt > 0u)
00007e  e007              B        |L1.144|
                  |L1.128|
;;;155        {
;;;156          /* Perform the multiply-accumulate */
;;;157          acc += (q63_t) (((q31_t) (*px++) * (*pb++)));
000080  f939eb02          LDRSH    lr,[r9],#2
000084  f936bb02          LDRSH    r11,[r6],#2
000088  fbce458b          SMLALBB  r4,r5,lr,r11
;;;158    
;;;159          /* Decrement the loop counter */
;;;160          tapCnt--;
00008c  f1aa0a01          SUB      r10,r10,#1
                  |L1.144|
000090  f1ba0f00          CMP      r10,#0                ;154
000094  d1f4              BNE      |L1.128|
;;;161        }
;;;162    
;;;163        /* Calc lower part of acc */
;;;164        acc_l = acc & 0xffffffff;
;;;165    
;;;166        /* Calc upper part of acc */
;;;167        acc_h = (acc >> 32) & 0xffffffff;
;;;168    
;;;169        /* Apply shift for lower part of acc and upper part of acc */
;;;170        acc = (uint32_t) acc_l >> lShift | acc_h << uShift;
000096  9e01              LDR      r6,[sp,#4]
000098  40f4              LSRS     r4,r4,r6
00009a  9e00              LDR      r6,[sp,#0]
00009c  40b5              LSLS     r5,r5,r6
00009e  432c              ORRS     r4,r4,r5
;;;171    
;;;172        /* Converting the result to 1.15 format and saturate the output */
;;;173        acc = __SSAT(acc, 16);
0000a0  f304040f          SSAT     r4,#16,r4
;;;174    
;;;175        /* Store the result from accumulator into the destination buffer. */
;;;176        *pOut++ = (q15_t) acc;
0000a4  f8234b02          STRH     r4,[r3],#2
;;;177    
;;;178        /* Compute and store error */
;;;179        e = *pRef++ - (q15_t) acc;
0000a8  f8325b02          LDRH     r5,[r2],#2
0000ac  1b2c              SUBS     r4,r5,r4
0000ae  b224              SXTH     r4,r4
;;;180    
;;;181        *pErr++ = (q15_t) e;
0000b0  9d14              LDR      r5,[sp,#0x50]
0000b2  802c              STRH     r4,[r5,#0]
0000b4  9d14              LDR      r5,[sp,#0x50]
0000b6  1cad              ADDS     r5,r5,#2
0000b8  9514              STR      r5,[sp,#0x50]
;;;182    
;;;183        /* Compute alpha i.e. intermediate constant for taps update */
;;;184        alpha = (q15_t) (((q31_t) e * (mu)) >> 15);
0000ba  9d02              LDR      r5,[sp,#8]
0000bc  436c              MULS     r4,r5,r4
0000be  f34436cf          SBFX     r6,r4,#15,#16
;;;185    
;;;186        /* Initialize state pointer */
;;;187        /* Advance state pointer by 1 for the next sample */
;;;188        px = pState++;
0000c2  460d              MOV      r5,r1
0000c4  1c89              ADDS     r1,r1,#2
;;;189    
;;;190        /* Initialize coefficient pointer */
;;;191        pb = pCoeffs;
0000c6  9c03              LDR      r4,[sp,#0xc]
;;;192    
;;;193        /* Loop unrolling.  Process 4 taps at a time. */
;;;194        tapCnt = numTaps >> 2u;
0000c8  f8dd9014          LDR      r9,[sp,#0x14]
;;;195    
;;;196        /* Update filter coefficients */
;;;197        while(tapCnt > 0u)
0000cc  e031              B        |L1.306|
                  |L1.206|
;;;198        {
;;;199          coef = (q31_t) * pb + (((q31_t) alpha * (*px++)) >> 15);
0000ce  f935ab02          LDRSH    r10,[r5],#2
0000d2  f9b4b000          LDRSH    r11,[r4,#0]
0000d6  fb0afa06          MUL      r10,r10,r6
0000da  eb0b3aea          ADD      r10,r11,r10,ASR #15
;;;200          *pb++ = (q15_t) __SSAT((coef), 16);
0000de  f30a0a0f          SSAT     r10,#16,r10
0000e2  f8a4a000          STRH     r10,[r4,#0]
;;;201          coef = (q31_t) * pb + (((q31_t) alpha * (*px++)) >> 15);
0000e6  f935ab02          LDRSH    r10,[r5],#2
0000ea  f9b4b002          LDRSH    r11,[r4,#2]
0000ee  fb0afa06          MUL      r10,r10,r6
0000f2  eb0b3aea          ADD      r10,r11,r10,ASR #15
;;;202          *pb++ = (q15_t) __SSAT((coef), 16);
0000f6  f30a0a0f          SSAT     r10,#16,r10
0000fa  f8a4a002          STRH     r10,[r4,#2]
;;;203          coef = (q31_t) * pb + (((q31_t) alpha * (*px++)) >> 15);
0000fe  f935ab02          LDRSH    r10,[r5],#2
000102  f9b4b004          LDRSH    r11,[r4,#4]
000106  fb0afa06          MUL      r10,r10,r6
00010a  eb0b3aea          ADD      r10,r11,r10,ASR #15
;;;204          *pb++ = (q15_t) __SSAT((coef), 16);
00010e  f30a0a0f          SSAT     r10,#16,r10
000112  f8a4a004          STRH     r10,[r4,#4]
;;;205          coef = (q31_t) * pb + (((q31_t) alpha * (*px++)) >> 15);
000116  f935ab02          LDRSH    r10,[r5],#2
00011a  f934bf06          LDRSH    r11,[r4,#6]!
00011e  fb0afa06          MUL      r10,r10,r6
000122  eb0b3aea          ADD      r10,r11,r10,ASR #15
;;;206          *pb++ = (q15_t) __SSAT((coef), 16);
000126  f30a0a0f          SSAT     r10,#16,r10
00012a  f824ab02          STRH     r10,[r4],#2
;;;207    
;;;208          /* Decrement the loop counter */
;;;209          tapCnt--;
00012e  f1a90901          SUB      r9,r9,#1
                  |L1.306|
000132  f1b90f00          CMP      r9,#0                 ;197
000136  d1ca              BNE      |L1.206|
;;;210        }
;;;211    
;;;212        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;213        tapCnt = numTaps % 0x4u;
000138  f8dd9010          LDR      r9,[sp,#0x10]
;;;214    
;;;215        while(tapCnt > 0u)
00013c  e00d              B        |L1.346|
                  |L1.318|
;;;216        {
;;;217          /* Perform the multiply-accumulate */
;;;218          coef = (q31_t) * pb + (((q31_t) alpha * (*px++)) >> 15);
00013e  f935ab02          LDRSH    r10,[r5],#2
000142  f9b4b000          LDRSH    r11,[r4,#0]
000146  fb0afa06          MUL      r10,r10,r6
00014a  eb0b3aea          ADD      r10,r11,r10,ASR #15
;;;219          *pb++ = (q15_t) __SSAT((coef), 16);
00014e  f30a0a0f          SSAT     r10,#16,r10
000152  f824ab02          STRH     r10,[r4],#2
;;;220    
;;;221          /* Decrement the loop counter */
;;;222          tapCnt--;
000156  f1a90901          SUB      r9,r9,#1
                  |L1.346|
00015a  f1b90f00          CMP      r9,#0                 ;215
00015e  d1ee              BNE      |L1.318|
;;;223        }
;;;224    
;;;225        /* Decrement the loop counter */
;;;226        blkCnt--;
000160  1e7f              SUBS     r7,r7,#1
                  |L1.354|
000162  2f00              CMP      r7,#0                 ;111
000164  f47faf66          BNE      |L1.52|
;;;227    
;;;228      }
;;;229    
;;;230      /* Processing is complete. Now copy the last numTaps - 1 samples to the    
;;;231         satrt of the state buffer. This prepares the state buffer for the    
;;;232         next function call. */
;;;233    
;;;234      /* Points to the start of the pState buffer */
;;;235      pStateCurnt = S->pState;
000168  6840              LDR      r0,[r0,#4]
;;;236    
;;;237      /* Calculation of count for copying integer writes */
;;;238      tapCnt = (numTaps - 1u) >> 2;
00016a  9a06              LDR      r2,[sp,#0x18]
00016c  0892              LSRS     r2,r2,#2
;;;239    
;;;240      while(tapCnt > 0u)
00016e  e006              B        |L1.382|
                  |L1.368|
;;;241      {
;;;242    
;;;243    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;244    
;;;245        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
000170  680b              LDR      r3,[r1,#0]
000172  6003              STR      r3,[r0,#0]
;;;246        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
000174  684b              LDR      r3,[r1,#4]
000176  3108              ADDS     r1,r1,#8
000178  6043              STR      r3,[r0,#4]
00017a  3008              ADDS     r0,r0,#8
;;;247    #else
;;;248        *pStateCurnt++ = *pState++;
;;;249        *pStateCurnt++ = *pState++;
;;;250        *pStateCurnt++ = *pState++;
;;;251        *pStateCurnt++ = *pState++;
;;;252    #endif
;;;253    
;;;254        tapCnt--;
00017c  1e52              SUBS     r2,r2,#1
                  |L1.382|
00017e  2a00              CMP      r2,#0                 ;240
000180  d1f6              BNE      |L1.368|
;;;255    
;;;256      }
;;;257    
;;;258      /* Calculation of count for remaining q15_t data */
;;;259      tapCnt = (numTaps - 1u) % 0x4u;
000182  9a06              LDR      r2,[sp,#0x18]
000184  f0020203          AND      r2,r2,#3
;;;260    
;;;261      /* copy data */
;;;262      while(tapCnt > 0u)
000188  e004              B        |L1.404|
                  |L1.394|
;;;263      {
;;;264        *pStateCurnt++ = *pState++;
00018a  f8313b02          LDRH     r3,[r1],#2
00018e  f8203b02          STRH     r3,[r0],#2
;;;265    
;;;266        /* Decrement the loop counter */
;;;267        tapCnt--;
000192  1e52              SUBS     r2,r2,#1
                  |L1.404|
000194  2a00              CMP      r2,#0                 ;262
000196  d1f8              BNE      |L1.394|
;;;268      }
;;;269    
;;;270    #else
;;;271    
;;;272      /* Run the below code for Cortex-M0 */
;;;273    
;;;274      /* S->pState points to buffer which contains previous frame (numTaps - 1) samples */
;;;275      /* pStateCurnt points to the location where the new input data should be written */
;;;276      pStateCurnt = &(S->pState[(numTaps - 1u)]);
;;;277    
;;;278      /* Loop over blockSize number of values */
;;;279      blkCnt = blockSize;
;;;280    
;;;281      while(blkCnt > 0u)
;;;282      {
;;;283        /* Copy the new input sample into the state buffer */
;;;284        *pStateCurnt++ = *pSrc++;
;;;285    
;;;286        /* Initialize pState pointer */
;;;287        px = pState;
;;;288    
;;;289        /* Initialize pCoeffs pointer */
;;;290        pb = pCoeffs;
;;;291    
;;;292        /* Set the accumulator to zero */
;;;293        acc = 0;
;;;294    
;;;295        /* Loop over numTaps number of values */
;;;296        tapCnt = numTaps;
;;;297    
;;;298        while(tapCnt > 0u)
;;;299        {
;;;300          /* Perform the multiply-accumulate */
;;;301          acc += (q63_t) ((q31_t) (*px++) * (*pb++));
;;;302    
;;;303          /* Decrement the loop counter */
;;;304          tapCnt--;
;;;305        }
;;;306    
;;;307        /* Calc lower part of acc */
;;;308        acc_l = acc & 0xffffffff;
;;;309    
;;;310        /* Calc upper part of acc */
;;;311        acc_h = (acc >> 32) & 0xffffffff;
;;;312    
;;;313        /* Apply shift for lower part of acc and upper part of acc */
;;;314        acc = (uint32_t) acc_l >> lShift | acc_h << uShift;
;;;315    
;;;316        /* Converting the result to 1.15 format and saturate the output */
;;;317        acc = __SSAT(acc, 16);
;;;318    
;;;319        /* Store the result from accumulator into the destination buffer. */
;;;320        *pOut++ = (q15_t) acc;
;;;321    
;;;322        /* Compute and store error */
;;;323        e = *pRef++ - (q15_t) acc;
;;;324    
;;;325        *pErr++ = (q15_t) e;
;;;326    
;;;327        /* Compute alpha i.e. intermediate constant for taps update */
;;;328        alpha = (q15_t) (((q31_t) e * (mu)) >> 15);
;;;329    
;;;330        /* Initialize pState pointer */
;;;331        /* Advance state pointer by 1 for the next sample */
;;;332        px = pState++;
;;;333    
;;;334        /* Initialize pCoeffs pointer */
;;;335        pb = pCoeffs;
;;;336    
;;;337        /* Loop over numTaps number of values */
;;;338        tapCnt = numTaps;
;;;339    
;;;340        while(tapCnt > 0u)
;;;341        {
;;;342          /* Perform the multiply-accumulate */
;;;343          coef = (q31_t) * pb + (((q31_t) alpha * (*px++)) >> 15);
;;;344          *pb++ = (q15_t) __SSAT((coef), 16);
;;;345    
;;;346          /* Decrement the loop counter */
;;;347          tapCnt--;
;;;348        }
;;;349    
;;;350        /* Decrement the loop counter */
;;;351        blkCnt--;
;;;352    
;;;353      }
;;;354    
;;;355      /* Processing is complete. Now copy the last numTaps - 1 samples to the        
;;;356         start of the state buffer. This prepares the state buffer for the   
;;;357         next function call. */
;;;358    
;;;359      /* Points to the start of the pState buffer */
;;;360      pStateCurnt = S->pState;
;;;361    
;;;362      /*  Copy (numTaps - 1u) samples  */
;;;363      tapCnt = (numTaps - 1u);
;;;364    
;;;365      /* Copy the data */
;;;366      while(tapCnt > 0u)
;;;367      {
;;;368        *pStateCurnt++ = *pState++;
;;;369    
;;;370        /* Decrement the loop counter */
;;;371        tapCnt--;
;;;372      }
;;;373    
;;;374    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;375    
;;;376    }
000198  b00b              ADD      sp,sp,#0x2c
00019a  e8bd8ff0          POP      {r4-r11,pc}
;;;377    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_lms_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_lms_q15_c_39f65420____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___13_arm_lms_q15_c_39f65420____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_lms_q15_c_39f65420____REVSH|
#line 144
|__asm___13_arm_lms_q15_c_39f65420____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_lms_q15_c_39f65420____RRX|
#line 300
|__asm___13_arm_lms_q15_c_39f65420____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
