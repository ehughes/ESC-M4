; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_partial_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_partial_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE\_CMSIS_DSP_4_5_O3 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_conv_partial_f32.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_partial_f32.c]
                          THUMB

                          AREA ||i.arm_conv_partial_f32||, CODE, READONLY, ALIGN=2

                  arm_conv_partial_f32 PROC
;;;94     
;;;95     arm_status arm_conv_partial_f32(
000000  e92d4ffc          PUSH     {r2-r11,lr}
;;;96       float32_t * pSrcA,
;;;97       uint32_t srcALen,
;;;98       float32_t * pSrcB,
;;;99       uint32_t srcBLen,
;;;100      float32_t * pDst,
;;;101      uint32_t firstIndex,
;;;102      uint32_t numPoints)
;;;103    {
;;;104    
;;;105    
;;;106    #ifndef ARM_MATH_CM0_FAMILY
;;;107    
;;;108      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;109    
;;;110      float32_t *pIn1 = pSrcA;                       /* inputA pointer */
;;;111      float32_t *pIn2 = pSrcB;                       /* inputB pointer */
;;;112      float32_t *pOut = pDst;                        /* output pointer */
;;;113      float32_t *px;                                 /* Intermediate inputA pointer */
;;;114      float32_t *py;                                 /* Intermediate inputB pointer */
;;;115      float32_t *pSrc1, *pSrc2;                      /* Intermediate pointers */
;;;116      float32_t sum, acc0, acc1, acc2, acc3;         /* Accumulator */
;;;117      float32_t x0, x1, x2, x3, c0;                  /* Temporary variables to hold state and coefficient values */
;;;118      uint32_t j, k, count = 0u, blkCnt, check;
;;;119      int32_t blockSize1, blockSize2, blockSize3;    /* loop counters */
;;;120      arm_status status;                             /* status of Partial convolution */
;;;121    
;;;122    
;;;123      /* Check for range of output samples to be calculated */
;;;124      if((firstIndex + numPoints) > ((srcALen + (srcBLen - 1u))))
000004  eb010c03          ADD      r12,r1,r3
000008  e9dd560c          LDRD     r5,r6,[sp,#0x30]      ;103
00000c  19af              ADDS     r7,r5,r6
00000e  f1ac0c01          SUB      r12,r12,#1
000012  f8dd802c          LDR      r8,[sp,#0x2c]
000016  4604              MOV      r4,r0                 ;110
000018  4692              MOV      r10,r2                ;111
00001a  4567              CMP      r7,r12
00001c  d903              BLS      |L1.38|
;;;125      {
;;;126        /* Set status as ARM_MATH_ARGUMENT_ERROR */
;;;127        status = ARM_MATH_ARGUMENT_ERROR;
00001e  f04f30ff          MOV      r0,#0xffffffff
                  |L1.34|
;;;128      }
;;;129      else
;;;130      {
;;;131    
;;;132        /* The algorithm implementation is based on the lengths of the inputs. */
;;;133        /* srcB is always made to slide across srcA. */
;;;134        /* So srcBLen is always considered as shorter or equal to srcALen */
;;;135        if(srcALen >= srcBLen)
;;;136        {
;;;137          /* Initialization of inputA pointer */
;;;138          pIn1 = pSrcA;
;;;139    
;;;140          /* Initialization of inputB pointer */
;;;141          pIn2 = pSrcB;
;;;142        }
;;;143        else
;;;144        {
;;;145          /* Initialization of inputA pointer */
;;;146          pIn1 = pSrcB;
;;;147    
;;;148          /* Initialization of inputB pointer */
;;;149          pIn2 = pSrcA;
;;;150    
;;;151          /* srcBLen is always considered as shorter or equal to srcALen */
;;;152          j = srcBLen;
;;;153          srcBLen = srcALen;
;;;154          srcALen = j;
;;;155        }
;;;156    
;;;157        /* Conditions to check which loopCounter holds    
;;;158         * the first and last indices of the output samples to be calculated. */
;;;159        check = firstIndex + numPoints;
;;;160        blockSize3 = ((int32_t)check > (int32_t)srcALen) ? (int32_t)check - (int32_t)srcALen : 0;
;;;161        blockSize3 = ((int32_t)firstIndex > (int32_t)srcALen - 1) ? blockSize3 - (int32_t)firstIndex + (int32_t)srcALen : blockSize3;
;;;162        blockSize1 = ((int32_t) srcBLen - 1) - (int32_t) firstIndex;
;;;163        blockSize1 = (blockSize1 > 0) ? ((check > (srcBLen - 1u)) ? blockSize1 :
;;;164                                         (int32_t) numPoints) : 0;
;;;165        blockSize2 = ((int32_t) check - blockSize3) -
;;;166          (blockSize1 + (int32_t) firstIndex);
;;;167        blockSize2 = (blockSize2 > 0) ? blockSize2 : 0;
;;;168    
;;;169        /* conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1] */
;;;170        /* The function is internally    
;;;171         * divided into three stages according to the number of multiplications that has to be    
;;;172         * taken place between inputA samples and inputB samples. In the first stage of the    
;;;173         * algorithm, the multiplications increase by one for every iteration.    
;;;174         * In the second stage of the algorithm, srcBLen number of multiplications are done.    
;;;175         * In the third stage of the algorithm, the multiplications decrease by one    
;;;176         * for every iteration. */
;;;177    
;;;178        /* Set the output pointer to point to the firstIndex    
;;;179         * of the output sample to be calculated. */
;;;180        pOut = pDst + firstIndex;
;;;181    
;;;182        /* --------------------------    
;;;183         * Initializations of stage1    
;;;184         * -------------------------*/
;;;185    
;;;186        /* sum = x[0] * y[0]    
;;;187         * sum = x[0] * y[1] + x[1] * y[0]    
;;;188         * ....    
;;;189         * sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]    
;;;190         */
;;;191    
;;;192        /* In this stage the MAC operations are increased by 1 for every iteration.    
;;;193           The count variable holds the number of MAC operations performed.    
;;;194           Since the partial convolution starts from from firstIndex    
;;;195           Number of Macs to be performed is firstIndex + 1 */
;;;196        count = 1u + firstIndex;
;;;197    
;;;198        /* Working pointer of inputA */
;;;199        px = pIn1;
;;;200    
;;;201        /* Working pointer of inputB */
;;;202        pSrc1 = pIn2 + firstIndex;
;;;203        py = pSrc1;
;;;204    
;;;205        /* ------------------------    
;;;206         * Stage1 process    
;;;207         * ----------------------*/
;;;208    
;;;209        /* The first stage starts here */
;;;210        while(blockSize1 > 0)
;;;211        {
;;;212          /* Accumulator is made zero for every iteration */
;;;213          sum = 0.0f;
;;;214    
;;;215          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;216          k = count >> 2u;
;;;217    
;;;218          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;219           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;220          while(k > 0u)
;;;221          {
;;;222            /* x[0] * y[srcBLen - 1] */
;;;223            sum += *px++ * *py--;
;;;224    
;;;225            /* x[1] * y[srcBLen - 2] */
;;;226            sum += *px++ * *py--;
;;;227    
;;;228            /* x[2] * y[srcBLen - 3] */
;;;229            sum += *px++ * *py--;
;;;230    
;;;231            /* x[3] * y[srcBLen - 4] */
;;;232            sum += *px++ * *py--;
;;;233    
;;;234            /* Decrement the loop counter */
;;;235            k--;
;;;236          }
;;;237    
;;;238          /* If the count is not a multiple of 4, compute any remaining MACs here.    
;;;239           ** No loop unrolling is used. */
;;;240          k = count % 0x4u;
;;;241    
;;;242          while(k > 0u)
;;;243          {
;;;244            /* Perform the multiply-accumulates */
;;;245            sum += *px++ * *py--;
;;;246    
;;;247            /* Decrement the loop counter */
;;;248            k--;
;;;249          }
;;;250    
;;;251          /* Store the result in the accumulator in the destination buffer. */
;;;252          *pOut++ = sum;
;;;253    
;;;254          /* Update the inputA and inputB pointers for next MAC calculation */
;;;255          py = ++pSrc1;
;;;256          px = pIn1;
;;;257    
;;;258          /* Increment the MAC count */
;;;259          count++;
;;;260    
;;;261          /* Decrement the loop counter */
;;;262          blockSize1--;
;;;263        }
;;;264    
;;;265        /* --------------------------    
;;;266         * Initializations of stage2    
;;;267         * ------------------------*/
;;;268    
;;;269        /* sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0]    
;;;270         * sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0]    
;;;271         * ....    
;;;272         * sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]    
;;;273         */
;;;274    
;;;275        /* Working pointer of inputA */
;;;276        if((int32_t)firstIndex - (int32_t)srcBLen + 1 > 0)
;;;277        {
;;;278          px = pIn1 + firstIndex - srcBLen + 1;
;;;279        }
;;;280        else
;;;281        {
;;;282          px = pIn1;
;;;283        }
;;;284    
;;;285        /* Working pointer of inputB */
;;;286        pSrc2 = pIn2 + (srcBLen - 1u);
;;;287        py = pSrc2;
;;;288    
;;;289        /* count is index by which the pointer pIn1 to be incremented */
;;;290        count = 0u;
;;;291    
;;;292        /* -------------------    
;;;293         * Stage2 process    
;;;294         * ------------------*/
;;;295    
;;;296        /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.    
;;;297         * So, to loop unroll over blockSize2,    
;;;298         * srcBLen should be greater than or equal to 4 */
;;;299        if(srcBLen >= 4u)
;;;300        {
;;;301          /* Loop unroll over blockSize2, by 4 */
;;;302          blkCnt = ((uint32_t) blockSize2 >> 2u);
;;;303    
;;;304          while(blkCnt > 0u)
;;;305          {
;;;306            /* Set all accumulators to zero */
;;;307            acc0 = 0.0f;
;;;308            acc1 = 0.0f;
;;;309            acc2 = 0.0f;
;;;310            acc3 = 0.0f;
;;;311    
;;;312            /* read x[0], x[1], x[2] samples */
;;;313            x0 = *(px++);
;;;314            x1 = *(px++);
;;;315            x2 = *(px++);
;;;316    
;;;317            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;318            k = srcBLen >> 2u;
;;;319    
;;;320            /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;321             ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;322            do
;;;323            {
;;;324              /* Read y[srcBLen - 1] sample */
;;;325              c0 = *(py--);
;;;326    
;;;327              /* Read x[3] sample */
;;;328              x3 = *(px++);
;;;329    
;;;330              /* Perform the multiply-accumulate */
;;;331              /* acc0 +=  x[0] * y[srcBLen - 1] */
;;;332              acc0 += x0 * c0;
;;;333    
;;;334              /* acc1 +=  x[1] * y[srcBLen - 1] */
;;;335              acc1 += x1 * c0;
;;;336    
;;;337              /* acc2 +=  x[2] * y[srcBLen - 1] */
;;;338              acc2 += x2 * c0;
;;;339    
;;;340              /* acc3 +=  x[3] * y[srcBLen - 1] */
;;;341              acc3 += x3 * c0;
;;;342    
;;;343              /* Read y[srcBLen - 2] sample */
;;;344              c0 = *(py--);
;;;345    
;;;346              /* Read x[4] sample */
;;;347              x0 = *(px++);
;;;348    
;;;349              /* Perform the multiply-accumulate */
;;;350              /* acc0 +=  x[1] * y[srcBLen - 2] */
;;;351              acc0 += x1 * c0;
;;;352              /* acc1 +=  x[2] * y[srcBLen - 2] */
;;;353              acc1 += x2 * c0;
;;;354              /* acc2 +=  x[3] * y[srcBLen - 2] */
;;;355              acc2 += x3 * c0;
;;;356              /* acc3 +=  x[4] * y[srcBLen - 2] */
;;;357              acc3 += x0 * c0;
;;;358    
;;;359              /* Read y[srcBLen - 3] sample */
;;;360              c0 = *(py--);
;;;361    
;;;362              /* Read x[5] sample */
;;;363              x1 = *(px++);
;;;364    
;;;365              /* Perform the multiply-accumulates */
;;;366              /* acc0 +=  x[2] * y[srcBLen - 3] */
;;;367              acc0 += x2 * c0;
;;;368              /* acc1 +=  x[3] * y[srcBLen - 2] */
;;;369              acc1 += x3 * c0;
;;;370              /* acc2 +=  x[4] * y[srcBLen - 2] */
;;;371              acc2 += x0 * c0;
;;;372              /* acc3 +=  x[5] * y[srcBLen - 2] */
;;;373              acc3 += x1 * c0;
;;;374    
;;;375              /* Read y[srcBLen - 4] sample */
;;;376              c0 = *(py--);
;;;377    
;;;378              /* Read x[6] sample */
;;;379              x2 = *(px++);
;;;380    
;;;381              /* Perform the multiply-accumulates */
;;;382              /* acc0 +=  x[3] * y[srcBLen - 4] */
;;;383              acc0 += x3 * c0;
;;;384              /* acc1 +=  x[4] * y[srcBLen - 4] */
;;;385              acc1 += x0 * c0;
;;;386              /* acc2 +=  x[5] * y[srcBLen - 4] */
;;;387              acc2 += x1 * c0;
;;;388              /* acc3 +=  x[6] * y[srcBLen - 4] */
;;;389              acc3 += x2 * c0;
;;;390    
;;;391    
;;;392            } while(--k);
;;;393    
;;;394            /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.    
;;;395             ** No loop unrolling is used. */
;;;396            k = srcBLen % 0x4u;
;;;397    
;;;398            while(k > 0u)
;;;399            {
;;;400              /* Read y[srcBLen - 5] sample */
;;;401              c0 = *(py--);
;;;402    
;;;403              /* Read x[7] sample */
;;;404              x3 = *(px++);
;;;405    
;;;406              /* Perform the multiply-accumulates */
;;;407              /* acc0 +=  x[4] * y[srcBLen - 5] */
;;;408              acc0 += x0 * c0;
;;;409              /* acc1 +=  x[5] * y[srcBLen - 5] */
;;;410              acc1 += x1 * c0;
;;;411              /* acc2 +=  x[6] * y[srcBLen - 5] */
;;;412              acc2 += x2 * c0;
;;;413              /* acc3 +=  x[7] * y[srcBLen - 5] */
;;;414              acc3 += x3 * c0;
;;;415    
;;;416              /* Reuse the present samples for the next MAC */
;;;417              x0 = x1;
;;;418              x1 = x2;
;;;419              x2 = x3;
;;;420    
;;;421              /* Decrement the loop counter */
;;;422              k--;
;;;423            }
;;;424    
;;;425            /* Store the result in the accumulator in the destination buffer. */
;;;426            *pOut++ = acc0;
;;;427            *pOut++ = acc1;
;;;428            *pOut++ = acc2;
;;;429            *pOut++ = acc3;
;;;430    
;;;431            /* Increment the pointer pIn1 index, count by 1 */
;;;432            count += 4u;
;;;433    
;;;434            /* Update the inputA and inputB pointers for next MAC calculation */
;;;435            px = pIn1 + count;
;;;436            py = pSrc2;
;;;437    
;;;438            /* Decrement the loop counter */
;;;439            blkCnt--;
;;;440          }
;;;441    
;;;442          /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.    
;;;443           ** No loop unrolling is used. */
;;;444          blkCnt = (uint32_t) blockSize2 % 0x4u;
;;;445    
;;;446          while(blkCnt > 0u)
;;;447          {
;;;448            /* Accumulator is made zero for every iteration */
;;;449            sum = 0.0f;
;;;450    
;;;451            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;452            k = srcBLen >> 2u;
;;;453    
;;;454            /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;455             ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;456            while(k > 0u)
;;;457            {
;;;458              /* Perform the multiply-accumulates */
;;;459              sum += *px++ * *py--;
;;;460              sum += *px++ * *py--;
;;;461              sum += *px++ * *py--;
;;;462              sum += *px++ * *py--;
;;;463    
;;;464              /* Decrement the loop counter */
;;;465              k--;
;;;466            }
;;;467    
;;;468            /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.    
;;;469             ** No loop unrolling is used. */
;;;470            k = srcBLen % 0x4u;
;;;471    
;;;472            while(k > 0u)
;;;473            {
;;;474              /* Perform the multiply-accumulate */
;;;475              sum += *px++ * *py--;
;;;476    
;;;477              /* Decrement the loop counter */
;;;478              k--;
;;;479            }
;;;480    
;;;481            /* Store the result in the accumulator in the destination buffer. */
;;;482            *pOut++ = sum;
;;;483    
;;;484            /* Increment the MAC count */
;;;485            count++;
;;;486    
;;;487            /* Update the inputA and inputB pointers for next MAC calculation */
;;;488            px = pIn1 + count;
;;;489            py = pSrc2;
;;;490    
;;;491            /* Decrement the loop counter */
;;;492            blkCnt--;
;;;493          }
;;;494        }
;;;495        else
;;;496        {
;;;497          /* If the srcBLen is not a multiple of 4,    
;;;498           * the blockSize2 loop cannot be unrolled by 4 */
;;;499          blkCnt = (uint32_t) blockSize2;
;;;500    
;;;501          while(blkCnt > 0u)
;;;502          {
;;;503            /* Accumulator is made zero for every iteration */
;;;504            sum = 0.0f;
;;;505    
;;;506            /* srcBLen number of MACS should be performed */
;;;507            k = srcBLen;
;;;508    
;;;509            while(k > 0u)
;;;510            {
;;;511              /* Perform the multiply-accumulate */
;;;512              sum += *px++ * *py--;
;;;513    
;;;514              /* Decrement the loop counter */
;;;515              k--;
;;;516            }
;;;517    
;;;518            /* Store the result in the accumulator in the destination buffer. */
;;;519            *pOut++ = sum;
;;;520    
;;;521            /* Increment the MAC count */
;;;522            count++;
;;;523    
;;;524            /* Update the inputA and inputB pointers for next MAC calculation */
;;;525            px = pIn1 + count;
;;;526            py = pSrc2;
;;;527    
;;;528            /* Decrement the loop counter */
;;;529            blkCnt--;
;;;530          }
;;;531        }
;;;532    
;;;533    
;;;534        /* --------------------------    
;;;535         * Initializations of stage3    
;;;536         * -------------------------*/
;;;537    
;;;538        /* sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1]    
;;;539         * sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2]    
;;;540         * ....    
;;;541         * sum +=  x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2]    
;;;542         * sum +=  x[srcALen-1] * y[srcBLen-1]    
;;;543         */
;;;544    
;;;545        /* In this stage the MAC operations are decreased by 1 for every iteration.    
;;;546           The count variable holds the number of MAC operations performed */
;;;547        count = srcBLen - 1u;
;;;548    
;;;549        /* Working pointer of inputA */
;;;550        pSrc1 = (pIn1 + srcALen) - (srcBLen - 1u);
;;;551        px = pSrc1;
;;;552    
;;;553        /* Working pointer of inputB */
;;;554        pSrc2 = pIn2 + (srcBLen - 1u);
;;;555        py = pSrc2;
;;;556    
;;;557        while(blockSize3 > 0)
;;;558        {
;;;559          /* Accumulator is made zero for every iteration */
;;;560          sum = 0.0f;
;;;561    
;;;562          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;563          k = count >> 2u;
;;;564    
;;;565          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;566           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;567          while(k > 0u)
;;;568          {
;;;569            /* sum += x[srcALen - srcBLen + 1] * y[srcBLen - 1] */
;;;570            sum += *px++ * *py--;
;;;571    
;;;572            /* sum += x[srcALen - srcBLen + 2] * y[srcBLen - 2] */
;;;573            sum += *px++ * *py--;
;;;574    
;;;575            /* sum += x[srcALen - srcBLen + 3] * y[srcBLen - 3] */
;;;576            sum += *px++ * *py--;
;;;577    
;;;578            /* sum += x[srcALen - srcBLen + 4] * y[srcBLen - 4] */
;;;579            sum += *px++ * *py--;
;;;580    
;;;581            /* Decrement the loop counter */
;;;582            k--;
;;;583          }
;;;584    
;;;585          /* If the count is not a multiple of 4, compute any remaining MACs here.    
;;;586           ** No loop unrolling is used. */
;;;587          k = count % 0x4u;
;;;588    
;;;589          while(k > 0u)
;;;590          {
;;;591            /* Perform the multiply-accumulates */
;;;592            /* sum +=  x[srcALen-1] * y[srcBLen-1] */
;;;593            sum += *px++ * *py--;
;;;594    
;;;595            /* Decrement the loop counter */
;;;596            k--;
;;;597          }
;;;598    
;;;599          /* Store the result in the accumulator in the destination buffer. */
;;;600          *pOut++ = sum;
;;;601    
;;;602          /* Update the inputA and inputB pointers for next MAC calculation */
;;;603          px = ++pSrc1;
;;;604          py = pSrc2;
;;;605    
;;;606          /* Decrement the MAC count */
;;;607          count--;
;;;608    
;;;609          /* Decrement the loop counter */
;;;610          blockSize3--;
;;;611    
;;;612        }
;;;613    
;;;614        /* set status as ARM_MATH_SUCCESS */
;;;615        status = ARM_MATH_SUCCESS;
;;;616      }
;;;617    
;;;618      /* Return to application */
;;;619      return (status);
;;;620    
;;;621    #else
;;;622    
;;;623      /* Run the below code for Cortex-M0 */
;;;624    
;;;625      float32_t *pIn1 = pSrcA;                       /* inputA pointer */
;;;626      float32_t *pIn2 = pSrcB;                       /* inputB pointer */
;;;627      float32_t sum;                                 /* Accumulator */
;;;628      uint32_t i, j;                                 /* loop counters */
;;;629      arm_status status;                             /* status of Partial convolution */
;;;630    
;;;631      /* Check for range of output samples to be calculated */
;;;632      if((firstIndex + numPoints) > ((srcALen + (srcBLen - 1u))))
;;;633      {
;;;634        /* Set status as ARM_ARGUMENT_ERROR */
;;;635        status = ARM_MATH_ARGUMENT_ERROR;
;;;636      }
;;;637      else
;;;638      {
;;;639        /* Loop to calculate convolution for output length number of values */
;;;640        for (i = firstIndex; i <= (firstIndex + numPoints - 1); i++)
;;;641        {
;;;642          /* Initialize sum with zero to carry on MAC operations */
;;;643          sum = 0.0f;
;;;644    
;;;645          /* Loop to perform MAC operations according to convolution equation */
;;;646          for (j = 0u; j <= i; j++)
;;;647          {
;;;648            /* Check the array limitations for inputs */
;;;649            if((((i - j) < srcBLen) && (j < srcALen)))
;;;650            {
;;;651              /* z[i] += x[i-j] * y[j] */
;;;652              sum += pIn1[j] * pIn2[i - j];
;;;653            }
;;;654          }
;;;655          /* Store the output in the destination buffer */
;;;656          pDst[i] = sum;
;;;657        }
;;;658        /* set status as ARM_SUCCESS as there are no argument errors */
;;;659        status = ARM_MATH_SUCCESS;
;;;660      }
;;;661      return (status);
;;;662    
;;;663    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;664    
;;;665    }
000022  e8bd8ffc          POP      {r2-r11,pc}
                  |L1.38|
000026  4299              CMP      r1,r3                 ;135
000028  d204              BCS      |L1.52|
00002a  4654              MOV      r4,r10                ;146
00002c  4682              MOV      r10,r0                ;149
00002e  4618              MOV      r0,r3                 ;152
000030  460b              MOV      r3,r1                 ;153
000032  4601              MOV      r1,r0                 ;154
                  |L1.52|
000034  428f              CMP      r7,r1                 ;160
000036  dd02              BLE      |L1.62|
000038  eba70c01          SUB      r12,r7,r1             ;160
00003c  e001              B        |L1.66|
                  |L1.62|
00003e  f04f0c00          MOV      r12,#0                ;160
                  |L1.66|
000042  1e48              SUBS     r0,r1,#1              ;161
000044  4285              CMP      r5,r0                 ;161
000046  dd03              BLE      |L1.80|
000048  ebac0005          SUB      r0,r12,r5             ;161
00004c  eb000c01          ADD      r12,r0,r1             ;161
                  |L1.80|
000050  1b58              SUBS     r0,r3,r5              ;162
000052  1e40              SUBS     r0,r0,#1              ;162
000054  2800              CMP      r0,#0                 ;163
000056  dd04              BLE      |L1.98|
000058  1e5a              SUBS     r2,r3,#1              ;163
00005a  4297              CMP      r7,r2                 ;163
00005c  d902              BLS      |L1.100|
00005e  4606              MOV      r6,r0                 ;163
000060  e000              B        |L1.100|
                  |L1.98|
000062  2600              MOVS     r6,#0                 ;164
                  |L1.100|
000064  eba7000c          SUB      r0,r7,r12             ;165
000068  1972              ADDS     r2,r6,r5              ;165
00006a  1a80              SUBS     r0,r0,r2              ;165
00006c  2800              CMP      r0,#0                 ;167
00006e  dc00              BGT      |L1.114|
000070  2000              MOVS     r0,#0                 ;167
                  |L1.114|
000072  4683              MOV      r11,r0                ;167
000074  eb0a0785          ADD      r7,r10,r5,LSL #2      ;202
000078  eb080285          ADD      r2,r8,r5,LSL #2       ;180
00007c  f1050e01          ADD      lr,r5,#1              ;180
000080  4620              MOV      r0,r4                 ;199
000082  eddf2aba          VLDR     s5,|L1.876|
000086  9700              STR      r7,[sp,#0]            ;210
000088  e045              B        |L1.278|
00008a  bf00              NOP                            ;213
                  |L1.140|
00008c  eeb00a62          VMOV.F32 s0,s5                 ;213
000090  ea4f089e          LSR      r8,lr,#2              ;216
000094  e024              B        |L1.224|
000096  bf00              NOP                            ;223
                  |L1.152|
000098  ecf00a01          VLDM     r0!,{s1}              ;223
00009c  ed971a00          VLDR     s2,[r7,#0]            ;223
0000a0  4681              MOV      r9,r0                 ;223
0000a2  1f38              SUBS     r0,r7,#4              ;223
0000a4  9001              STR      r0,[sp,#4]            ;226
0000a6  ee000a81          VMLA.F32 s0,s1,s2              ;223
0000aa  ecf90a01          VLDM     r9!,{s1}              ;226
0000ae  ed171a01          VLDR     s2,[r7,#-4]           ;226
0000b2  1f00              SUBS     r0,r0,#4
0000b4  9001              STR      r0,[sp,#4]            ;229
0000b6  1f00              SUBS     r0,r0,#4
0000b8  ee000a81          VMLA.F32 s0,s1,s2              ;226
0000bc  ecb91a01          VLDM     r9!,{s2}              ;229
0000c0  ed570a02          VLDR     s1,[r7,#-8]           ;229
0000c4  9001              STR      r0,[sp,#4]            ;232
0000c6  f1090004          ADD      r0,r9,#4              ;232
0000ca  f1a80801          SUB      r8,r8,#1              ;232
0000ce  ee010a20          VMLA.F32 s0,s2,s1              ;229
0000d2  edd90a00          VLDR     s1,[r9,#0]            ;232
0000d6  ed171a03          VLDR     s2,[r7,#-0xc]         ;232
0000da  3f10              SUBS     r7,r7,#0x10           ;232
0000dc  ee000a81          VMLA.F32 s0,s1,s2              ;232
                  |L1.224|
0000e0  f1b80f00          CMP      r8,#0                 ;220
0000e4  d1d8              BNE      |L1.152|
0000e6  f00e0803          AND      r8,lr,#3              ;240
0000ea  e008              B        |L1.254|
                  |L1.236|
0000ec  ecf00a01          VLDM     r0!,{s1}              ;245
0000f0  ed971a00          VLDR     s2,[r7,#0]            ;245
0000f4  1f3f              SUBS     r7,r7,#4              ;245
0000f6  f1a80801          SUB      r8,r8,#1              ;245
0000fa  ee000a81          VMLA.F32 s0,s1,s2              ;245
                  |L1.254|
0000fe  f1b80f00          CMP      r8,#0                 ;242
000102  d1f3              BNE      |L1.236|
000104  eca20a01          VSTM     r2!,{s0}              ;252
000108  9f00              LDR      r7,[sp,#0]            ;255
00010a  4620              MOV      r0,r4                 ;256
00010c  1d3f              ADDS     r7,r7,#4              ;255
00010e  f10e0e01          ADD      lr,lr,#1              ;259
000112  1e76              SUBS     r6,r6,#1              ;259
000114  9700              STR      r7,[sp,#0]            ;259
                  |L1.278|
000116  2e00              CMP      r6,#0                 ;210
000118  dcb8              BGT      |L1.140|
00011a  1aee              SUBS     r6,r5,r3              ;276
00011c  1c76              ADDS     r6,r6,#1              ;276
00011e  2e00              CMP      r6,#0                 ;276
000120  dd04              BLE      |L1.300|
000122  eb040085          ADD      r0,r4,r5,LSL #2       ;278
000126  eba00083          SUB      r0,r0,r3,LSL #2       ;278
00012a  1d00              ADDS     r0,r0,#4              ;278
                  |L1.300|
00012c  eb0a0e83          ADD      lr,r10,r3,LSL #2      ;286
000130  f1ae0504          SUB      r5,lr,#4              ;286
000134  2600              MOVS     r6,#0                 ;290
000136  46aa              MOV      r10,r5                ;286
000138  2b04              CMP      r3,#4                 ;299
00013a  d37a              BCC      |L1.562|
00013c  ea4f099b          LSR      r9,r11,#2             ;302
000140  e071              B        |L1.550|
000142  bf00              NOP                            ;307
                  |L1.324|
000144  eeb00a62          VMOV.F32 s0,s5                 ;307
000148  ed902a00          VLDR     s4,[r0,#0]            ;313
00014c  edd01a01          VLDR     s3,[r0,#4]            ;314
000150  ed901a02          VLDR     s2,[r0,#8]            ;315
000154  089f              LSRS     r7,r3,#2              ;318
000156  eeb03a40          VMOV.F32 s6,s0                 ;307
00015a  eef00a40          VMOV.F32 s1,s0                 ;308
00015e  eef03a40          VMOV.F32 s7,s0                 ;310
000162  300c              ADDS     r0,r0,#0xc            ;318
                  |L1.356|
000164  ed954a00          VLDR     s8,[r5,#0]            ;325
000168  ed905a00          VLDR     s10,[r0,#0]           ;328
00016c  ee023a04          VMLA.F32 s6,s4,s8              ;332
000170  ee410a84          VMLA.F32 s1,s3,s8              ;335
000174  ee010a04          VMLA.F32 s0,s2,s8              ;338
000178  ee453a04          VMLA.F32 s7,s10,s8             ;341
00017c  ed154a01          VLDR     s8,[r5,#-4]           ;344
000180  ed902a01          VLDR     s4,[r0,#4]            ;347
000184  eef04a43          VMOV.F32 s9,s6                 ;351
000188  ed153a02          VLDR     s6,[r5,#-8]           ;360
00018c  ee414a84          VMLA.F32 s9,s3,s8              ;351
000190  ee410a04          VMLA.F32 s1,s2,s8              ;353
000194  ee050a04          VMLA.F32 s0,s10,s8             ;355
000198  ee423a04          VMLA.F32 s7,s4,s8              ;357
00019c  edd01a02          VLDR     s3,[r0,#8]            ;363
0001a0  ed154a03          VLDR     s8,[r5,#-0xc]         ;376
0001a4  ee414a03          VMLA.F32 s9,s2,s6              ;367
0001a8  ee450a03          VMLA.F32 s1,s10,s6             ;369
0001ac  ee020a03          VMLA.F32 s0,s4,s6              ;371
0001b0  ee413a83          VMLA.F32 s7,s3,s6              ;373
0001b4  ed901a03          VLDR     s2,[r0,#0xc]          ;379
0001b8  3010              ADDS     r0,r0,#0x10           ;389
0001ba  eeb03a64          VMOV.F32 s6,s9                 ;379
0001be  ee420a04          VMLA.F32 s1,s4,s8              ;385
0001c2  ee053a04          VMLA.F32 s6,s10,s8             ;383
0001c6  ee010a84          VMLA.F32 s0,s3,s8              ;387
0001ca  ee413a04          VMLA.F32 s7,s2,s8              ;389
0001ce  3d10              SUBS     r5,r5,#0x10           ;389
0001d0  1e7f              SUBS     r7,r7,#1              ;389
0001d2  d1c7              BNE      |L1.356|
0001d4  f0030703          AND      r7,r3,#3              ;396
0001d8  e014              B        |L1.516|
0001da  bf00              NOP                            ;401
                  |L1.476|
0001dc  edd54a00          VLDR     s9,[r5,#0]            ;401
0001e0  1f2d              SUBS     r5,r5,#4              ;419
0001e2  ecb04a01          VLDM     r0!,{s8}              ;404
0001e6  ee023a24          VMLA.F32 s6,s4,s9              ;408
0001ea  ee410aa4          VMLA.F32 s1,s3,s9              ;410
0001ee  ee010a24          VMLA.F32 s0,s2,s9              ;412
0001f2  eeb02a61          VMOV.F32 s4,s3                 ;417
0001f6  ee443a24          VMLA.F32 s7,s8,s9              ;414
0001fa  eef01a41          VMOV.F32 s3,s2                 ;418
0001fe  eeb01a44          VMOV.F32 s2,s8                 ;419
000202  1e7f              SUBS     r7,r7,#1              ;419
                  |L1.516|
000204  2f00              CMP      r7,#0                 ;398
000206  d1e9              BNE      |L1.476|
000208  ed823a00          VSTR     s6,[r2,#0]            ;426
00020c  edc20a01          VSTR     s1,[r2,#4]            ;427
000210  ed820a02          VSTR     s0,[r2,#8]            ;428
000214  1d36              ADDS     r6,r6,#4              ;429
000216  edc23a03          VSTR     s7,[r2,#0xc]          ;429
00021a  eb040086          ADD      r0,r4,r6,LSL #2       ;435
00021e  4655              MOV      r5,r10                ;436
000220  f1a90901          SUB      r9,r9,#1              ;439
000224  3210              ADDS     r2,r2,#0x10           ;439
                  |L1.550|
000226  f1b90f00          CMP      r9,#0                 ;304
00022a  d18b              BNE      |L1.324|
00022c  f00b0903          AND      r9,r11,#3             ;444
000230  e036              B        |L1.672|
                  |L1.562|
000232  e039              B        |L1.680|
                  |L1.564|
000234  eeb00a62          VMOV.F32 s0,s5                 ;449
000238  089f              LSRS     r7,r3,#2              ;452
00023a  e01a              B        |L1.626|
                  |L1.572|
00023c  edd00a00          VLDR     s1,[r0,#0]            ;459
000240  ed951a00          VLDR     s2,[r5,#0]            ;459
000244  ee000a81          VMLA.F32 s0,s1,s2              ;459
000248  edd00a01          VLDR     s1,[r0,#4]            ;460
00024c  ed151a01          VLDR     s2,[r5,#-4]           ;460
000250  ee000a81          VMLA.F32 s0,s1,s2              ;460
000254  edd00a02          VLDR     s1,[r0,#8]            ;461
000258  ed151a02          VLDR     s2,[r5,#-8]           ;461
00025c  ee000a81          VMLA.F32 s0,s1,s2              ;461
000260  edd00a03          VLDR     s1,[r0,#0xc]          ;462
000264  ed151a03          VLDR     s2,[r5,#-0xc]         ;462
000268  3010              ADDS     r0,r0,#0x10           ;462
00026a  3d10              SUBS     r5,r5,#0x10           ;462
00026c  1e7f              SUBS     r7,r7,#1              ;462
00026e  ee000a81          VMLA.F32 s0,s1,s2              ;462
                  |L1.626|
000272  2f00              CMP      r7,#0                 ;456
000274  d1e2              BNE      |L1.572|
000276  f0030703          AND      r7,r3,#3              ;470
00027a  e007              B        |L1.652|
                  |L1.636|
00027c  ecf00a01          VLDM     r0!,{s1}              ;475
000280  ed951a00          VLDR     s2,[r5,#0]            ;475
000284  1f2d              SUBS     r5,r5,#4              ;475
000286  1e7f              SUBS     r7,r7,#1              ;475
000288  ee000a81          VMLA.F32 s0,s1,s2              ;475
                  |L1.652|
00028c  2f00              CMP      r7,#0                 ;472
00028e  d1f5              BNE      |L1.636|
000290  1c76              ADDS     r6,r6,#1              ;482
000292  eca20a01          VSTM     r2!,{s0}              ;482
000296  eb040086          ADD      r0,r4,r6,LSL #2       ;488
00029a  4655              MOV      r5,r10                ;489
00029c  f1a90901          SUB      r9,r9,#1              ;492
                  |L1.672|
0002a0  f1b90f00          CMP      r9,#0                 ;446
0002a4  d1c6              BNE      |L1.564|
0002a6  e01a              B        |L1.734|
                  |L1.680|
0002a8  46d8              MOV      r8,r11                ;499
0002aa  e015              B        |L1.728|
                  |L1.684|
0002ac  eeb00a62          VMOV.F32 s0,s5                 ;504
0002b0  461f              MOV      r7,r3                 ;507
0002b2  e007              B        |L1.708|
                  |L1.692|
0002b4  ecf00a01          VLDM     r0!,{s1}              ;512
0002b8  ed951a00          VLDR     s2,[r5,#0]            ;512
0002bc  1f2d              SUBS     r5,r5,#4              ;512
0002be  1e7f              SUBS     r7,r7,#1              ;512
0002c0  ee000a81          VMLA.F32 s0,s1,s2              ;512
                  |L1.708|
0002c4  2f00              CMP      r7,#0                 ;509
0002c6  d1f5              BNE      |L1.692|
0002c8  1c76              ADDS     r6,r6,#1              ;519
0002ca  eca20a01          VSTM     r2!,{s0}              ;519
0002ce  eb040086          ADD      r0,r4,r6,LSL #2       ;525
0002d2  4655              MOV      r5,r10                ;526
0002d4  f1a80801          SUB      r8,r8,#1              ;526
                  |L1.728|
0002d8  f1b80f00          CMP      r8,#0                 ;501
0002dc  d1e6              BNE      |L1.684|
                  |L1.734|
0002de  eb040081          ADD      r0,r4,r1,LSL #2       ;550
0002e2  1e5d              SUBS     r5,r3,#1              ;547
0002e4  eba00083          SUB      r0,r0,r3,LSL #2       ;550
0002e8  1d00              ADDS     r0,r0,#4              ;550
0002ea  f1ae0404          SUB      r4,lr,#4              ;554
0002ee  4603              MOV      r3,r0                 ;550
0002f0  4621              MOV      r1,r4                 ;555
0002f2  e035              B        |L1.864|
                  |L1.756|
0002f4  eeb00a62          VMOV.F32 s0,s5                 ;560
0002f8  08ae              LSRS     r6,r5,#2              ;563
0002fa  e01a              B        |L1.818|
                  |L1.764|
0002fc  edd00a00          VLDR     s1,[r0,#0]            ;570
000300  ed911a00          VLDR     s2,[r1,#0]            ;570
000304  ee000a81          VMLA.F32 s0,s1,s2              ;570
000308  edd00a01          VLDR     s1,[r0,#4]            ;573
00030c  ed111a01          VLDR     s2,[r1,#-4]           ;573
000310  ee000a81          VMLA.F32 s0,s1,s2              ;573
000314  edd00a02          VLDR     s1,[r0,#8]            ;576
000318  ed111a02          VLDR     s2,[r1,#-8]           ;576
00031c  ee000a81          VMLA.F32 s0,s1,s2              ;576
000320  edd00a03          VLDR     s1,[r0,#0xc]          ;579
000324  ed111a03          VLDR     s2,[r1,#-0xc]         ;579
000328  3010              ADDS     r0,r0,#0x10           ;579
00032a  3910              SUBS     r1,r1,#0x10           ;579
00032c  1e76              SUBS     r6,r6,#1              ;579
00032e  ee000a81          VMLA.F32 s0,s1,s2              ;579
                  |L1.818|
000332  2e00              CMP      r6,#0                 ;567
000334  d1e2              BNE      |L1.764|
000336  f0050603          AND      r6,r5,#3              ;587
00033a  e007              B        |L1.844|
                  |L1.828|
00033c  ecf00a01          VLDM     r0!,{s1}              ;593
000340  ed911a00          VLDR     s2,[r1,#0]            ;593
000344  1f09              SUBS     r1,r1,#4              ;593
000346  1e76              SUBS     r6,r6,#1              ;593
000348  ee000a81          VMLA.F32 s0,s1,s2              ;593
                  |L1.844|
00034c  2e00              CMP      r6,#0                 ;589
00034e  d1f5              BNE      |L1.828|
000350  1d18              ADDS     r0,r3,#4              ;603
000352  eca20a01          VSTM     r2!,{s0}              ;600
000356  4603              MOV      r3,r0                 ;603
000358  4621              MOV      r1,r4                 ;604
00035a  1e6d              SUBS     r5,r5,#1              ;604
00035c  f1ac0c01          SUB      r12,r12,#1            ;604
                  |L1.864|
000360  f1bc0f00          CMP      r12,#0                ;557
000364  dcc6              BGT      |L1.756|
000366  2000              MOVS     r0,#0                 ;615
000368  e65b              B        |L1.34|
;;;666    
                          ENDP

00036a  0000              DCW      0x0000
                  |L1.876|
00036c  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_partial_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_conv_partial_f32_c_903aa6a7____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___22_arm_conv_partial_f32_c_903aa6a7____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_conv_partial_f32_c_903aa6a7____REVSH|
#line 144
|__asm___22_arm_conv_partial_f32_c_903aa6a7____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_conv_partial_f32_c_903aa6a7____RRX|
#line 300
|__asm___22_arm_conv_partial_f32_c_903aa6a7____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
