; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_partial_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_partial_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_conv_partial_f32.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_partial_f32.c]
                          THUMB

                          AREA ||i.arm_conv_partial_f32||, CODE, READONLY, ALIGN=2

                  arm_conv_partial_f32 PROC
;;;94     
;;;95     arm_status arm_conv_partial_f32(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;96       float32_t * pSrcA,
;;;97       uint32_t srcALen,
;;;98       float32_t * pSrcB,
;;;99       uint32_t srcBLen,
;;;100      float32_t * pDst,
;;;101      uint32_t firstIndex,
;;;102      uint32_t numPoints)
;;;103    {
000004  e9dd7c0a          LDRD     r7,r12,[sp,#0x28]
000008  9e09              LDR      r6,[sp,#0x24]
;;;104    
;;;105    
;;;106    #ifndef ARM_MATH_CM0_FAMILY
;;;107    
;;;108      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;109    
;;;110      float32_t *pIn1 = pSrcA;                       /* inputA pointer */
00000a  4605              MOV      r5,r0
;;;111      float32_t *pIn2 = pSrcB;                       /* inputB pointer */
00000c  4692              MOV      r10,r2
;;;112      float32_t *pOut = pDst;                        /* output pointer */
;;;113      float32_t *px;                                 /* Intermediate inputA pointer */
;;;114      float32_t *py;                                 /* Intermediate inputB pointer */
;;;115      float32_t *pSrc1, *pSrc2;                      /* Intermediate pointers */
;;;116      float32_t sum, acc0, acc1, acc2, acc3;         /* Accumulator */
;;;117      float32_t x0, x1, x2, x3, c0;                  /* Temporary variables to hold state and coefficient values */
;;;118      uint32_t j, k, count = 0u, blkCnt, check;
;;;119      int32_t blockSize1, blockSize2, blockSize3;    /* loop counters */
;;;120      arm_status status;                             /* status of Partial convolution */
;;;121    
;;;122    
;;;123      /* Check for range of output samples to be calculated */
;;;124      if((firstIndex + numPoints) > ((srcALen + (srcBLen - 1u))))
00000e  eb010803          ADD      r8,r1,r3
000012  eb07040c          ADD      r4,r7,r12
000016  f1a80801          SUB      r8,r8,#1
00001a  4544              CMP      r4,r8
00001c  d903              BLS      |L1.38|
;;;125      {
;;;126        /* Set status as ARM_MATH_ARGUMENT_ERROR */
;;;127        status = ARM_MATH_ARGUMENT_ERROR;
00001e  f04f30ff          MOV      r0,#0xffffffff
                  |L1.34|
;;;128      }
;;;129      else
;;;130      {
;;;131    
;;;132        /* The algorithm implementation is based on the lengths of the inputs. */
;;;133        /* srcB is always made to slide across srcA. */
;;;134        /* So srcBLen is always considered as shorter or equal to srcALen */
;;;135        if(srcALen >= srcBLen)
;;;136        {
;;;137          /* Initialization of inputA pointer */
;;;138          pIn1 = pSrcA;
;;;139    
;;;140          /* Initialization of inputB pointer */
;;;141          pIn2 = pSrcB;
;;;142        }
;;;143        else
;;;144        {
;;;145          /* Initialization of inputA pointer */
;;;146          pIn1 = pSrcB;
;;;147    
;;;148          /* Initialization of inputB pointer */
;;;149          pIn2 = pSrcA;
;;;150    
;;;151          /* srcBLen is always considered as shorter or equal to srcALen */
;;;152          j = srcBLen;
;;;153          srcBLen = srcALen;
;;;154          srcALen = j;
;;;155        }
;;;156    
;;;157        /* Conditions to check which loopCounter holds    
;;;158         * the first and last indices of the output samples to be calculated. */
;;;159        check = firstIndex + numPoints;
;;;160        blockSize3 = ((int32_t)check > (int32_t)srcALen) ? (int32_t)check - (int32_t)srcALen : 0;
;;;161        blockSize3 = ((int32_t)firstIndex > (int32_t)srcALen - 1) ? blockSize3 - (int32_t)firstIndex + (int32_t)srcALen : blockSize3;
;;;162        blockSize1 = ((int32_t) srcBLen - 1) - (int32_t) firstIndex;
;;;163        blockSize1 = (blockSize1 > 0) ? ((check > (srcBLen - 1u)) ? blockSize1 :
;;;164                                         (int32_t) numPoints) : 0;
;;;165        blockSize2 = ((int32_t) check - blockSize3) -
;;;166          (blockSize1 + (int32_t) firstIndex);
;;;167        blockSize2 = (blockSize2 > 0) ? blockSize2 : 0;
;;;168    
;;;169        /* conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1] */
;;;170        /* The function is internally    
;;;171         * divided into three stages according to the number of multiplications that has to be    
;;;172         * taken place between inputA samples and inputB samples. In the first stage of the    
;;;173         * algorithm, the multiplications increase by one for every iteration.    
;;;174         * In the second stage of the algorithm, srcBLen number of multiplications are done.    
;;;175         * In the third stage of the algorithm, the multiplications decrease by one    
;;;176         * for every iteration. */
;;;177    
;;;178        /* Set the output pointer to point to the firstIndex    
;;;179         * of the output sample to be calculated. */
;;;180        pOut = pDst + firstIndex;
;;;181    
;;;182        /* --------------------------    
;;;183         * Initializations of stage1    
;;;184         * -------------------------*/
;;;185    
;;;186        /* sum = x[0] * y[0]    
;;;187         * sum = x[0] * y[1] + x[1] * y[0]    
;;;188         * ....    
;;;189         * sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]    
;;;190         */
;;;191    
;;;192        /* In this stage the MAC operations are increased by 1 for every iteration.    
;;;193           The count variable holds the number of MAC operations performed.    
;;;194           Since the partial convolution starts from from firstIndex    
;;;195           Number of Macs to be performed is firstIndex + 1 */
;;;196        count = 1u + firstIndex;
;;;197    
;;;198        /* Working pointer of inputA */
;;;199        px = pIn1;
;;;200    
;;;201        /* Working pointer of inputB */
;;;202        pSrc1 = pIn2 + firstIndex;
;;;203        py = pSrc1;
;;;204    
;;;205        /* ------------------------    
;;;206         * Stage1 process    
;;;207         * ----------------------*/
;;;208    
;;;209        /* The first stage starts here */
;;;210        while(blockSize1 > 0)
;;;211        {
;;;212          /* Accumulator is made zero for every iteration */
;;;213          sum = 0.0f;
;;;214    
;;;215          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;216          k = count >> 2u;
;;;217    
;;;218          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;219           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;220          while(k > 0u)
;;;221          {
;;;222            /* x[0] * y[srcBLen - 1] */
;;;223            sum += *px++ * *py--;
;;;224    
;;;225            /* x[1] * y[srcBLen - 2] */
;;;226            sum += *px++ * *py--;
;;;227    
;;;228            /* x[2] * y[srcBLen - 3] */
;;;229            sum += *px++ * *py--;
;;;230    
;;;231            /* x[3] * y[srcBLen - 4] */
;;;232            sum += *px++ * *py--;
;;;233    
;;;234            /* Decrement the loop counter */
;;;235            k--;
;;;236          }
;;;237    
;;;238          /* If the count is not a multiple of 4, compute any remaining MACs here.    
;;;239           ** No loop unrolling is used. */
;;;240          k = count % 0x4u;
;;;241    
;;;242          while(k > 0u)
;;;243          {
;;;244            /* Perform the multiply-accumulates */
;;;245            sum += *px++ * *py--;
;;;246    
;;;247            /* Decrement the loop counter */
;;;248            k--;
;;;249          }
;;;250    
;;;251          /* Store the result in the accumulator in the destination buffer. */
;;;252          *pOut++ = sum;
;;;253    
;;;254          /* Update the inputA and inputB pointers for next MAC calculation */
;;;255          py = ++pSrc1;
;;;256          px = pIn1;
;;;257    
;;;258          /* Increment the MAC count */
;;;259          count++;
;;;260    
;;;261          /* Decrement the loop counter */
;;;262          blockSize1--;
;;;263        }
;;;264    
;;;265        /* --------------------------    
;;;266         * Initializations of stage2    
;;;267         * ------------------------*/
;;;268    
;;;269        /* sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0]    
;;;270         * sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0]    
;;;271         * ....    
;;;272         * sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]    
;;;273         */
;;;274    
;;;275        /* Working pointer of inputA */
;;;276        if((int32_t)firstIndex - (int32_t)srcBLen + 1 > 0)
;;;277        {
;;;278          px = pIn1 + firstIndex - srcBLen + 1;
;;;279        }
;;;280        else
;;;281        {
;;;282          px = pIn1;
;;;283        }
;;;284    
;;;285        /* Working pointer of inputB */
;;;286        pSrc2 = pIn2 + (srcBLen - 1u);
;;;287        py = pSrc2;
;;;288    
;;;289        /* count is index by which the pointer pIn1 to be incremented */
;;;290        count = 0u;
;;;291    
;;;292        /* -------------------    
;;;293         * Stage2 process    
;;;294         * ------------------*/
;;;295    
;;;296        /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.    
;;;297         * So, to loop unroll over blockSize2,    
;;;298         * srcBLen should be greater than or equal to 4 */
;;;299        if(srcBLen >= 4u)
;;;300        {
;;;301          /* Loop unroll over blockSize2, by 4 */
;;;302          blkCnt = ((uint32_t) blockSize2 >> 2u);
;;;303    
;;;304          while(blkCnt > 0u)
;;;305          {
;;;306            /* Set all accumulators to zero */
;;;307            acc0 = 0.0f;
;;;308            acc1 = 0.0f;
;;;309            acc2 = 0.0f;
;;;310            acc3 = 0.0f;
;;;311    
;;;312            /* read x[0], x[1], x[2] samples */
;;;313            x0 = *(px++);
;;;314            x1 = *(px++);
;;;315            x2 = *(px++);
;;;316    
;;;317            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;318            k = srcBLen >> 2u;
;;;319    
;;;320            /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;321             ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;322            do
;;;323            {
;;;324              /* Read y[srcBLen - 1] sample */
;;;325              c0 = *(py--);
;;;326    
;;;327              /* Read x[3] sample */
;;;328              x3 = *(px++);
;;;329    
;;;330              /* Perform the multiply-accumulate */
;;;331              /* acc0 +=  x[0] * y[srcBLen - 1] */
;;;332              acc0 += x0 * c0;
;;;333    
;;;334              /* acc1 +=  x[1] * y[srcBLen - 1] */
;;;335              acc1 += x1 * c0;
;;;336    
;;;337              /* acc2 +=  x[2] * y[srcBLen - 1] */
;;;338              acc2 += x2 * c0;
;;;339    
;;;340              /* acc3 +=  x[3] * y[srcBLen - 1] */
;;;341              acc3 += x3 * c0;
;;;342    
;;;343              /* Read y[srcBLen - 2] sample */
;;;344              c0 = *(py--);
;;;345    
;;;346              /* Read x[4] sample */
;;;347              x0 = *(px++);
;;;348    
;;;349              /* Perform the multiply-accumulate */
;;;350              /* acc0 +=  x[1] * y[srcBLen - 2] */
;;;351              acc0 += x1 * c0;
;;;352              /* acc1 +=  x[2] * y[srcBLen - 2] */
;;;353              acc1 += x2 * c0;
;;;354              /* acc2 +=  x[3] * y[srcBLen - 2] */
;;;355              acc2 += x3 * c0;
;;;356              /* acc3 +=  x[4] * y[srcBLen - 2] */
;;;357              acc3 += x0 * c0;
;;;358    
;;;359              /* Read y[srcBLen - 3] sample */
;;;360              c0 = *(py--);
;;;361    
;;;362              /* Read x[5] sample */
;;;363              x1 = *(px++);
;;;364    
;;;365              /* Perform the multiply-accumulates */
;;;366              /* acc0 +=  x[2] * y[srcBLen - 3] */
;;;367              acc0 += x2 * c0;
;;;368              /* acc1 +=  x[3] * y[srcBLen - 2] */
;;;369              acc1 += x3 * c0;
;;;370              /* acc2 +=  x[4] * y[srcBLen - 2] */
;;;371              acc2 += x0 * c0;
;;;372              /* acc3 +=  x[5] * y[srcBLen - 2] */
;;;373              acc3 += x1 * c0;
;;;374    
;;;375              /* Read y[srcBLen - 4] sample */
;;;376              c0 = *(py--);
;;;377    
;;;378              /* Read x[6] sample */
;;;379              x2 = *(px++);
;;;380    
;;;381              /* Perform the multiply-accumulates */
;;;382              /* acc0 +=  x[3] * y[srcBLen - 4] */
;;;383              acc0 += x3 * c0;
;;;384              /* acc1 +=  x[4] * y[srcBLen - 4] */
;;;385              acc1 += x0 * c0;
;;;386              /* acc2 +=  x[5] * y[srcBLen - 4] */
;;;387              acc2 += x1 * c0;
;;;388              /* acc3 +=  x[6] * y[srcBLen - 4] */
;;;389              acc3 += x2 * c0;
;;;390    
;;;391    
;;;392            } while(--k);
;;;393    
;;;394            /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.    
;;;395             ** No loop unrolling is used. */
;;;396            k = srcBLen % 0x4u;
;;;397    
;;;398            while(k > 0u)
;;;399            {
;;;400              /* Read y[srcBLen - 5] sample */
;;;401              c0 = *(py--);
;;;402    
;;;403              /* Read x[7] sample */
;;;404              x3 = *(px++);
;;;405    
;;;406              /* Perform the multiply-accumulates */
;;;407              /* acc0 +=  x[4] * y[srcBLen - 5] */
;;;408              acc0 += x0 * c0;
;;;409              /* acc1 +=  x[5] * y[srcBLen - 5] */
;;;410              acc1 += x1 * c0;
;;;411              /* acc2 +=  x[6] * y[srcBLen - 5] */
;;;412              acc2 += x2 * c0;
;;;413              /* acc3 +=  x[7] * y[srcBLen - 5] */
;;;414              acc3 += x3 * c0;
;;;415    
;;;416              /* Reuse the present samples for the next MAC */
;;;417              x0 = x1;
;;;418              x1 = x2;
;;;419              x2 = x3;
;;;420    
;;;421              /* Decrement the loop counter */
;;;422              k--;
;;;423            }
;;;424    
;;;425            /* Store the result in the accumulator in the destination buffer. */
;;;426            *pOut++ = acc0;
;;;427            *pOut++ = acc1;
;;;428            *pOut++ = acc2;
;;;429            *pOut++ = acc3;
;;;430    
;;;431            /* Increment the pointer pIn1 index, count by 1 */
;;;432            count += 4u;
;;;433    
;;;434            /* Update the inputA and inputB pointers for next MAC calculation */
;;;435            px = pIn1 + count;
;;;436            py = pSrc2;
;;;437    
;;;438            /* Decrement the loop counter */
;;;439            blkCnt--;
;;;440          }
;;;441    
;;;442          /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.    
;;;443           ** No loop unrolling is used. */
;;;444          blkCnt = (uint32_t) blockSize2 % 0x4u;
;;;445    
;;;446          while(blkCnt > 0u)
;;;447          {
;;;448            /* Accumulator is made zero for every iteration */
;;;449            sum = 0.0f;
;;;450    
;;;451            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;452            k = srcBLen >> 2u;
;;;453    
;;;454            /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;455             ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;456            while(k > 0u)
;;;457            {
;;;458              /* Perform the multiply-accumulates */
;;;459              sum += *px++ * *py--;
;;;460              sum += *px++ * *py--;
;;;461              sum += *px++ * *py--;
;;;462              sum += *px++ * *py--;
;;;463    
;;;464              /* Decrement the loop counter */
;;;465              k--;
;;;466            }
;;;467    
;;;468            /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.    
;;;469             ** No loop unrolling is used. */
;;;470            k = srcBLen % 0x4u;
;;;471    
;;;472            while(k > 0u)
;;;473            {
;;;474              /* Perform the multiply-accumulate */
;;;475              sum += *px++ * *py--;
;;;476    
;;;477              /* Decrement the loop counter */
;;;478              k--;
;;;479            }
;;;480    
;;;481            /* Store the result in the accumulator in the destination buffer. */
;;;482            *pOut++ = sum;
;;;483    
;;;484            /* Increment the MAC count */
;;;485            count++;
;;;486    
;;;487            /* Update the inputA and inputB pointers for next MAC calculation */
;;;488            px = pIn1 + count;
;;;489            py = pSrc2;
;;;490    
;;;491            /* Decrement the loop counter */
;;;492            blkCnt--;
;;;493          }
;;;494        }
;;;495        else
;;;496        {
;;;497          /* If the srcBLen is not a multiple of 4,    
;;;498           * the blockSize2 loop cannot be unrolled by 4 */
;;;499          blkCnt = (uint32_t) blockSize2;
;;;500    
;;;501          while(blkCnt > 0u)
;;;502          {
;;;503            /* Accumulator is made zero for every iteration */
;;;504            sum = 0.0f;
;;;505    
;;;506            /* srcBLen number of MACS should be performed */
;;;507            k = srcBLen;
;;;508    
;;;509            while(k > 0u)
;;;510            {
;;;511              /* Perform the multiply-accumulate */
;;;512              sum += *px++ * *py--;
;;;513    
;;;514              /* Decrement the loop counter */
;;;515              k--;
;;;516            }
;;;517    
;;;518            /* Store the result in the accumulator in the destination buffer. */
;;;519            *pOut++ = sum;
;;;520    
;;;521            /* Increment the MAC count */
;;;522            count++;
;;;523    
;;;524            /* Update the inputA and inputB pointers for next MAC calculation */
;;;525            px = pIn1 + count;
;;;526            py = pSrc2;
;;;527    
;;;528            /* Decrement the loop counter */
;;;529            blkCnt--;
;;;530          }
;;;531        }
;;;532    
;;;533    
;;;534        /* --------------------------    
;;;535         * Initializations of stage3    
;;;536         * -------------------------*/
;;;537    
;;;538        /* sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1]    
;;;539         * sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2]    
;;;540         * ....    
;;;541         * sum +=  x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2]    
;;;542         * sum +=  x[srcALen-1] * y[srcBLen-1]    
;;;543         */
;;;544    
;;;545        /* In this stage the MAC operations are decreased by 1 for every iteration.    
;;;546           The count variable holds the number of MAC operations performed */
;;;547        count = srcBLen - 1u;
;;;548    
;;;549        /* Working pointer of inputA */
;;;550        pSrc1 = (pIn1 + srcALen) - (srcBLen - 1u);
;;;551        px = pSrc1;
;;;552    
;;;553        /* Working pointer of inputB */
;;;554        pSrc2 = pIn2 + (srcBLen - 1u);
;;;555        py = pSrc2;
;;;556    
;;;557        while(blockSize3 > 0)
;;;558        {
;;;559          /* Accumulator is made zero for every iteration */
;;;560          sum = 0.0f;
;;;561    
;;;562          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;563          k = count >> 2u;
;;;564    
;;;565          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;566           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;567          while(k > 0u)
;;;568          {
;;;569            /* sum += x[srcALen - srcBLen + 1] * y[srcBLen - 1] */
;;;570            sum += *px++ * *py--;
;;;571    
;;;572            /* sum += x[srcALen - srcBLen + 2] * y[srcBLen - 2] */
;;;573            sum += *px++ * *py--;
;;;574    
;;;575            /* sum += x[srcALen - srcBLen + 3] * y[srcBLen - 3] */
;;;576            sum += *px++ * *py--;
;;;577    
;;;578            /* sum += x[srcALen - srcBLen + 4] * y[srcBLen - 4] */
;;;579            sum += *px++ * *py--;
;;;580    
;;;581            /* Decrement the loop counter */
;;;582            k--;
;;;583          }
;;;584    
;;;585          /* If the count is not a multiple of 4, compute any remaining MACs here.    
;;;586           ** No loop unrolling is used. */
;;;587          k = count % 0x4u;
;;;588    
;;;589          while(k > 0u)
;;;590          {
;;;591            /* Perform the multiply-accumulates */
;;;592            /* sum +=  x[srcALen-1] * y[srcBLen-1] */
;;;593            sum += *px++ * *py--;
;;;594    
;;;595            /* Decrement the loop counter */
;;;596            k--;
;;;597          }
;;;598    
;;;599          /* Store the result in the accumulator in the destination buffer. */
;;;600          *pOut++ = sum;
;;;601    
;;;602          /* Update the inputA and inputB pointers for next MAC calculation */
;;;603          px = ++pSrc1;
;;;604          py = pSrc2;
;;;605    
;;;606          /* Decrement the MAC count */
;;;607          count--;
;;;608    
;;;609          /* Decrement the loop counter */
;;;610          blockSize3--;
;;;611    
;;;612        }
;;;613    
;;;614        /* set status as ARM_MATH_SUCCESS */
;;;615        status = ARM_MATH_SUCCESS;
;;;616      }
;;;617    
;;;618      /* Return to application */
;;;619      return (status);
;;;620    
;;;621    #else
;;;622    
;;;623      /* Run the below code for Cortex-M0 */
;;;624    
;;;625      float32_t *pIn1 = pSrcA;                       /* inputA pointer */
;;;626      float32_t *pIn2 = pSrcB;                       /* inputB pointer */
;;;627      float32_t sum;                                 /* Accumulator */
;;;628      uint32_t i, j;                                 /* loop counters */
;;;629      arm_status status;                             /* status of Partial convolution */
;;;630    
;;;631      /* Check for range of output samples to be calculated */
;;;632      if((firstIndex + numPoints) > ((srcALen + (srcBLen - 1u))))
;;;633      {
;;;634        /* Set status as ARM_ARGUMENT_ERROR */
;;;635        status = ARM_MATH_ARGUMENT_ERROR;
;;;636      }
;;;637      else
;;;638      {
;;;639        /* Loop to calculate convolution for output length number of values */
;;;640        for (i = firstIndex; i <= (firstIndex + numPoints - 1); i++)
;;;641        {
;;;642          /* Initialize sum with zero to carry on MAC operations */
;;;643          sum = 0.0f;
;;;644    
;;;645          /* Loop to perform MAC operations according to convolution equation */
;;;646          for (j = 0u; j <= i; j++)
;;;647          {
;;;648            /* Check the array limitations for inputs */
;;;649            if((((i - j) < srcBLen) && (j < srcALen)))
;;;650            {
;;;651              /* z[i] += x[i-j] * y[j] */
;;;652              sum += pIn1[j] * pIn2[i - j];
;;;653            }
;;;654          }
;;;655          /* Store the output in the destination buffer */
;;;656          pDst[i] = sum;
;;;657        }
;;;658        /* set status as ARM_SUCCESS as there are no argument errors */
;;;659        status = ARM_MATH_SUCCESS;
;;;660      }
;;;661      return (status);
;;;662    
;;;663    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;664    
;;;665    }
000022  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.38|
000026  4299              CMP      r1,r3                 ;135
000028  d204              BCS      |L1.52|
00002a  4615              MOV      r5,r2                 ;146
00002c  4682              MOV      r10,r0                ;149
00002e  4618              MOV      r0,r3                 ;152
000030  460b              MOV      r3,r1                 ;153
000032  4601              MOV      r1,r0                 ;154
                  |L1.52|
000034  428c              CMP      r4,r1                 ;160
000036  dd02              BLE      |L1.62|
000038  eba40901          SUB      r9,r4,r1              ;160
00003c  e001              B        |L1.66|
                  |L1.62|
00003e  f04f0900          MOV      r9,#0                 ;160
                  |L1.66|
000042  1e48              SUBS     r0,r1,#1              ;161
000044  4287              CMP      r7,r0                 ;161
000046  dd03              BLE      |L1.80|
000048  eba90007          SUB      r0,r9,r7              ;161
00004c  eb000901          ADD      r9,r0,r1              ;161
                  |L1.80|
000050  eba30807          SUB      r8,r3,r7              ;162
000054  f1a80801          SUB      r8,r8,#1              ;162
000058  f1b80f00          CMP      r8,#0                 ;163
00005c  dd04              BLE      |L1.104|
00005e  1e58              SUBS     r0,r3,#1              ;163
000060  4284              CMP      r4,r0                 ;163
000062  d803              BHI      |L1.108|
000064  46e0              MOV      r8,r12                ;164
000066  e001              B        |L1.108|
                  |L1.104|
000068  f04f0800          MOV      r8,#0                 ;164
                  |L1.108|
00006c  eba40009          SUB      r0,r4,r9              ;165
000070  eb080207          ADD      r2,r8,r7              ;165
000074  eba00e02          SUB      lr,r0,r2              ;165
000078  f1be0f00          CMP      lr,#0                 ;167
00007c  dc01              BGT      |L1.130|
00007e  f04f0e00          MOV      lr,#0                 ;167
                  |L1.130|
000082  eb060087          ADD      r0,r6,r7,LSL #2       ;180
000086  f1070c01          ADD      r12,r7,#1             ;196
00008a  462c              MOV      r4,r5                 ;199
00008c  eb0a0b87          ADD      r11,r10,r7,LSL #2     ;202
000090  465a              MOV      r2,r11                ;203
000092  eddf6abe          VLDR     s13,|L1.908|
000096  e03a              B        |L1.270|
                  |L1.152|
000098  eef01a66          VMOV.F32 s3,s13                ;213
00009c  ea4f069c          LSR      r6,r12,#2             ;216
0000a0  e01c              B        |L1.220|
                  |L1.162|
0000a2  ecb40a01          VLDM     r4!,{s0}              ;223
0000a6  edd20a00          VLDR     s1,[r2,#0]            ;223
0000aa  1f12              SUBS     r2,r2,#4              ;223
0000ac  ee401a20          VMLA.F32 s3,s0,s1              ;223
0000b0  ecb40a01          VLDM     r4!,{s0}              ;226
0000b4  edd20a00          VLDR     s1,[r2,#0]            ;226
0000b8  1f12              SUBS     r2,r2,#4              ;226
0000ba  ee401a20          VMLA.F32 s3,s0,s1              ;226
0000be  ecb40a01          VLDM     r4!,{s0}              ;229
0000c2  edd20a00          VLDR     s1,[r2,#0]            ;229
0000c6  1f12              SUBS     r2,r2,#4              ;229
0000c8  ee401a20          VMLA.F32 s3,s0,s1              ;229
0000cc  ecb40a01          VLDM     r4!,{s0}              ;232
0000d0  edd20a00          VLDR     s1,[r2,#0]            ;232
0000d4  1f12              SUBS     r2,r2,#4              ;232
0000d6  ee401a20          VMLA.F32 s3,s0,s1              ;232
0000da  1e76              SUBS     r6,r6,#1              ;235
                  |L1.220|
0000dc  2e00              CMP      r6,#0                 ;220
0000de  d1e0              BNE      |L1.162|
0000e0  f00c0603          AND      r6,r12,#3             ;240
0000e4  e007              B        |L1.246|
                  |L1.230|
0000e6  ecb40a01          VLDM     r4!,{s0}              ;245
0000ea  edd20a00          VLDR     s1,[r2,#0]            ;245
0000ee  1f12              SUBS     r2,r2,#4              ;245
0000f0  ee401a20          VMLA.F32 s3,s0,s1              ;245
0000f4  1e76              SUBS     r6,r6,#1              ;248
                  |L1.246|
0000f6  2e00              CMP      r6,#0                 ;242
0000f8  d1f5              BNE      |L1.230|
0000fa  ece01a01          VSTM     r0!,{s3}              ;252
0000fe  f10b0204          ADD      r2,r11,#4             ;255
000102  4693              MOV      r11,r2                ;255
000104  462c              MOV      r4,r5                 ;256
000106  f10c0c01          ADD      r12,r12,#1            ;259
00010a  f1a80801          SUB      r8,r8,#1              ;262
                  |L1.270|
00010e  f1b80f00          CMP      r8,#0                 ;210
000112  dcc1              BGT      |L1.152|
000114  1afa              SUBS     r2,r7,r3              ;276
000116  1c52              ADDS     r2,r2,#1              ;276
000118  2a00              CMP      r2,#0                 ;276
00011a  dd04              BLE      |L1.294|
00011c  eb050287          ADD      r2,r5,r7,LSL #2       ;278
000120  eba20483          SUB      r4,r2,r3,LSL #2       ;278
000124  1d24              ADDS     r4,r4,#4              ;278
                  |L1.294|
000126  f1a30b01          SUB      r11,r3,#1             ;286
00012a  eb0a078b          ADD      r7,r10,r11,LSL #2     ;286
00012e  463a              MOV      r2,r7                 ;287
000130  2600              MOVS     r6,#0                 ;290
000132  2b04              CMP      r3,#4                 ;299
000134  d37d              BCC      |L1.562|
000136  ea4f089e          LSR      r8,lr,#2              ;302
00013a  e07d              B        |L1.568|
                  |L1.316|
00013c  eef01a66          VMOV.F32 s3,s13                ;308
000140  eeb02a61          VMOV.F32 s4,s3                 ;308
000144  eef01a66          VMOV.F32 s3,s13                ;309
000148  eef02a61          VMOV.F32 s5,s3                 ;309
00014c  eef01a66          VMOV.F32 s3,s13                ;310
000150  eef03a61          VMOV.F32 s7,s3                 ;310
000154  ecb41a01          VLDM     r4!,{s2}              ;313
000158  ecf40a01          VLDM     r4!,{s1}              ;314
00015c  ecb40a01          VLDM     r4!,{s0}              ;315
000160  ea4f0c93          LSR      r12,r3,#2             ;318
                  |L1.356|
000164  edd24a00          VLDR     s9,[r2,#0]            ;325
000168  1f12              SUBS     r2,r2,#4              ;325
00016a  ecb44a01          VLDM     r4!,{s8}              ;328
00016e  eef05a61          VMOV.F32 s11,s3                ;332
000172  ee415a24          VMLA.F32 s11,s2,s9             ;332
000176  ee002aa4          VMLA.F32 s4,s1,s9              ;335
00017a  ee402a24          VMLA.F32 s5,s0,s9              ;338
00017e  eeb06a63          VMOV.F32 s12,s7                ;341
000182  ee046a24          VMLA.F32 s12,s8,s9             ;341
000186  edd21a00          VLDR     s3,[r2,#0]            ;344
00018a  1f12              SUBS     r2,r2,#4              ;344
00018c  ecb41a01          VLDM     r4!,{s2}              ;347
000190  ee405aa1          VMLA.F32 s11,s1,s3             ;351
000194  ee002a21          VMLA.F32 s4,s0,s3              ;353
000198  ee442a21          VMLA.F32 s5,s8,s3              ;355
00019c  ee016a21          VMLA.F32 s12,s2,s3             ;357
0001a0  edd21a00          VLDR     s3,[r2,#0]            ;360
0001a4  1f12              SUBS     r2,r2,#4              ;360
0001a6  ecf40a01          VLDM     r4!,{s1}              ;363
0001aa  ee405a21          VMLA.F32 s11,s0,s3             ;367
0001ae  ee042a21          VMLA.F32 s4,s8,s3              ;369
0001b2  ee412a21          VMLA.F32 s5,s2,s3              ;371
0001b6  ee006aa1          VMLA.F32 s12,s1,s3             ;373
0001ba  edd23a00          VLDR     s7,[r2,#0]            ;376
0001be  1f12              SUBS     r2,r2,#4              ;376
0001c0  ecb40a01          VLDM     r4!,{s0}              ;379
0001c4  eef01a65          VMOV.F32 s3,s11                ;383
0001c8  ee441a23          VMLA.F32 s3,s8,s7              ;383
0001cc  ee012a23          VMLA.F32 s4,s2,s7              ;385
0001d0  ee402aa3          VMLA.F32 s5,s1,s7              ;387
0001d4  ee006a23          VMLA.F32 s12,s0,s7             ;389
0001d8  eef03a46          VMOV.F32 s7,s12                ;389
0001dc  f1bc0c01          SUBS     r12,r12,#1            ;392
0001e0  d1c0              BNE      |L1.356|
0001e2  f0030c03          AND      r12,r3,#3             ;396
0001e6  e014              B        |L1.530|
                  |L1.488|
0001e8  ed924a00          VLDR     s8,[r2,#0]            ;401
0001ec  1f12              SUBS     r2,r2,#4              ;401
0001ee  ecf44a01          VLDM     r4!,{s9}              ;404
0001f2  ee411a04          VMLA.F32 s3,s2,s8              ;408
0001f6  ee002a84          VMLA.F32 s4,s1,s8              ;410
0001fa  ee402a04          VMLA.F32 s5,s0,s8              ;412
0001fe  ee443a84          VMLA.F32 s7,s9,s8              ;414
000202  eeb01a60          VMOV.F32 s2,s1                 ;417
000206  eef00a40          VMOV.F32 s1,s0                 ;418
00020a  eeb00a64          VMOV.F32 s0,s9                 ;419
00020e  f1ac0c01          SUB      r12,r12,#1            ;422
                  |L1.530|
000212  f1bc0f00          CMP      r12,#0                ;398
000216  d1e7              BNE      |L1.488|
000218  ece01a01          VSTM     r0!,{s3}              ;426
00021c  eca02a01          VSTM     r0!,{s4}              ;427
000220  ece02a01          VSTM     r0!,{s5}              ;428
000224  ece03a01          VSTM     r0!,{s7}              ;429
000228  1d36              ADDS     r6,r6,#4              ;432
00022a  eb050486          ADD      r4,r5,r6,LSL #2       ;435
00022e  463a              MOV      r2,r7                 ;436
000230  e000              B        |L1.564|
                  |L1.562|
000232  e061              B        |L1.760|
                  |L1.564|
000234  f1a80801          SUB      r8,r8,#1              ;439
                  |L1.568|
000238  f1b80f00          CMP      r8,#0                 ;304
00023c  f47faf7e          BNE      |L1.316|
000240  f00e0803          AND      r8,lr,#3              ;444
000244  e03c              B        |L1.704|
                  |L1.582|
000246  eef01a66          VMOV.F32 s3,s13                ;449
00024a  ea4f0c93          LSR      r12,r3,#2             ;452
00024e  e01d              B        |L1.652|
                  |L1.592|
000250  ecb40a01          VLDM     r4!,{s0}              ;459
000254  edd20a00          VLDR     s1,[r2,#0]            ;459
000258  1f12              SUBS     r2,r2,#4              ;459
00025a  ee401a20          VMLA.F32 s3,s0,s1              ;459
00025e  ecb40a01          VLDM     r4!,{s0}              ;460
000262  edd20a00          VLDR     s1,[r2,#0]            ;460
000266  1f12              SUBS     r2,r2,#4              ;460
000268  ee401a20          VMLA.F32 s3,s0,s1              ;460
00026c  ecb40a01          VLDM     r4!,{s0}              ;461
000270  edd20a00          VLDR     s1,[r2,#0]            ;461
000274  1f12              SUBS     r2,r2,#4              ;461
000276  ee401a20          VMLA.F32 s3,s0,s1              ;461
00027a  ecb40a01          VLDM     r4!,{s0}              ;462
00027e  edd20a00          VLDR     s1,[r2,#0]            ;462
000282  1f12              SUBS     r2,r2,#4              ;462
000284  ee401a20          VMLA.F32 s3,s0,s1              ;462
000288  f1ac0c01          SUB      r12,r12,#1            ;465
                  |L1.652|
00028c  f1bc0f00          CMP      r12,#0                ;456
000290  d1de              BNE      |L1.592|
000292  f0030c03          AND      r12,r3,#3             ;470
000296  e008              B        |L1.682|
                  |L1.664|
000298  ecb40a01          VLDM     r4!,{s0}              ;475
00029c  edd20a00          VLDR     s1,[r2,#0]            ;475
0002a0  1f12              SUBS     r2,r2,#4              ;475
0002a2  ee401a20          VMLA.F32 s3,s0,s1              ;475
0002a6  f1ac0c01          SUB      r12,r12,#1            ;478
                  |L1.682|
0002aa  f1bc0f00          CMP      r12,#0                ;472
0002ae  d1f3              BNE      |L1.664|
0002b0  ece01a01          VSTM     r0!,{s3}              ;482
0002b4  1c76              ADDS     r6,r6,#1              ;485
0002b6  eb050486          ADD      r4,r5,r6,LSL #2       ;488
0002ba  463a              MOV      r2,r7                 ;489
0002bc  f1a80801          SUB      r8,r8,#1              ;492
                  |L1.704|
0002c0  f1b80f00          CMP      r8,#0                 ;446
0002c4  d1bf              BNE      |L1.582|
0002c6  e01a              B        |L1.766|
                  |L1.712|
0002c8  eeb05a66          VMOV.F32 s10,s13               ;504
0002cc  469c              MOV      r12,r3                ;507
0002ce  e008              B        |L1.738|
                  |L1.720|
0002d0  ecb40a01          VLDM     r4!,{s0}              ;512
0002d4  edd20a00          VLDR     s1,[r2,#0]            ;512
0002d8  1f12              SUBS     r2,r2,#4              ;512
0002da  ee005a20          VMLA.F32 s10,s0,s1             ;512
0002de  f1ac0c01          SUB      r12,r12,#1            ;515
                  |L1.738|
0002e2  f1bc0f00          CMP      r12,#0                ;509
0002e6  d1f3              BNE      |L1.720|
0002e8  eca05a01          VSTM     r0!,{s10}             ;519
0002ec  1c76              ADDS     r6,r6,#1              ;522
0002ee  eb050486          ADD      r4,r5,r6,LSL #2       ;525
0002f2  463a              MOV      r2,r7                 ;526
0002f4  f1ae0e01          SUB      lr,lr,#1              ;529
                  |L1.760|
0002f8  f1be0f00          CMP      lr,#0                 ;501
0002fc  d1e4              BNE      |L1.712|
                  |L1.766|
0002fe  1e5b              SUBS     r3,r3,#1              ;547
000300  eb050181          ADD      r1,r5,r1,LSL #2       ;550
000304  eba1048b          SUB      r4,r1,r11,LSL #2      ;550
000308  4621              MOV      r1,r4                 ;551
00030a  463d              MOV      r5,r7                 ;554
00030c  462f              MOV      r7,r5                 ;555
00030e  e037              B        |L1.896|
                  |L1.784|
000310  eeb03a66          VMOV.F32 s6,s13                ;560
000314  089a              LSRS     r2,r3,#2              ;563
000316  e01c              B        |L1.850|
                  |L1.792|
000318  ecb10a01          VLDM     r1!,{s0}              ;570
00031c  edd70a00          VLDR     s1,[r7,#0]            ;570
000320  1f3f              SUBS     r7,r7,#4              ;570
000322  ee003a20          VMLA.F32 s6,s0,s1              ;570
000326  ecb10a01          VLDM     r1!,{s0}              ;573
00032a  edd70a00          VLDR     s1,[r7,#0]            ;573
00032e  1f3f              SUBS     r7,r7,#4              ;573
000330  ee003a20          VMLA.F32 s6,s0,s1              ;573
000334  ecb10a01          VLDM     r1!,{s0}              ;576
000338  edd70a00          VLDR     s1,[r7,#0]            ;576
00033c  1f3f              SUBS     r7,r7,#4              ;576
00033e  ee003a20          VMLA.F32 s6,s0,s1              ;576
000342  ecb10a01          VLDM     r1!,{s0}              ;579
000346  edd70a00          VLDR     s1,[r7,#0]            ;579
00034a  1f3f              SUBS     r7,r7,#4              ;579
00034c  ee003a20          VMLA.F32 s6,s0,s1              ;579
000350  1e52              SUBS     r2,r2,#1              ;582
                  |L1.850|
000352  2a00              CMP      r2,#0                 ;567
000354  d1e0              BNE      |L1.792|
000356  f0030203          AND      r2,r3,#3              ;587
00035a  e007              B        |L1.876|
                  |L1.860|
00035c  ecb10a01          VLDM     r1!,{s0}              ;593
000360  edd70a00          VLDR     s1,[r7,#0]            ;593
000364  1f3f              SUBS     r7,r7,#4              ;593
000366  ee003a20          VMLA.F32 s6,s0,s1              ;593
00036a  1e52              SUBS     r2,r2,#1              ;596
                  |L1.876|
00036c  2a00              CMP      r2,#0                 ;589
00036e  d1f5              BNE      |L1.860|
000370  eca03a01          VSTM     r0!,{s6}              ;600
000374  1d21              ADDS     r1,r4,#4              ;603
000376  460c              MOV      r4,r1                 ;603
000378  462f              MOV      r7,r5                 ;604
00037a  1e5b              SUBS     r3,r3,#1              ;607
00037c  f1a90901          SUB      r9,r9,#1              ;610
                  |L1.896|
000380  f1b90f00          CMP      r9,#0                 ;557
000384  dcc4              BGT      |L1.784|
000386  2000              MOVS     r0,#0                 ;615
000388  e64b              B        |L1.34|
;;;666    
                          ENDP

00038a  0000              DCW      0x0000
                  |L1.908|
00038c  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_partial_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_conv_partial_f32_c_903aa6a7____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___22_arm_conv_partial_f32_c_903aa6a7____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_conv_partial_f32_c_903aa6a7____REVSH|
#line 144
|__asm___22_arm_conv_partial_f32_c_903aa6a7____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_conv_partial_f32_c_903aa6a7____RRX|
#line 300
|__asm___22_arm_conv_partial_f32_c_903aa6a7____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
