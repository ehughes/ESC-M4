; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_lattice_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_lattice_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_fir_lattice_f32.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_fir_lattice_f32.c]
                          THUMB

                          AREA ||i.arm_fir_lattice_f32||, CODE, READONLY, ALIGN=1

                  arm_fir_lattice_f32 PROC
;;;130    
;;;131    void arm_fir_lattice_f32(
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;132      const arm_fir_lattice_instance_f32 * S,
;;;133      float32_t * pSrc,
;;;134      float32_t * pDst,
;;;135      uint32_t blockSize)
;;;136    {
000004  ed2d8b04          VPUSH    {d8-d9}
;;;137      float32_t *pState;                             /* State pointer */
;;;138      float32_t *pCoeffs = S->pCoeffs;               /* Coefficient pointer */
000008  f8d0c008          LDR      r12,[r0,#8]
;;;139      float32_t *px;                                 /* temporary state pointer */
;;;140      float32_t *pk;                                 /* temporary coefficient pointer */
;;;141    
;;;142    
;;;143    #ifndef ARM_MATH_CM0_FAMILY
;;;144    
;;;145      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;146    
;;;147      float32_t fcurr1, fnext1, gcurr1, gnext1;      /* temporary variables for first sample in loop unrolling */
;;;148      float32_t fcurr2, fnext2, gnext2;              /* temporary variables for second sample in loop unrolling */
;;;149      float32_t fcurr3, fnext3, gnext3;              /* temporary variables for third sample in loop unrolling */
;;;150      float32_t fcurr4, fnext4, gnext4;              /* temporary variables for fourth sample in loop unrolling */
;;;151      uint32_t numStages = S->numStages;             /* Number of stages in the filter */
00000c  f8b08000          LDRH     r8,[r0,#0]
;;;152      uint32_t blkCnt, stageCnt;                     /* temporary variables for counts */
;;;153    
;;;154      gcurr1 = 0.0f;
;;;155      pState = &S->pState[0];
000010  f8d09004          LDR      r9,[r0,#4]
;;;156    
;;;157      blkCnt = blockSize >> 2;
000014  089e              LSRS     r6,r3,#2
000016  e0f6              B        |L1.518|
                  |L1.24|
;;;158    
;;;159      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;160         a second loop below computes the remaining 1 to 3 samples. */
;;;161      while(blkCnt > 0u)
;;;162      {
;;;163    
;;;164        /* Read two samples from input buffer */
;;;165        /* f0(n) = x(n) */
;;;166        fcurr1 = *pSrc++;
000018  ecb13a01          VLDM     r1!,{s6}
;;;167        fcurr2 = *pSrc++;
00001c  ecf12a01          VLDM     r1!,{s5}
;;;168    
;;;169        /* Initialize coeff pointer */
;;;170        pk = (pCoeffs);
000020  4664              MOV      r4,r12
;;;171    
;;;172        /* Initialize state pointer */
;;;173        px = pState;
000022  4648              MOV      r0,r9
;;;174    
;;;175        /* Read g0(n-1) from state */
;;;176        gcurr1 = *px;
000024  edd03a00          VLDR     s7,[r0,#0]
;;;177    
;;;178        /* Process first sample for first tap */
;;;179        /* f1(n) = f0(n) +  K1 * g0(n-1) */
;;;180        fnext1 = fcurr1 + ((*pk) * gcurr1);
000028  ed940a00          VLDR     s0,[r4,#0]
00002c  eef04a43          VMOV.F32 s9,s6
000030  ee404a23          VMLA.F32 s9,s0,s7
;;;181        /* g1(n) = f0(n) * K1  +  g0(n-1) */
;;;182        gnext1 = (fcurr1 * (*pk)) + gcurr1;
000034  ee433a00          VMLA.F32 s7,s6,s0
;;;183    
;;;184        /* Process second sample for first tap */
;;;185        /* for sample 2 processing */
;;;186        fnext2 = fcurr2 + ((*pk) * fcurr1);
000038  eef01a62          VMOV.F32 s3,s5
00003c  ee401a03          VMLA.F32 s3,s0,s6
;;;187        gnext2 = (fcurr2 * (*pk)) + fcurr1;
000040  ee023a80          VMLA.F32 s6,s5,s0
;;;188    
;;;189        /* Read next two samples from input buffer */
;;;190        /* f0(n+2) = x(n+2) */
;;;191        fcurr3 = *pSrc++;
000044  ecb14a01          VLDM     r1!,{s8}
;;;192        fcurr4 = *pSrc++;
000048  ecb10a01          VLDM     r1!,{s0}
;;;193    
;;;194        /* Copy only last input samples into the state buffer    
;;;195           which will be used for next four samples processing */
;;;196        *px++ = fcurr4;
00004c  eca00a01          VSTM     r0!,{s0}
;;;197    
;;;198        /* Process third sample for first tap */
;;;199        fnext3 = fcurr3 + ((*pk) * fcurr2);
000050  ed941a00          VLDR     s2,[r4,#0]
000054  eef00a44          VMOV.F32 s1,s8
000058  ee410a22          VMLA.F32 s1,s2,s5
;;;200        gnext3 = (fcurr3 * (*pk)) + fcurr2;
00005c  ee442a01          VMLA.F32 s5,s8,s2
;;;201    
;;;202        /* Process fourth sample for first tap */
;;;203        fnext4 = fcurr4 + ((*pk) * fcurr3);
000060  eeb02a40          VMOV.F32 s4,s0
000064  ee012a04          VMLA.F32 s4,s2,s8
;;;204        gnext4 = (fcurr4 * (*pk++)) + fcurr3;
000068  ee004a01          VMLA.F32 s8,s0,s2
00006c  1d24              ADDS     r4,r4,#4
;;;205    
;;;206        /* Update of f values for next coefficient set processing */
;;;207        fcurr1 = fnext1;
00006e  eeb01a64          VMOV.F32 s2,s9
;;;208        fcurr2 = fnext2;
;;;209        fcurr3 = fnext3;
;;;210        fcurr4 = fnext4;
;;;211    
;;;212        /* Loop unrolling.  Process 4 taps at a time . */
;;;213        stageCnt = (numStages - 1u) >> 2u;
000072  f1a80701          SUB      r7,r8,#1
000076  08bd              LSRS     r5,r7,#2
;;;214    
;;;215        /* Loop over the number of taps.  Unroll by a factor of 4.    
;;;216         ** Repeat until we've computed numStages-3 coefficients. */
;;;217    
;;;218        /* Process 2nd, 3rd, 4th and 5th taps ... here */
;;;219        while(stageCnt > 0u)
000078  e084              B        |L1.388|
                  |L1.122|
;;;220        {
;;;221          /* Read g1(n-1), g3(n-1) .... from state */
;;;222          gcurr1 = *px;
00007a  edd09a00          VLDR     s19,[r0,#0]
;;;223    
;;;224          /* save g1(n) in state buffer */
;;;225          *px++ = gnext4;
00007e  eca04a01          VSTM     r0!,{s8}
;;;226    
;;;227          /* Process first sample for 2nd, 6th .. tap */
;;;228          /* Sample processing for K2, K6.... */
;;;229          /* f2(n) = f1(n) +  K2 * g1(n-1) */
;;;230          fnext1 = fcurr1 + ((*pk) * gcurr1);
000082  ed940a00          VLDR     s0,[r4,#0]
000086  eeb05a41          VMOV.F32 s10,s2
00008a  ee005a29          VMLA.F32 s10,s0,s19
;;;231          /* Process second sample for 2nd, 6th .. tap */
;;;232          /* for sample 2 processing */
;;;233          fnext2 = fcurr2 + ((*pk) * gnext1);
00008e  eef06a61          VMOV.F32 s13,s3
000092  ee406a23          VMLA.F32 s13,s0,s7
;;;234          /* Process third sample for 2nd, 6th .. tap */
;;;235          fnext3 = fcurr3 + ((*pk) * gnext2);
000096  eef07a60          VMOV.F32 s15,s1
00009a  ee407a03          VMLA.F32 s15,s0,s6
;;;236          /* Process fourth sample for 2nd, 6th .. tap */
;;;237          fnext4 = fcurr4 + ((*pk) * gnext3);
00009e  eef04a42          VMOV.F32 s9,s4
0000a2  ee404a22          VMLA.F32 s9,s0,s5
;;;238    
;;;239          /* g2(n) = f1(n) * K2  +  g1(n-1) */
;;;240          /* Calculation of state values for next stage */
;;;241          gnext4 = (fcurr4 * (*pk)) + gnext3;
0000a6  eef05a62          VMOV.F32 s11,s5
0000aa  ee425a00          VMLA.F32 s11,s4,s0
;;;242          gnext3 = (fcurr3 * (*pk)) + gnext2;
0000ae  ee003a80          VMLA.F32 s6,s1,s0
;;;243          gnext2 = (fcurr2 * (*pk)) + gnext1;
0000b2  ee413a80          VMLA.F32 s7,s3,s0
;;;244          gnext1 = (fcurr1 * (*pk++)) + gcurr1;
0000b6  ee419a00          VMLA.F32 s19,s2,s0
0000ba  1d24              ADDS     r4,r4,#4
0000bc  eeb04a69          VMOV.F32 s8,s19
;;;245    
;;;246    
;;;247          /* Read g2(n-1), g4(n-1) .... from state */
;;;248          gcurr1 = *px;
0000c0  edd02a00          VLDR     s5,[r0,#0]
;;;249    
;;;250          /* save g2(n) in state buffer */
;;;251          *px++ = gnext4;
0000c4  ece05a01          VSTM     r0!,{s11}
;;;252    
;;;253          /* Sample processing for K3, K7.... */
;;;254          /* Process first sample for 3rd, 7th .. tap */
;;;255          /* f3(n) = f2(n) +  K3 * g2(n-1) */
;;;256          fcurr1 = fnext1 + ((*pk) * gcurr1);
0000c8  ed940a00          VLDR     s0,[r4,#0]
0000cc  eeb01a45          VMOV.F32 s2,s10
0000d0  ee001a22          VMLA.F32 s2,s0,s5
;;;257          /* Process second sample for 3rd, 7th .. tap */
;;;258          fcurr2 = fnext2 + ((*pk) * gnext1);
0000d4  eeb06a66          VMOV.F32 s12,s13
0000d8  ee006a04          VMLA.F32 s12,s0,s8
;;;259          /* Process third sample for 3rd, 7th .. tap */
;;;260          fcurr3 = fnext3 + ((*pk) * gnext2);
0000dc  eeb08a67          VMOV.F32 s16,s15
0000e0  ee008a23          VMLA.F32 s16,s0,s7
;;;261          /* Process fourth sample for 3rd, 7th .. tap */
;;;262          fcurr4 = fnext4 + ((*pk) * gnext3);
0000e4  eef01a64          VMOV.F32 s3,s9
0000e8  ee401a03          VMLA.F32 s3,s0,s6
;;;263    
;;;264          /* Calculation of state values for next stage */
;;;265          /* g3(n) = f2(n) * K3  +  g2(n-1) */
;;;266          gnext4 = (fnext4 * (*pk)) + gnext3;
0000ec  ee043a80          VMLA.F32 s6,s9,s0
;;;267          gnext3 = (fnext3 * (*pk)) + gnext2;
0000f0  ee473a80          VMLA.F32 s7,s15,s0
;;;268          gnext2 = (fnext2 * (*pk)) + gnext1;
0000f4  ee064a80          VMLA.F32 s8,s13,s0
;;;269          gnext1 = (fnext1 * (*pk++)) + gcurr1;
0000f8  ee452a00          VMLA.F32 s5,s10,s0
0000fc  1d24              ADDS     r4,r4,#4
;;;270    
;;;271    
;;;272          /* Read g1(n-1), g3(n-1) .... from state */
;;;273          gcurr1 = *px;
0000fe  ed909a00          VLDR     s18,[r0,#0]
;;;274    
;;;275          /* save g3(n) in state buffer */
;;;276          *px++ = gnext4;
000102  eca03a01          VSTM     r0!,{s6}
;;;277    
;;;278          /* Sample processing for K4, K8.... */
;;;279          /* Process first sample for 4th, 8th .. tap */
;;;280          /* f4(n) = f3(n) +  K4 * g3(n-1) */
;;;281          fnext1 = fcurr1 + ((*pk) * gcurr1);
000106  ed940a00          VLDR     s0,[r4,#0]
00010a  eef05a41          VMOV.F32 s11,s2
00010e  ee405a09          VMLA.F32 s11,s0,s18
;;;282          /* Process second sample for 4th, 8th .. tap */
;;;283          /* for sample 2 processing */
;;;284          fnext2 = fcurr2 + ((*pk) * gnext1);
000112  eeb03a46          VMOV.F32 s6,s12
000116  ee003a22          VMLA.F32 s6,s0,s5
;;;285          /* Process third sample for 4th, 8th .. tap */
;;;286          fnext3 = fcurr3 + ((*pk) * gnext2);
00011a  eeb07a48          VMOV.F32 s14,s16
00011e  ee007a04          VMLA.F32 s14,s0,s8
;;;287          /* Process fourth sample for 4th, 8th .. tap */
;;;288          fnext4 = fcurr4 + ((*pk) * gnext3);
000122  eef08a61          VMOV.F32 s17,s3
000126  ee408a23          VMLA.F32 s17,s0,s7
;;;289    
;;;290          /* g4(n) = f3(n) * K4  +  g3(n-1) */
;;;291          /* Calculation of state values for next stage */
;;;292          gnext4 = (fcurr4 * (*pk)) + gnext3;
00012a  ee413a80          VMLA.F32 s7,s3,s0
;;;293          gnext3 = (fcurr3 * (*pk)) + gnext2;
00012e  ee084a00          VMLA.F32 s8,s16,s0
;;;294          gnext2 = (fcurr2 * (*pk)) + gnext1;
000132  ee462a00          VMLA.F32 s5,s12,s0
;;;295          gnext1 = (fcurr1 * (*pk++)) + gcurr1;
000136  ee019a00          VMLA.F32 s18,s2,s0
00013a  1d24              ADDS     r4,r4,#4
;;;296    
;;;297          /* Read g2(n-1), g4(n-1) .... from state */
;;;298          gcurr1 = *px;
00013c  edd04a00          VLDR     s9,[r0,#0]
;;;299    
;;;300          /* save g4(n) in state buffer */
;;;301          *px++ = gnext4;
000140  ece03a01          VSTM     r0!,{s7}
;;;302    
;;;303          /* Sample processing for K5, K9.... */
;;;304          /* Process first sample for 5th, 9th .. tap */
;;;305          /* f5(n) = f4(n) +  K5 * g4(n-1) */
;;;306          fcurr1 = fnext1 + ((*pk) * gcurr1);
000144  ed940a00          VLDR     s0,[r4,#0]
000148  eeb01a65          VMOV.F32 s2,s11
00014c  ee001a24          VMLA.F32 s2,s0,s9
;;;307          /* Process second sample for 5th, 9th .. tap */
;;;308          fcurr2 = fnext2 + ((*pk) * gnext1);
000150  eef01a43          VMOV.F32 s3,s6
000154  ee401a09          VMLA.F32 s3,s0,s18
;;;309          /* Process third sample for 5th, 9th .. tap */
;;;310          fcurr3 = fnext3 + ((*pk) * gnext2);
000158  eef00a47          VMOV.F32 s1,s14
00015c  ee400a22          VMLA.F32 s1,s0,s5
;;;311          /* Process fourth sample for 5th, 9th .. tap */
;;;312          fcurr4 = fnext4 + ((*pk) * gnext3);
000160  eeb02a68          VMOV.F32 s4,s17
000164  ee002a04          VMLA.F32 s4,s0,s8
;;;313    
;;;314          /* Calculation of state values for next stage */
;;;315          /* g5(n) = f4(n) * K5  +  g4(n-1) */
;;;316          gnext4 = (fnext4 * (*pk)) + gnext3;
000168  ee084a80          VMLA.F32 s8,s17,s0
;;;317          gnext3 = (fnext3 * (*pk)) + gnext2;
00016c  ee472a00          VMLA.F32 s5,s14,s0
;;;318          gnext2 = (fnext2 * (*pk)) + gnext1;
000170  ee039a00          VMLA.F32 s18,s6,s0
000174  eeb03a49          VMOV.F32 s6,s18
;;;319          gnext1 = (fnext1 * (*pk++)) + gcurr1;
000178  eef03a64          VMOV.F32 s7,s9
00017c  1d24              ADDS     r4,r4,#4
00017e  ee453a80          VMLA.F32 s7,s11,s0
;;;320    
;;;321          stageCnt--;
000182  1e6d              SUBS     r5,r5,#1
                  |L1.388|
000184  2d00              CMP      r5,#0                 ;219
000186  f47faf78          BNE      |L1.122|
;;;322        }
;;;323    
;;;324        /* If the (filter length -1) is not a multiple of 4, compute the remaining filter taps */
;;;325        stageCnt = (numStages - 1u) % 0x4u;
00018a  f0070503          AND      r5,r7,#3
;;;326    
;;;327        while(stageCnt > 0u)
00018e  e02f              B        |L1.496|
                  |L1.400|
;;;328        {
;;;329          gcurr1 = *px;
000190  edd04a00          VLDR     s9,[r0,#0]
;;;330    
;;;331          /* save g value in state buffer */
;;;332          *px++ = gnext4;
000194  eca04a01          VSTM     r0!,{s8}
;;;333    
;;;334          /* Process four samples for last three taps here */
;;;335          fnext1 = fcurr1 + ((*pk) * gcurr1);
000198  ed940a00          VLDR     s0,[r4,#0]
00019c  eeb05a41          VMOV.F32 s10,s2
0001a0  ee005a24          VMLA.F32 s10,s0,s9
;;;336          fnext2 = fcurr2 + ((*pk) * gnext1);
0001a4  eef05a61          VMOV.F32 s11,s3
0001a8  ee405a23          VMLA.F32 s11,s0,s7
;;;337          fnext3 = fcurr3 + ((*pk) * gnext2);
0001ac  eeb06a60          VMOV.F32 s12,s1
0001b0  ee006a03          VMLA.F32 s12,s0,s6
;;;338          fnext4 = fcurr4 + ((*pk) * gnext3);
0001b4  eef06a42          VMOV.F32 s13,s4
0001b8  ee406a22          VMLA.F32 s13,s0,s5
;;;339    
;;;340          /* g1(n) = f0(n) * K1  +  g0(n-1) */
;;;341          gnext4 = (fcurr4 * (*pk)) + gnext3;
0001bc  eeb04a62          VMOV.F32 s8,s5
0001c0  ee024a00          VMLA.F32 s8,s4,s0
;;;342          gnext3 = (fcurr3 * (*pk)) + gnext2;
0001c4  eef02a43          VMOV.F32 s5,s6
0001c8  ee402a80          VMLA.F32 s5,s1,s0
;;;343          gnext2 = (fcurr2 * (*pk)) + gnext1;
0001cc  eeb03a63          VMOV.F32 s6,s7
0001d0  ee013a80          VMLA.F32 s6,s3,s0
;;;344          gnext1 = (fcurr1 * (*pk++)) + gcurr1;
0001d4  eef03a64          VMOV.F32 s7,s9
0001d8  1d24              ADDS     r4,r4,#4
0001da  ee413a00          VMLA.F32 s7,s2,s0
;;;345    
;;;346          /* Update of f values for next coefficient set processing */
;;;347          fcurr1 = fnext1;
0001de  eeb01a45          VMOV.F32 s2,s10
;;;348          fcurr2 = fnext2;
0001e2  eef01a65          VMOV.F32 s3,s11
;;;349          fcurr3 = fnext3;
0001e6  eef00a46          VMOV.F32 s1,s12
;;;350          fcurr4 = fnext4;
0001ea  eeb02a66          VMOV.F32 s4,s13
;;;351    
;;;352          stageCnt--;
0001ee  1e6d              SUBS     r5,r5,#1
                  |L1.496|
0001f0  2d00              CMP      r5,#0                 ;327
0001f2  d1cd              BNE      |L1.400|
;;;353    
;;;354        }
;;;355    
;;;356        /* The results in the 4 accumulators, store in the destination buffer. */
;;;357        /* y(n) = fN(n) */
;;;358        *pDst++ = fcurr1;
0001f4  eca21a01          VSTM     r2!,{s2}
;;;359        *pDst++ = fcurr2;
0001f8  ece21a01          VSTM     r2!,{s3}
;;;360        *pDst++ = fcurr3;
0001fc  ece20a01          VSTM     r2!,{s1}
;;;361        *pDst++ = fcurr4;
000200  eca22a01          VSTM     r2!,{s4}
;;;362    
;;;363        blkCnt--;
000204  1e76              SUBS     r6,r6,#1
                  |L1.518|
000206  2e00              CMP      r6,#0                 ;161
000208  f47faf06          BNE      |L1.24|
;;;364      }
;;;365    
;;;366      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;367       ** No loop unrolling is used. */
;;;368      blkCnt = blockSize % 0x4u;
00020c  f0030003          AND      r0,r3,#3
;;;369    
;;;370      while(blkCnt > 0u)
000210  e02a              B        |L1.616|
                  |L1.530|
;;;371      {
;;;372        /* f0(n) = x(n) */
;;;373        fcurr1 = *pSrc++;
000212  ecf10a01          VLDM     r1!,{s1}
;;;374    
;;;375        /* Initialize coeff pointer */
;;;376        pk = (pCoeffs);
000216  4666              MOV      r6,r12
;;;377    
;;;378        /* Initialize state pointer */
;;;379        px = pState;
000218  464d              MOV      r5,r9
;;;380    
;;;381        /* read g2(n) from state buffer */
;;;382        gcurr1 = *px;
00021a  edd51a00          VLDR     s3,[r5,#0]
;;;383    
;;;384        /* for sample 1 processing */
;;;385        /* f1(n) = f0(n) +  K1 * g0(n-1) */
;;;386        fnext1 = fcurr1 + ((*pk) * gcurr1);
00021e  ed961a00          VLDR     s2,[r6,#0]
000222  eeb00a60          VMOV.F32 s0,s1
000226  ee010a21          VMLA.F32 s0,s2,s3
;;;387        /* g1(n) = f0(n) * K1  +  g0(n-1) */
;;;388        gnext1 = (fcurr1 * (*pk++)) + gcurr1;
00022a  ee401a81          VMLA.F32 s3,s1,s2
00022e  1d36              ADDS     r6,r6,#4
;;;389    
;;;390        /* save g1(n) in state buffer */
;;;391        *px++ = fcurr1;
000230  ece50a01          VSTM     r5!,{s1}
;;;392    
;;;393        /* f1(n) is saved in fcurr1    
;;;394           for next stage processing */
;;;395        fcurr1 = fnext1;
;;;396    
;;;397        stageCnt = (numStages - 1u);
000234  f1a80701          SUB      r7,r8,#1
;;;398    
;;;399        /* stage loop */
;;;400        while(stageCnt > 0u)
000238  e011              B        |L1.606|
                  |L1.570|
;;;401        {
;;;402          /* read g2(n) from state buffer */
;;;403          gcurr1 = *px;
00023a  edd50a00          VLDR     s1,[r5,#0]
;;;404    
;;;405          /* save g1(n) in state buffer */
;;;406          *px++ = gnext1;
00023e  ece51a01          VSTM     r5!,{s3}
;;;407    
;;;408          /* Sample processing for K2, K3.... */
;;;409          /* f2(n) = f1(n) +  K2 * g1(n-1) */
;;;410          fnext1 = fcurr1 + ((*pk) * gcurr1);
000242  ed961a00          VLDR     s2,[r6,#0]
000246  eeb02a40          VMOV.F32 s4,s0
00024a  ee012a20          VMLA.F32 s4,s2,s1
;;;411          /* g2(n) = f1(n) * K2  +  g1(n-1) */
;;;412          gnext1 = (fcurr1 * (*pk++)) + gcurr1;
00024e  ee400a01          VMLA.F32 s1,s0,s2
000252  1d36              ADDS     r6,r6,#4
000254  eef01a60          VMOV.F32 s3,s1
;;;413    
;;;414          /* f1(n) is saved in fcurr1    
;;;415             for next stage processing */
;;;416          fcurr1 = fnext1;
000258  eeb00a42          VMOV.F32 s0,s4
;;;417    
;;;418          stageCnt--;
00025c  1e7f              SUBS     r7,r7,#1
                  |L1.606|
00025e  2f00              CMP      r7,#0                 ;400
000260  d1eb              BNE      |L1.570|
;;;419    
;;;420        }
;;;421    
;;;422        /* y(n) = fN(n) */
;;;423        *pDst++ = fcurr1;
000262  eca20a01          VSTM     r2!,{s0}
;;;424    
;;;425        blkCnt--;
000266  1e40              SUBS     r0,r0,#1
                  |L1.616|
000268  2800              CMP      r0,#0                 ;370
00026a  d1d2              BNE      |L1.530|
;;;426    
;;;427      }
;;;428    
;;;429    #else
;;;430    
;;;431      /* Run the below code for Cortex-M0 */
;;;432    
;;;433      float32_t fcurr, fnext, gcurr, gnext;          /* temporary variables */
;;;434      uint32_t numStages = S->numStages;             /* Length of the filter */
;;;435      uint32_t blkCnt, stageCnt;                     /* temporary variables for counts */
;;;436    
;;;437      pState = &S->pState[0];
;;;438    
;;;439      blkCnt = blockSize;
;;;440    
;;;441      while(blkCnt > 0u)
;;;442      {
;;;443        /* f0(n) = x(n) */
;;;444        fcurr = *pSrc++;
;;;445    
;;;446        /* Initialize coeff pointer */
;;;447        pk = pCoeffs;
;;;448    
;;;449        /* Initialize state pointer */
;;;450        px = pState;
;;;451    
;;;452        /* read g0(n-1) from state buffer */
;;;453        gcurr = *px;
;;;454    
;;;455        /* for sample 1 processing */
;;;456        /* f1(n) = f0(n) +  K1 * g0(n-1) */
;;;457        fnext = fcurr + ((*pk) * gcurr);
;;;458        /* g1(n) = f0(n) * K1  +  g0(n-1) */
;;;459        gnext = (fcurr * (*pk++)) + gcurr;
;;;460    
;;;461        /* save f0(n) in state buffer */
;;;462        *px++ = fcurr;
;;;463    
;;;464        /* f1(n) is saved in fcurr            
;;;465           for next stage processing */
;;;466        fcurr = fnext;
;;;467    
;;;468        stageCnt = (numStages - 1u);
;;;469    
;;;470        /* stage loop */
;;;471        while(stageCnt > 0u)
;;;472        {
;;;473          /* read g2(n) from state buffer */
;;;474          gcurr = *px;
;;;475    
;;;476          /* save g1(n) in state buffer */
;;;477          *px++ = gnext;
;;;478    
;;;479          /* Sample processing for K2, K3.... */
;;;480          /* f2(n) = f1(n) +  K2 * g1(n-1) */
;;;481          fnext = fcurr + ((*pk) * gcurr);
;;;482          /* g2(n) = f1(n) * K2  +  g1(n-1) */
;;;483          gnext = (fcurr * (*pk++)) + gcurr;
;;;484    
;;;485          /* f1(n) is saved in fcurr1            
;;;486             for next stage processing */
;;;487          fcurr = fnext;
;;;488    
;;;489          stageCnt--;
;;;490    
;;;491        }
;;;492    
;;;493        /* y(n) = fN(n) */
;;;494        *pDst++ = fcurr;
;;;495    
;;;496        blkCnt--;
;;;497    
;;;498      }
;;;499    
;;;500    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;501    
;;;502    }
00026c  ecbd8b04          VPOP     {d8-d9}
000270  e8bd83f0          POP      {r4-r9,pc}
;;;503    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_fir_lattice_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_fir_lattice_f32_c_9890ec63____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___21_arm_fir_lattice_f32_c_9890ec63____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_fir_lattice_f32_c_9890ec63____REVSH|
#line 144
|__asm___21_arm_fir_lattice_f32_c_9890ec63____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_fir_lattice_f32_c_9890ec63____RRX|
#line 300
|__asm___21_arm_fir_lattice_f32_c_9890ec63____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
