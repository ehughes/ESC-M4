; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_fast_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_fast_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_fir_fast_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_fir_fast_q15.c]
                          THUMB

                          AREA ||i.arm_fir_fast_q15||, CODE, READONLY, ALIGN=1

                  arm_fir_fast_q15 PROC
;;;71     
;;;72     void arm_fir_fast_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;73       const arm_fir_instance_q15 * S,
;;;74       q15_t * pSrc,
;;;75       q15_t * pDst,
;;;76       uint32_t blockSize)
;;;77     {
000004  b085              SUB      sp,sp,#0x14
;;;78       q15_t *pState = S->pState;                     /* State pointer */
000006  9805              LDR      r0,[sp,#0x14]
000008  6843              LDR      r3,[r0,#4]
;;;79       q15_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
00000a  9805              LDR      r0,[sp,#0x14]
00000c  6880              LDR      r0,[r0,#8]
00000e  9003              STR      r0,[sp,#0xc]
;;;80       q15_t *pStateCurnt;                            /* Points to the current sample of the state */
;;;81       q31_t acc0, acc1, acc2, acc3;                  /* Accumulators */
;;;82       q15_t *pb;                                     /* Temporary pointer for coefficient buffer */
;;;83       q15_t *px;                                     /* Temporary q31 pointer for SIMD state buffer accesses */
;;;84       q31_t x0, x1, x2, c0;                          /* Temporary variables to hold SIMD state and coefficient values */
;;;85       uint32_t numTaps = S->numTaps;                 /* Number of taps in the filter */
000010  9805              LDR      r0,[sp,#0x14]
000012  8800              LDRH     r0,[r0,#0]
000014  9002              STR      r0,[sp,#8]
;;;86       uint32_t tapCnt, blkCnt;                       /* Loop counters */
;;;87     
;;;88     
;;;89       /* S->pState points to state array which contains previous frame (numTaps - 1) samples */
;;;90       /* pStateCurnt points to the location where the new input data should be written */
;;;91       pStateCurnt = &(S->pState[(numTaps - 1u)]);
000016  9802              LDR      r0,[sp,#8]
000018  1e40              SUBS     r0,r0,#1
00001a  eb030a40          ADD      r10,r3,r0,LSL #1
00001e  9004              STR      r0,[sp,#0x10]
;;;92     
;;;93       /* Apply loop unrolling and compute 4 output values simultaneously.      
;;;94        * The variables acc0 ... acc3 hold output values that are being computed:      
;;;95        *      
;;;96        *    acc0 =  b[numTaps-1] * x[n-numTaps-1] + b[numTaps-2] * x[n-numTaps-2] + b[numTaps-3] * x[n-numTaps-3] +...+ b[0] * x[0]      
;;;97        *    acc1 =  b[numTaps-1] * x[n-numTaps] +   b[numTaps-2] * x[n-numTaps-1] + b[numTaps-3] * x[n-numTaps-2] +...+ b[0] * x[1]      
;;;98        *    acc2 =  b[numTaps-1] * x[n-numTaps+1] + b[numTaps-2] * x[n-numTaps] +   b[numTaps-3] * x[n-numTaps-1] +...+ b[0] * x[2]      
;;;99        *    acc3 =  b[numTaps-1] * x[n-numTaps+2] + b[numTaps-2] * x[n-numTaps+1] + b[numTaps-3] * x[n-numTaps]   +...+ b[0] * x[3]      
;;;100       */
;;;101    
;;;102      blkCnt = blockSize >> 2;
000020  9808              LDR      r0,[sp,#0x20]
000022  0880              LSRS     r0,r0,#2
000024  9000              STR      r0,[sp,#0]
000026  e062              B        |L1.238|
                  |L1.40|
;;;103    
;;;104      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.      
;;;105       ** a second loop below computes the remaining 1 to 3 samples. */
;;;106      while(blkCnt > 0u)
;;;107      {
;;;108        /* Copy four new input samples into the state buffer.      
;;;109         ** Use 32-bit SIMD to move the 16-bit data.  Only requires two copies. */
;;;110        *pStateCurnt++ = *pSrc++;
000028  8808              LDRH     r0,[r1,#0]
00002a  f82a0b02          STRH     r0,[r10],#2
;;;111        *pStateCurnt++ = *pSrc++;
00002e  8848              LDRH     r0,[r1,#2]
000030  f82a0b02          STRH     r0,[r10],#2
;;;112        *pStateCurnt++ = *pSrc++;
000034  8888              LDRH     r0,[r1,#4]
000036  f82a0b02          STRH     r0,[r10],#2
;;;113        *pStateCurnt++ = *pSrc++;
00003a  88c8              LDRH     r0,[r1,#6]
00003c  3108              ADDS     r1,r1,#8
00003e  f82a0b02          STRH     r0,[r10],#2
;;;114    
;;;115    
;;;116        /* Set all accumulators to zero */
;;;117        acc0 = 0;
000042  2700              MOVS     r7,#0
;;;118        acc1 = 0;
000044  46bc              MOV      r12,r7
;;;119        acc2 = 0;
000046  46b8              MOV      r8,r7
;;;120        acc3 = 0;
000048  46b9              MOV      r9,r7
;;;121    
;;;122        /* Typecast q15_t pointer to q31_t pointer for state reading in q31_t */
;;;123        px = pState;
00004a  461d              MOV      r5,r3
;;;124    
;;;125        /* Typecast q15_t pointer to q31_t pointer for coefficient reading in q31_t */
;;;126        pb = pCoeffs;
00004c  f8ddb00c          LDR      r11,[sp,#0xc]
;;;127    
;;;128        /* Read the first two samples from the state buffer:  x[n-N], x[n-N-1] */
;;;129        x0 = *__SIMD32(px)++;
000050  682c              LDR      r4,[r5,#0]
;;;130    
;;;131        /* Read the third and forth samples from the state buffer: x[n-N-2], x[n-N-3] */
;;;132        x2 = *__SIMD32(px)++;
000052  6868              LDR      r0,[r5,#4]
000054  3508              ADDS     r5,r5,#8
;;;133    
;;;134        /* Loop over the number of taps.  Unroll by a factor of 4.      
;;;135         ** Repeat until we've computed numTaps-(numTaps%4) coefficients. */
;;;136        tapCnt = numTaps >> 2;
000056  9e02              LDR      r6,[sp,#8]
000058  08b6              LSRS     r6,r6,#2
00005a  9601              STR      r6,[sp,#4]
;;;137    
;;;138        while(tapCnt > 0)
00005c  e01f              B        |L1.158|
                  |L1.94|
;;;139        {
;;;140          /* Read the first two coefficients using SIMD:  b[N] and b[N-1] coefficients */
;;;141          c0 = *__SIMD32(pb)++;
00005e  f85b6b04          LDR      r6,[r11],#4
;;;142    
;;;143          /* acc0 +=  b[N] * x[n-N] + b[N-1] * x[n-N-1] */
;;;144          acc0 = __SMLAD(x0, c0, acc0);
000062  fb247706          SMLAD    r7,r4,r6,r7
;;;145    
;;;146          /* acc2 +=  b[N] * x[n-N-2] + b[N-1] * x[n-N-3] */
;;;147          acc2 = __SMLAD(x2, c0, acc2);
000066  fb208806          SMLAD    r8,r0,r6,r8
;;;148    
;;;149          /* pack  x[n-N-1] and x[n-N-2] */
;;;150    #ifndef ARM_MATH_BIG_ENDIAN
;;;151          x1 = __PKHBT(x2, x0, 0);
00006a  eac00e04          PKHBT    lr,r0,r4
;;;152    #else
;;;153          x1 = __PKHBT(x0, x2, 0);
;;;154    #endif
;;;155    
;;;156          /* Read state x[n-N-4], x[n-N-5] */
;;;157          x0 = _SIMD32_OFFSET(px);
00006e  682c              LDR      r4,[r5,#0]
;;;158    
;;;159          /* acc1 +=  b[N] * x[n-N-1] + b[N-1] * x[n-N-2] */
;;;160          acc1 = __SMLADX(x1, c0, acc1);
000070  fb2ece16          SMLADX   lr,lr,r6,r12
;;;161    
;;;162          /* pack  x[n-N-3] and x[n-N-4] */
;;;163    #ifndef ARM_MATH_BIG_ENDIAN
;;;164          x1 = __PKHBT(x0, x2, 0);
000074  eac40c00          PKHBT    r12,r4,r0
;;;165    #else
;;;166          x1 = __PKHBT(x2, x0, 0);
;;;167    #endif
;;;168    
;;;169          /* acc3 +=  b[N] * x[n-N-3] + b[N-1] * x[n-N-4] */
;;;170          acc3 = __SMLADX(x1, c0, acc3);
000078  fb2c9916          SMLADX   r9,r12,r6,r9
;;;171    
;;;172          /* Read coefficients b[N-2], b[N-3] */
;;;173          c0 = *__SIMD32(pb)++;
00007c  f85b6b04          LDR      r6,[r11],#4
;;;174    
;;;175          /* acc0 +=  b[N-2] * x[n-N-2] + b[N-3] * x[n-N-3] */
;;;176          acc0 = __SMLAD(x2, c0, acc0);
000080  fb207706          SMLAD    r7,r0,r6,r7
;;;177    
;;;178          /* Read state x[n-N-6], x[n-N-7] with offset */
;;;179          x2 = _SIMD32_OFFSET(px + 2u);
000084  6868              LDR      r0,[r5,#4]
;;;180    
;;;181          /* acc2 +=  b[N-2] * x[n-N-4] + b[N-3] * x[n-N-5] */
;;;182          acc2 = __SMLAD(x0, c0, acc2);
000086  fb248806          SMLAD    r8,r4,r6,r8
;;;183    
;;;184          /* acc1 +=  b[N-2] * x[n-N-3] + b[N-3] * x[n-N-4] */
;;;185          acc1 = __SMLADX(x1, c0, acc1);
00008a  fb2cec16          SMLADX   r12,r12,r6,lr
;;;186    
;;;187          /* pack  x[n-N-5] and x[n-N-6] */
;;;188    #ifndef ARM_MATH_BIG_ENDIAN
;;;189          x1 = __PKHBT(x2, x0, 0);
00008e  eac00e04          PKHBT    lr,r0,r4
;;;190    #else
;;;191          x1 = __PKHBT(x0, x2, 0);
;;;192    #endif
;;;193    
;;;194          /* acc3 +=  b[N-2] * x[n-N-5] + b[N-3] * x[n-N-6] */
;;;195          acc3 = __SMLADX(x1, c0, acc3);
000092  fb2e9916          SMLADX   r9,lr,r6,r9
;;;196    
;;;197          /* Update state pointer for next state reading */
;;;198          px += 4u;
000096  3508              ADDS     r5,r5,#8
;;;199    
;;;200          /* Decrement tap count */
;;;201          tapCnt--;
000098  9e01              LDR      r6,[sp,#4]
00009a  1e76              SUBS     r6,r6,#1
00009c  9601              STR      r6,[sp,#4]
                  |L1.158|
00009e  9e01              LDR      r6,[sp,#4]            ;138
0000a0  2e00              CMP      r6,#0                 ;138
0000a2  d1dc              BNE      |L1.94|
;;;202    
;;;203        }
;;;204    
;;;205        /* If the filter length is not a multiple of 4, compute the remaining filter taps.       
;;;206         ** This is always be 2 taps since the filter length is even. */
;;;207        if((numTaps & 0x3u) != 0u)
0000a4  9e02              LDR      r6,[sp,#8]
0000a6  07b6              LSLS     r6,r6,#30
0000a8  d00e              BEQ      |L1.200|
;;;208        {
;;;209    
;;;210          /* Read last two coefficients */
;;;211          c0 = *__SIMD32(pb)++;
0000aa  f8db6000          LDR      r6,[r11,#0]
;;;212    
;;;213          /* Perform the multiply-accumulates */
;;;214          acc0 = __SMLAD(x0, c0, acc0);
0000ae  fb247706          SMLAD    r7,r4,r6,r7
;;;215          acc2 = __SMLAD(x2, c0, acc2);
0000b2  fb208806          SMLAD    r8,r0,r6,r8
;;;216    
;;;217          /* pack state variables */
;;;218    #ifndef ARM_MATH_BIG_ENDIAN
;;;219          x1 = __PKHBT(x2, x0, 0);
0000b6  eac00404          PKHBT    r4,r0,r4
;;;220    #else
;;;221          x1 = __PKHBT(x0, x2, 0);
;;;222    #endif
;;;223    
;;;224          /* Read last state variables */
;;;225          x0 = *__SIMD32(px);
0000ba  682d              LDR      r5,[r5,#0]
;;;226    
;;;227          /* Perform the multiply-accumulates */
;;;228          acc1 = __SMLADX(x1, c0, acc1);
0000bc  fb24cc16          SMLADX   r12,r4,r6,r12
;;;229    
;;;230          /* pack state variables */
;;;231    #ifndef ARM_MATH_BIG_ENDIAN
;;;232          x1 = __PKHBT(x0, x2, 0);
0000c0  eac50000          PKHBT    r0,r5,r0
;;;233    #else
;;;234          x1 = __PKHBT(x2, x0, 0);
;;;235    #endif
;;;236    
;;;237          /* Perform the multiply-accumulates */
;;;238          acc3 = __SMLADX(x1, c0, acc3);
0000c4  fb209916          SMLADX   r9,r0,r6,r9
                  |L1.200|
;;;239        }
;;;240    
;;;241        /* The results in the 4 accumulators are in 2.30 format.  Convert to 1.15 with saturation.       
;;;242         ** Then store the 4 outputs in the destination buffer. */
;;;243    
;;;244    #ifndef ARM_MATH_BIG_ENDIAN
;;;245    
;;;246        *__SIMD32(pDst)++ =
0000c8  f32730cf          SSAT     r0,#16,r7,ASR #15
0000cc  f32c34cf          SSAT     r4,#16,r12,ASR #15
0000d0  eac04004          PKHBT    r0,r0,r4,LSL #16
0000d4  6010              STR      r0,[r2,#0]
;;;247          __PKHBT(__SSAT((acc0 >> 15), 16), __SSAT((acc1 >> 15), 16), 16);
;;;248    
;;;249        *__SIMD32(pDst)++ =
0000d6  f32830cf          SSAT     r0,#16,r8,ASR #15
0000da  f32934cf          SSAT     r4,#16,r9,ASR #15
0000de  eac04004          PKHBT    r0,r0,r4,LSL #16
0000e2  6050              STR      r0,[r2,#4]
0000e4  3208              ADDS     r2,r2,#8
;;;250          __PKHBT(__SSAT((acc2 >> 15), 16), __SSAT((acc3 >> 15), 16), 16);
;;;251    
;;;252    #else
;;;253    
;;;254        *__SIMD32(pDst)++ =
;;;255          __PKHBT(__SSAT((acc1 >> 15), 16), __SSAT((acc0 >> 15), 16), 16);
;;;256    
;;;257        *__SIMD32(pDst)++ =
;;;258          __PKHBT(__SSAT((acc3 >> 15), 16), __SSAT((acc2 >> 15), 16), 16);
;;;259    
;;;260    
;;;261    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN       */
;;;262    
;;;263        /* Advance the state pointer by 4 to process the next group of 4 samples */
;;;264        pState = pState + 4u;
0000e6  3308              ADDS     r3,r3,#8
;;;265    
;;;266        /* Decrement the loop counter */
;;;267        blkCnt--;
0000e8  9800              LDR      r0,[sp,#0]
0000ea  1e40              SUBS     r0,r0,#1
0000ec  9000              STR      r0,[sp,#0]
                  |L1.238|
0000ee  9800              LDR      r0,[sp,#0]            ;106
0000f0  2800              CMP      r0,#0                 ;106
0000f2  d199              BNE      |L1.40|
;;;268      }
;;;269    
;;;270      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.      
;;;271       ** No loop unrolling is used. */
;;;272      blkCnt = blockSize % 0x4u;
0000f4  9808              LDR      r0,[sp,#0x20]
0000f6  f0000703          AND      r7,r0,#3
;;;273      while(blkCnt > 0u)
0000fa  e01d              B        |L1.312|
                  |L1.252|
;;;274      {
;;;275        /* Copy two samples into state buffer */
;;;276        *pStateCurnt++ = *pSrc++;
0000fc  f8310b02          LDRH     r0,[r1],#2
000100  f82a0b02          STRH     r0,[r10],#2
;;;277    
;;;278        /* Set the accumulator to zero */
;;;279        acc0 = 0;
000104  2600              MOVS     r6,#0
;;;280    
;;;281        /* Use SIMD to hold states and coefficients */
;;;282        px = pState;
000106  461c              MOV      r4,r3
;;;283        pb = pCoeffs;
000108  9803              LDR      r0,[sp,#0xc]
;;;284    
;;;285        tapCnt = numTaps >> 1u;
00010a  9d02              LDR      r5,[sp,#8]
00010c  086d              LSRS     r5,r5,#1
                  |L1.270|
;;;286    
;;;287        do
;;;288        {
;;;289    
;;;290          acc0 += (q31_t) * px++ * *pb++;
00010e  f834cb02          LDRH     r12,[r4],#2
000112  f8308b02          LDRH     r8,[r0],#2
000116  fb1c6608          SMLABB   r6,r12,r8,r6
;;;291    	  acc0 += (q31_t) * px++ * *pb++;
00011a  f834cb02          LDRH     r12,[r4],#2
00011e  f8308b02          LDRH     r8,[r0],#2
000122  fb1c6608          SMLABB   r6,r12,r8,r6
;;;292    
;;;293          tapCnt--;
000126  1e6d              SUBS     r5,r5,#1
;;;294        }
;;;295        while(tapCnt > 0u);
000128  2d00              CMP      r5,#0
00012a  d1f0              BNE      |L1.270|
;;;296    
;;;297        /* The result is in 2.30 format.  Convert to 1.15 with saturation.      
;;;298         ** Then store the output in the destination buffer. */
;;;299        *pDst++ = (q15_t) (__SSAT((acc0 >> 15), 16));
00012c  f32630cf          SSAT     r0,#16,r6,ASR #15
000130  f8220b02          STRH     r0,[r2],#2
;;;300    
;;;301        /* Advance state pointer by 1 for the next sample */
;;;302        pState = pState + 1u;
000134  1c9b              ADDS     r3,r3,#2
;;;303    
;;;304        /* Decrement the loop counter */
;;;305        blkCnt--;
000136  1e7f              SUBS     r7,r7,#1
                  |L1.312|
000138  2f00              CMP      r7,#0                 ;273
00013a  d1df              BNE      |L1.252|
;;;306      }
;;;307    
;;;308      /* Processing is complete.      
;;;309       ** Now copy the last numTaps - 1 samples to the satrt of the state buffer.      
;;;310       ** This prepares the state buffer for the next function call. */
;;;311    
;;;312      /* Points to the start of the state buffer */
;;;313      pStateCurnt = S->pState;
00013c  9805              LDR      r0,[sp,#0x14]
00013e  6840              LDR      r0,[r0,#4]
;;;314    
;;;315      /* Calculation of count for copying integer writes */
;;;316      tapCnt = (numTaps - 1u) >> 2;
000140  9904              LDR      r1,[sp,#0x10]
000142  0889              LSRS     r1,r1,#2
;;;317    
;;;318      while(tapCnt > 0u)
000144  e00a              B        |L1.348|
                  |L1.326|
;;;319      {
;;;320        *pStateCurnt++ = *pState++;
000146  881a              LDRH     r2,[r3,#0]
000148  8002              STRH     r2,[r0,#0]
;;;321        *pStateCurnt++ = *pState++;
00014a  885a              LDRH     r2,[r3,#2]
00014c  8042              STRH     r2,[r0,#2]
;;;322        *pStateCurnt++ = *pState++;
00014e  889a              LDRH     r2,[r3,#4]
000150  8082              STRH     r2,[r0,#4]
;;;323        *pStateCurnt++ = *pState++;
000152  88da              LDRH     r2,[r3,#6]
000154  3308              ADDS     r3,r3,#8
000156  80c2              STRH     r2,[r0,#6]
000158  3008              ADDS     r0,r0,#8
;;;324    
;;;325        tapCnt--;
00015a  1e49              SUBS     r1,r1,#1
                  |L1.348|
00015c  2900              CMP      r1,#0                 ;318
00015e  d1f2              BNE      |L1.326|
;;;326    
;;;327      }
;;;328    
;;;329      /* Calculation of count for remaining q15_t data */
;;;330      tapCnt = (numTaps - 1u) % 0x4u;
000160  9904              LDR      r1,[sp,#0x10]
000162  f0010103          AND      r1,r1,#3
;;;331    
;;;332      /* copy remaining data */
;;;333      while(tapCnt > 0u)
000166  e004              B        |L1.370|
                  |L1.360|
;;;334      {
;;;335        *pStateCurnt++ = *pState++;
000168  f8332b02          LDRH     r2,[r3],#2
00016c  f8202b02          STRH     r2,[r0],#2
;;;336    
;;;337        /* Decrement the loop counter */
;;;338        tapCnt--;
000170  1e49              SUBS     r1,r1,#1
                  |L1.370|
000172  2900              CMP      r1,#0                 ;333
000174  d1f8              BNE      |L1.360|
;;;339      }
;;;340    
;;;341    }
000176  b009              ADD      sp,sp,#0x24
000178  e8bd8ff0          POP      {r4-r11,pc}
;;;342    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_fir_fast_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_fir_fast_q15_c_9f269210____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___18_arm_fir_fast_q15_c_9f269210____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_fir_fast_q15_c_9f269210____REVSH|
#line 144
|__asm___18_arm_fir_fast_q15_c_9f269210____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_fir_fast_q15_c_9f269210____RRX|
#line 300
|__asm___18_arm_fir_fast_q15_c_9f269210____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
