; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_conv_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_q31.c]
                          THUMB

                          AREA ||i.arm_conv_q31||, CODE, READONLY, ALIGN=1

                  arm_conv_q31 PROC
;;;77     
;;;78     void arm_conv_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;79       q31_t * pSrcA,
;;;80       uint32_t srcALen,
;;;81       q31_t * pSrcB,
;;;82       uint32_t srcBLen,
;;;83       q31_t * pDst)
;;;84     {
000004  b089              SUB      sp,sp,#0x24
000006  f8ddc058          LDR      r12,[sp,#0x58]
;;;85     
;;;86     
;;;87     #ifndef ARM_MATH_CM0_FAMILY
;;;88     
;;;89       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;90     
;;;91       q31_t *pIn1;                                   /* inputA pointer */
;;;92       q31_t *pIn2;                                   /* inputB pointer */
;;;93       q31_t *pOut = pDst;                            /* output pointer */
;;;94       q31_t *px;                                     /* Intermediate inputA pointer  */
;;;95       q31_t *py;                                     /* Intermediate inputB pointer  */
;;;96       q31_t *pSrc1, *pSrc2;                          /* Intermediate pointers */
;;;97       q63_t sum;                                     /* Accumulator */
;;;98       q63_t acc0, acc1, acc2;                        /* Accumulator */
;;;99       q31_t x0, x1, x2, c0;                          /* Temporary variables to hold state and coefficient values */
;;;100      uint32_t j, k, count, blkCnt, blockSize1, blockSize2, blockSize3;     /* loop counter */
;;;101    
;;;102      /* The algorithm implementation is based on the lengths of the inputs. */
;;;103      /* srcB is always made to slide across srcA. */
;;;104      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;105      if(srcALen >= srcBLen)
00000a  990a              LDR      r1,[sp,#0x28]
00000c  4299              CMP      r1,r3
00000e  d302              BCC      |L1.22|
;;;106      {
;;;107        /* Initialization of inputA pointer */
;;;108        pIn1 = pSrcA;
000010  9006              STR      r0,[sp,#0x18]
;;;109    
;;;110        /* Initialization of inputB pointer */
;;;111        pIn2 = pSrcB;
000012  4610              MOV      r0,r2
000014  e003              B        |L1.30|
                  |L1.22|
;;;112      }
;;;113      else
;;;114      {
;;;115        /* Initialization of inputA pointer */
;;;116        pIn1 = (q31_t *) pSrcB;
000016  9206              STR      r2,[sp,#0x18]
;;;117    
;;;118        /* Initialization of inputB pointer */
;;;119        pIn2 = (q31_t *) pSrcA;
;;;120    
;;;121        /* srcBLen is always considered as shorter or equal to srcALen */
;;;122        j = srcBLen;
000018  4619              MOV      r1,r3
;;;123        srcBLen = srcALen;
00001a  9b0a              LDR      r3,[sp,#0x28]
;;;124        srcALen = j;
00001c  910a              STR      r1,[sp,#0x28]
                  |L1.30|
;;;125      }
;;;126    
;;;127      /* conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1] */
;;;128      /* The function is internally    
;;;129       * divided into three stages according to the number of multiplications that has to be    
;;;130       * taken place between inputA samples and inputB samples. In the first stage of the    
;;;131       * algorithm, the multiplications increase by one for every iteration.    
;;;132       * In the second stage of the algorithm, srcBLen number of multiplications are done.    
;;;133       * In the third stage of the algorithm, the multiplications decrease by one    
;;;134       * for every iteration. */
;;;135    
;;;136      /* The algorithm is implemented in three stages.    
;;;137         The loop counters of each stage is initiated here. */
;;;138      blockSize1 = srcBLen - 1u;
00001e  f1a30901          SUB      r9,r3,#1
;;;139      blockSize2 = srcALen - (srcBLen - 1u);
000022  990a              LDR      r1,[sp,#0x28]
000024  1ac9              SUBS     r1,r1,r3
000026  1c49              ADDS     r1,r1,#1
000028  9101              STR      r1,[sp,#4]
;;;140      blockSize3 = blockSize1;
00002a  f8cd9000          STR      r9,[sp,#0]
;;;141    
;;;142      /* --------------------------    
;;;143       * Initializations of stage1    
;;;144       * -------------------------*/
;;;145    
;;;146      /* sum = x[0] * y[0]    
;;;147       * sum = x[0] * y[1] + x[1] * y[0]    
;;;148       * ....    
;;;149       * sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]    
;;;150       */
;;;151    
;;;152      /* In this stage the MAC operations are increased by 1 for every iteration.    
;;;153         The count variable holds the number of MAC operations performed */
;;;154      count = 1u;
00002e  2101              MOVS     r1,#1
;;;155    
;;;156      /* Working pointer of inputA */
;;;157      px = pIn1;
000030  f8dd8018          LDR      r8,[sp,#0x18]
;;;158    
;;;159      /* Working pointer of inputB */
;;;160      py = pIn2;
000034  4607              MOV      r7,r0
;;;161    
;;;162    
;;;163      /* ------------------------    
;;;164       * Stage1 process    
;;;165       * ----------------------*/
;;;166    
;;;167      /* The first stage starts here */
;;;168      while(blockSize1 > 0u)
000036  e045              B        |L1.196|
                  |L1.56|
;;;169      {
;;;170        /* Accumulator is made zero for every iteration */
;;;171        sum = 0;
000038  2400              MOVS     r4,#0
00003a  4625              MOV      r5,r4
;;;172    
;;;173        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;174        k = count >> 2u;
00003c  088e              LSRS     r6,r1,#2
;;;175    
;;;176        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;177         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;178        while(k > 0u)
00003e  e024              B        |L1.138|
                  |L1.64|
;;;179        {
;;;180          /* x[0] * y[srcBLen - 1] */
;;;181          sum += (q63_t) * px++ * (*py--);
000040  f8582b04          LDR      r2,[r8],#4
000044  f857a904          LDR      r10,[r7],#-4
000048  fb82a20a          SMULL    r10,r2,r2,r10
00004c  eb1a0404          ADDS     r4,r10,r4
000050  4155              ADCS     r5,r5,r2
;;;182          /* x[1] * y[srcBLen - 2] */
;;;183          sum += (q63_t) * px++ * (*py--);
000052  f8582b04          LDR      r2,[r8],#4
000056  f857a904          LDR      r10,[r7],#-4
00005a  fb82a20a          SMULL    r10,r2,r2,r10
00005e  eb1a0404          ADDS     r4,r10,r4
000062  4155              ADCS     r5,r5,r2
;;;184          /* x[2] * y[srcBLen - 3] */
;;;185          sum += (q63_t) * px++ * (*py--);
000064  f8582b04          LDR      r2,[r8],#4
000068  f857a904          LDR      r10,[r7],#-4
00006c  fb82a20a          SMULL    r10,r2,r2,r10
000070  eb1a0404          ADDS     r4,r10,r4
000074  4155              ADCS     r5,r5,r2
;;;186          /* x[3] * y[srcBLen - 4] */
;;;187          sum += (q63_t) * px++ * (*py--);
000076  f8582b04          LDR      r2,[r8],#4
00007a  f857a904          LDR      r10,[r7],#-4
00007e  fb82a20a          SMULL    r10,r2,r2,r10
000082  eb1a0404          ADDS     r4,r10,r4
000086  4155              ADCS     r5,r5,r2
;;;188    
;;;189          /* Decrement the loop counter */
;;;190          k--;
000088  1e76              SUBS     r6,r6,#1
                  |L1.138|
00008a  2e00              CMP      r6,#0                 ;178
00008c  d1d8              BNE      |L1.64|
;;;191        }
;;;192    
;;;193        /* If the count is not a multiple of 4, compute any remaining MACs here.    
;;;194         ** No loop unrolling is used. */
;;;195        k = count % 0x4u;
00008e  f0010203          AND      r2,r1,#3
;;;196    
;;;197        while(k > 0u)
000092  e009              B        |L1.168|
                  |L1.148|
;;;198        {
;;;199          /* Perform the multiply-accumulate */
;;;200          sum += (q63_t) * px++ * (*py--);
000094  f8586b04          LDR      r6,[r8],#4
000098  f857a904          LDR      r10,[r7],#-4
00009c  fb86a60a          SMULL    r10,r6,r6,r10
0000a0  eb1a0404          ADDS     r4,r10,r4
0000a4  4175              ADCS     r5,r5,r6
;;;201    
;;;202          /* Decrement the loop counter */
;;;203          k--;
0000a6  1e52              SUBS     r2,r2,#1
                  |L1.168|
0000a8  2a00              CMP      r2,#0                 ;197
0000aa  d1f3              BNE      |L1.148|
;;;204        }
;;;205    
;;;206        /* Store the result in the accumulator in the destination buffer. */
;;;207        *pOut++ = (q31_t) (sum >> 31);
0000ac  0fe2              LSRS     r2,r4,#31
0000ae  ea420245          ORR      r2,r2,r5,LSL #1
0000b2  f84c2b04          STR      r2,[r12],#4
;;;208    
;;;209        /* Update the inputA and inputB pointers for next MAC calculation */
;;;210        py = pIn2 + count;
0000b6  eb000781          ADD      r7,r0,r1,LSL #2
;;;211        px = pIn1;
0000ba  f8dd8018          LDR      r8,[sp,#0x18]
;;;212    
;;;213        /* Increment the MAC count */
;;;214        count++;
0000be  1c49              ADDS     r1,r1,#1
;;;215    
;;;216        /* Decrement the loop counter */
;;;217        blockSize1--;
0000c0  f1a90901          SUB      r9,r9,#1
                  |L1.196|
0000c4  f1b90f00          CMP      r9,#0                 ;168
0000c8  d1b6              BNE      |L1.56|
;;;218      }
;;;219    
;;;220      /* --------------------------    
;;;221       * Initializations of stage2    
;;;222       * ------------------------*/
;;;223    
;;;224      /* sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0]    
;;;225       * sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0]    
;;;226       * ....    
;;;227       * sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]    
;;;228       */
;;;229    
;;;230      /* Working pointer of inputA */
;;;231      px = pIn1;
;;;232    
;;;233      /* Working pointer of inputB */
;;;234      pSrc2 = pIn2 + (srcBLen - 1u);
0000ca  1e59              SUBS     r1,r3,#1
0000cc  eb000281          ADD      r2,r0,r1,LSL #2
0000d0  e9cd2107          STRD     r2,r1,[sp,#0x1c]
0000d4  9205              STR      r2,[sp,#0x14]
;;;235      py = pSrc2;
0000d6  9a05              LDR      r2,[sp,#0x14]
;;;236    
;;;237      /* count is index by which the pointer pIn1 to be incremented */
;;;238      count = 0u;
0000d8  2000              MOVS     r0,#0
0000da  9003              STR      r0,[sp,#0xc]
;;;239    
;;;240      /* -------------------    
;;;241       * Stage2 process    
;;;242       * ------------------*/
;;;243    
;;;244      /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.    
;;;245       * So, to loop unroll over blockSize2,    
;;;246       * srcBLen should be greater than or equal to 4 */
;;;247      if(srcBLen >= 4u)
0000dc  2b04              CMP      r3,#4
0000de  d37d              BCC      |L1.476|
;;;248      {
;;;249        /* Loop unroll by 3 */
;;;250        blkCnt = blockSize2 / 3;
0000e0  9801              LDR      r0,[sp,#4]
0000e2  2103              MOVS     r1,#3
0000e4  fbb0f0f1          UDIV     r0,r0,r1
0000e8  9002              STR      r0,[sp,#8]
;;;251    
;;;252        while(blkCnt > 0u)
0000ea  e072              B        |L1.466|
                  |L1.236|
;;;253        {
;;;254          /* Set all accumulators to zero */
;;;255          acc0 = 0;
0000ec  2000              MOVS     r0,#0
0000ee  4601              MOV      r1,r0
;;;256          acc1 = 0;
0000f0  2400              MOVS     r4,#0
0000f2  4625              MOV      r5,r4
;;;257          acc2 = 0;
0000f4  2600              MOVS     r6,#0
0000f6  4637              MOV      r7,r6
;;;258    
;;;259          /* read x[0], x[1], x[2] samples */
;;;260          x0 = *(px++);
0000f8  f858ab04          LDR      r10,[r8],#4
;;;261          x1 = *(px++);
0000fc  f8589b04          LDR      r9,[r8],#4
;;;262    
;;;263          /* Apply loop unrolling and compute 3 MACs simultaneously. */
;;;264          k = srcBLen / 3;
000100  f04f0b03          MOV      r11,#3
000104  fbb3fbfb          UDIV     r11,r3,r11
000108  f8cdb010          STR      r11,[sp,#0x10]
                  |L1.268|
;;;265    
;;;266          /* First part of the processing with loop unrolling.  Compute 3 MACs at a time.        
;;;267           ** a second loop below computes MACs for the remaining 1 to 2 samples. */
;;;268          do
;;;269          {
;;;270            /* Read y[srcBLen - 1] sample */
;;;271            c0 = *(py);
00010c  f8d2e000          LDR      lr,[r2,#0]
;;;272    
;;;273            /* Read x[3] sample */
;;;274            x2 = *(px);
000110  f8d8b000          LDR      r11,[r8,#0]
;;;275    
;;;276            /* Perform the multiply-accumulates */
;;;277            /* acc0 +=  x[0] * y[srcBLen - 1] */
;;;278            acc0 += ((q63_t) x0 * c0);
000114  fbca010e          SMLAL    r0,r1,r10,lr
;;;279            /* acc1 +=  x[1] * y[srcBLen - 1] */
;;;280            acc1 += ((q63_t) x1 * c0);
000118  fbc9450e          SMLAL    r4,r5,r9,lr
;;;281            /* acc2 +=  x[2] * y[srcBLen - 1] */
;;;282            acc2 += ((q63_t) x2 * c0);
00011c  fbcb670e          SMLAL    r6,r7,r11,lr
;;;283    
;;;284            /* Read y[srcBLen - 2] sample */
;;;285            c0 = *(py - 1u);
000120  f852ec04          LDR      lr,[r2,#-4]
;;;286    
;;;287            /* Read x[4] sample */
;;;288            x0 = *(px + 1u);
000124  f8d8a004          LDR      r10,[r8,#4]
;;;289    
;;;290            /* Perform the multiply-accumulate */
;;;291            /* acc0 +=  x[1] * y[srcBLen - 2] */
;;;292            acc0 += ((q63_t) x1 * c0);
000128  fbc9010e          SMLAL    r0,r1,r9,lr
;;;293            /* acc1 +=  x[2] * y[srcBLen - 2] */
;;;294            acc1 += ((q63_t) x2 * c0);
00012c  fbcb450e          SMLAL    r4,r5,r11,lr
;;;295            /* acc2 +=  x[3] * y[srcBLen - 2] */
;;;296            acc2 += ((q63_t) x0 * c0);
000130  fbca670e          SMLAL    r6,r7,r10,lr
;;;297    
;;;298            /* Read y[srcBLen - 3] sample */
;;;299            c0 = *(py - 2u);
000134  f852ec08          LDR      lr,[r2,#-8]
;;;300    
;;;301            /* Read x[5] sample */
;;;302            x1 = *(px + 2u);
000138  f8d89008          LDR      r9,[r8,#8]
;;;303    
;;;304            /* Perform the multiply-accumulates */
;;;305            /* acc0 +=  x[2] * y[srcBLen - 3] */
;;;306            acc0 += ((q63_t) x2 * c0);
00013c  fbcb010e          SMLAL    r0,r1,r11,lr
;;;307            /* acc1 +=  x[3] * y[srcBLen - 2] */
;;;308            acc1 += ((q63_t) x0 * c0);
000140  fbca450e          SMLAL    r4,r5,r10,lr
;;;309            /* acc2 +=  x[4] * y[srcBLen - 2] */
;;;310            acc2 += ((q63_t) x1 * c0);
000144  fbc9670e          SMLAL    r6,r7,r9,lr
;;;311    
;;;312            /* update scratch pointers */
;;;313            px += 3u;
000148  f108080c          ADD      r8,r8,#0xc
;;;314            py -= 3u;
00014c  3a0c              SUBS     r2,r2,#0xc
;;;315    
;;;316          } while(--k);
00014e  f8ddb010          LDR      r11,[sp,#0x10]
000152  f1bb0b01          SUBS     r11,r11,#1
000156  f8cdb010          STR      r11,[sp,#0x10]
00015a  d1d7              BNE      |L1.268|
;;;317    
;;;318          /* If the srcBLen is not a multiple of 3, compute any remaining MACs here.        
;;;319           ** No loop unrolling is used. */
;;;320          k = srcBLen - (3 * (srcBLen / 3));
00015c  f04f0b03          MOV      r11,#3
000160  fbb3fbfb          UDIV     r11,r3,r11
000164  ebab0b8b          SUB      r11,r11,r11,LSL #2
000168  449b              ADD      r11,r11,r3
00016a  f8cdb010          STR      r11,[sp,#0x10]
;;;321    
;;;322          while(k > 0u)
00016e  e011              B        |L1.404|
                  |L1.368|
;;;323          {
;;;324            /* Read y[srcBLen - 5] sample */
;;;325            c0 = *(py--);
000170  f852e904          LDR      lr,[r2],#-4
;;;326    
;;;327            /* Read x[7] sample */
;;;328            x2 = *(px++);
000174  f858bb04          LDR      r11,[r8],#4
;;;329    
;;;330            /* Perform the multiply-accumulates */
;;;331            /* acc0 +=  x[4] * y[srcBLen - 5] */
;;;332            acc0 += ((q63_t) x0 * c0);
000178  fbca010e          SMLAL    r0,r1,r10,lr
;;;333            /* acc1 +=  x[5] * y[srcBLen - 5] */
;;;334            acc1 += ((q63_t) x1 * c0);
00017c  fbc9450e          SMLAL    r4,r5,r9,lr
;;;335            /* acc2 +=  x[6] * y[srcBLen - 5] */
;;;336            acc2 += ((q63_t) x2 * c0);
000180  fbcb670e          SMLAL    r6,r7,r11,lr
;;;337    
;;;338            /* Reuse the present samples for the next MAC */
;;;339            x0 = x1;
000184  46ca              MOV      r10,r9
;;;340            x1 = x2;
000186  46d9              MOV      r9,r11
;;;341    
;;;342            /* Decrement the loop counter */
;;;343            k--;
000188  f8ddb010          LDR      r11,[sp,#0x10]
00018c  f1ab0b01          SUB      r11,r11,#1
000190  f8cdb010          STR      r11,[sp,#0x10]
                  |L1.404|
000194  f8ddb010          LDR      r11,[sp,#0x10]        ;322
000198  f1bb0f00          CMP      r11,#0                ;322
00019c  d1e8              BNE      |L1.368|
;;;344          }
;;;345    
;;;346          /* Store the results in the accumulators in the destination buffer. */
;;;347          *pOut++ = (q31_t) (acc0 >> 31);
00019e  0fc0              LSRS     r0,r0,#31
0001a0  ea400041          ORR      r0,r0,r1,LSL #1
0001a4  f84c0b04          STR      r0,[r12],#4
;;;348          *pOut++ = (q31_t) (acc1 >> 31);
0001a8  0fe0              LSRS     r0,r4,#31
0001aa  ea400045          ORR      r0,r0,r5,LSL #1
0001ae  f84c0b04          STR      r0,[r12],#4
;;;349          *pOut++ = (q31_t) (acc2 >> 31);
0001b2  0ff0              LSRS     r0,r6,#31
0001b4  ea400047          ORR      r0,r0,r7,LSL #1
0001b8  f84c0b04          STR      r0,[r12],#4
;;;350    
;;;351          /* Increment the pointer pIn1 index, count by 3 */
;;;352          count += 3u;
0001bc  9803              LDR      r0,[sp,#0xc]
0001be  1cc0              ADDS     r0,r0,#3
0001c0  9003              STR      r0,[sp,#0xc]
;;;353    
;;;354          /* Update the inputA and inputB pointers for next MAC calculation */
;;;355          px = pIn1 + count;
0001c2  9903              LDR      r1,[sp,#0xc]
0001c4  9806              LDR      r0,[sp,#0x18]
0001c6  eb000881          ADD      r8,r0,r1,LSL #2
;;;356          py = pSrc2;
0001ca  9a05              LDR      r2,[sp,#0x14]
;;;357    
;;;358          /* Decrement the loop counter */
;;;359          blkCnt--;
0001cc  9802              LDR      r0,[sp,#8]
0001ce  1e40              SUBS     r0,r0,#1
0001d0  9002              STR      r0,[sp,#8]
                  |L1.466|
0001d2  9802              LDR      r0,[sp,#8]            ;252
0001d4  2800              CMP      r0,#0                 ;252
0001d6  d189              BNE      |L1.236|
;;;360        }
;;;361    
;;;362        /* If the blockSize2 is not a multiple of 3, compute any remaining output samples here.        
;;;363         ** No loop unrolling is used. */
;;;364        blkCnt = blockSize2 - 3 * (blockSize2 / 3);
0001d8  2003              MOVS     r0,#3
0001da  e000              B        |L1.478|
                  |L1.476|
0001dc  e04b              B        |L1.630|
                  |L1.478|
0001de  9901              LDR      r1,[sp,#4]
0001e0  fbb1f0f0          UDIV     r0,r1,r0
0001e4  eba00180          SUB      r1,r0,r0,LSL #2
0001e8  9801              LDR      r0,[sp,#4]
0001ea  4401              ADD      r1,r1,r0
;;;365    
;;;366        while(blkCnt > 0u)
0001ec  e040              B        |L1.624|
                  |L1.494|
;;;367        {
;;;368          /* Accumulator is made zero for every iteration */
;;;369          sum = 0;
0001ee  2400              MOVS     r4,#0
0001f0  4625              MOV      r5,r4
;;;370    
;;;371          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;372          k = srcBLen >> 2u;
0001f2  0898              LSRS     r0,r3,#2
;;;373    
;;;374          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;375           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;376          while(k > 0u)
0001f4  e01e              B        |L1.564|
                  |L1.502|
;;;377          {
;;;378            /* Perform the multiply-accumulates */
;;;379            sum += (q63_t) * px++ * (*py--);
0001f6  3a0c              SUBS     r2,r2,#0xc
0001f8  f8586b04          LDR      r6,[r8],#4
0001fc  68d7              LDR      r7,[r2,#0xc]
0001fe  fb867607          SMULL    r7,r6,r6,r7
000202  193c              ADDS     r4,r7,r4
000204  4175              ADCS     r5,r5,r6
;;;380            sum += (q63_t) * px++ * (*py--);
000206  f8586b04          LDR      r6,[r8],#4
00020a  6897              LDR      r7,[r2,#8]
00020c  fb867607          SMULL    r7,r6,r6,r7
000210  193c              ADDS     r4,r7,r4
000212  4175              ADCS     r5,r5,r6
;;;381            sum += (q63_t) * px++ * (*py--);
000214  f8586b04          LDR      r6,[r8],#4
000218  6857              LDR      r7,[r2,#4]
00021a  fb867607          SMULL    r7,r6,r6,r7
00021e  193c              ADDS     r4,r7,r4
000220  4175              ADCS     r5,r5,r6
;;;382            sum += (q63_t) * px++ * (*py--);
000222  f8586b04          LDR      r6,[r8],#4
000226  f8527904          LDR      r7,[r2],#-4
00022a  fb867607          SMULL    r7,r6,r6,r7
00022e  193c              ADDS     r4,r7,r4
000230  4175              ADCS     r5,r5,r6
;;;383    
;;;384            /* Decrement the loop counter */
;;;385            k--;
000232  1e40              SUBS     r0,r0,#1
                  |L1.564|
000234  2800              CMP      r0,#0                 ;376
000236  d1de              BNE      |L1.502|
;;;386          }
;;;387    
;;;388          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.    
;;;389           ** No loop unrolling is used. */
;;;390          k = srcBLen % 0x4u;
000238  f0030003          AND      r0,r3,#3
;;;391    
;;;392          while(k > 0u)
00023c  e008              B        |L1.592|
                  |L1.574|
;;;393          {
;;;394            /* Perform the multiply-accumulate */
;;;395            sum += (q63_t) * px++ * (*py--);
00023e  f8586b04          LDR      r6,[r8],#4
000242  f8527904          LDR      r7,[r2],#-4
000246  fb867607          SMULL    r7,r6,r6,r7
00024a  193c              ADDS     r4,r7,r4
00024c  4175              ADCS     r5,r5,r6
;;;396    
;;;397            /* Decrement the loop counter */
;;;398            k--;
00024e  1e40              SUBS     r0,r0,#1
                  |L1.592|
000250  2800              CMP      r0,#0                 ;392
000252  d1f4              BNE      |L1.574|
;;;399          }
;;;400    
;;;401          /* Store the result in the accumulator in the destination buffer. */
;;;402          *pOut++ = (q31_t) (sum >> 31);
000254  0fe0              LSRS     r0,r4,#31
000256  ea400045          ORR      r0,r0,r5,LSL #1
00025a  f84c0b04          STR      r0,[r12],#4
;;;403    
;;;404          /* Increment the MAC count */
;;;405          count++;
00025e  9803              LDR      r0,[sp,#0xc]
000260  1c40              ADDS     r0,r0,#1
000262  9003              STR      r0,[sp,#0xc]
;;;406    
;;;407          /* Update the inputA and inputB pointers for next MAC calculation */
;;;408          px = pIn1 + count;
000264  9a03              LDR      r2,[sp,#0xc]
000266  9806              LDR      r0,[sp,#0x18]
000268  eb000882          ADD      r8,r0,r2,LSL #2
;;;409          py = pSrc2;
00026c  9a05              LDR      r2,[sp,#0x14]
;;;410    
;;;411          /* Decrement the loop counter */
;;;412          blkCnt--;
00026e  1e49              SUBS     r1,r1,#1
                  |L1.624|
000270  2900              CMP      r1,#0                 ;366
000272  d1bc              BNE      |L1.494|
000274  e020              B        |L1.696|
                  |L1.630|
;;;413        }
;;;414      }
;;;415      else
;;;416      {
;;;417        /* If the srcBLen is not a multiple of 4,    
;;;418         * the blockSize2 loop cannot be unrolled by 4 */
;;;419        blkCnt = blockSize2;
000276  9901              LDR      r1,[sp,#4]
;;;420    
;;;421        while(blkCnt > 0u)
000278  e01c              B        |L1.692|
                  |L1.634|
;;;422        {
;;;423          /* Accumulator is made zero for every iteration */
;;;424          sum = 0;
00027a  2400              MOVS     r4,#0
00027c  4625              MOV      r5,r4
;;;425    
;;;426          /* srcBLen number of MACS should be performed */
;;;427          k = srcBLen;
00027e  4618              MOV      r0,r3
;;;428    
;;;429          while(k > 0u)
000280  e008              B        |L1.660|
                  |L1.642|
;;;430          {
;;;431            /* Perform the multiply-accumulate */
;;;432            sum += (q63_t) * px++ * (*py--);
000282  f8586b04          LDR      r6,[r8],#4
000286  f8527904          LDR      r7,[r2],#-4
00028a  fb867607          SMULL    r7,r6,r6,r7
00028e  193c              ADDS     r4,r7,r4
000290  4175              ADCS     r5,r5,r6
;;;433    
;;;434            /* Decrement the loop counter */
;;;435            k--;
000292  1e40              SUBS     r0,r0,#1
                  |L1.660|
000294  2800              CMP      r0,#0                 ;429
000296  d1f4              BNE      |L1.642|
;;;436          }
;;;437    
;;;438          /* Store the result in the accumulator in the destination buffer. */
;;;439          *pOut++ = (q31_t) (sum >> 31);
000298  0fe0              LSRS     r0,r4,#31
00029a  ea400045          ORR      r0,r0,r5,LSL #1
00029e  f84c0b04          STR      r0,[r12],#4
;;;440    
;;;441          /* Increment the MAC count */
;;;442          count++;
0002a2  9803              LDR      r0,[sp,#0xc]
0002a4  1c40              ADDS     r0,r0,#1
0002a6  9003              STR      r0,[sp,#0xc]
;;;443    
;;;444          /* Update the inputA and inputB pointers for next MAC calculation */
;;;445          px = pIn1 + count;
0002a8  9a03              LDR      r2,[sp,#0xc]
0002aa  9806              LDR      r0,[sp,#0x18]
0002ac  eb000882          ADD      r8,r0,r2,LSL #2
;;;446          py = pSrc2;
0002b0  9a05              LDR      r2,[sp,#0x14]
;;;447    
;;;448          /* Decrement the loop counter */
;;;449          blkCnt--;
0002b2  1e49              SUBS     r1,r1,#1
                  |L1.692|
0002b4  2900              CMP      r1,#0                 ;421
0002b6  d1e0              BNE      |L1.634|
                  |L1.696|
;;;450        }
;;;451      }
;;;452    
;;;453    
;;;454      /* --------------------------    
;;;455       * Initializations of stage3    
;;;456       * -------------------------*/
;;;457    
;;;458      /* sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1]    
;;;459       * sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2]    
;;;460       * ....    
;;;461       * sum +=  x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2]    
;;;462       * sum +=  x[srcALen-1] * y[srcBLen-1]    
;;;463       */
;;;464    
;;;465      /* In this stage the MAC operations are decreased by 1 for every iteration.    
;;;466         The blockSize3 variable holds the number of MAC operations performed */
;;;467    
;;;468      /* Working pointer of inputA */
;;;469      pSrc1 = (pIn1 + srcALen) - (srcBLen - 1u);
0002b8  990a              LDR      r1,[sp,#0x28]
0002ba  9806              LDR      r0,[sp,#0x18]
0002bc  eb000181          ADD      r1,r0,r1,LSL #2
0002c0  9808              LDR      r0,[sp,#0x20]
0002c2  eba10380          SUB      r3,r1,r0,LSL #2
;;;470      px = pSrc1;
0002c6  4618              MOV      r0,r3
;;;471    
;;;472      /* Working pointer of inputB */
;;;473      pSrc2 = pIn2 + (srcBLen - 1u);
0002c8  9e07              LDR      r6,[sp,#0x1c]
;;;474      py = pSrc2;
0002ca  4631              MOV      r1,r6
;;;475    
;;;476      /* -------------------    
;;;477       * Stage3 process    
;;;478       * ------------------*/
;;;479    
;;;480      while(blockSize3 > 0u)
0002cc  e042              B        |L1.852|
                  |L1.718|
;;;481      {
;;;482        /* Accumulator is made zero for every iteration */
;;;483        sum = 0;
0002ce  2400              MOVS     r4,#0
0002d0  4625              MOV      r5,r4
;;;484    
;;;485        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;486        k = blockSize3 >> 2u;
0002d2  9a00              LDR      r2,[sp,#0]
0002d4  0892              LSRS     r2,r2,#2
;;;487    
;;;488        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;489         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;490        while(k > 0u)
0002d6  e021              B        |L1.796|
                  |L1.728|
;;;491        {
;;;492          /* sum += x[srcALen - srcBLen + 1] * y[srcBLen - 1] */
;;;493          sum += (q63_t) * px++ * (*py--);
0002d8  6807              LDR      r7,[r0,#0]
0002da  f8518904          LDR      r8,[r1],#-4
0002de  fb878708          SMULL    r8,r7,r7,r8
0002e2  eb180404          ADDS     r4,r8,r4
0002e6  417d              ADCS     r5,r5,r7
;;;494          /* sum += x[srcALen - srcBLen + 2] * y[srcBLen - 2] */
;;;495          sum += (q63_t) * px++ * (*py--);
0002e8  6847              LDR      r7,[r0,#4]
0002ea  f8518904          LDR      r8,[r1],#-4
0002ee  fb878708          SMULL    r8,r7,r7,r8
0002f2  eb180404          ADDS     r4,r8,r4
0002f6  417d              ADCS     r5,r5,r7
;;;496          /* sum += x[srcALen - srcBLen + 3] * y[srcBLen - 3] */
;;;497          sum += (q63_t) * px++ * (*py--);
0002f8  6887              LDR      r7,[r0,#8]
0002fa  f8518904          LDR      r8,[r1],#-4
0002fe  fb878708          SMULL    r8,r7,r7,r8
000302  eb180404          ADDS     r4,r8,r4
000306  417d              ADCS     r5,r5,r7
;;;498          /* sum += x[srcALen - srcBLen + 4] * y[srcBLen - 4] */
;;;499          sum += (q63_t) * px++ * (*py--);
000308  68c7              LDR      r7,[r0,#0xc]
00030a  f8518904          LDR      r8,[r1],#-4
00030e  3010              ADDS     r0,r0,#0x10
000310  fb878708          SMULL    r8,r7,r7,r8
000314  eb180404          ADDS     r4,r8,r4
000318  417d              ADCS     r5,r5,r7
;;;500    
;;;501          /* Decrement the loop counter */
;;;502          k--;
00031a  1e52              SUBS     r2,r2,#1
                  |L1.796|
00031c  2a00              CMP      r2,#0                 ;490
00031e  d1db              BNE      |L1.728|
;;;503        }
;;;504    
;;;505        /* If the blockSize3 is not a multiple of 4, compute any remaining MACs here.    
;;;506         ** No loop unrolling is used. */
;;;507        k = blockSize3 % 0x4u;
000320  9a00              LDR      r2,[sp,#0]
000322  f0020203          AND      r2,r2,#3
;;;508    
;;;509        while(k > 0u)
000326  e008              B        |L1.826|
                  |L1.808|
;;;510        {
;;;511          /* Perform the multiply-accumulate */
;;;512          sum += (q63_t) * px++ * (*py--);
000328  c880              LDM      r0!,{r7}
00032a  f8518904          LDR      r8,[r1],#-4
00032e  fb878708          SMULL    r8,r7,r7,r8
000332  eb180404          ADDS     r4,r8,r4
000336  417d              ADCS     r5,r5,r7
;;;513    
;;;514          /* Decrement the loop counter */
;;;515          k--;
000338  1e52              SUBS     r2,r2,#1
                  |L1.826|
00033a  2a00              CMP      r2,#0                 ;509
00033c  d1f4              BNE      |L1.808|
;;;516        }
;;;517    
;;;518        /* Store the result in the accumulator in the destination buffer. */
;;;519        *pOut++ = (q31_t) (sum >> 31);
00033e  0fe0              LSRS     r0,r4,#31
000340  ea400045          ORR      r0,r0,r5,LSL #1
000344  f84c0b04          STR      r0,[r12],#4
;;;520    
;;;521        /* Update the inputA and inputB pointers for next MAC calculation */
;;;522        px = ++pSrc1;
000348  1d18              ADDS     r0,r3,#4
00034a  4603              MOV      r3,r0
;;;523        py = pSrc2;
00034c  4631              MOV      r1,r6
;;;524    
;;;525        /* Decrement the loop counter */
;;;526        blockSize3--;
00034e  9a00              LDR      r2,[sp,#0]
000350  1e52              SUBS     r2,r2,#1
000352  9200              STR      r2,[sp,#0]
                  |L1.852|
000354  9a00              LDR      r2,[sp,#0]            ;480
000356  2a00              CMP      r2,#0                 ;480
000358  d1b9              BNE      |L1.718|
;;;527      }
;;;528    
;;;529    #else
;;;530    
;;;531      /* Run the below code for Cortex-M0 */
;;;532    
;;;533      q31_t *pIn1 = pSrcA;                           /* input pointer */
;;;534      q31_t *pIn2 = pSrcB;                           /* coefficient pointer */
;;;535      q63_t sum;                                     /* Accumulator */
;;;536      uint32_t i, j;                                 /* loop counter */
;;;537    
;;;538      /* Loop to calculate output of convolution for output length number of times */
;;;539      for (i = 0; i < (srcALen + srcBLen - 1); i++)
;;;540      {
;;;541        /* Initialize sum with zero to carry on MAC operations */
;;;542        sum = 0;
;;;543    
;;;544        /* Loop to perform MAC operations according to convolution equation */
;;;545        for (j = 0; j <= i; j++)
;;;546        {
;;;547          /* Check the array limitations */
;;;548          if(((i - j) < srcBLen) && (j < srcALen))
;;;549          {
;;;550            /* z[i] += x[i-j] * y[j] */
;;;551            sum += ((q63_t) pIn1[j] * (pIn2[i - j]));
;;;552          }
;;;553        }
;;;554    
;;;555        /* Store the output in the destination buffer */
;;;556        pDst[i] = (q31_t) (sum >> 31u);
;;;557      }
;;;558    
;;;559    #endif /*     #ifndef ARM_MATH_CM0_FAMILY */
;;;560    
;;;561    }
00035a  b00d              ADD      sp,sp,#0x34
00035c  e8bd8ff0          POP      {r4-r11,pc}
;;;562    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_conv_q31_c_e38094d5____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___14_arm_conv_q31_c_e38094d5____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_conv_q31_c_e38094d5____REVSH|
#line 144
|__asm___14_arm_conv_q31_c_e38094d5____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_conv_q31_c_e38094d5____RRX|
#line 300
|__asm___14_arm_conv_q31_c_e38094d5____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
