; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_fir_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_fir_q15.c]
                          THUMB

                          AREA ||i.arm_fir_q15||, CODE, READONLY, ALIGN=1

                  arm_fir_q15 PROC
;;;84     
;;;85     void arm_fir_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;86       const arm_fir_instance_q15 * S,
;;;87       q15_t * pSrc,
;;;88       q15_t * pDst,
;;;89       uint32_t blockSize)
;;;90     {
000004  b08d              SUB      sp,sp,#0x34
;;;91       q15_t *pState = S->pState;                     /* State pointer */
000006  980d              LDR      r0,[sp,#0x34]
000008  f8d0c004          LDR      r12,[r0,#4]
;;;92       q15_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
00000c  980d              LDR      r0,[sp,#0x34]
00000e  6880              LDR      r0,[r0,#8]
000010  9007              STR      r0,[sp,#0x1c]
;;;93       q15_t *pStateCurnt;                            /* Points to the current sample of the state */
;;;94       q15_t *px1;                                    /* Temporary q15 pointer for state buffer */
;;;95       q15_t *pb;                                     /* Temporary pointer for coefficient buffer */
;;;96       q31_t x0, x1, x2, x3, c0;                      /* Temporary variables to hold SIMD state and coefficient values */
;;;97       q63_t acc0, acc1, acc2, acc3;                  /* Accumulators */
;;;98       uint32_t numTaps = S->numTaps;                 /* Number of taps in the filter */
000012  980d              LDR      r0,[sp,#0x34]
000014  8800              LDRH     r0,[r0,#0]
000016  9002              STR      r0,[sp,#8]
;;;99       uint32_t tapCnt, blkCnt;                       /* Loop counters */
;;;100    
;;;101    
;;;102      /* S->pState points to state array which contains previous frame (numTaps - 1) samples */
;;;103      /* pStateCurnt points to the location where the new input data should be written */
;;;104      pStateCurnt = &(S->pState[(numTaps - 1u)]);
000018  9802              LDR      r0,[sp,#8]
00001a  1e40              SUBS     r0,r0,#1
00001c  eb0c0a40          ADD      r10,r12,r0,LSL #1
000020  900c              STR      r0,[sp,#0x30]
;;;105    
;;;106      /* Apply loop unrolling and compute 4 output values simultaneously.       
;;;107       * The variables acc0 ... acc3 hold output values that are being computed:       
;;;108       *       
;;;109       *    acc0 =  b[numTaps-1] * x[n-numTaps-1] + b[numTaps-2] * x[n-numTaps-2] + b[numTaps-3] * x[n-numTaps-3] +...+ b[0] * x[0]       
;;;110       *    acc1 =  b[numTaps-1] * x[n-numTaps] +   b[numTaps-2] * x[n-numTaps-1] + b[numTaps-3] * x[n-numTaps-2] +...+ b[0] * x[1]       
;;;111       *    acc2 =  b[numTaps-1] * x[n-numTaps+1] + b[numTaps-2] * x[n-numTaps] +   b[numTaps-3] * x[n-numTaps-1] +...+ b[0] * x[2]       
;;;112       *    acc3 =  b[numTaps-1] * x[n-numTaps+2] + b[numTaps-2] * x[n-numTaps+1] + b[numTaps-3] * x[n-numTaps]   +...+ b[0] * x[3]       
;;;113       */
;;;114    
;;;115      blkCnt = blockSize >> 2;
000022  9810              LDR      r0,[sp,#0x40]
000024  0880              LSRS     r0,r0,#2
000026  9000              STR      r0,[sp,#0]
000028  e0ac              B        |L1.388|
                  |L1.42|
;;;116    
;;;117      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.       
;;;118       ** a second loop below computes the remaining 1 to 3 samples. */
;;;119      while(blkCnt > 0u)
;;;120      {
;;;121        /* Copy four new input samples into the state buffer.       
;;;122         ** Use 32-bit SIMD to move the 16-bit data.  Only requires two copies. */
;;;123        *__SIMD32(pStateCurnt)++ = *__SIMD32(pSrc)++;
00002a  980e              LDR      r0,[sp,#0x38]
00002c  6800              LDR      r0,[r0,#0]
00002e  f84a0b04          STR      r0,[r10],#4
000032  980e              LDR      r0,[sp,#0x38]
;;;124        *__SIMD32(pStateCurnt)++ = *__SIMD32(pSrc)++;
000034  6841              LDR      r1,[r0,#4]
000036  3008              ADDS     r0,r0,#8
000038  f84a1b04          STR      r1,[r10],#4
00003c  900e              STR      r0,[sp,#0x38]
;;;125    
;;;126        /* Set all accumulators to zero */
;;;127        acc0 = 0;
00003e  2000              MOVS     r0,#0
000040  4601              MOV      r1,r0
;;;128        acc1 = 0;
000042  2200              MOVS     r2,#0
000044  4613              MOV      r3,r2
;;;129        acc2 = 0;
000046  2400              MOVS     r4,#0
000048  4625              MOV      r5,r4
;;;130        acc3 = 0;
00004a  2600              MOVS     r6,#0
00004c  4637              MOV      r7,r6
;;;131    
;;;132        /* Initialize state pointer of type q15 */
;;;133        px1 = pState;
00004e  46e0              MOV      r8,r12
;;;134    
;;;135        /* Initialize coeff pointer of type q31 */
;;;136        pb = pCoeffs;
000050  f8ddb01c          LDR      r11,[sp,#0x1c]
;;;137    
;;;138        /* Read the first two samples from the state buffer:  x[n-N], x[n-N-1] */
;;;139        x0 = _SIMD32_OFFSET(px1);
000054  f8d89000          LDR      r9,[r8,#0]
000058  f8cd9014          STR      r9,[sp,#0x14]
;;;140    
;;;141        /* Read the third and forth samples from the state buffer: x[n-N-1], x[n-N-2] */
;;;142        x1 = _SIMD32_OFFSET(px1 + 1u);
00005c  f8d89002          LDR      r9,[r8,#2]
000060  f8cd9010          STR      r9,[sp,#0x10]
;;;143    
;;;144        px1 += 2u;
000064  f1080804          ADD      r8,r8,#4
;;;145    
;;;146        /* Loop over the number of taps.  Unroll by a factor of 4.       
;;;147         ** Repeat until we've computed numTaps-4 coefficients. */
;;;148        tapCnt = numTaps >> 2;
000068  f8dd9008          LDR      r9,[sp,#8]
00006c  ea4f0999          LSR      r9,r9,#2
000070  f8cd9004          STR      r9,[sp,#4]
;;;149    
;;;150        while(tapCnt > 0u)
000074  e043              B        |L1.254|
                  |L1.118|
;;;151        {
;;;152          /* Read the first two coefficients using SIMD:  b[N] and b[N-1] coefficients */
;;;153          c0 = *__SIMD32(pb)++;
000076  f85b9b04          LDR      r9,[r11],#4
00007a  f8cdb018          STR      r11,[sp,#0x18]
;;;154    
;;;155          /* acc0 +=  b[N] * x[n-N] + b[N-1] * x[n-N-1] */
;;;156          acc0 = __SMLALD(x0, c0, acc0);
00007e  f8ddb014          LDR      r11,[sp,#0x14]
000082  fbcb01c9          SMLALD   r0,r1,r11,r9
;;;157    
;;;158          /* acc1 +=  b[N] * x[n-N-1] + b[N-1] * x[n-N-2] */
;;;159          acc1 = __SMLALD(x1, c0, acc1);
000086  f8ddb010          LDR      r11,[sp,#0x10]
00008a  fbcb23c9          SMLALD   r2,r3,r11,r9
;;;160    
;;;161          /* Read state x[n-N-2], x[n-N-3] */
;;;162          x2 = _SIMD32_OFFSET(px1);
00008e  f8d8e000          LDR      lr,[r8,#0]
000092  f8cde02c          STR      lr,[sp,#0x2c]
;;;163    
;;;164          /* Read state x[n-N-3], x[n-N-4] */
;;;165          x3 = _SIMD32_OFFSET(px1 + 1u);
000096  f8d8e002          LDR      lr,[r8,#2]
00009a  f8cde028          STR      lr,[sp,#0x28]
;;;166    
;;;167          /* acc2 +=  b[N] * x[n-N-2] + b[N-1] * x[n-N-3] */
;;;168          acc2 = __SMLALD(x2, c0, acc2);
00009e  f8dde02c          LDR      lr,[sp,#0x2c]
0000a2  fbce45c9          SMLALD   r4,r5,lr,r9
;;;169    
;;;170          /* acc3 +=  b[N] * x[n-N-3] + b[N-1] * x[n-N-4] */
;;;171          acc3 = __SMLALD(x3, c0, acc3);
0000a6  f8dde028          LDR      lr,[sp,#0x28]
0000aa  fbce67c9          SMLALD   r6,r7,lr,r9
;;;172    
;;;173          /* Read coefficients b[N-2], b[N-3] */
;;;174          c0 = *__SIMD32(pb)++;
0000ae  f8ddb018          LDR      r11,[sp,#0x18]
0000b2  f85b9b04          LDR      r9,[r11],#4
;;;175    
;;;176          /* acc0 +=  b[N-2] * x[n-N-2] + b[N-3] * x[n-N-3] */
;;;177          acc0 = __SMLALD(x2, c0, acc0);
0000b6  f8dde02c          LDR      lr,[sp,#0x2c]
0000ba  fbce01c9          SMLALD   r0,r1,lr,r9
;;;178    
;;;179          /* acc1 +=  b[N-2] * x[n-N-3] + b[N-3] * x[n-N-4] */
;;;180          acc1 = __SMLALD(x3, c0, acc1);
0000be  f8dde028          LDR      lr,[sp,#0x28]
0000c2  fbce23c9          SMLALD   r2,r3,lr,r9
;;;181    
;;;182          /* Read state x[n-N-4], x[n-N-5] */
;;;183          x0 = _SIMD32_OFFSET(px1 + 2u);
0000c6  f8d8e004          LDR      lr,[r8,#4]
0000ca  f8cde024          STR      lr,[sp,#0x24]
0000ce  f8cde014          STR      lr,[sp,#0x14]
;;;184    
;;;185          /* Read state x[n-N-5], x[n-N-6] */
;;;186          x1 = _SIMD32_OFFSET(px1 + 3u);
0000d2  f8d8e006          LDR      lr,[r8,#6]
0000d6  f8cde020          STR      lr,[sp,#0x20]
0000da  f8cde010          STR      lr,[sp,#0x10]
;;;187    
;;;188          /* acc2 +=  b[N-2] * x[n-N-4] + b[N-3] * x[n-N-5] */
;;;189          acc2 = __SMLALD(x0, c0, acc2);
0000de  f8dde024          LDR      lr,[sp,#0x24]
0000e2  fbce45c9          SMLALD   r4,r5,lr,r9
;;;190    
;;;191          /* acc3 +=  b[N-2] * x[n-N-5] + b[N-3] * x[n-N-6] */
;;;192          acc3 = __SMLALD(x1, c0, acc3);
0000e6  f8dde020          LDR      lr,[sp,#0x20]
0000ea  fbce67c9          SMLALD   r6,r7,lr,r9
;;;193    
;;;194          px1 += 4u;
0000ee  f1080808          ADD      r8,r8,#8
;;;195    
;;;196          tapCnt--;
0000f2  f8dd9004          LDR      r9,[sp,#4]
0000f6  f1a90901          SUB      r9,r9,#1
0000fa  f8cd9004          STR      r9,[sp,#4]
                  |L1.254|
0000fe  f8dd9004          LDR      r9,[sp,#4]            ;150
000102  f1b90f00          CMP      r9,#0                 ;150
000106  d1b6              BNE      |L1.118|
;;;197    
;;;198        }
;;;199    
;;;200    
;;;201        /* If the filter length is not a multiple of 4, compute the remaining filter taps.       
;;;202         ** This is always be 2 taps since the filter length is even. */
;;;203        if((numTaps & 0x3u) != 0u)
000108  f8dd9008          LDR      r9,[sp,#8]
00010c  ea5f7989          LSLS     r9,r9,#30
000110  d015              BEQ      |L1.318|
;;;204        {
;;;205          /* Read 2 coefficients */
;;;206          c0 = *__SIMD32(pb)++;
000112  f8db9000          LDR      r9,[r11,#0]
;;;207    
;;;208          /* Fetch 4 state variables */
;;;209          x2 = _SIMD32_OFFSET(px1);
000116  f8d8b000          LDR      r11,[r8,#0]
;;;210    
;;;211          x3 = _SIMD32_OFFSET(px1 + 1u);
00011a  f8d8e002          LDR      lr,[r8,#2]
00011e  f8cde00c          STR      lr,[sp,#0xc]
;;;212    
;;;213          /* Perform the multiply-accumulates */
;;;214          acc0 = __SMLALD(x0, c0, acc0);
000122  f8dde014          LDR      lr,[sp,#0x14]
000126  fbce01c9          SMLALD   r0,r1,lr,r9
;;;215    
;;;216          px1 += 2u;
;;;217    
;;;218          acc1 = __SMLALD(x1, c0, acc1);
00012a  f8dde010          LDR      lr,[sp,#0x10]
00012e  fbce23c9          SMLALD   r2,r3,lr,r9
;;;219          acc2 = __SMLALD(x2, c0, acc2);
000132  fbcb45c9          SMLALD   r4,r5,r11,r9
;;;220          acc3 = __SMLALD(x3, c0, acc3);
000136  f8dde00c          LDR      lr,[sp,#0xc]
00013a  fbce67c9          SMLALD   r6,r7,lr,r9
                  |L1.318|
;;;221        }
;;;222    
;;;223        /* The results in the 4 accumulators are in 2.30 format.  Convert to 1.15 with saturation.       
;;;224         ** Then store the 4 outputs in the destination buffer. */
;;;225    
;;;226    #ifndef ARM_MATH_BIG_ENDIAN
;;;227    
;;;228        *__SIMD32(pDst)++ =
00013e  0bc0              LSRS     r0,r0,#15
000140  ea404041          ORR      r0,r0,r1,LSL #17
000144  f300010f          SSAT     r1,#16,r0
000148  0bd0              LSRS     r0,r2,#15
00014a  ea404043          ORR      r0,r0,r3,LSL #17
00014e  f300000f          SSAT     r0,#16,r0
000152  eac14100          PKHBT    r1,r1,r0,LSL #16
000156  980f              LDR      r0,[sp,#0x3c]
000158  6001              STR      r1,[r0,#0]
00015a  980f              LDR      r0,[sp,#0x3c]
;;;229          __PKHBT(__SSAT((acc0 >> 15), 16), __SSAT((acc1 >> 15), 16), 16);
;;;230        *__SIMD32(pDst)++ =
00015c  0be1              LSRS     r1,r4,#15
00015e  ea414145          ORR      r1,r1,r5,LSL #17
000162  f301020f          SSAT     r2,#16,r1
000166  0bf1              LSRS     r1,r6,#15
000168  ea414147          ORR      r1,r1,r7,LSL #17
00016c  f301010f          SSAT     r1,#16,r1
000170  eac24101          PKHBT    r1,r2,r1,LSL #16
000174  6041              STR      r1,[r0,#4]
000176  3008              ADDS     r0,r0,#8
000178  900f              STR      r0,[sp,#0x3c]
;;;231          __PKHBT(__SSAT((acc2 >> 15), 16), __SSAT((acc3 >> 15), 16), 16);
;;;232    
;;;233    #else
;;;234    
;;;235        *__SIMD32(pDst)++ =
;;;236          __PKHBT(__SSAT((acc1 >> 15), 16), __SSAT((acc0 >> 15), 16), 16);
;;;237        *__SIMD32(pDst)++ =
;;;238          __PKHBT(__SSAT((acc3 >> 15), 16), __SSAT((acc2 >> 15), 16), 16);
;;;239    
;;;240    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN       */
;;;241    
;;;242    
;;;243    
;;;244        /* Advance the state pointer by 4 to process the next group of 4 samples */
;;;245        pState = pState + 4;
00017a  f10c0c08          ADD      r12,r12,#8
;;;246    
;;;247        /* Decrement the loop counter */
;;;248        blkCnt--;
00017e  9800              LDR      r0,[sp,#0]
000180  1e40              SUBS     r0,r0,#1
000182  9000              STR      r0,[sp,#0]
                  |L1.388|
000184  9800              LDR      r0,[sp,#0]            ;119
000186  2800              CMP      r0,#0                 ;119
000188  f47faf4f          BNE      |L1.42|
;;;249      }
;;;250    
;;;251      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.       
;;;252       ** No loop unrolling is used. */
;;;253      blkCnt = blockSize % 0x4u;
00018c  9810              LDR      r0,[sp,#0x40]
00018e  f0000503          AND      r5,r0,#3
;;;254      while(blkCnt > 0u)
000192  e022              B        |L1.474|
                  |L1.404|
;;;255      {
;;;256        /* Copy two samples into state buffer */
;;;257        *pStateCurnt++ = *pSrc++;
000194  980e              LDR      r0,[sp,#0x38]
000196  8800              LDRH     r0,[r0,#0]
000198  f82a0b02          STRH     r0,[r10],#2
00019c  980e              LDR      r0,[sp,#0x38]
00019e  1c80              ADDS     r0,r0,#2
0001a0  900e              STR      r0,[sp,#0x38]
;;;258    
;;;259        /* Set the accumulator to zero */
;;;260        acc0 = 0;
0001a2  2000              MOVS     r0,#0
0001a4  4601              MOV      r1,r0
;;;261    
;;;262        /* Initialize state pointer of type q15 */
;;;263        px1 = pState;
0001a6  4662              MOV      r2,r12
;;;264    
;;;265        /* Initialize coeff pointer of type q31 */
;;;266        pb = pCoeffs;
0001a8  9b07              LDR      r3,[sp,#0x1c]
;;;267    
;;;268        tapCnt = numTaps >> 1;
0001aa  9c02              LDR      r4,[sp,#8]
0001ac  0864              LSRS     r4,r4,#1
                  |L1.430|
;;;269    
;;;270        do
;;;271        {
;;;272    
;;;273          c0 = *__SIMD32(pb)++;
0001ae  f8536b04          LDR      r6,[r3],#4
;;;274          x0 = *__SIMD32(px1)++;
0001b2  f8527b04          LDR      r7,[r2],#4
;;;275    
;;;276          acc0 = __SMLALD(x0, c0, acc0);
0001b6  fbc701c6          SMLALD   r0,r1,r7,r6
;;;277          tapCnt--;
0001ba  1e64              SUBS     r4,r4,#1
;;;278        }
;;;279        while(tapCnt > 0u);
0001bc  2c00              CMP      r4,#0
0001be  d1f6              BNE      |L1.430|
;;;280    
;;;281        /* The result is in 2.30 format.  Convert to 1.15 with saturation.       
;;;282         ** Then store the output in the destination buffer. */
;;;283        *pDst++ = (q15_t) (__SSAT((acc0 >> 15), 16));
0001c0  0bc0              LSRS     r0,r0,#15
0001c2  ea404041          ORR      r0,r0,r1,LSL #17
0001c6  f300010f          SSAT     r1,#16,r0
0001ca  980f              LDR      r0,[sp,#0x3c]
0001cc  8001              STRH     r1,[r0,#0]
0001ce  980f              LDR      r0,[sp,#0x3c]
0001d0  1c80              ADDS     r0,r0,#2
0001d2  900f              STR      r0,[sp,#0x3c]
;;;284    
;;;285        /* Advance state pointer by 1 for the next sample */
;;;286        pState = pState + 1;
0001d4  f10c0c02          ADD      r12,r12,#2
;;;287    
;;;288        /* Decrement the loop counter */
;;;289        blkCnt--;
0001d8  1e6d              SUBS     r5,r5,#1
                  |L1.474|
0001da  2d00              CMP      r5,#0                 ;254
0001dc  d1da              BNE      |L1.404|
;;;290      }
;;;291    
;;;292      /* Processing is complete.       
;;;293       ** Now copy the last numTaps - 1 samples to the satrt of the state buffer.       
;;;294       ** This prepares the state buffer for the next function call. */
;;;295    
;;;296      /* Points to the start of the state buffer */
;;;297      pStateCurnt = S->pState;
0001de  980d              LDR      r0,[sp,#0x34]
0001e0  6840              LDR      r0,[r0,#4]
;;;298    
;;;299      /* Calculation of count for copying integer writes */
;;;300      tapCnt = (numTaps - 1u) >> 2;
0001e2  990c              LDR      r1,[sp,#0x30]
0001e4  0889              LSRS     r1,r1,#2
;;;301    
;;;302      while(tapCnt > 0u)
0001e6  e007              B        |L1.504|
                  |L1.488|
;;;303      {
;;;304    
;;;305        /* Copy state values to start of state buffer */
;;;306        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
0001e8  f85c2b04          LDR      r2,[r12],#4
0001ec  6002              STR      r2,[r0,#0]
;;;307        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
0001ee  f85c2b04          LDR      r2,[r12],#4
0001f2  6042              STR      r2,[r0,#4]
0001f4  3008              ADDS     r0,r0,#8
;;;308    
;;;309        tapCnt--;
0001f6  1e49              SUBS     r1,r1,#1
                  |L1.504|
0001f8  2900              CMP      r1,#0                 ;302
0001fa  d1f5              BNE      |L1.488|
;;;310    
;;;311      }
;;;312    
;;;313      /* Calculation of count for remaining q15_t data */
;;;314      tapCnt = (numTaps - 1u) % 0x4u;
0001fc  990c              LDR      r1,[sp,#0x30]
0001fe  f0010103          AND      r1,r1,#3
;;;315    
;;;316      /* copy remaining data */
;;;317      while(tapCnt > 0u)
000202  e004              B        |L1.526|
                  |L1.516|
;;;318      {
;;;319        *pStateCurnt++ = *pState++;
000204  f83c2b02          LDRH     r2,[r12],#2
000208  f8202b02          STRH     r2,[r0],#2
;;;320    
;;;321        /* Decrement the loop counter */
;;;322        tapCnt--;
00020c  1e49              SUBS     r1,r1,#1
                  |L1.526|
00020e  2900              CMP      r1,#0                 ;317
000210  d1f8              BNE      |L1.516|
;;;323      }
;;;324    }
000212  b011              ADD      sp,sp,#0x44
000214  e8bd8ff0          POP      {r4-r11,pc}
;;;325    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_fir_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_fir_q15_c_3b7760c8____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___13_arm_fir_q15_c_3b7760c8____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_fir_q15_c_3b7760c8____REVSH|
#line 144
|__asm___13_arm_fir_q15_c_3b7760c8____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_fir_q15_c_3b7760c8____RRX|
#line 300
|__asm___13_arm_fir_q15_c_3b7760c8____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
