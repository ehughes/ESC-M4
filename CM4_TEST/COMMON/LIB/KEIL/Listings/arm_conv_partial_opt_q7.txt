; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_partial_opt_q7.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_partial_opt_q7.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE\_CMSIS_DSP_4_5_O3 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_conv_partial_opt_q7.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_partial_opt_q7.c]
                          THUMB

                          AREA ||i.arm_conv_partial_opt_q7||, CODE, READONLY, ALIGN=2

                  arm_conv_partial_opt_q7 PROC
;;;75     
;;;76     arm_status arm_conv_partial_opt_q7(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;77       q7_t * pSrcA,
;;;78       uint32_t srcALen,
;;;79       q7_t * pSrcB,
;;;80       uint32_t srcBLen,
;;;81       q7_t * pDst,
;;;82       uint32_t firstIndex,
;;;83       uint32_t numPoints,
;;;84       q15_t * pScratch1,
;;;85       q15_t * pScratch2)
;;;86     {
000004  b085              SUB      sp,sp,#0x14
000006  460f              MOV      r7,r1
000008  e9dda60e          LDRD     r10,r6,[sp,#0x38]
;;;87     
;;;88       q15_t *pScr2, *pScr1;                          /* Intermediate pointers for scratch pointers */
;;;89       q15_t x4;                                      /* Temporary input variable */
;;;90       q7_t *pIn1, *pIn2;                             /* inputA and inputB pointer */
;;;91       uint32_t j, k, blkCnt, tapCnt;                 /* loop counter */
;;;92       q7_t *px;                                      /* Temporary input1 pointer */
;;;93       q15_t *py;                                     /* Temporary input2 pointer */
;;;94       q31_t acc0, acc1, acc2, acc3;                  /* Accumulator */
;;;95       q31_t x1, x2, x3, y1;                          /* Temporary input variables */
;;;96       arm_status status;
;;;97       q7_t *pOut = pDst;                             /* output pointer */
;;;98       q7_t out0, out1, out2, out3;                   /* temporary variables */
;;;99     
;;;100      /* Check for range of output samples to be calculated */
;;;101      if((firstIndex + numPoints) > ((srcALen + (srcBLen - 1u))))
00000c  9910              LDR      r1,[sp,#0x40]
00000e  461c              MOV      r4,r3                 ;86
000010  1873              ADDS     r3,r6,r1
000012  e9dd9811          LDRD     r9,r8,[sp,#0x44]      ;86
000016  1939              ADDS     r1,r7,r4
000018  1e49              SUBS     r1,r1,#1
00001a  428b              CMP      r3,r1
00001c  d904              BLS      |L1.40|
;;;102      {
;;;103        /* Set status as ARM_MATH_ARGUMENT_ERROR */
;;;104        status = ARM_MATH_ARGUMENT_ERROR;
00001e  f04f30ff          MOV      r0,#0xffffffff
                  |L1.34|
;;;105      }
;;;106      else
;;;107      {
;;;108    
;;;109        /* The algorithm implementation is based on the lengths of the inputs. */
;;;110        /* srcB is always made to slide across srcA. */
;;;111        /* So srcBLen is always considered as shorter or equal to srcALen */
;;;112        if(srcALen >= srcBLen)
;;;113        {
;;;114          /* Initialization of inputA pointer */
;;;115          pIn1 = pSrcA;
;;;116    
;;;117          /* Initialization of inputB pointer */
;;;118          pIn2 = pSrcB;
;;;119        }
;;;120        else
;;;121        {
;;;122          /* Initialization of inputA pointer */
;;;123          pIn1 = pSrcB;
;;;124    
;;;125          /* Initialization of inputB pointer */
;;;126          pIn2 = pSrcA;
;;;127    
;;;128          /* srcBLen is always considered as shorter or equal to srcALen */
;;;129          j = srcBLen;
;;;130          srcBLen = srcALen;
;;;131          srcALen = j;
;;;132        }
;;;133    
;;;134        /* pointer to take end of scratch2 buffer */
;;;135        pScr2 = pScratch2;
;;;136    
;;;137        /* points to smaller length sequence */
;;;138        px = pIn2 + srcBLen - 1;
;;;139    
;;;140        /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;141        k = srcBLen >> 2u;
;;;142    
;;;143        /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;144         ** a second loop below copies for the remaining 1 to 3 samples. */
;;;145        while(k > 0u)
;;;146        {
;;;147          /* copy second buffer in reversal manner */
;;;148          x4 = (q15_t) * px--;
;;;149          *pScr2++ = x4;
;;;150          x4 = (q15_t) * px--;
;;;151          *pScr2++ = x4;
;;;152          x4 = (q15_t) * px--;
;;;153          *pScr2++ = x4;
;;;154          x4 = (q15_t) * px--;
;;;155          *pScr2++ = x4;
;;;156    
;;;157          /* Decrement the loop counter */
;;;158          k--;
;;;159        }
;;;160    
;;;161        /* If the count is not a multiple of 4, copy remaining samples here.       
;;;162         ** No loop unrolling is used. */
;;;163        k = srcBLen % 0x4u;
;;;164    
;;;165        while(k > 0u)
;;;166        {
;;;167          /* copy second buffer in reversal manner for remaining samples */
;;;168          x4 = (q15_t) * px--;
;;;169          *pScr2++ = x4;
;;;170    
;;;171          /* Decrement the loop counter */
;;;172          k--;
;;;173        }
;;;174    
;;;175        /* Initialze temporary scratch pointer */
;;;176        pScr1 = pScratch1;
;;;177    
;;;178        /* Fill (srcBLen - 1u) zeros in scratch buffer */
;;;179        arm_fill_q15(0, pScr1, (srcBLen - 1u));
;;;180    
;;;181        /* Update temporary scratch pointer */
;;;182        pScr1 += (srcBLen - 1u);
;;;183    
;;;184        /* Copy (srcALen) samples in scratch buffer */
;;;185        /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;186        k = srcALen >> 2u;
;;;187    
;;;188        /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;189         ** a second loop below copies for the remaining 1 to 3 samples. */
;;;190        while(k > 0u)
;;;191        {
;;;192          /* copy second buffer in reversal manner */
;;;193          x4 = (q15_t) * pIn1++;
;;;194          *pScr1++ = x4;
;;;195          x4 = (q15_t) * pIn1++;
;;;196          *pScr1++ = x4;
;;;197          x4 = (q15_t) * pIn1++;
;;;198          *pScr1++ = x4;
;;;199          x4 = (q15_t) * pIn1++;
;;;200          *pScr1++ = x4;
;;;201    
;;;202          /* Decrement the loop counter */
;;;203          k--;
;;;204        }
;;;205    
;;;206        /* If the count is not a multiple of 4, copy remaining samples here.       
;;;207         ** No loop unrolling is used. */
;;;208        k = srcALen % 0x4u;
;;;209    
;;;210        while(k > 0u)
;;;211        {
;;;212          /* copy second buffer in reversal manner for remaining samples */
;;;213          x4 = (q15_t) * pIn1++;
;;;214          *pScr1++ = x4;
;;;215    
;;;216          /* Decrement the loop counter */
;;;217          k--;
;;;218        }
;;;219    
;;;220        /* Fill (srcBLen - 1u) zeros at end of scratch buffer */
;;;221        arm_fill_q15(0, pScr1, (srcBLen - 1u));
;;;222    
;;;223        /* Update pointer */
;;;224        pScr1 += (srcBLen - 1u);
;;;225    
;;;226    
;;;227        /* Temporary pointer for scratch2 */
;;;228        py = pScratch2;
;;;229    
;;;230        /* Initialization of pIn2 pointer */
;;;231        pIn2 = (q7_t *) py;
;;;232    
;;;233        pScr2 = py;
;;;234    
;;;235        pOut = pDst + firstIndex;
;;;236    
;;;237        pScratch1 += firstIndex;
;;;238    
;;;239        /* Actual convolution process starts here */
;;;240        blkCnt = (numPoints) >> 2;
;;;241    
;;;242    
;;;243        while(blkCnt > 0)
;;;244        {
;;;245          /* Initialze temporary scratch pointer as scratch1 */
;;;246          pScr1 = pScratch1;
;;;247    
;;;248          /* Clear Accumlators */
;;;249          acc0 = 0;
;;;250          acc1 = 0;
;;;251          acc2 = 0;
;;;252          acc3 = 0;
;;;253    
;;;254          /* Read two samples from scratch1 buffer */
;;;255          x1 = *__SIMD32(pScr1)++;
;;;256    
;;;257          /* Read next two samples from scratch1 buffer */
;;;258          x2 = *__SIMD32(pScr1)++;
;;;259    
;;;260          tapCnt = (srcBLen) >> 2u;
;;;261    
;;;262          while(tapCnt > 0u)
;;;263          {
;;;264    
;;;265            /* Read four samples from smaller buffer */
;;;266            y1 = _SIMD32_OFFSET(pScr2);
;;;267    
;;;268            /* multiply and accumlate */
;;;269            acc0 = __SMLAD(x1, y1, acc0);
;;;270            acc2 = __SMLAD(x2, y1, acc2);
;;;271    
;;;272            /* pack input data */
;;;273    #ifndef ARM_MATH_BIG_ENDIAN
;;;274            x3 = __PKHBT(x2, x1, 0);
;;;275    #else
;;;276            x3 = __PKHBT(x1, x2, 0);
;;;277    #endif
;;;278    
;;;279            /* multiply and accumlate */
;;;280            acc1 = __SMLADX(x3, y1, acc1);
;;;281    
;;;282            /* Read next two samples from scratch1 buffer */
;;;283            x1 = *__SIMD32(pScr1)++;
;;;284    
;;;285            /* pack input data */
;;;286    #ifndef ARM_MATH_BIG_ENDIAN
;;;287            x3 = __PKHBT(x1, x2, 0);
;;;288    #else
;;;289            x3 = __PKHBT(x2, x1, 0);
;;;290    #endif
;;;291    
;;;292            acc3 = __SMLADX(x3, y1, acc3);
;;;293    
;;;294            /* Read four samples from smaller buffer */
;;;295            y1 = _SIMD32_OFFSET(pScr2 + 2u);
;;;296    
;;;297            acc0 = __SMLAD(x2, y1, acc0);
;;;298    
;;;299            acc2 = __SMLAD(x1, y1, acc2);
;;;300    
;;;301            acc1 = __SMLADX(x3, y1, acc1);
;;;302    
;;;303            x2 = *__SIMD32(pScr1)++;
;;;304    
;;;305    #ifndef ARM_MATH_BIG_ENDIAN
;;;306            x3 = __PKHBT(x2, x1, 0);
;;;307    #else
;;;308            x3 = __PKHBT(x1, x2, 0);
;;;309    #endif
;;;310    
;;;311            acc3 = __SMLADX(x3, y1, acc3);
;;;312    
;;;313            pScr2 += 4u;
;;;314    
;;;315    
;;;316            /* Decrement the loop counter */
;;;317            tapCnt--;
;;;318          }
;;;319    
;;;320    
;;;321    
;;;322          /* Update scratch pointer for remaining samples of smaller length sequence */
;;;323          pScr1 -= 4u;
;;;324    
;;;325    
;;;326          /* apply same above for remaining samples of smaller length sequence */
;;;327          tapCnt = (srcBLen) & 3u;
;;;328    
;;;329          while(tapCnt > 0u)
;;;330          {
;;;331    
;;;332            /* accumlate the results */
;;;333            acc0 += (*pScr1++ * *pScr2);
;;;334            acc1 += (*pScr1++ * *pScr2);
;;;335            acc2 += (*pScr1++ * *pScr2);
;;;336            acc3 += (*pScr1++ * *pScr2++);
;;;337    
;;;338            pScr1 -= 3u;
;;;339    
;;;340            /* Decrement the loop counter */
;;;341            tapCnt--;
;;;342          }
;;;343    
;;;344          blkCnt--;
;;;345    
;;;346          /* Store the result in the accumulator in the destination buffer. */
;;;347          out0 = (q7_t) (__SSAT(acc0 >> 7u, 8));
;;;348          out1 = (q7_t) (__SSAT(acc1 >> 7u, 8));
;;;349          out2 = (q7_t) (__SSAT(acc2 >> 7u, 8));
;;;350          out3 = (q7_t) (__SSAT(acc3 >> 7u, 8));
;;;351    
;;;352          *__SIMD32(pOut)++ = __PACKq7(out0, out1, out2, out3);
;;;353    
;;;354          /* Initialization of inputB pointer */
;;;355          pScr2 = py;
;;;356    
;;;357          pScratch1 += 4u;
;;;358    
;;;359        }
;;;360    
;;;361        blkCnt = (numPoints) & 0x3;
;;;362    
;;;363        /* Calculate convolution for remaining samples of Bigger length sequence */
;;;364        while(blkCnt > 0)
;;;365        {
;;;366          /* Initialze temporary scratch pointer as scratch1 */
;;;367          pScr1 = pScratch1;
;;;368    
;;;369          /* Clear Accumlators */
;;;370          acc0 = 0;
;;;371    
;;;372          tapCnt = (srcBLen) >> 1u;
;;;373    
;;;374          while(tapCnt > 0u)
;;;375          {
;;;376    
;;;377            /* Read next two samples from scratch1 buffer */
;;;378            x1 = *__SIMD32(pScr1)++;
;;;379    
;;;380            /* Read two samples from smaller buffer */
;;;381            y1 = *__SIMD32(pScr2)++;
;;;382    
;;;383            acc0 = __SMLAD(x1, y1, acc0);
;;;384    
;;;385            /* Decrement the loop counter */
;;;386            tapCnt--;
;;;387          }
;;;388    
;;;389          tapCnt = (srcBLen) & 1u;
;;;390    
;;;391          /* apply same above for remaining samples of smaller length sequence */
;;;392          while(tapCnt > 0u)
;;;393          {
;;;394    
;;;395            /* accumlate the results */
;;;396            acc0 += (*pScr1++ * *pScr2++);
;;;397    
;;;398            /* Decrement the loop counter */
;;;399            tapCnt--;
;;;400          }
;;;401    
;;;402          blkCnt--;
;;;403    
;;;404          /* Store the result in the accumulator in the destination buffer. */
;;;405          *pOut++ = (q7_t) (__SSAT(acc0 >> 7u, 8));
;;;406    
;;;407          /* Initialization of inputB pointer */
;;;408          pScr2 = py;
;;;409    
;;;410          pScratch1 += 1u;
;;;411    
;;;412        }
;;;413    
;;;414        /* set status as ARM_MATH_SUCCESS */
;;;415        status = ARM_MATH_SUCCESS;
;;;416    
;;;417    
;;;418      }
;;;419    
;;;420      return (status);
;;;421    
;;;422    }
000022  b005              ADD      sp,sp,#0x14
000024  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.40|
000028  42a7              CMP      r7,r4                 ;112
00002a  d301              BCC      |L1.48|
00002c  4605              MOV      r5,r0                 ;115
00002e  e004              B        |L1.58|
                  |L1.48|
000030  4615              MOV      r5,r2                 ;123
000032  4602              MOV      r2,r0                 ;126
000034  4620              MOV      r0,r4                 ;129
000036  463c              MOV      r4,r7                 ;130
000038  4607              MOV      r7,r0                 ;131
                  |L1.58|
00003a  1911              ADDS     r1,r2,r4              ;138
00003c  08a2              LSRS     r2,r4,#2              ;141
00003e  4640              MOV      r0,r8                 ;135
000040  1e49              SUBS     r1,r1,#1              ;141
000042  9204              STR      r2,[sp,#0x10]         ;145
000044  e012              B        |L1.108|
000046  bf00              NOP                            ;148
                  |L1.72|
000048  f991c000          LDRSB    r12,[r1,#0]           ;148
00004c  f820cb02          STRH     r12,[r0],#2           ;149
000050  f911cc01          LDRSB    r12,[r1,#-1]          ;150
000054  f820cb02          STRH     r12,[r0],#2           ;151
000058  f911cc02          LDRSB    r12,[r1,#-2]          ;152
00005c  f820cb04          STRH     r12,[r0],#4           ;153
000060  f9113c03          LDRSB    r3,[r1,#-3]           ;154
000064  1f09              SUBS     r1,r1,#4              ;155
000066  f8203c02          STRH     r3,[r0,#-2]           ;155
00006a  1e52              SUBS     r2,r2,#1              ;155
                  |L1.108|
00006c  2a00              CMP      r2,#0                 ;145
00006e  d1eb              BNE      |L1.72|
000070  f0040203          AND      r2,r4,#3              ;163
000074  9203              STR      r2,[sp,#0xc]          ;165
000076  e004              B        |L1.130|
                  |L1.120|
000078  f9113901          LDRSB    r3,[r1],#-1           ;168
00007c  f8203b02          STRH     r3,[r0],#2            ;169
000080  1e52              SUBS     r2,r2,#1              ;169
                  |L1.130|
000082  2a00              CMP      r2,#0                 ;165
000084  d1f8              BNE      |L1.120|
000086  1e62              SUBS     r2,r4,#1              ;179
000088  4649              MOV      r1,r9                 ;179
00008a  2000              MOVS     r0,#0                 ;179
00008c  f7fffffe          BL       arm_fill_q15
000090  eb090144          ADD      r1,r9,r4,LSL #1       ;182
000094  08b8              LSRS     r0,r7,#2              ;186
000096  1e89              SUBS     r1,r1,#2              ;186
000098  e011              B        |L1.190|
00009a  bf00              NOP                            ;193
                  |L1.156|
00009c  f9152b01          LDRSB    r2,[r5],#1            ;193
0000a0  f8212b02          STRH     r2,[r1],#2            ;194
0000a4  f9152b01          LDRSB    r2,[r5],#1            ;195
0000a8  f8212b02          STRH     r2,[r1],#2            ;196
0000ac  f9152b02          LDRSB    r2,[r5],#2            ;197
0000b0  f8212b04          STRH     r2,[r1],#4            ;198
0000b4  f9152c01          LDRSB    r2,[r5,#-1]           ;199
0000b8  f8212c02          STRH     r2,[r1,#-2]           ;200
0000bc  1e40              SUBS     r0,r0,#1              ;200
                  |L1.190|
0000be  2800              CMP      r0,#0                 ;190
0000c0  d1ec              BNE      |L1.156|
0000c2  f0070003          AND      r0,r7,#3              ;208
0000c6  e004              B        |L1.210|
                  |L1.200|
0000c8  f9152b01          LDRSB    r2,[r5],#1            ;213
0000cc  f8212b02          STRH     r2,[r1],#2            ;214
0000d0  1e40              SUBS     r0,r0,#1              ;214
                  |L1.210|
0000d2  2800              CMP      r0,#0                 ;210
0000d4  d1f8              BNE      |L1.200|
0000d6  1e62              SUBS     r2,r4,#1              ;221
0000d8  f7fffffe          BL       arm_fill_q15
0000dc  eb0a0106          ADD      r1,r10,r6             ;235
0000e0  e9cd1800          STRD     r1,r8,[sp,#0]         ;235
0000e4  9910              LDR      r1,[sp,#0x40]         ;240
0000e6  4640              MOV      r0,r8                 ;228
0000e8  0889              LSRS     r1,r1,#2              ;240
0000ea  eb090e46          ADD      lr,r9,r6,LSL #1       ;237
0000ee  9102              STR      r1,[sp,#8]            ;243
0000f0  e06a              B        |L1.456|
                  |L1.242|
0000f2  f10e0704          ADD      r7,lr,#4              ;255
0000f6  2300              MOVS     r3,#0                 ;249
0000f8  f8571b04          LDR      r1,[r7],#4            ;258
0000fc  46bb              MOV      r11,r7                ;258
0000fe  461d              MOV      r5,r3                 ;250
000100  461e              MOV      r6,r3                 ;251
000102  469c              MOV      r12,r3                ;252
000104  f8de2000          LDR      r2,[lr,#0]            ;255
000108  9f04              LDR      r7,[sp,#0x10]         ;262
00010a  e022              B        |L1.338|
                  |L1.268|
00010c  f8507b04          LDR      r7,[r0],#4            ;266
000110  fb223307          SMLAD    r3,r2,r7,r3           ;269
000114  fb216607          SMLAD    r6,r1,r7,r6           ;270
000118  eac10202          PKHBT    r2,r1,r2              ;274
00011c  fb225917          SMLADX   r9,r2,r7,r5           ;280
000120  f8db2000          LDR      r2,[r11,#0]           ;283
000124  f10b0804          ADD      r8,r11,#4             ;283
000128  eac20501          PKHBT    r5,r2,r1              ;287
00012c  fb25cc17          SMLADX   r12,r5,r7,r12         ;292
000130  f8507b04          LDR      r7,[r0],#4            ;295
000134  fb213307          SMLAD    r3,r1,r7,r3           ;297
000138  fb226607          SMLAD    r6,r2,r7,r6           ;299
00013c  fb259517          SMLADX   r5,r5,r7,r9           ;301
000140  f8581b04          LDR      r1,[r8],#4            ;303
000144  46c3              MOV      r11,r8                ;303
000146  eac10802          PKHBT    r8,r1,r2              ;306
00014a  fb28cc17          SMLADX   r12,r8,r7,r12         ;311
00014e  f1aa0701          SUB      r7,r10,#1             ;317
                  |L1.338|
000152  ea5f0a07          MOVS     r10,r7                ;260
000156  d1d9              BNE      |L1.268|
000158  f1ab0808          SUB      r8,r11,#8             ;323
00015c  9903              LDR      r1,[sp,#0xc]          ;329
00015e  e012              B        |L1.390|
                  |L1.352|
000160  f8387b02          LDRH     r7,[r8],#2            ;333
000164  f8302b02          LDRH     r2,[r0],#2            ;333
000168  fb173302          SMLABB   r3,r7,r2,r3           ;333
00016c  f8b87000          LDRH     r7,[r8,#0]            ;334
000170  fb175502          SMLABB   r5,r7,r2,r5           ;334
000174  f8b87002          LDRH     r7,[r8,#2]            ;335
000178  fb176602          SMLABB   r6,r7,r2,r6           ;335
00017c  f8b87004          LDRH     r7,[r8,#4]            ;336
000180  fb17cc02          SMLABB   r12,r7,r2,r12         ;336
000184  1e49              SUBS     r1,r1,#1              ;336
                  |L1.390|
000186  2900              CMP      r1,#0                 ;329
000188  d1ea              BNE      |L1.352|
00018a  9802              LDR      r0,[sp,#8]            ;344
00018c  f32311c7          SSAT     r1,#8,r3,ASR #7       ;347
000190  1e40              SUBS     r0,r0,#1              ;344
000192  9002              STR      r0,[sp,#8]            ;348
000194  f32510c7          SSAT     r0,#8,r5,ASR #7       ;348
000198  f64f75ff          MOV      r5,#0xffff            ;352
00019c  b2c9              UXTB     r1,r1                 ;352
00019e  ea052000          AND      r0,r5,r0,LSL #8       ;352
0001a2  f32612c7          SSAT     r2,#8,r6,ASR #7       ;349
0001a6  4301              ORRS     r1,r1,r0              ;352
0001a8  b2d0              UXTB     r0,r2                 ;352
0001aa  f32c13c7          SSAT     r3,#8,r12,ASR #7      ;350
0001ae  ea414000          ORR      r0,r1,r0,LSL #16      ;352
0001b2  ea406103          ORR      r1,r0,r3,LSL #24      ;352
0001b6  9800              LDR      r0,[sp,#0]            ;352
0001b8  f10e0e08          ADD      lr,lr,#8              ;357
0001bc  6001              STR      r1,[r0,#0]            ;352
0001be  9800              LDR      r0,[sp,#0]            ;352
0001c0  1d00              ADDS     r0,r0,#4              ;352
0001c2  9000              STR      r0,[sp,#0]            ;357
0001c4  e9dd0101          LDRD     r0,r1,[sp,#4]         ;357
                  |L1.456|
0001c8  2900              CMP      r1,#0                 ;243
0001ca  d192              BNE      |L1.242|
0001cc  9910              LDR      r1,[sp,#0x40]         ;361
0001ce  f0010303          AND      r3,r1,#3              ;361
0001d2  e023              B        |L1.540|
                  |L1.468|
0001d4  2200              MOVS     r2,#0                 ;370
0001d6  4671              MOV      r1,lr                 ;367
0001d8  0865              LSRS     r5,r4,#1              ;372
0001da  e006              B        |L1.490|
                  |L1.476|
0001dc  f8517b04          LDR      r7,[r1],#4            ;378
0001e0  f8506b04          LDR      r6,[r0],#4            ;381
0001e4  fb272206          SMLAD    r2,r7,r6,r2           ;383
0001e8  1e6d              SUBS     r5,r5,#1              ;383
                  |L1.490|
0001ea  2d00              CMP      r5,#0                 ;374
0001ec  d1f6              BNE      |L1.476|
0001ee  f0040501          AND      r5,r4,#1              ;389
0001f2  e006              B        |L1.514|
                  |L1.500|
0001f4  f8316b02          LDRH     r6,[r1],#2            ;396
0001f8  f8307b02          LDRH     r7,[r0],#2            ;396
0001fc  fb162207          SMLABB   r2,r6,r7,r2           ;396
000200  1e6d              SUBS     r5,r5,#1              ;396
                  |L1.514|
000202  2d00              CMP      r5,#0                 ;392
000204  d1f6              BNE      |L1.500|
000206  9800              LDR      r0,[sp,#0]            ;405
000208  f32211c7          SSAT     r1,#8,r2,ASR #7       ;405
00020c  f10e0e02          ADD      lr,lr,#2              ;410
000210  7001              STRB     r1,[r0,#0]            ;405
000212  9800              LDR      r0,[sp,#0]            ;405
000214  1c40              ADDS     r0,r0,#1              ;405
000216  9000              STR      r0,[sp,#0]            ;408
000218  9801              LDR      r0,[sp,#4]            ;410
00021a  1e5b              SUBS     r3,r3,#1              ;410
                  |L1.540|
00021c  2b00              CMP      r3,#0                 ;364
00021e  d1d9              BNE      |L1.468|
000220  2000              MOVS     r0,#0                 ;415
000222  e6fe              B        |L1.34|
;;;423    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_partial_opt_q7.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_conv_partial_opt_q7_c_727da03f____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___25_arm_conv_partial_opt_q7_c_727da03f____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_conv_partial_opt_q7_c_727da03f____REVSH|
#line 144
|__asm___25_arm_conv_partial_opt_q7_c_727da03f____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_conv_partial_opt_q7_c_727da03f____RRX|
#line 300
|__asm___25_arm_conv_partial_opt_q7_c_727da03f____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
