; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_partial_opt_q7.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_partial_opt_q7.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_conv_partial_opt_q7.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_partial_opt_q7.c]
                          THUMB

                          AREA ||i.arm_conv_partial_opt_q7||, CODE, READONLY, ALIGN=1

                  arm_conv_partial_opt_q7 PROC
;;;75     
;;;76     arm_status arm_conv_partial_opt_q7(
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;77       q7_t * pSrcA,
;;;78       uint32_t srcALen,
;;;79       q7_t * pSrcB,
;;;80       uint32_t srcBLen,
;;;81       q7_t * pDst,
;;;82       uint32_t firstIndex,
;;;83       uint32_t numPoints,
;;;84       q15_t * pScratch1,
;;;85       q15_t * pScratch2)
;;;86     {
000004  460e              MOV      r6,r1
000006  e9dda70e          LDRD     r10,r7,[sp,#0x38]
00000a  e9dd9411          LDRD     r9,r4,[sp,#0x44]
00000e  4698              MOV      r8,r3
;;;87     
;;;88       q15_t *pScr2, *pScr1;                          /* Intermediate pointers for scratch pointers */
;;;89       q15_t x4;                                      /* Temporary input variable */
;;;90       q7_t *pIn1, *pIn2;                             /* inputA and inputB pointer */
;;;91       uint32_t j, k, blkCnt, tapCnt;                 /* loop counter */
;;;92       q7_t *px;                                      /* Temporary input1 pointer */
;;;93       q15_t *py;                                     /* Temporary input2 pointer */
;;;94       q31_t acc0, acc1, acc2, acc3;                  /* Accumulator */
;;;95       q31_t x1, x2, x3, y1;                          /* Temporary input variables */
;;;96       arm_status status;
;;;97       q7_t *pOut = pDst;                             /* output pointer */
;;;98       q7_t out0, out1, out2, out3;                   /* temporary variables */
;;;99     
;;;100      /* Check for range of output samples to be calculated */
;;;101      if((firstIndex + numPoints) > ((srcALen + (srcBLen - 1u))))
000010  9910              LDR      r1,[sp,#0x40]
000012  187b              ADDS     r3,r7,r1
000014  eb060108          ADD      r1,r6,r8
000018  1e49              SUBS     r1,r1,#1
00001a  428b              CMP      r3,r1
00001c  d904              BLS      |L1.40|
;;;102      {
;;;103        /* Set status as ARM_MATH_ARGUMENT_ERROR */
;;;104        status = ARM_MATH_ARGUMENT_ERROR;
00001e  f04f30ff          MOV      r0,#0xffffffff
                  |L1.34|
;;;105      }
;;;106      else
;;;107      {
;;;108    
;;;109        /* The algorithm implementation is based on the lengths of the inputs. */
;;;110        /* srcB is always made to slide across srcA. */
;;;111        /* So srcBLen is always considered as shorter or equal to srcALen */
;;;112        if(srcALen >= srcBLen)
;;;113        {
;;;114          /* Initialization of inputA pointer */
;;;115          pIn1 = pSrcA;
;;;116    
;;;117          /* Initialization of inputB pointer */
;;;118          pIn2 = pSrcB;
;;;119        }
;;;120        else
;;;121        {
;;;122          /* Initialization of inputA pointer */
;;;123          pIn1 = pSrcB;
;;;124    
;;;125          /* Initialization of inputB pointer */
;;;126          pIn2 = pSrcA;
;;;127    
;;;128          /* srcBLen is always considered as shorter or equal to srcALen */
;;;129          j = srcBLen;
;;;130          srcBLen = srcALen;
;;;131          srcALen = j;
;;;132        }
;;;133    
;;;134        /* pointer to take end of scratch2 buffer */
;;;135        pScr2 = pScratch2;
;;;136    
;;;137        /* points to smaller length sequence */
;;;138        px = pIn2 + srcBLen - 1;
;;;139    
;;;140        /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;141        k = srcBLen >> 2u;
;;;142    
;;;143        /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;144         ** a second loop below copies for the remaining 1 to 3 samples. */
;;;145        while(k > 0u)
;;;146        {
;;;147          /* copy second buffer in reversal manner */
;;;148          x4 = (q15_t) * px--;
;;;149          *pScr2++ = x4;
;;;150          x4 = (q15_t) * px--;
;;;151          *pScr2++ = x4;
;;;152          x4 = (q15_t) * px--;
;;;153          *pScr2++ = x4;
;;;154          x4 = (q15_t) * px--;
;;;155          *pScr2++ = x4;
;;;156    
;;;157          /* Decrement the loop counter */
;;;158          k--;
;;;159        }
;;;160    
;;;161        /* If the count is not a multiple of 4, copy remaining samples here.       
;;;162         ** No loop unrolling is used. */
;;;163        k = srcBLen % 0x4u;
;;;164    
;;;165        while(k > 0u)
;;;166        {
;;;167          /* copy second buffer in reversal manner for remaining samples */
;;;168          x4 = (q15_t) * px--;
;;;169          *pScr2++ = x4;
;;;170    
;;;171          /* Decrement the loop counter */
;;;172          k--;
;;;173        }
;;;174    
;;;175        /* Initialze temporary scratch pointer */
;;;176        pScr1 = pScratch1;
;;;177    
;;;178        /* Fill (srcBLen - 1u) zeros in scratch buffer */
;;;179        arm_fill_q15(0, pScr1, (srcBLen - 1u));
;;;180    
;;;181        /* Update temporary scratch pointer */
;;;182        pScr1 += (srcBLen - 1u);
;;;183    
;;;184        /* Copy (srcALen) samples in scratch buffer */
;;;185        /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;186        k = srcALen >> 2u;
;;;187    
;;;188        /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;189         ** a second loop below copies for the remaining 1 to 3 samples. */
;;;190        while(k > 0u)
;;;191        {
;;;192          /* copy second buffer in reversal manner */
;;;193          x4 = (q15_t) * pIn1++;
;;;194          *pScr1++ = x4;
;;;195          x4 = (q15_t) * pIn1++;
;;;196          *pScr1++ = x4;
;;;197          x4 = (q15_t) * pIn1++;
;;;198          *pScr1++ = x4;
;;;199          x4 = (q15_t) * pIn1++;
;;;200          *pScr1++ = x4;
;;;201    
;;;202          /* Decrement the loop counter */
;;;203          k--;
;;;204        }
;;;205    
;;;206        /* If the count is not a multiple of 4, copy remaining samples here.       
;;;207         ** No loop unrolling is used. */
;;;208        k = srcALen % 0x4u;
;;;209    
;;;210        while(k > 0u)
;;;211        {
;;;212          /* copy second buffer in reversal manner for remaining samples */
;;;213          x4 = (q15_t) * pIn1++;
;;;214          *pScr1++ = x4;
;;;215    
;;;216          /* Decrement the loop counter */
;;;217          k--;
;;;218        }
;;;219    
;;;220        /* Fill (srcBLen - 1u) zeros at end of scratch buffer */
;;;221        arm_fill_q15(0, pScr1, (srcBLen - 1u));
;;;222    
;;;223        /* Update pointer */
;;;224        pScr1 += (srcBLen - 1u);
;;;225    
;;;226    
;;;227        /* Temporary pointer for scratch2 */
;;;228        py = pScratch2;
;;;229    
;;;230        /* Initialization of pIn2 pointer */
;;;231        pIn2 = (q7_t *) py;
;;;232    
;;;233        pScr2 = py;
;;;234    
;;;235        pOut = pDst + firstIndex;
;;;236    
;;;237        pScratch1 += firstIndex;
;;;238    
;;;239        /* Actual convolution process starts here */
;;;240        blkCnt = (numPoints) >> 2;
;;;241    
;;;242    
;;;243        while(blkCnt > 0)
;;;244        {
;;;245          /* Initialze temporary scratch pointer as scratch1 */
;;;246          pScr1 = pScratch1;
;;;247    
;;;248          /* Clear Accumlators */
;;;249          acc0 = 0;
;;;250          acc1 = 0;
;;;251          acc2 = 0;
;;;252          acc3 = 0;
;;;253    
;;;254          /* Read two samples from scratch1 buffer */
;;;255          x1 = *__SIMD32(pScr1)++;
;;;256    
;;;257          /* Read next two samples from scratch1 buffer */
;;;258          x2 = *__SIMD32(pScr1)++;
;;;259    
;;;260          tapCnt = (srcBLen) >> 2u;
;;;261    
;;;262          while(tapCnt > 0u)
;;;263          {
;;;264    
;;;265            /* Read four samples from smaller buffer */
;;;266            y1 = _SIMD32_OFFSET(pScr2);
;;;267    
;;;268            /* multiply and accumlate */
;;;269            acc0 = __SMLAD(x1, y1, acc0);
;;;270            acc2 = __SMLAD(x2, y1, acc2);
;;;271    
;;;272            /* pack input data */
;;;273    #ifndef ARM_MATH_BIG_ENDIAN
;;;274            x3 = __PKHBT(x2, x1, 0);
;;;275    #else
;;;276            x3 = __PKHBT(x1, x2, 0);
;;;277    #endif
;;;278    
;;;279            /* multiply and accumlate */
;;;280            acc1 = __SMLADX(x3, y1, acc1);
;;;281    
;;;282            /* Read next two samples from scratch1 buffer */
;;;283            x1 = *__SIMD32(pScr1)++;
;;;284    
;;;285            /* pack input data */
;;;286    #ifndef ARM_MATH_BIG_ENDIAN
;;;287            x3 = __PKHBT(x1, x2, 0);
;;;288    #else
;;;289            x3 = __PKHBT(x2, x1, 0);
;;;290    #endif
;;;291    
;;;292            acc3 = __SMLADX(x3, y1, acc3);
;;;293    
;;;294            /* Read four samples from smaller buffer */
;;;295            y1 = _SIMD32_OFFSET(pScr2 + 2u);
;;;296    
;;;297            acc0 = __SMLAD(x2, y1, acc0);
;;;298    
;;;299            acc2 = __SMLAD(x1, y1, acc2);
;;;300    
;;;301            acc1 = __SMLADX(x3, y1, acc1);
;;;302    
;;;303            x2 = *__SIMD32(pScr1)++;
;;;304    
;;;305    #ifndef ARM_MATH_BIG_ENDIAN
;;;306            x3 = __PKHBT(x2, x1, 0);
;;;307    #else
;;;308            x3 = __PKHBT(x1, x2, 0);
;;;309    #endif
;;;310    
;;;311            acc3 = __SMLADX(x3, y1, acc3);
;;;312    
;;;313            pScr2 += 4u;
;;;314    
;;;315    
;;;316            /* Decrement the loop counter */
;;;317            tapCnt--;
;;;318          }
;;;319    
;;;320    
;;;321    
;;;322          /* Update scratch pointer for remaining samples of smaller length sequence */
;;;323          pScr1 -= 4u;
;;;324    
;;;325    
;;;326          /* apply same above for remaining samples of smaller length sequence */
;;;327          tapCnt = (srcBLen) & 3u;
;;;328    
;;;329          while(tapCnt > 0u)
;;;330          {
;;;331    
;;;332            /* accumlate the results */
;;;333            acc0 += (*pScr1++ * *pScr2);
;;;334            acc1 += (*pScr1++ * *pScr2);
;;;335            acc2 += (*pScr1++ * *pScr2);
;;;336            acc3 += (*pScr1++ * *pScr2++);
;;;337    
;;;338            pScr1 -= 3u;
;;;339    
;;;340            /* Decrement the loop counter */
;;;341            tapCnt--;
;;;342          }
;;;343    
;;;344          blkCnt--;
;;;345    
;;;346          /* Store the result in the accumulator in the destination buffer. */
;;;347          out0 = (q7_t) (__SSAT(acc0 >> 7u, 8));
;;;348          out1 = (q7_t) (__SSAT(acc1 >> 7u, 8));
;;;349          out2 = (q7_t) (__SSAT(acc2 >> 7u, 8));
;;;350          out3 = (q7_t) (__SSAT(acc3 >> 7u, 8));
;;;351    
;;;352          *__SIMD32(pOut)++ = __PACKq7(out0, out1, out2, out3);
;;;353    
;;;354          /* Initialization of inputB pointer */
;;;355          pScr2 = py;
;;;356    
;;;357          pScratch1 += 4u;
;;;358    
;;;359        }
;;;360    
;;;361        blkCnt = (numPoints) & 0x3;
;;;362    
;;;363        /* Calculate convolution for remaining samples of Bigger length sequence */
;;;364        while(blkCnt > 0)
;;;365        {
;;;366          /* Initialze temporary scratch pointer as scratch1 */
;;;367          pScr1 = pScratch1;
;;;368    
;;;369          /* Clear Accumlators */
;;;370          acc0 = 0;
;;;371    
;;;372          tapCnt = (srcBLen) >> 1u;
;;;373    
;;;374          while(tapCnt > 0u)
;;;375          {
;;;376    
;;;377            /* Read next two samples from scratch1 buffer */
;;;378            x1 = *__SIMD32(pScr1)++;
;;;379    
;;;380            /* Read two samples from smaller buffer */
;;;381            y1 = *__SIMD32(pScr2)++;
;;;382    
;;;383            acc0 = __SMLAD(x1, y1, acc0);
;;;384    
;;;385            /* Decrement the loop counter */
;;;386            tapCnt--;
;;;387          }
;;;388    
;;;389          tapCnt = (srcBLen) & 1u;
;;;390    
;;;391          /* apply same above for remaining samples of smaller length sequence */
;;;392          while(tapCnt > 0u)
;;;393          {
;;;394    
;;;395            /* accumlate the results */
;;;396            acc0 += (*pScr1++ * *pScr2++);
;;;397    
;;;398            /* Decrement the loop counter */
;;;399            tapCnt--;
;;;400          }
;;;401    
;;;402          blkCnt--;
;;;403    
;;;404          /* Store the result in the accumulator in the destination buffer. */
;;;405          *pOut++ = (q7_t) (__SSAT(acc0 >> 7u, 8));
;;;406    
;;;407          /* Initialization of inputB pointer */
;;;408          pScr2 = py;
;;;409    
;;;410          pScratch1 += 1u;
;;;411    
;;;412        }
;;;413    
;;;414        /* set status as ARM_MATH_SUCCESS */
;;;415        status = ARM_MATH_SUCCESS;
;;;416    
;;;417    
;;;418      }
;;;419    
;;;420      return (status);
;;;421    
;;;422    }
000022  b004              ADD      sp,sp,#0x10
000024  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.40|
000028  4546              CMP      r6,r8                 ;112
00002a  d301              BCC      |L1.48|
00002c  4605              MOV      r5,r0                 ;115
00002e  e004              B        |L1.58|
                  |L1.48|
000030  4615              MOV      r5,r2                 ;123
000032  4602              MOV      r2,r0                 ;126
000034  4640              MOV      r0,r8                 ;129
000036  46b0              MOV      r8,r6                 ;130
000038  4606              MOV      r6,r0                 ;131
                  |L1.58|
00003a  4620              MOV      r0,r4                 ;135
00003c  eb020108          ADD      r1,r2,r8              ;138
000040  1e49              SUBS     r1,r1,#1              ;138
000042  ea4f0298          LSR      r2,r8,#2              ;141
000046  9203              STR      r2,[sp,#0xc]          ;141
000048  e00e              B        |L1.104|
                  |L1.74|
00004a  1ec9              SUBS     r1,r1,#3              ;148
00004c  f9913003          LDRSB    r3,[r1,#3]            ;148
000050  8003              STRH     r3,[r0,#0]            ;149
000052  f9913002          LDRSB    r3,[r1,#2]            ;150
000056  8043              STRH     r3,[r0,#2]            ;151
000058  f9913001          LDRSB    r3,[r1,#1]            ;152
00005c  8083              STRH     r3,[r0,#4]            ;153
00005e  f9113901          LDRSB    r3,[r1],#-1           ;154
000062  80c3              STRH     r3,[r0,#6]            ;155
000064  3008              ADDS     r0,r0,#8              ;155
000066  1e52              SUBS     r2,r2,#1              ;158
                  |L1.104|
000068  2a00              CMP      r2,#0                 ;145
00006a  d1ee              BNE      |L1.74|
00006c  f0080203          AND      r2,r8,#3              ;163
000070  9202              STR      r2,[sp,#8]            ;163
000072  e004              B        |L1.126|
                  |L1.116|
000074  f9113901          LDRSB    r3,[r1],#-1           ;168
000078  f8203b02          STRH     r3,[r0],#2            ;169
00007c  1e52              SUBS     r2,r2,#1              ;172
                  |L1.126|
00007e  2a00              CMP      r2,#0                 ;165
000080  d1f8              BNE      |L1.116|
000082  f1a80201          SUB      r2,r8,#1              ;179
000086  4649              MOV      r1,r9                 ;179
000088  2000              MOVS     r0,#0                 ;179
00008a  f7fffffe          BL       arm_fill_q15
00008e  f1a80001          SUB      r0,r8,#1              ;182
000092  eb090140          ADD      r1,r9,r0,LSL #1       ;182
000096  08b0              LSRS     r0,r6,#2              ;186
000098  e00e              B        |L1.184|
                  |L1.154|
00009a  f9952000          LDRSB    r2,[r5,#0]            ;193
00009e  800a              STRH     r2,[r1,#0]            ;194
0000a0  f9952001          LDRSB    r2,[r5,#1]            ;195
0000a4  804a              STRH     r2,[r1,#2]            ;196
0000a6  f9952002          LDRSB    r2,[r5,#2]            ;197
0000aa  808a              STRH     r2,[r1,#4]            ;198
0000ac  f9952003          LDRSB    r2,[r5,#3]            ;199
0000b0  1d2d              ADDS     r5,r5,#4              ;199
0000b2  80ca              STRH     r2,[r1,#6]            ;200
0000b4  3108              ADDS     r1,r1,#8              ;200
0000b6  1e40              SUBS     r0,r0,#1              ;203
                  |L1.184|
0000b8  2800              CMP      r0,#0                 ;190
0000ba  d1ee              BNE      |L1.154|
0000bc  f0060003          AND      r0,r6,#3              ;208
0000c0  e004              B        |L1.204|
                  |L1.194|
0000c2  f9152b01          LDRSB    r2,[r5],#1            ;213
0000c6  f8212b02          STRH     r2,[r1],#2            ;214
0000ca  1e40              SUBS     r0,r0,#1              ;217
                  |L1.204|
0000cc  2800              CMP      r0,#0                 ;210
0000ce  d1f8              BNE      |L1.194|
0000d0  f1a80201          SUB      r2,r8,#1              ;221
0000d4  f7fffffe          BL       arm_fill_q15
0000d8  9400              STR      r4,[sp,#0]            ;228
0000da  9c00              LDR      r4,[sp,#0]            ;233
0000dc  44ba              ADD      r10,r10,r7            ;235
0000de  eb090947          ADD      r9,r9,r7,LSL #1       ;237
0000e2  9810              LDR      r0,[sp,#0x40]         ;240
0000e4  0880              LSRS     r0,r0,#2              ;240
0000e6  9001              STR      r0,[sp,#4]            ;240
0000e8  e05b              B        |L1.418|
                  |L1.234|
0000ea  464b              MOV      r3,r9                 ;246
0000ec  2500              MOVS     r5,#0                 ;249
0000ee  2600              MOVS     r6,#0                 ;250
0000f0  2700              MOVS     r7,#0                 ;251
0000f2  46ac              MOV      r12,r5                ;252
0000f4  681a              LDR      r2,[r3,#0]            ;255
0000f6  6858              LDR      r0,[r3,#4]            ;258
0000f8  3308              ADDS     r3,r3,#8              ;258
0000fa  f8ddb00c          LDR      r11,[sp,#0xc]         ;260
0000fe  e01d              B        |L1.316|
                  |L1.256|
000100  6821              LDR      r1,[r4,#0]            ;266
000102  fb225501          SMLAD    r5,r2,r1,r5           ;269
000106  fb207701          SMLAD    r7,r0,r1,r7           ;270
00010a  eac00202          PKHBT    r2,r0,r2              ;274
00010e  fb226e11          SMLADX   lr,r2,r1,r6           ;280
000112  681a              LDR      r2,[r3,#0]            ;283
000114  eac20600          PKHBT    r6,r2,r0              ;287
000118  fb26cc11          SMLADX   r12,r6,r1,r12         ;292
00011c  6861              LDR      r1,[r4,#4]            ;295
00011e  fb205501          SMLAD    r5,r0,r1,r5           ;297
000122  fb227701          SMLAD    r7,r2,r1,r7           ;299
000126  fb26e611          SMLADX   r6,r6,r1,lr           ;301
00012a  6858              LDR      r0,[r3,#4]            ;303
00012c  3308              ADDS     r3,r3,#8              ;303
00012e  eac00e02          PKHBT    lr,r0,r2              ;306
000132  fb2ecc11          SMLADX   r12,lr,r1,r12         ;311
000136  3408              ADDS     r4,r4,#8              ;313
000138  f1ab0b01          SUB      r11,r11,#1            ;317
                  |L1.316|
00013c  f1bb0f00          CMP      r11,#0                ;262
000140  d1de              BNE      |L1.256|
000142  3b08              SUBS     r3,r3,#8              ;323
000144  9902              LDR      r1,[sp,#8]            ;327
000146  e00f              B        |L1.360|
                  |L1.328|
000148  f8332b02          LDRH     r2,[r3],#2            ;333
00014c  f8340b02          LDRH     r0,[r4],#2            ;333
000150  fb125500          SMLABB   r5,r2,r0,r5           ;333
000154  881a              LDRH     r2,[r3,#0]            ;334
000156  fb126600          SMLABB   r6,r2,r0,r6           ;334
00015a  885a              LDRH     r2,[r3,#2]            ;335
00015c  fb127700          SMLABB   r7,r2,r0,r7           ;335
000160  889a              LDRH     r2,[r3,#4]            ;336
000162  fb12cc00          SMLABB   r12,r2,r0,r12         ;336
000166  1e49              SUBS     r1,r1,#1              ;341
                  |L1.360|
000168  2900              CMP      r1,#0                 ;329
00016a  d1ed              BNE      |L1.328|
00016c  9801              LDR      r0,[sp,#4]            ;344
00016e  1e40              SUBS     r0,r0,#1              ;344
000170  9001              STR      r0,[sp,#4]            ;344
000172  f32510c7          SSAT     r0,#8,r5,ASR #7       ;347
000176  f32611c7          SSAT     r1,#8,r6,ASR #7       ;348
00017a  f32712c7          SSAT     r2,#8,r7,ASR #7       ;349
00017e  f32c13c7          SSAT     r3,#8,r12,ASR #7      ;350
000182  f64f74ff          MOV      r4,#0xffff            ;352
000186  b2c0              UXTB     r0,r0                 ;352
000188  ea042101          AND      r1,r4,r1,LSL #8       ;352
00018c  4308              ORRS     r0,r0,r1              ;352
00018e  b2d1              UXTB     r1,r2                 ;352
000190  ea404001          ORR      r0,r0,r1,LSL #16      ;352
000194  ea406003          ORR      r0,r0,r3,LSL #24      ;352
000198  f84a0b04          STR      r0,[r10],#4           ;352
00019c  9c00              LDR      r4,[sp,#0]            ;355
00019e  f1090908          ADD      r9,r9,#8              ;357
                  |L1.418|
0001a2  9801              LDR      r0,[sp,#4]            ;243
0001a4  2800              CMP      r0,#0                 ;243
0001a6  d1a0              BNE      |L1.234|
0001a8  9810              LDR      r0,[sp,#0x40]         ;361
0001aa  f0000303          AND      r3,r0,#3              ;361
0001ae  e021              B        |L1.500|
                  |L1.432|
0001b0  4648              MOV      r0,r9                 ;367
0001b2  2100              MOVS     r1,#0                 ;370
0001b4  ea4f0258          LSR      r2,r8,#1              ;372
0001b8  e006              B        |L1.456|
                  |L1.442|
0001ba  f8505b04          LDR      r5,[r0],#4            ;378
0001be  f8546b04          LDR      r6,[r4],#4            ;381
0001c2  fb251106          SMLAD    r1,r5,r6,r1           ;383
0001c6  1e52              SUBS     r2,r2,#1              ;386
                  |L1.456|
0001c8  2a00              CMP      r2,#0                 ;374
0001ca  d1f6              BNE      |L1.442|
0001cc  f0080201          AND      r2,r8,#1              ;389
0001d0  e006              B        |L1.480|
                  |L1.466|
0001d2  f8305b02          LDRH     r5,[r0],#2            ;396
0001d6  f8346b02          LDRH     r6,[r4],#2            ;396
0001da  fb151106          SMLABB   r1,r5,r6,r1           ;396
0001de  1e52              SUBS     r2,r2,#1              ;399
                  |L1.480|
0001e0  2a00              CMP      r2,#0                 ;392
0001e2  d1f6              BNE      |L1.466|
0001e4  1e5b              SUBS     r3,r3,#1              ;402
0001e6  f32110c7          SSAT     r0,#8,r1,ASR #7       ;405
0001ea  f80a0b01          STRB     r0,[r10],#1           ;405
0001ee  9c00              LDR      r4,[sp,#0]            ;408
0001f0  f1090902          ADD      r9,r9,#2              ;410
                  |L1.500|
0001f4  2b00              CMP      r3,#0                 ;364
0001f6  d1db              BNE      |L1.432|
0001f8  2000              MOVS     r0,#0                 ;415
0001fa  e712              B        |L1.34|
;;;423    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_partial_opt_q7.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_conv_partial_opt_q7_c_727da03f____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___25_arm_conv_partial_opt_q7_c_727da03f____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_conv_partial_opt_q7_c_727da03f____REVSH|
#line 144
|__asm___25_arm_conv_partial_opt_q7_c_727da03f____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_conv_partial_opt_q7_c_727da03f____RRX|
#line 300
|__asm___25_arm_conv_partial_opt_q7_c_727da03f____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
