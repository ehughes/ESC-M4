; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE\_CMSIS_DSP_4_5_O3 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_conv_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_q15.c]
                          THUMB

                          AREA ||i.arm_conv_q15||, CODE, READONLY, ALIGN=2

                  arm_conv_q15 PROC
;;;78     
;;;79     void arm_conv_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;80       q15_t * pSrcA,
;;;81       uint32_t srcALen,
;;;82       q15_t * pSrcB,
;;;83       uint32_t srcBLen,
;;;84       q15_t * pDst)
;;;85     {
000004  b08b              SUB      sp,sp,#0x2c
;;;86     
;;;87     #if (defined(ARM_MATH_CM4) || defined(ARM_MATH_CM3)) && !defined(UNALIGNED_SUPPORT_DISABLE)
;;;88     
;;;89       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;90     
;;;91       q15_t *pIn1;                                   /* inputA pointer */
;;;92       q15_t *pIn2;                                   /* inputB pointer */
;;;93       q15_t *pOut = pDst;                            /* output pointer */
;;;94       q63_t sum, acc0, acc1, acc2, acc3;             /* Accumulator */
;;;95       q15_t *px;                                     /* Intermediate inputA pointer  */
;;;96       q15_t *py;                                     /* Intermediate inputB pointer  */
;;;97       q15_t *pSrc1, *pSrc2;                          /* Intermediate pointers */
;;;98       q31_t x0, x1, x2, x3, c0;                      /* Temporary variables to hold state and coefficient values */
;;;99       uint32_t blockSize1, blockSize2, blockSize3, j, k, count, blkCnt;     /* loop counter */
;;;100    
;;;101      /* The algorithm implementation is based on the lengths of the inputs. */
;;;102      /* srcB is always made to slide across srcA. */
;;;103      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;104      if(srcALen >= srcBLen)
000006  990c              LDR      r1,[sp,#0x30]
000008  9c18              LDR      r4,[sp,#0x60]
00000a  4299              CMP      r1,r3
00000c  d302              BCC      |L1.20|
;;;105      {
;;;106        /* Initialization of inputA pointer */
;;;107        pIn1 = pSrcA;
;;;108    
;;;109        /* Initialization of inputB pointer */
;;;110        pIn2 = pSrcB;
00000e  4693              MOV      r11,r2
000010  9003              STR      r0,[sp,#0xc]
000012  e004              B        |L1.30|
                  |L1.20|
;;;111      }
;;;112      else
;;;113      {
;;;114        /* Initialization of inputA pointer */
;;;115        pIn1 = pSrcB;
;;;116    
;;;117        /* Initialization of inputB pointer */
;;;118        pIn2 = pSrcA;
000014  4683              MOV      r11,r0
;;;119    
;;;120        /* srcBLen is always considered as shorter or equal to srcALen */
;;;121        j = srcBLen;
000016  4618              MOV      r0,r3
;;;122        srcBLen = srcALen;
000018  460b              MOV      r3,r1
;;;123        srcALen = j;
00001a  9203              STR      r2,[sp,#0xc]
00001c  900c              STR      r0,[sp,#0x30]
                  |L1.30|
;;;124      }
;;;125    
;;;126      /* conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1] */
;;;127      /* The function is internally   
;;;128       * divided into three stages according to the number of multiplications that has to be   
;;;129       * taken place between inputA samples and inputB samples. In the first stage of the   
;;;130       * algorithm, the multiplications increase by one for every iteration.   
;;;131       * In the second stage of the algorithm, srcBLen number of multiplications are done.   
;;;132       * In the third stage of the algorithm, the multiplications decrease by one   
;;;133       * for every iteration. */
;;;134    
;;;135      /* The algorithm is implemented in three stages.   
;;;136         The loop counters of each stage is initiated here. */
;;;137      blockSize1 = srcBLen - 1u;
;;;138      blockSize2 = srcALen - (srcBLen - 1u);
00001e  980c              LDR      r0,[sp,#0x30]
000020  1e5e              SUBS     r6,r3,#1              ;137
000022  1ac0              SUBS     r0,r0,r3
000024  1c40              ADDS     r0,r0,#1
;;;139    
;;;140      /* --------------------------   
;;;141       * Initializations of stage1   
;;;142       * -------------------------*/
;;;143    
;;;144      /* sum = x[0] * y[0]   
;;;145       * sum = x[0] * y[1] + x[1] * y[0]   
;;;146       * ....   
;;;147       * sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]   
;;;148       */
;;;149    
;;;150      /* In this stage the MAC operations are increased by 1 for every iteration.   
;;;151         The count variable holds the number of MAC operations performed */
;;;152      count = 1u;
;;;153    
;;;154      /* Working pointer of inputA */
;;;155      px = pIn1;
000026  9007              STR      r0,[sp,#0x1c]
000028  f04f0a01          MOV      r10,#1                ;152
;;;156    
;;;157      /* Working pointer of inputB */
;;;158      py = pIn2;
00002c  4659              MOV      r1,r11
;;;159    
;;;160    
;;;161      /* ------------------------   
;;;162       * Stage1 process   
;;;163       * ----------------------*/
;;;164    
;;;165      /* For loop unrolling by 4, this stage is divided into two. */
;;;166      /* First part of this stage computes the MAC operations less than 4 */
;;;167      /* Second part of this stage computes the MAC operations greater than or equal to 4 */
;;;168    
;;;169      /* The first part of the stage starts here */
;;;170      while((count < 4u) && (blockSize1 > 0u))
00002e  9803              LDR      r0,[sp,#0xc]
000030  e01d              B        |L1.110|
                  |L1.50|
000032  2200              MOVS     r2,#0
000034  4615              MOV      r5,r2
;;;171      {
;;;172        /* Accumulator is made zero for every iteration */
;;;173        sum = 0;
;;;174    
;;;175        /* Loop over number of MAC operations between   
;;;176         * inputA samples and inputB samples */
;;;177        k = count;
000036  4657              MOV      r7,r10
;;;178    
;;;179        while(k > 0u)
000038  e007              B        |L1.74|
;;;180        {
;;;181          /* Perform the multiply-accumulates */
;;;182          sum = __SMLALD(*px++, *py--, sum);
00003a  bf00              NOP      
                  |L1.60|
00003c  f9308b02          LDRSH    r8,[r0],#2
000040  f931c902          LDRSH    r12,[r1],#-2
000044  fbc825cc          SMLALD   r2,r5,r8,r12
000048  1e7f              SUBS     r7,r7,#1
                  |L1.74|
00004a  2f00              CMP      r7,#0                 ;179
00004c  d1f6              BNE      |L1.60|
;;;183    
;;;184          /* Decrement the loop counter */
;;;185          k--;
;;;186        }
;;;187    
;;;188        /* Store the result in the accumulator in the destination buffer. */
;;;189        *pOut++ = (q15_t) (__SSAT((sum >> 15), 16));
00004e  0bd0              LSRS     r0,r2,#15
000050  ea404045          ORR      r0,r0,r5,LSL #17
000054  f300000f          SSAT     r0,#16,r0
000058  f8240b02          STRH     r0,[r4],#2
;;;190    
;;;191        /* Update the inputA and inputB pointers for next MAC calculation */
;;;192        py = pIn2 + count;
00005c  eb0b014a          ADD      r1,r11,r10,LSL #1
;;;193        px = pIn1;
;;;194    
;;;195        /* Increment the MAC count */
;;;196        count++;
000060  f10a0a01          ADD      r10,r10,#1
000064  1e76              SUBS     r6,r6,#1
000066  9803              LDR      r0,[sp,#0xc]          ;170
000068  f1ba0f04          CMP      r10,#4                ;170
;;;197    
;;;198        /* Decrement the loop counter */
;;;199        blockSize1--;
00006c  d201              BCS      |L1.114|
                  |L1.110|
00006e  2e00              CMP      r6,#0                 ;170
000070  d1df              BNE      |L1.50|
                  |L1.114|
000072  1e89              SUBS     r1,r1,#2              ;170
;;;200      }
;;;201    
;;;202      /* The second part of the stage starts here */
;;;203      /* The internal loop, over count, is unrolled by 4 */
;;;204      /* To, read the last two inputB samples using SIMD:   
;;;205       * y[srcBLen] and y[srcBLen-1] coefficients, py is decremented by 1 */
;;;206      py = py - 1;
;;;207    
;;;208      while(blockSize1 > 0u)
000074  e031              B        |L1.218|
                  |L1.118|
000076  2200              MOVS     r2,#0
000078  4615              MOV      r5,r2
;;;209      {
;;;210        /* Accumulator is made zero for every iteration */
;;;211        sum = 0;
;;;212    
;;;213        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;214        k = count >> 2u;
00007a  ea4f079a          LSR      r7,r10,#2
;;;215    
;;;216        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;217         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;218        while(k > 0u)
00007e  e00f              B        |L1.160|
                  |L1.128|
;;;219        {
;;;220          /* Perform the multiply-accumulates */
;;;221          /* x[0], x[1] are multiplied with y[srcBLen - 1], y[srcBLen - 2] respectively */
;;;222          sum = __SMLALDX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
000080  f850cb04          LDR      r12,[r0],#4
000084  4686              MOV      lr,r0
000086  6808              LDR      r0,[r1,#0]
000088  fbcc25d0          SMLALDX  r2,r5,r12,r0
;;;223          /* x[2], x[3] are multiplied with y[srcBLen - 3], y[srcBLen - 4] respectively */
;;;224          sum = __SMLALDX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
00008c  f8de8000          LDR      r8,[lr,#0]
000090  f851cc04          LDR      r12,[r1,#-4]
000094  f10e0004          ADD      r0,lr,#4
000098  fbc825dc          SMLALDX  r2,r5,r8,r12
00009c  3908              SUBS     r1,r1,#8
00009e  1e7f              SUBS     r7,r7,#1
                  |L1.160|
0000a0  2f00              CMP      r7,#0                 ;218
0000a2  d1ed              BNE      |L1.128|
;;;225    
;;;226          /* Decrement the loop counter */
;;;227          k--;
;;;228        }
;;;229    
;;;230        /* For the next MAC operations, the pointer py is used without SIMD   
;;;231         * So, py is incremented by 1 */
;;;232        py = py + 1u;
;;;233    
;;;234        /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;235         ** No loop unrolling is used. */
;;;236        k = count % 0x4u;
0000a4  f00a0703          AND      r7,r10,#3
0000a8  1c89              ADDS     r1,r1,#2
;;;237    
;;;238        while(k > 0u)
0000aa  e006              B        |L1.186|
                  |L1.172|
;;;239        {
;;;240          /* Perform the multiply-accumulates */
;;;241          sum = __SMLALD(*px++, *py--, sum);
0000ac  f930cb02          LDRSH    r12,[r0],#2
0000b0  f9318902          LDRSH    r8,[r1],#-2
0000b4  fbcc25c8          SMLALD   r2,r5,r12,r8
0000b8  1e7f              SUBS     r7,r7,#1
                  |L1.186|
0000ba  2f00              CMP      r7,#0                 ;238
0000bc  d1f6              BNE      |L1.172|
;;;242    
;;;243          /* Decrement the loop counter */
;;;244          k--;
;;;245        }
;;;246    
;;;247        /* Store the result in the accumulator in the destination buffer. */
;;;248        *pOut++ = (q15_t) (__SSAT((sum >> 15), 16));
0000be  0bd0              LSRS     r0,r2,#15
0000c0  ea404045          ORR      r0,r0,r5,LSL #17
0000c4  f300000f          SSAT     r0,#16,r0
;;;249    
;;;250        /* Update the inputA and inputB pointers for next MAC calculation */
;;;251        py = pIn2 + (count - 1u);
0000c8  eb0b014a          ADD      r1,r11,r10,LSL #1
0000cc  f8240b02          STRH     r0,[r4],#2            ;248
;;;252        px = pIn1;
;;;253    
;;;254        /* Increment the MAC count */
;;;255        count++;
0000d0  1e89              SUBS     r1,r1,#2
0000d2  9803              LDR      r0,[sp,#0xc]
0000d4  f10a0a01          ADD      r10,r10,#1
0000d8  1e76              SUBS     r6,r6,#1
                  |L1.218|
0000da  2e00              CMP      r6,#0                 ;208
0000dc  d1cb              BNE      |L1.118|
;;;256    
;;;257        /* Decrement the loop counter */
;;;258        blockSize1--;
;;;259      }
;;;260    
;;;261      /* --------------------------   
;;;262       * Initializations of stage2   
;;;263       * ------------------------*/
;;;264    
;;;265      /* sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0]   
;;;266       * sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0]   
;;;267       * ....   
;;;268       * sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]   
;;;269       */
;;;270    
;;;271      /* Working pointer of inputA */
;;;272      px = pIn1;
;;;273    
;;;274      /* Working pointer of inputB */
;;;275      pSrc2 = pIn2 + (srcBLen - 1u);
0000de  eb0b0143          ADD      r1,r11,r3,LSL #1
0000e2  910a              STR      r1,[sp,#0x28]
0000e4  1e89              SUBS     r1,r1,#2
;;;276      py = pSrc2;
;;;277    
;;;278      /* count is the index by which the pointer pIn1 to be incremented */
;;;279      count = 0u;
0000e6  2200              MOVS     r2,#0
;;;280    
;;;281    
;;;282      /* --------------------   
;;;283       * Stage2 process   
;;;284       * -------------------*/
;;;285    
;;;286      /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.   
;;;287       * So, to loop unroll over blockSize2,   
;;;288       * srcBLen should be greater than or equal to 4 */
;;;289      if(srcBLen >= 4u)
0000e8  9202              STR      r2,[sp,#8]
0000ea  9105              STR      r1,[sp,#0x14]
0000ec  2b04              CMP      r3,#4
0000ee  d376              BCC      |L1.478|
;;;290      {
;;;291        /* Loop unroll over blockSize2, by 4 */
;;;292        blkCnt = blockSize2 >> 2u;
0000f0  9a07              LDR      r2,[sp,#0x1c]
0000f2  0892              LSRS     r2,r2,#2
;;;293    
;;;294        while(blkCnt > 0u)
0000f4  e0f1              B        |L1.730|
                  |L1.246|
0000f6  2500              MOVS     r5,#0
;;;295        {
;;;296          py = py - 1u;
;;;297    
;;;298          /* Set all accumulators to zero */
;;;299          acc0 = 0;
;;;300          acc1 = 0;
0000f8  e9cd5500          STRD     r5,r5,[sp,#0]
0000fc  9509              STR      r5,[sp,#0x24]
0000fe  9508              STR      r5,[sp,#0x20]
;;;301          acc2 = 0;
;;;302          acc3 = 0;
;;;303    
;;;304    
;;;305          /* read x[0], x[1] samples */
;;;306          x0 = *__SIMD32(px);
000100  f8507b02          LDR      r7,[r0],#2
000104  46ab              MOV      r11,r5                ;299
;;;307          /* read x[1], x[2] samples */
;;;308          x1 = _SIMD32_OFFSET(px+1);
000106  f8502b02          LDR      r2,[r0],#2
00010a  46ae              MOV      lr,r5                 ;300
00010c  46a8              MOV      r8,r5                 ;300
00010e  46aa              MOV      r10,r5                ;302
;;;309    	  px+= 2u;
;;;310    
;;;311    
;;;312          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;313          k = srcBLen >> 2u;
000110  ea4f0993          LSR      r9,r3,#2
000114  f1b10102          SUBS.W   r1,r1,#2
                  |L1.280|
;;;314    
;;;315          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;316           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;317          do
;;;318          {
;;;319            /* Read the last two inputB samples using SIMD:   
;;;320             * y[srcBLen - 1] and y[srcBLen - 2] */
;;;321            c0 = *__SIMD32(py)--;
000118  1f0d              SUBS     r5,r1,#4
00011a  f8d1c000          LDR      r12,[r1,#0]
;;;322    
;;;323            /* acc0 +=  x[0] * y[srcBLen - 1] + x[1] * y[srcBLen - 2] */
;;;324            acc0 = __SMLALDX(x0, c0, acc0);
00011e  9504              STR      r5,[sp,#0x10]
000120  9e09              LDR      r6,[sp,#0x24]
000122  465d              MOV      r5,r11
000124  fbc756dc          SMLALDX  r5,r6,r7,r12
;;;325    
;;;326            /* acc1 +=  x[1] * y[srcBLen - 1] + x[2] * y[srcBLen - 2] */
;;;327            acc1 = __SMLALDX(x1, c0, acc1);
000128  9609              STR      r6,[sp,#0x24]
00012a  46ab              MOV      r11,r5                ;324
00012c  9e08              LDR      r6,[sp,#0x20]
00012e  4675              MOV      r5,lr
000130  fbc256dc          SMLALDX  r5,r6,r2,r12
;;;328    
;;;329            /* Read x[2], x[3] */
;;;330            x2 = *__SIMD32(px);
000134  9608              STR      r6,[sp,#0x20]
000136  46ae              MOV      lr,r5                 ;327
000138  f8502b02          LDR      r2,[r0],#2
;;;331    
;;;332            /* Read x[3], x[4] */
;;;333            x3 = _SIMD32_OFFSET(px+1);
00013c  e9dd5600          LDRD     r5,r6,[sp,#0]
000140  f8507b02          LDR      r7,[r0],#2
;;;334    
;;;335            /* acc2 +=  x[2] * y[srcBLen - 1] + x[3] * y[srcBLen - 2] */
;;;336            acc2 = __SMLALDX(x2, c0, acc2);
000144  fbc256dc          SMLALDX  r5,r6,r2,r12
000148  e9cd5600          STRD     r5,r6,[sp,#0]
;;;337    
;;;338            /* acc3 +=  x[3] * y[srcBLen - 1] + x[4] * y[srcBLen - 2] */
;;;339            acc3 = __SMLALDX(x3, c0, acc3);
00014c  4655              MOV      r5,r10
00014e  fbc785dc          SMLALDX  r8,r5,r7,r12
000152  46aa              MOV      r10,r5
;;;340    
;;;341            /* Read y[srcBLen - 3] and y[srcBLen - 4] */
;;;342            c0 = *__SIMD32(py)--;
000154  9d04              LDR      r5,[sp,#0x10]
;;;343    
;;;344            /* acc0 +=  x[2] * y[srcBLen - 3] + x[3] * y[srcBLen - 4] */
;;;345            acc0 = __SMLALDX(x2, c0, acc0);
000156  9e09              LDR      r6,[sp,#0x24]
000158  f8d5c000          LDR      r12,[r5,#0]           ;342
00015c  465d              MOV      r5,r11
00015e  fbc256dc          SMLALDX  r5,r6,r2,r12
;;;346    
;;;347            /* acc1 +=  x[3] * y[srcBLen - 3] + x[4] * y[srcBLen - 4] */
;;;348            acc1 = __SMLALDX(x3, c0, acc1);
000162  9609              STR      r6,[sp,#0x24]
000164  46ab              MOV      r11,r5                ;345
000166  9e08              LDR      r6,[sp,#0x20]
000168  4675              MOV      r5,lr
00016a  fbc756dc          SMLALDX  r5,r6,r7,r12
;;;349    
;;;350            /* Read x[4], x[5] */
;;;351            x0 = _SIMD32_OFFSET(px+2);
00016e  9608              STR      r6,[sp,#0x20]
000170  46ae              MOV      lr,r5                 ;348
000172  f8507b04          LDR      r7,[r0],#4
;;;352    
;;;353            /* Read x[5], x[6] */
;;;354            x1 = _SIMD32_OFFSET(px+3);
000176  e9dd5600          LDRD     r5,r6,[sp,#0]
00017a  f8502c02          LDR      r2,[r0,#-2]
;;;355    		px += 4u;
;;;356    
;;;357            /* acc2 +=  x[4] * y[srcBLen - 3] + x[5] * y[srcBLen - 4] */
;;;358            acc2 = __SMLALDX(x0, c0, acc2);
00017e  fbc756dc          SMLALDX  r5,r6,r7,r12
000182  e9cd5600          STRD     r5,r6,[sp,#0]
;;;359    
;;;360            /* acc3 +=  x[5] * y[srcBLen - 3] + x[6] * y[srcBLen - 4] */
;;;361            acc3 = __SMLALDX(x1, c0, acc3);
000186  4655              MOV      r5,r10
000188  fbc285dc          SMLALDX  r8,r5,r2,r12
00018c  46aa              MOV      r10,r5
;;;362    
;;;363          } while(--k);
00018e  f1a90501          SUB      r5,r9,#1
000192  3908              SUBS     r1,r1,#8
000194  ea5f0905          MOVS     r9,r5
000198  d1be              BNE      |L1.280|
;;;364    
;;;365          /* For the next MAC operations, SIMD is not used   
;;;366           * So, the 16 bit pointer if inputB, py is updated */
;;;367    
;;;368          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;369           ** No loop unrolling is used. */
;;;370          k = srcBLen % 0x4u;
00019a  f0030503          AND      r5,r3,#3
;;;371    
;;;372          if(k == 1u)
00019e  2d01              CMP      r5,#1
0001a0  d004              BEQ      |L1.428|
;;;373          {
;;;374            /* Read y[srcBLen - 5] */
;;;375            c0 = *(py+1);
;;;376    
;;;377    #ifdef  ARM_MATH_BIG_ENDIAN
;;;378    
;;;379            c0 = c0 << 16u;
;;;380    
;;;381    #else
;;;382    
;;;383            c0 = c0 & 0x0000FFFF;
;;;384    
;;;385    #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;386            /* Read x[7] */
;;;387            x3 = *__SIMD32(px);
;;;388    		px++;
;;;389    
;;;390            /* Perform the multiply-accumulates */
;;;391            acc0 = __SMLALD(x0, c0, acc0);
;;;392            acc1 = __SMLALD(x1, c0, acc1);
;;;393            acc2 = __SMLALDX(x1, c0, acc2);
;;;394            acc3 = __SMLALDX(x3, c0, acc3);
;;;395          }
;;;396    
;;;397          if(k == 2u)
0001a2  2d02              CMP      r5,#2
0001a4  d01c              BEQ      |L1.480|
;;;398          {
;;;399            /* Read y[srcBLen - 5], y[srcBLen - 6] */
;;;400            c0 = _SIMD32_OFFSET(py);
;;;401    
;;;402            /* Read x[7], x[8] */
;;;403            x3 = *__SIMD32(px);
;;;404    
;;;405            /* Read x[9] */
;;;406            x2 = _SIMD32_OFFSET(px+1);
;;;407    		px += 2u;
;;;408    
;;;409            /* Perform the multiply-accumulates */
;;;410            acc0 = __SMLALDX(x0, c0, acc0);
;;;411            acc1 = __SMLALDX(x1, c0, acc1);
;;;412            acc2 = __SMLALDX(x3, c0, acc2);
;;;413            acc3 = __SMLALDX(x2, c0, acc3);
;;;414          }
;;;415    
;;;416          if(k == 3u)
0001a6  2d03              CMP      r5,#3
0001a8  d036              BEQ      |L1.536|
0001aa  e06a              B        |L1.642|
                  |L1.428|
0001ac  8849              LDRH     r1,[r1,#2]            ;375
0001ae  6805              LDR      r5,[r0,#0]            ;387
0001b0  9e09              LDR      r6,[sp,#0x24]         ;391
0001b2  b289              UXTH     r1,r1                 ;383
0001b4  4658              MOV      r0,r11                ;391
0001b6  fbc706c1          SMLALD   r0,r6,r7,r1           ;391
0001ba  9609              STR      r6,[sp,#0x24]         ;392
0001bc  4683              MOV      r11,r0                ;391
0001be  9e08              LDR      r6,[sp,#0x20]         ;392
0001c0  4670              MOV      r0,lr                 ;392
0001c2  fbc206c1          SMLALD   r0,r6,r2,r1           ;392
0001c6  4686              MOV      lr,r0                 ;392
0001c8  9608              STR      r6,[sp,#0x20]         ;392
0001ca  e9dd0600          LDRD     r0,r6,[sp,#0]         ;392
0001ce  fbc206d1          SMLALDX  r0,r6,r2,r1           ;393
0001d2  e9cd0600          STRD     r0,r6,[sp,#0]         ;393
0001d6  4650              MOV      r0,r10                ;394
0001d8  fbc580d1          SMLALDX  r8,r0,r5,r1           ;394
0001dc  e01a              B        |L1.532|
                  |L1.478|
0001de  e0c7              B        |L1.880|
                  |L1.480|
0001e0  680d              LDR      r5,[r1,#0]            ;400
0001e2  f8d0c000          LDR      r12,[r0,#0]           ;403
0001e6  f8d06002          LDR      r6,[r0,#2]            ;406
0001ea  9909              LDR      r1,[sp,#0x24]         ;410
0001ec  4658              MOV      r0,r11                ;410
0001ee  fbc701d5          SMLALDX  r0,r1,r7,r5           ;410
0001f2  9109              STR      r1,[sp,#0x24]         ;411
0001f4  4683              MOV      r11,r0                ;410
0001f6  9908              LDR      r1,[sp,#0x20]         ;411
0001f8  4670              MOV      r0,lr                 ;411
0001fa  fbc201d5          SMLALDX  r0,r1,r2,r5           ;411
0001fe  4686              MOV      lr,r0                 ;411
000200  9108              STR      r1,[sp,#0x20]         ;411
000202  e9dd0100          LDRD     r0,r1,[sp,#0]         ;411
000206  fbcc01d5          SMLALDX  r0,r1,r12,r5          ;412
00020a  e9cd0100          STRD     r0,r1,[sp,#0]         ;412
00020e  4650              MOV      r0,r10                ;413
000210  fbc680d5          SMLALDX  r8,r0,r6,r5           ;413
                  |L1.532|
000214  4682              MOV      r10,r0                ;413
000216  e034              B        |L1.642|
                  |L1.536|
;;;417          {
;;;418            /* Read y[srcBLen - 5], y[srcBLen - 6] */
;;;419            c0 = _SIMD32_OFFSET(py);
000218  f8d19000          LDR      r9,[r1,#0]
;;;420    
;;;421            /* Read x[7], x[8] */
;;;422            x3 = *__SIMD32(px);
00021c  6806              LDR      r6,[r0,#0]
;;;423    
;;;424            /* Read x[9] */
;;;425            x2 = _SIMD32_OFFSET(px+1);
00021e  9604              STR      r6,[sp,#0x10]
000220  f8d0c002          LDR      r12,[r0,#2]
;;;426    
;;;427            /* Perform the multiply-accumulates */
;;;428            acc0 = __SMLALDX(x0, c0, acc0);
000224  9e09              LDR      r6,[sp,#0x24]
000226  465d              MOV      r5,r11
000228  fbc756d9          SMLALDX  r5,r6,r7,r9
00022c  46ab              MOV      r11,r5
;;;429            acc1 = __SMLALDX(x1, c0, acc1);
00022e  9609              STR      r6,[sp,#0x24]
000230  9d08              LDR      r5,[sp,#0x20]
000232  4676              MOV      r6,lr
000234  fbc265d9          SMLALDX  r6,r5,r2,r9
000238  9508              STR      r5,[sp,#0x20]
00023a  46b6              MOV      lr,r6
00023c  e9dd5700          LDRD     r5,r7,[sp,#0]
;;;430            acc2 = __SMLALDX(x3, c0, acc2);
000240  9e04              LDR      r6,[sp,#0x10]
000242  fbc657d9          SMLALDX  r5,r7,r6,r9
;;;431            acc3 = __SMLALDX(x2, c0, acc3);
000246  9500              STR      r5,[sp,#0]
000248  4655              MOV      r5,r10
00024a  fbcc85d9          SMLALDX  r8,r5,r12,r9
;;;432    
;;;433    		c0 = *(py-1);
00024e  f8311c02          LDRH     r1,[r1,#-2]
000252  46a9              MOV      r9,r5                 ;431
;;;434    
;;;435    #ifdef  ARM_MATH_BIG_ENDIAN
;;;436    
;;;437            c0 = c0 << 16u;
;;;438    #else
;;;439    
;;;440            c0 = c0 & 0x0000FFFF;
;;;441    #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;442            /* Read x[10] */
;;;443            x3 =  _SIMD32_OFFSET(px+2);
000254  6840              LDR      r0,[r0,#4]
;;;444    		px += 3u;
;;;445    
;;;446            /* Perform the multiply-accumulates */
;;;447            acc0 = __SMLALDX(x1, c0, acc0);
000256  9e09              LDR      r6,[sp,#0x24]
000258  b289              UXTH     r1,r1                 ;440
00025a  465d              MOV      r5,r11
00025c  fbc256d1          SMLALDX  r5,r6,r2,r1
000260  46ab              MOV      r11,r5
;;;448            acc1 = __SMLALD(x2, c0, acc1);
000262  9609              STR      r6,[sp,#0x24]
000264  9d08              LDR      r5,[sp,#0x20]
000266  4676              MOV      r6,lr
000268  fbcc65c1          SMLALD   r6,r5,r12,r1
;;;449            acc2 = __SMLALDX(x2, c0, acc2);
00026c  9508              STR      r5,[sp,#0x20]
00026e  9d00              LDR      r5,[sp,#0]
000270  46b6              MOV      lr,r6                 ;448
000272  fbcc57d1          SMLALDX  r5,r7,r12,r1
000276  e9cd5700          STRD     r5,r7,[sp,#0]
;;;450            acc3 = __SMLALDX(x3, c0, acc3);
00027a  464d              MOV      r5,r9
00027c  fbc085d1          SMLALDX  r8,r5,r0,r1
000280  46aa              MOV      r10,r5
                  |L1.642|
;;;451          }
;;;452    
;;;453    
;;;454          /* Store the results in the accumulators in the destination buffer. */
;;;455    
;;;456    #ifndef  ARM_MATH_BIG_ENDIAN
;;;457    
;;;458          *__SIMD32(pOut)++ =
000282  9909              LDR      r1,[sp,#0x24]
000284  ea4f30db          LSR      r0,r11,#15
000288  ea404041          ORR      r0,r0,r1,LSL #17
00028c  f300010f          SSAT     r1,#16,r0
000290  9a08              LDR      r2,[sp,#0x20]
000292  ea4f30de          LSR      r0,lr,#15
000296  ea404042          ORR      r0,r0,r2,LSL #17
00029a  f300000f          SSAT     r0,#16,r0
00029e  eac14000          PKHBT    r0,r1,r0,LSL #16
0002a2  f8440b04          STR      r0,[r4],#4
0002a6  e9dd0100          LDRD     r0,r1,[sp,#0]
;;;459            __PKHBT(__SSAT((acc0 >> 15), 16), __SSAT((acc1 >> 15), 16), 16);
;;;460          *__SIMD32(pOut)++ =
0002aa  0bc0              LSRS     r0,r0,#15
0002ac  ea404041          ORR      r0,r0,r1,LSL #17
0002b0  ea4f31d8          LSR      r1,r8,#15
0002b4  ea41414a          ORR      r1,r1,r10,LSL #17
0002b8  f300000f          SSAT     r0,#16,r0
0002bc  f301010f          SSAT     r1,#16,r1
0002c0  eac04001          PKHBT    r0,r0,r1,LSL #16
0002c4  f8440b04          STR      r0,[r4],#4
;;;461            __PKHBT(__SSAT((acc2 >> 15), 16), __SSAT((acc3 >> 15), 16), 16);
;;;462    
;;;463    #else
;;;464    
;;;465          *__SIMD32(pOut)++ =
;;;466            __PKHBT(__SSAT((acc1 >> 15), 16), __SSAT((acc0 >> 15), 16), 16);
;;;467          *__SIMD32(pOut)++ =
;;;468            __PKHBT(__SSAT((acc3 >> 15), 16), __SSAT((acc2 >> 15), 16), 16);
;;;469    
;;;470    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;471    
;;;472          /* Increment the pointer pIn1 index, count by 4 */
;;;473          count += 4u;
0002c8  9802              LDR      r0,[sp,#8]
;;;474    
;;;475          /* Update the inputA and inputB pointers for next MAC calculation */
;;;476          px = pIn1 + count;
0002ca  9903              LDR      r1,[sp,#0xc]
0002cc  1d00              ADDS     r0,r0,#4              ;473
0002ce  9002              STR      r0,[sp,#8]
0002d0  eb010040          ADD      r0,r1,r0,LSL #1
0002d4  e9dd1205          LDRD     r1,r2,[sp,#0x14]
0002d8  1e52              SUBS     r2,r2,#1
                  |L1.730|
0002da  9206              STR      r2,[sp,#0x18]         ;292
0002dc  2a00              CMP      r2,#0                 ;292
0002de  f47faf0a          BNE      |L1.246|
;;;477          py = pSrc2;
;;;478    
;;;479           /* Decrement the loop counter */
;;;480          blkCnt--;
;;;481        }
;;;482    
;;;483        /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.   
;;;484         ** No loop unrolling is used. */
;;;485        blkCnt = blockSize2 % 0x4u;
0002e2  9a07              LDR      r2,[sp,#0x1c]
0002e4  f0020203          AND      r2,r2,#3
;;;486    
;;;487        while(blkCnt > 0u)
0002e8  e03e              B        |L1.872|
                  |L1.746|
0002ea  2200              MOVS     r2,#0
0002ec  4615              MOV      r5,r2
;;;488        {
;;;489          /* Accumulator is made zero for every iteration */
;;;490          sum = 0;
;;;491    
;;;492          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;493          k = srcBLen >> 2u;
0002ee  089e              LSRS     r6,r3,#2
;;;494    
;;;495          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;496           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;497          while(k > 0u)
0002f0  e01a              B        |L1.808|
;;;498          {
;;;499            /* Perform the multiply-accumulates */
;;;500            sum += (q63_t) ((q31_t) * px++ * *py--);
0002f2  bf00              NOP      
                  |L1.756|
0002f4  f930cb02          LDRSH    r12,[r0],#2
0002f8  f9b17000          LDRSH    r7,[r1,#0]
0002fc  fbcc2587          SMLALBB  r2,r5,r12,r7
;;;501            sum += (q63_t) ((q31_t) * px++ * *py--);
000300  f9309b02          LDRSH    r9,[r0],#2
000304  f931cc02          LDRSH    r12,[r1,#-2]
000308  fbc9258c          SMLALBB  r2,r5,r9,r12
;;;502            sum += (q63_t) ((q31_t) * px++ * *py--);
00030c  f9308b02          LDRSH    r8,[r0],#2
000310  f931cc04          LDRSH    r12,[r1,#-4]
000314  fbc8258c          SMLALBB  r2,r5,r8,r12
;;;503            sum += (q63_t) ((q31_t) * px++ * *py--);
000318  f930cb02          LDRSH    r12,[r0],#2
00031c  f9317c06          LDRSH    r7,[r1,#-6]
000320  fbcc2587          SMLALBB  r2,r5,r12,r7
000324  3908              SUBS     r1,r1,#8
000326  1e76              SUBS     r6,r6,#1
                  |L1.808|
000328  2e00              CMP      r6,#0                 ;497
00032a  d1e3              BNE      |L1.756|
;;;504    
;;;505            /* Decrement the loop counter */
;;;506            k--;
;;;507          }
;;;508    
;;;509          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;510           ** No loop unrolling is used. */
;;;511          k = srcBLen % 0x4u;
00032c  f0030603          AND      r6,r3,#3
;;;512    
;;;513          while(k > 0u)
000330  e007              B        |L1.834|
;;;514          {
;;;515            /* Perform the multiply-accumulates */
;;;516            sum += (q63_t) ((q31_t) * px++ * *py--);
000332  bf00              NOP      
                  |L1.820|
000334  f930cb02          LDRSH    r12,[r0],#2
000338  f9317902          LDRSH    r7,[r1],#-2
00033c  fbcc2587          SMLALBB  r2,r5,r12,r7
000340  1e76              SUBS     r6,r6,#1
                  |L1.834|
000342  2e00              CMP      r6,#0                 ;513
000344  d1f6              BNE      |L1.820|
;;;517    
;;;518            /* Decrement the loop counter */
;;;519            k--;
;;;520          }
;;;521    
;;;522          /* Store the result in the accumulator in the destination buffer. */
;;;523          *pOut++ = (q15_t) (__SSAT(sum >> 15, 16));
000346  0bd0              LSRS     r0,r2,#15
000348  ea404045          ORR      r0,r0,r5,LSL #17
00034c  f300000f          SSAT     r0,#16,r0
000350  f8240b02          STRH     r0,[r4],#2
;;;524    
;;;525          /* Increment the pointer pIn1 index, count by 1 */
;;;526          count++;
000354  9802              LDR      r0,[sp,#8]
;;;527    
;;;528          /* Update the inputA and inputB pointers for next MAC calculation */
;;;529          px = pIn1 + count;
;;;530          py = pSrc2;
;;;531    
;;;532          /* Decrement the loop counter */
;;;533          blkCnt--;
000356  f1aa0201          SUB      r2,r10,#1
00035a  1c40              ADDS     r0,r0,#1              ;526
00035c  9002              STR      r0,[sp,#8]            ;526
00035e  e9dd1002          LDRD     r1,r0,[sp,#8]         ;526
000362  eb000041          ADD      r0,r0,r1,LSL #1       ;529
000366  9905              LDR      r1,[sp,#0x14]
                  |L1.872|
000368  ea5f0a02          MOVS     r10,r2                ;485
00036c  d1bd              BNE      |L1.746|
00036e  e020              B        |L1.946|
                  |L1.880|
;;;534        }
;;;535      }
;;;536      else
;;;537      {
;;;538        /* If the srcBLen is not a multiple of 4,   
;;;539         * the blockSize2 loop cannot be unrolled by 4 */
;;;540        blkCnt = blockSize2;
;;;541    
;;;542        while(blkCnt > 0u)
000370  9f07              LDR      r7,[sp,#0x1c]
000372  e01c              B        |L1.942|
                  |L1.884|
000374  2200              MOVS     r2,#0
000376  4615              MOV      r5,r2
;;;543        {
;;;544          /* Accumulator is made zero for every iteration */
;;;545          sum = 0;
;;;546    
;;;547          /* srcBLen number of MACS should be performed */
;;;548          k = srcBLen;
000378  461e              MOV      r6,r3
;;;549    
;;;550          while(k > 0u)
00037a  e006              B        |L1.906|
                  |L1.892|
;;;551          {
;;;552            /* Perform the multiply-accumulate */
;;;553            sum += (q63_t) ((q31_t) * px++ * *py--);
00037c  f9308b02          LDRSH    r8,[r0],#2
000380  f931c902          LDRSH    r12,[r1],#-2
000384  fbc8258c          SMLALBB  r2,r5,r8,r12
000388  1e76              SUBS     r6,r6,#1
                  |L1.906|
00038a  2e00              CMP      r6,#0                 ;550
00038c  d1f6              BNE      |L1.892|
;;;554    
;;;555            /* Decrement the loop counter */
;;;556            k--;
;;;557          }
;;;558    
;;;559          /* Store the result in the accumulator in the destination buffer. */
;;;560          *pOut++ = (q15_t) (__SSAT(sum >> 15, 16));
00038e  0bd0              LSRS     r0,r2,#15
000390  ea404045          ORR      r0,r0,r5,LSL #17
000394  f300000f          SSAT     r0,#16,r0
000398  f8240b02          STRH     r0,[r4],#2
;;;561    
;;;562          /* Increment the MAC count */
;;;563          count++;
00039c  9802              LDR      r0,[sp,#8]
00039e  1c40              ADDS     r0,r0,#1
0003a0  9002              STR      r0,[sp,#8]
0003a2  e9dd1002          LDRD     r1,r0,[sp,#8]
;;;564    
;;;565          /* Update the inputA and inputB pointers for next MAC calculation */
;;;566          px = pIn1 + count;
0003a6  eb000041          ADD      r0,r0,r1,LSL #1
;;;567          py = pSrc2;
0003aa  9905              LDR      r1,[sp,#0x14]
0003ac  1e7f              SUBS     r7,r7,#1
                  |L1.942|
0003ae  2f00              CMP      r7,#0                 ;542
0003b0  d1e0              BNE      |L1.884|
                  |L1.946|
;;;568    
;;;569          /* Decrement the loop counter */
;;;570          blkCnt--;
;;;571        }
;;;572      }
;;;573    
;;;574    
;;;575      /* --------------------------   
;;;576       * Initializations of stage3   
;;;577       * -------------------------*/
;;;578    
;;;579      /* sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1]   
;;;580       * sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2]   
;;;581       * ....   
;;;582       * sum +=  x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2]   
;;;583       * sum +=  x[srcALen-1] * y[srcBLen-1]   
;;;584       */
;;;585    
;;;586      /* In this stage the MAC operations are decreased by 1 for every iteration.   
;;;587         The blockSize3 variable holds the number of MAC operations performed */
;;;588    
;;;589      blockSize3 = srcBLen - 1u;
;;;590    
;;;591      /* Working pointer of inputA */
;;;592      pSrc1 = (pIn1 + srcALen) - (srcBLen - 1u);
0003b2  990c              LDR      r1,[sp,#0x30]
0003b4  9803              LDR      r0,[sp,#0xc]
;;;593      px = pSrc1;
0003b6  9d0a              LDR      r5,[sp,#0x28]
0003b8  eb000041          ADD      r0,r0,r1,LSL #1       ;592
0003bc  eba00743          SUB      r7,r0,r3,LSL #1       ;592
0003c0  1e5e              SUBS     r6,r3,#1              ;589
0003c2  1cbf              ADDS     r7,r7,#2              ;592
0003c4  f1a50e02          SUB      lr,r5,#2
;;;594    
;;;595      /* Working pointer of inputB */
;;;596      pSrc2 = pIn2 + (srcBLen - 1u);
;;;597      pIn2 = pSrc2 - 1u;
0003c8  1f2d              SUBS     r5,r5,#4
0003ca  4638              MOV      r0,r7                 ;593
;;;598      py = pIn2;
;;;599    
;;;600      /* -------------------   
;;;601       * Stage3 process   
;;;602       * ------------------*/
;;;603    
;;;604      /* For loop unrolling by 4, this stage is divided into two. */
;;;605      /* First part of this stage computes the MAC operations greater than 4 */
;;;606      /* Second part of this stage computes the MAC operations less than or equal to 4 */
;;;607    
;;;608      /* The first part of the stage starts here */
;;;609      j = blockSize3 >> 2u;
0003cc  ea4f0996          LSR      r9,r6,#2
;;;610    
;;;611      while((j > 0u) && (blockSize3 > 0u))
0003d0  9500              STR      r5,[sp,#0]
0003d2  e02d              B        |L1.1072|
                  |L1.980|
0003d4  2100              MOVS     r1,#0
0003d6  460a              MOV      r2,r1
;;;612      {
;;;613        /* Accumulator is made zero for every iteration */
;;;614        sum = 0;
;;;615    
;;;616        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;617        k = blockSize3 >> 2u;
0003d8  08b3              LSRS     r3,r6,#2
;;;618    
;;;619        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;620         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;621        while(k > 0u)
0003da  e00d              B        |L1.1016|
                  |L1.988|
;;;622        {
;;;623          /* x[srcALen - srcBLen + 1], x[srcALen - srcBLen + 2] are multiplied   
;;;624           * with y[srcBLen - 1], y[srcBLen - 2] respectively */
;;;625          sum = __SMLALDX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
0003dc  f850ab04          LDR      r10,[r0],#4
0003e0  f8d5c000          LDR      r12,[r5,#0]
0003e4  fbca12dc          SMLALDX  r1,r2,r10,r12
;;;626          /* x[srcALen - srcBLen + 3], x[srcALen - srcBLen + 4] are multiplied   
;;;627           * with y[srcBLen - 3], y[srcBLen - 4] respectively */
;;;628          sum = __SMLALDX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
0003e8  f850ab04          LDR      r10,[r0],#4
0003ec  f855cc04          LDR      r12,[r5,#-4]
0003f0  fbca12dc          SMLALDX  r1,r2,r10,r12
0003f4  1e5b              SUBS     r3,r3,#1
0003f6  3d08              SUBS     r5,r5,#8
                  |L1.1016|
0003f8  2b00              CMP      r3,#0                 ;621
0003fa  d1ef              BNE      |L1.988|
;;;629    
;;;630          /* Decrement the loop counter */
;;;631          k--;
;;;632        }
;;;633    
;;;634        /* For the next MAC operations, the pointer py is used without SIMD   
;;;635         * So, py is incremented by 1 */
;;;636        py = py + 1u;
;;;637    
;;;638        /* If the blockSize3 is not a multiple of 4, compute any remaining MACs here.   
;;;639         ** No loop unrolling is used. */
;;;640        k = blockSize3 % 0x4u;
0003fc  f0060303          AND      r3,r6,#3
000400  1cad              ADDS     r5,r5,#2
;;;641    
;;;642        while(k > 0u)
000402  e006              B        |L1.1042|
                  |L1.1028|
;;;643        {
;;;644          /* sum += x[srcALen - srcBLen + 5] * y[srcBLen - 5] */
;;;645          sum = __SMLALD(*px++, *py--, sum);
000404  f9308b02          LDRSH    r8,[r0],#2
000408  f935c902          LDRSH    r12,[r5],#-2
00040c  fbc812cc          SMLALD   r1,r2,r8,r12
000410  1e5b              SUBS     r3,r3,#1
                  |L1.1042|
000412  2b00              CMP      r3,#0                 ;642
000414  d1f6              BNE      |L1.1028|
;;;646    
;;;647          /* Decrement the loop counter */
;;;648          k--;
;;;649        }
;;;650    
;;;651        /* Store the result in the accumulator in the destination buffer. */
;;;652        *pOut++ = (q15_t) (__SSAT((sum >> 15), 16));
000416  0bc8              LSRS     r0,r1,#15
000418  ea404042          ORR      r0,r0,r2,LSL #17
00041c  f300000f          SSAT     r0,#16,r0
000420  f8240b02          STRH     r0,[r4],#2
;;;653    
;;;654        /* Update the inputA and inputB pointers for next MAC calculation */
;;;655        px = ++pSrc1;
000424  1cb8              ADDS     r0,r7,#2
;;;656        py = pIn2;
;;;657    
;;;658        /* Decrement the loop counter */
;;;659        blockSize3--;
;;;660    
;;;661        j--;
000426  9d00              LDR      r5,[sp,#0]
000428  4607              MOV      r7,r0                 ;655
00042a  f1a90901          SUB      r9,r9,#1
00042e  1e76              SUBS     r6,r6,#1
                  |L1.1072|
000430  f1b90f00          CMP      r9,#0                 ;611
000434  d001              BEQ      |L1.1082|
000436  2e00              CMP      r6,#0                 ;611
000438  d1cc              BNE      |L1.980|
                  |L1.1082|
00043a  1cad              ADDS     r5,r5,#2              ;611
;;;662      }
;;;663    
;;;664      /* The second part of the stage starts here */
;;;665      /* SIMD is not used for the next MAC operations,   
;;;666       * so pointer py is updated to read only one sample at a time */
;;;667      py = py + 1u;
;;;668    
;;;669      while(blockSize3 > 0u)
00043c  e018              B        |L1.1136|
                  |L1.1086|
00043e  2100              MOVS     r1,#0
000440  460a              MOV      r2,r1
;;;670      {
;;;671        /* Accumulator is made zero for every iteration */
;;;672        sum = 0;
;;;673    
;;;674        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;675        k = blockSize3;
000442  4633              MOV      r3,r6
;;;676    
;;;677        while(k > 0u)
000444  e007              B        |L1.1110|
;;;678        {
;;;679          /* Perform the multiply-accumulates */
;;;680          /* sum +=  x[srcALen-1] * y[srcBLen-1] */
;;;681          sum = __SMLALD(*px++, *py--, sum);
000446  bf00              NOP      
                  |L1.1096|
000448  f9308b02          LDRSH    r8,[r0],#2
00044c  f935c902          LDRSH    r12,[r5],#-2
000450  fbc812cc          SMLALD   r1,r2,r8,r12
000454  1e5b              SUBS     r3,r3,#1
                  |L1.1110|
000456  2b00              CMP      r3,#0                 ;677
000458  d1f6              BNE      |L1.1096|
;;;682    
;;;683          /* Decrement the loop counter */
;;;684          k--;
;;;685        }
;;;686    
;;;687        /* Store the result in the accumulator in the destination buffer. */
;;;688        *pOut++ = (q15_t) (__SSAT((sum >> 15), 16));
00045a  0bc8              LSRS     r0,r1,#15
00045c  ea404042          ORR      r0,r0,r2,LSL #17
000460  f300000f          SSAT     r0,#16,r0
000464  f8240b02          STRH     r0,[r4],#2
;;;689    
;;;690        /* Update the inputA and inputB pointers for next MAC calculation */
;;;691        px = ++pSrc1;
000468  1cb8              ADDS     r0,r7,#2
00046a  4607              MOV      r7,r0
;;;692        py = pSrc2;
00046c  4675              MOV      r5,lr
00046e  1e76              SUBS     r6,r6,#1
                  |L1.1136|
000470  2e00              CMP      r6,#0                 ;669
000472  d1e4              BNE      |L1.1086|
;;;693    
;;;694        /* Decrement the loop counter */
;;;695        blockSize3--;
;;;696      }
;;;697    
;;;698    #else
;;;699    
;;;700    /* Run the below code for Cortex-M0 */
;;;701    
;;;702      q15_t *pIn1 = pSrcA;                           /* input pointer */
;;;703      q15_t *pIn2 = pSrcB;                           /* coefficient pointer */
;;;704      q63_t sum;                                     /* Accumulator */
;;;705      uint32_t i, j;                                 /* loop counter */
;;;706    
;;;707      /* Loop to calculate output of convolution for output length number of times */
;;;708      for (i = 0; i < (srcALen + srcBLen - 1); i++)
;;;709      {
;;;710        /* Initialize sum with zero to carry on MAC operations */
;;;711        sum = 0;
;;;712    
;;;713        /* Loop to perform MAC operations according to convolution equation */
;;;714        for (j = 0; j <= i; j++)
;;;715        {
;;;716          /* Check the array limitations */
;;;717          if(((i - j) < srcBLen) && (j < srcALen))
;;;718          {
;;;719            /* z[i] += x[i-j] * y[j] */
;;;720            sum += (q31_t) pIn1[j] * (pIn2[i - j]);
;;;721          }
;;;722        }
;;;723    
;;;724        /* Store the output in the destination buffer */
;;;725        pDst[i] = (q15_t) __SSAT((sum >> 15u), 16u);
;;;726      }
;;;727    
;;;728    #endif /*  #if (defined(ARM_MATH_CM4) || defined(ARM_MATH_CM3)) && !defined(UNALIGNED_SUPPORT_DISABLE)*/
;;;729    
;;;730    }
000474  b00f              ADD      sp,sp,#0x3c
000476  e8bd8ff0          POP      {r4-r11,pc}
;;;731    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_conv_q15_c_d6db324e____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___14_arm_conv_q15_c_d6db324e____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_conv_q15_c_d6db324e____REVSH|
#line 144
|__asm___14_arm_conv_q15_c_d6db324e____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_conv_q15_c_d6db324e____RRX|
#line 300
|__asm___14_arm_conv_q15_c_d6db324e____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
