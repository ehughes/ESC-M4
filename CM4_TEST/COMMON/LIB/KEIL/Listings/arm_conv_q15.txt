; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_conv_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_q15.c]
                          THUMB

                          AREA ||i.arm_conv_q15||, CODE, READONLY, ALIGN=1

                  arm_conv_q15 PROC
;;;78     
;;;79     void arm_conv_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;80       q15_t * pSrcA,
;;;81       uint32_t srcALen,
;;;82       q15_t * pSrcB,
;;;83       uint32_t srcBLen,
;;;84       q15_t * pDst)
;;;85     {
000004  b095              SUB      sp,sp,#0x54
000006  f8ddc088          LDR      r12,[sp,#0x88]
;;;86     
;;;87     #if (defined(ARM_MATH_CM4) || defined(ARM_MATH_CM3)) && !defined(UNALIGNED_SUPPORT_DISABLE)
;;;88     
;;;89       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;90     
;;;91       q15_t *pIn1;                                   /* inputA pointer */
;;;92       q15_t *pIn2;                                   /* inputB pointer */
;;;93       q15_t *pOut = pDst;                            /* output pointer */
;;;94       q63_t sum, acc0, acc1, acc2, acc3;             /* Accumulator */
;;;95       q15_t *px;                                     /* Intermediate inputA pointer  */
;;;96       q15_t *py;                                     /* Intermediate inputB pointer  */
;;;97       q15_t *pSrc1, *pSrc2;                          /* Intermediate pointers */
;;;98       q31_t x0, x1, x2, x3, c0;                      /* Temporary variables to hold state and coefficient values */
;;;99       uint32_t blockSize1, blockSize2, blockSize3, j, k, count, blkCnt;     /* loop counter */
;;;100    
;;;101      /* The algorithm implementation is based on the lengths of the inputs. */
;;;102      /* srcB is always made to slide across srcA. */
;;;103      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;104      if(srcALen >= srcBLen)
00000a  9b18              LDR      r3,[sp,#0x60]
00000c  9916              LDR      r1,[sp,#0x58]
00000e  4299              CMP      r1,r3
000010  d302              BCC      |L1.24|
;;;105      {
;;;106        /* Initialization of inputA pointer */
;;;107        pIn1 = pSrcA;
000012  900d              STR      r0,[sp,#0x34]
;;;108    
;;;109        /* Initialization of inputB pointer */
;;;110        pIn2 = pSrcB;
000014  4610              MOV      r0,r2
000016  e004              B        |L1.34|
                  |L1.24|
;;;111      }
;;;112      else
;;;113      {
;;;114        /* Initialization of inputA pointer */
;;;115        pIn1 = pSrcB;
000018  920d              STR      r2,[sp,#0x34]
;;;116    
;;;117        /* Initialization of inputB pointer */
;;;118        pIn2 = pSrcA;
;;;119    
;;;120        /* srcBLen is always considered as shorter or equal to srcALen */
;;;121        j = srcBLen;
00001a  9918              LDR      r1,[sp,#0x60]
;;;122        srcBLen = srcALen;
00001c  9a16              LDR      r2,[sp,#0x58]
00001e  9218              STR      r2,[sp,#0x60]
;;;123        srcALen = j;
000020  9116              STR      r1,[sp,#0x58]
                  |L1.34|
;;;124      }
;;;125    
;;;126      /* conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1] */
;;;127      /* The function is internally   
;;;128       * divided into three stages according to the number of multiplications that has to be   
;;;129       * taken place between inputA samples and inputB samples. In the first stage of the   
;;;130       * algorithm, the multiplications increase by one for every iteration.   
;;;131       * In the second stage of the algorithm, srcBLen number of multiplications are done.   
;;;132       * In the third stage of the algorithm, the multiplications decrease by one   
;;;133       * for every iteration. */
;;;134    
;;;135      /* The algorithm is implemented in three stages.   
;;;136         The loop counters of each stage is initiated here. */
;;;137      blockSize1 = srcBLen - 1u;
000022  9d18              LDR      r5,[sp,#0x60]
000024  1e6d              SUBS     r5,r5,#1
;;;138      blockSize2 = srcALen - (srcBLen - 1u);
000026  9a18              LDR      r2,[sp,#0x60]
000028  9916              LDR      r1,[sp,#0x58]
00002a  1a89              SUBS     r1,r1,r2
00002c  1c49              ADDS     r1,r1,#1
00002e  9106              STR      r1,[sp,#0x18]
;;;139    
;;;140      /* --------------------------   
;;;141       * Initializations of stage1   
;;;142       * -------------------------*/
;;;143    
;;;144      /* sum = x[0] * y[0]   
;;;145       * sum = x[0] * y[1] + x[1] * y[0]   
;;;146       * ....   
;;;147       * sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]   
;;;148       */
;;;149    
;;;150      /* In this stage the MAC operations are increased by 1 for every iteration.   
;;;151         The count variable holds the number of MAC operations performed */
;;;152      count = 1u;
000030  2101              MOVS     r1,#1
;;;153    
;;;154      /* Working pointer of inputA */
;;;155      px = pIn1;
000032  f8dd8034          LDR      r8,[sp,#0x34]
;;;156    
;;;157      /* Working pointer of inputB */
;;;158      py = pIn2;
000036  4602              MOV      r2,r0
;;;159    
;;;160    
;;;161      /* ------------------------   
;;;162       * Stage1 process   
;;;163       * ----------------------*/
;;;164    
;;;165      /* For loop unrolling by 4, this stage is divided into two. */
;;;166      /* First part of this stage computes the MAC operations less than 4 */
;;;167      /* Second part of this stage computes the MAC operations greater than or equal to 4 */
;;;168    
;;;169      /* The first part of the stage starts here */
;;;170      while((count < 4u) && (blockSize1 > 0u))
000038  e019              B        |L1.110|
                  |L1.58|
;;;171      {
;;;172        /* Accumulator is made zero for every iteration */
;;;173        sum = 0;
00003a  2300              MOVS     r3,#0
00003c  461c              MOV      r4,r3
;;;174    
;;;175        /* Loop over number of MAC operations between   
;;;176         * inputA samples and inputB samples */
;;;177        k = count;
00003e  460e              MOV      r6,r1
;;;178    
;;;179        while(k > 0u)
000040  e006              B        |L1.80|
                  |L1.66|
;;;180        {
;;;181          /* Perform the multiply-accumulates */
;;;182          sum = __SMLALD(*px++, *py--, sum);
000042  f9389b02          LDRSH    r9,[r8],#2
000046  f9327902          LDRSH    r7,[r2],#-2
00004a  fbc934c7          SMLALD   r3,r4,r9,r7
;;;183    
;;;184          /* Decrement the loop counter */
;;;185          k--;
00004e  1e76              SUBS     r6,r6,#1
                  |L1.80|
000050  2e00              CMP      r6,#0                 ;179
000052  d1f6              BNE      |L1.66|
;;;186        }
;;;187    
;;;188        /* Store the result in the accumulator in the destination buffer. */
;;;189        *pOut++ = (q15_t) (__SSAT((sum >> 15), 16));
000054  0bda              LSRS     r2,r3,#15
000056  ea424244          ORR      r2,r2,r4,LSL #17
00005a  f302020f          SSAT     r2,#16,r2
00005e  f82c2b02          STRH     r2,[r12],#2
;;;190    
;;;191        /* Update the inputA and inputB pointers for next MAC calculation */
;;;192        py = pIn2 + count;
000062  eb000241          ADD      r2,r0,r1,LSL #1
;;;193        px = pIn1;
000066  f8dd8034          LDR      r8,[sp,#0x34]
;;;194    
;;;195        /* Increment the MAC count */
;;;196        count++;
00006a  1c49              ADDS     r1,r1,#1
;;;197    
;;;198        /* Decrement the loop counter */
;;;199        blockSize1--;
00006c  1e6d              SUBS     r5,r5,#1
                  |L1.110|
00006e  2904              CMP      r1,#4                 ;170
000070  d201              BCS      |L1.118|
000072  2d00              CMP      r5,#0                 ;170
000074  d1e1              BNE      |L1.58|
                  |L1.118|
;;;200      }
;;;201    
;;;202      /* The second part of the stage starts here */
;;;203      /* The internal loop, over count, is unrolled by 4 */
;;;204      /* To, read the last two inputB samples using SIMD:   
;;;205       * y[srcBLen] and y[srcBLen-1] coefficients, py is decremented by 1 */
;;;206      py = py - 1;
000076  1e92              SUBS     r2,r2,#2
;;;207    
;;;208      while(blockSize1 > 0u)
000078  e02d              B        |L1.214|
                  |L1.122|
;;;209      {
;;;210        /* Accumulator is made zero for every iteration */
;;;211        sum = 0;
00007a  2300              MOVS     r3,#0
00007c  461c              MOV      r4,r3
;;;212    
;;;213        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;214        k = count >> 2u;
00007e  088e              LSRS     r6,r1,#2
;;;215    
;;;216        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;217         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;218        while(k > 0u)
000080  e00c              B        |L1.156|
                  |L1.130|
;;;219        {
;;;220          /* Perform the multiply-accumulates */
;;;221          /* x[0], x[1] are multiplied with y[srcBLen - 1], y[srcBLen - 2] respectively */
;;;222          sum = __SMLALDX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
000082  f8587b04          LDR      r7,[r8],#4
000086  f8529904          LDR      r9,[r2],#-4
00008a  fbc734d9          SMLALDX  r3,r4,r7,r9
;;;223          /* x[2], x[3] are multiplied with y[srcBLen - 3], y[srcBLen - 4] respectively */
;;;224          sum = __SMLALDX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
00008e  f8587b04          LDR      r7,[r8],#4
000092  f8529904          LDR      r9,[r2],#-4
000096  fbc734d9          SMLALDX  r3,r4,r7,r9
;;;225    
;;;226          /* Decrement the loop counter */
;;;227          k--;
00009a  1e76              SUBS     r6,r6,#1
                  |L1.156|
00009c  2e00              CMP      r6,#0                 ;218
00009e  d1f0              BNE      |L1.130|
;;;228        }
;;;229    
;;;230        /* For the next MAC operations, the pointer py is used without SIMD   
;;;231         * So, py is incremented by 1 */
;;;232        py = py + 1u;
0000a0  1c92              ADDS     r2,r2,#2
;;;233    
;;;234        /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;235         ** No loop unrolling is used. */
;;;236        k = count % 0x4u;
0000a2  f0010603          AND      r6,r1,#3
;;;237    
;;;238        while(k > 0u)
0000a6  e006              B        |L1.182|
                  |L1.168|
;;;239        {
;;;240          /* Perform the multiply-accumulates */
;;;241          sum = __SMLALD(*px++, *py--, sum);
0000a8  f938ab02          LDRSH    r10,[r8],#2
0000ac  f9327902          LDRSH    r7,[r2],#-2
0000b0  fbca34c7          SMLALD   r3,r4,r10,r7
;;;242    
;;;243          /* Decrement the loop counter */
;;;244          k--;
0000b4  1e76              SUBS     r6,r6,#1
                  |L1.182|
0000b6  2e00              CMP      r6,#0                 ;238
0000b8  d1f6              BNE      |L1.168|
;;;245        }
;;;246    
;;;247        /* Store the result in the accumulator in the destination buffer. */
;;;248        *pOut++ = (q15_t) (__SSAT((sum >> 15), 16));
0000ba  0bda              LSRS     r2,r3,#15
0000bc  ea424244          ORR      r2,r2,r4,LSL #17
0000c0  f302020f          SSAT     r2,#16,r2
0000c4  f82c2b02          STRH     r2,[r12],#2
;;;249    
;;;250        /* Update the inputA and inputB pointers for next MAC calculation */
;;;251        py = pIn2 + (count - 1u);
0000c8  1e4a              SUBS     r2,r1,#1
0000ca  eb000242          ADD      r2,r0,r2,LSL #1
;;;252        px = pIn1;
0000ce  f8dd8034          LDR      r8,[sp,#0x34]
;;;253    
;;;254        /* Increment the MAC count */
;;;255        count++;
0000d2  1c49              ADDS     r1,r1,#1
;;;256    
;;;257        /* Decrement the loop counter */
;;;258        blockSize1--;
0000d4  1e6d              SUBS     r5,r5,#1
                  |L1.214|
0000d6  2d00              CMP      r5,#0                 ;208
0000d8  d1cf              BNE      |L1.122|
;;;259      }
;;;260    
;;;261      /* --------------------------   
;;;262       * Initializations of stage2   
;;;263       * ------------------------*/
;;;264    
;;;265      /* sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0]   
;;;266       * sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0]   
;;;267       * ....   
;;;268       * sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]   
;;;269       */
;;;270    
;;;271      /* Working pointer of inputA */
;;;272      px = pIn1;
;;;273    
;;;274      /* Working pointer of inputB */
;;;275      pSrc2 = pIn2 + (srcBLen - 1u);
0000da  9918              LDR      r1,[sp,#0x60]
0000dc  1e49              SUBS     r1,r1,#1
0000de  eb000a41          ADD      r10,r0,r1,LSL #1
0000e2  e9cda112          STRD     r10,r1,[sp,#0x48]
0000e6  f8cda02c          STR      r10,[sp,#0x2c]
;;;276      py = pSrc2;
0000ea  f8dda02c          LDR      r10,[sp,#0x2c]
;;;277    
;;;278      /* count is the index by which the pointer pIn1 to be incremented */
;;;279      count = 0u;
0000ee  2000              MOVS     r0,#0
0000f0  9004              STR      r0,[sp,#0x10]
;;;280    
;;;281    
;;;282      /* --------------------   
;;;283       * Stage2 process   
;;;284       * -------------------*/
;;;285    
;;;286      /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.   
;;;287       * So, to loop unroll over blockSize2,   
;;;288       * srcBLen should be greater than or equal to 4 */
;;;289      if(srcBLen >= 4u)
0000f2  9818              LDR      r0,[sp,#0x60]
0000f4  2804              CMP      r0,#4
0000f6  d37c              BCC      |L1.498|
;;;290      {
;;;291        /* Loop unroll over blockSize2, by 4 */
;;;292        blkCnt = blockSize2 >> 2u;
0000f8  9806              LDR      r0,[sp,#0x18]
0000fa  0880              LSRS     r0,r0,#2
0000fc  9003              STR      r0,[sp,#0xc]
;;;293    
;;;294        while(blkCnt > 0u)
0000fe  e10c              B        |L1.794|
                  |L1.256|
;;;295        {
;;;296          py = py - 1u;
000100  f1aa0a02          SUB      r10,r10,#2
;;;297    
;;;298          /* Set all accumulators to zero */
;;;299          acc0 = 0;
000104  2000              MOVS     r0,#0
000106  4601              MOV      r1,r0
;;;300          acc1 = 0;
000108  2200              MOVS     r2,#0
00010a  4613              MOV      r3,r2
;;;301          acc2 = 0;
00010c  2400              MOVS     r4,#0
00010e  4625              MOV      r5,r4
;;;302          acc3 = 0;
000110  2600              MOVS     r6,#0
000112  4637              MOV      r7,r6
;;;303    
;;;304    
;;;305          /* read x[0], x[1] samples */
;;;306          x0 = *__SIMD32(px);
000114  f8d89000          LDR      r9,[r8,#0]
000118  f8cd9028          STR      r9,[sp,#0x28]
;;;307          /* read x[1], x[2] samples */
;;;308          x1 = _SIMD32_OFFSET(px+1);
00011c  f8d89002          LDR      r9,[r8,#2]
;;;309    	  px+= 2u;
000120  f1080804          ADD      r8,r8,#4
;;;310    
;;;311    
;;;312          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;313          k = srcBLen >> 2u;
000124  f8ddb060          LDR      r11,[sp,#0x60]
000128  ea4f0b9b          LSR      r11,r11,#2
00012c  f8cdb014          STR      r11,[sp,#0x14]
                  |L1.304|
;;;314    
;;;315          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;316           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;317          do
;;;318          {
;;;319            /* Read the last two inputB samples using SIMD:   
;;;320             * y[srcBLen - 1] and y[srcBLen - 2] */
;;;321            c0 = *__SIMD32(py)--;
000130  f85ab904          LDR      r11,[r10],#-4
000134  f8cda030          STR      r10,[sp,#0x30]
;;;322    
;;;323            /* acc0 +=  x[0] * y[srcBLen - 1] + x[1] * y[srcBLen - 2] */
;;;324            acc0 = __SMLALDX(x0, c0, acc0);
000138  f8dda028          LDR      r10,[sp,#0x28]
00013c  fbca01db          SMLALDX  r0,r1,r10,r11
;;;325    
;;;326            /* acc1 +=  x[1] * y[srcBLen - 1] + x[2] * y[srcBLen - 2] */
;;;327            acc1 = __SMLALDX(x1, c0, acc1);
000140  fbc923db          SMLALDX  r2,r3,r9,r11
;;;328    
;;;329            /* Read x[2], x[3] */
;;;330            x2 = *__SIMD32(px);
000144  f8d8e000          LDR      lr,[r8,#0]
;;;331    
;;;332            /* Read x[3], x[4] */
;;;333            x3 = _SIMD32_OFFSET(px+1);
000148  f8d89002          LDR      r9,[r8,#2]
00014c  f8cd9044          STR      r9,[sp,#0x44]
;;;334    
;;;335            /* acc2 +=  x[2] * y[srcBLen - 1] + x[3] * y[srcBLen - 2] */
;;;336            acc2 = __SMLALDX(x2, c0, acc2);
000150  fbce45db          SMLALDX  r4,r5,lr,r11
;;;337    
;;;338            /* acc3 +=  x[3] * y[srcBLen - 1] + x[4] * y[srcBLen - 2] */
;;;339            acc3 = __SMLALDX(x3, c0, acc3);
000154  f8dd9044          LDR      r9,[sp,#0x44]
000158  fbc967db          SMLALDX  r6,r7,r9,r11
;;;340    
;;;341            /* Read y[srcBLen - 3] and y[srcBLen - 4] */
;;;342            c0 = *__SIMD32(py)--;
00015c  f8dda030          LDR      r10,[sp,#0x30]
000160  f85ab904          LDR      r11,[r10],#-4
;;;343    
;;;344            /* acc0 +=  x[2] * y[srcBLen - 3] + x[3] * y[srcBLen - 4] */
;;;345            acc0 = __SMLALDX(x2, c0, acc0);
000164  fbce01db          SMLALDX  r0,r1,lr,r11
;;;346    
;;;347            /* acc1 +=  x[3] * y[srcBLen - 3] + x[4] * y[srcBLen - 4] */
;;;348            acc1 = __SMLALDX(x3, c0, acc1);
000168  f8dd9044          LDR      r9,[sp,#0x44]
00016c  fbc923db          SMLALDX  r2,r3,r9,r11
;;;349    
;;;350            /* Read x[4], x[5] */
;;;351            x0 = _SIMD32_OFFSET(px+2);
000170  f8d89004          LDR      r9,[r8,#4]
000174  f8cd9028          STR      r9,[sp,#0x28]
;;;352    
;;;353            /* Read x[5], x[6] */
;;;354            x1 = _SIMD32_OFFSET(px+3);
000178  f8d89006          LDR      r9,[r8,#6]
;;;355    		px += 4u;
00017c  f1080808          ADD      r8,r8,#8
;;;356    
;;;357            /* acc2 +=  x[4] * y[srcBLen - 3] + x[5] * y[srcBLen - 4] */
;;;358            acc2 = __SMLALDX(x0, c0, acc2);
000180  f8dde028          LDR      lr,[sp,#0x28]
000184  9502              STR      r5,[sp,#8]
000186  fbce45db          SMLALDX  r4,r5,lr,r11
;;;359    
;;;360            /* acc3 +=  x[5] * y[srcBLen - 3] + x[6] * y[srcBLen - 4] */
;;;361            acc3 = __SMLALDX(x1, c0, acc3);
00018a  46be              MOV      lr,r7
00018c  fbc96edb          SMLALDX  r6,lr,r9,r11
000190  4677              MOV      r7,lr
;;;362    
;;;363          } while(--k);
000192  f8ddb014          LDR      r11,[sp,#0x14]
000196  f1bb0b01          SUBS     r11,r11,#1
00019a  f8cdb014          STR      r11,[sp,#0x14]
00019e  d1c7              BNE      |L1.304|
;;;364    
;;;365          /* For the next MAC operations, SIMD is not used   
;;;366           * So, the 16 bit pointer if inputB, py is updated */
;;;367    
;;;368          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;369           ** No loop unrolling is used. */
;;;370          k = srcBLen % 0x4u;
0001a0  f8ddb060          LDR      r11,[sp,#0x60]
0001a4  f00b0b03          AND      r11,r11,#3
0001a8  f8cdb014          STR      r11,[sp,#0x14]
;;;371    
;;;372          if(k == 1u)
0001ac  f8ddb014          LDR      r11,[sp,#0x14]
0001b0  f1bb0f01          CMP      r11,#1
0001b4  d12a              BNE      |L1.524|
;;;373          {
;;;374            /* Read y[srcBLen - 5] */
;;;375            c0 = *(py+1);
0001b6  f8bab002          LDRH     r11,[r10,#2]
;;;376    
;;;377    #ifdef  ARM_MATH_BIG_ENDIAN
;;;378    
;;;379            c0 = c0 << 16u;
;;;380    
;;;381    #else
;;;382    
;;;383            c0 = c0 & 0x0000FFFF;
0001ba  fa1ffb8b          UXTH     r11,r11
0001be  f8cdb01c          STR      r11,[sp,#0x1c]
;;;384    
;;;385    #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;386            /* Read x[7] */
;;;387            x3 = *__SIMD32(px);
0001c2  f8d8b000          LDR      r11,[r8,#0]
0001c6  f8cdb020          STR      r11,[sp,#0x20]
;;;388    		px++;
0001ca  f1080802          ADD      r8,r8,#2
;;;389    
;;;390            /* Perform the multiply-accumulates */
;;;391            acc0 = __SMLALD(x0, c0, acc0);
0001ce  9102              STR      r1,[sp,#8]
0001d0  e9cd0100          STRD     r0,r1,[sp,#0]
0001d4  f8dde008          LDR      lr,[sp,#8]
0001d8  f8ddb01c          LDR      r11,[sp,#0x1c]
0001dc  990a              LDR      r1,[sp,#0x28]
0001de  fbc10ecb          SMLALD   r0,lr,r1,r11
0001e2  4671              MOV      r1,lr
;;;392            acc1 = __SMLALD(x1, c0, acc1);
0001e4  f8ddb01c          LDR      r11,[sp,#0x1c]
0001e8  fbc923cb          SMLALD   r2,r3,r9,r11
;;;393            acc2 = __SMLALDX(x1, c0, acc2);
0001ec  f8ddb01c          LDR      r11,[sp,#0x1c]
0001f0  e000              B        |L1.500|
                  |L1.498|
0001f2  e0db              B        |L1.940|
                  |L1.500|
0001f4  fbc945db          SMLALDX  r4,r5,r9,r11
;;;394            acc3 = __SMLALDX(x3, c0, acc3);
0001f8  9702              STR      r7,[sp,#8]
0001fa  e9cd6700          STRD     r6,r7,[sp,#0]
0001fe  e9ddb707          LDRD     r11,r7,[sp,#0x1c]
000202  f8dde008          LDR      lr,[sp,#8]
000206  fbc76edb          SMLALDX  r6,lr,r7,r11
00020a  4677              MOV      r7,lr
                  |L1.524|
;;;395          }
;;;396    
;;;397          if(k == 2u)
00020c  f8ddb014          LDR      r11,[sp,#0x14]
000210  f1bb0f02          CMP      r11,#2
000214  d123              BNE      |L1.606|
;;;398          {
;;;399            /* Read y[srcBLen - 5], y[srcBLen - 6] */
;;;400            c0 = _SIMD32_OFFSET(py);
000216  f8dae000          LDR      lr,[r10,#0]
00021a  f8cde040          STR      lr,[sp,#0x40]
;;;401    
;;;402            /* Read x[7], x[8] */
;;;403            x3 = *__SIMD32(px);
00021e  f8d8b000          LDR      r11,[r8,#0]
000222  f8cdb020          STR      r11,[sp,#0x20]
;;;404    
;;;405            /* Read x[9] */
;;;406            x2 = _SIMD32_OFFSET(px+1);
000226  f8d8b002          LDR      r11,[r8,#2]
00022a  f8cdb024          STR      r11,[sp,#0x24]
;;;407    		px += 2u;
00022e  f1080804          ADD      r8,r8,#4
;;;408    
;;;409            /* Perform the multiply-accumulates */
;;;410            acc0 = __SMLALDX(x0, c0, acc0);
000232  f8dde040          LDR      lr,[sp,#0x40]
000236  f8ddb028          LDR      r11,[sp,#0x28]
00023a  fbcb01de          SMLALDX  r0,r1,r11,lr
;;;411            acc1 = __SMLALDX(x1, c0, acc1);
00023e  f8dde040          LDR      lr,[sp,#0x40]
000242  fbc923de          SMLALDX  r2,r3,r9,lr
;;;412            acc2 = __SMLALDX(x3, c0, acc2);
000246  f8dde040          LDR      lr,[sp,#0x40]
00024a  f8ddb020          LDR      r11,[sp,#0x20]
00024e  fbcb45de          SMLALDX  r4,r5,r11,lr
;;;413            acc3 = __SMLALDX(x2, c0, acc3);
000252  f8dde040          LDR      lr,[sp,#0x40]
000256  f8ddb024          LDR      r11,[sp,#0x24]
00025a  fbcb67de          SMLALDX  r6,r7,r11,lr
                  |L1.606|
;;;414          }
;;;415    
;;;416          if(k == 3u)
00025e  f8ddb014          LDR      r11,[sp,#0x14]
000262  f1bb0f03          CMP      r11,#3
000266  d130              BNE      |L1.714|
;;;417          {
;;;418            /* Read y[srcBLen - 5], y[srcBLen - 6] */
;;;419            c0 = _SIMD32_OFFSET(py);
000268  f8dab000          LDR      r11,[r10,#0]
;;;420    
;;;421            /* Read x[7], x[8] */
;;;422            x3 = *__SIMD32(px);
00026c  f8d8e000          LDR      lr,[r8,#0]
000270  f8cde03c          STR      lr,[sp,#0x3c]
;;;423    
;;;424            /* Read x[9] */
;;;425            x2 = _SIMD32_OFFSET(px+1);
000274  f8d8e002          LDR      lr,[r8,#2]
000278  f8cde038          STR      lr,[sp,#0x38]
00027c  f8cde024          STR      lr,[sp,#0x24]
;;;426    
;;;427            /* Perform the multiply-accumulates */
;;;428            acc0 = __SMLALDX(x0, c0, acc0);
000280  e9cd0100          STRD     r0,r1,[sp,#0]
000284  f8dde000          LDR      lr,[sp,#0]
000288  980a              LDR      r0,[sp,#0x28]
00028a  9102              STR      r1,[sp,#8]
00028c  fbc0e1db          SMLALDX  lr,r1,r0,r11
000290  4670              MOV      r0,lr
;;;429            acc1 = __SMLALDX(x1, c0, acc1);
000292  fbc923db          SMLALDX  r2,r3,r9,r11
;;;430            acc2 = __SMLALDX(x3, c0, acc2);
000296  f8dde03c          LDR      lr,[sp,#0x3c]
00029a  fbce45db          SMLALDX  r4,r5,lr,r11
;;;431            acc3 = __SMLALDX(x2, c0, acc3);
00029e  f8dde038          LDR      lr,[sp,#0x38]
0002a2  fbce67db          SMLALDX  r6,r7,lr,r11
;;;432    
;;;433    		c0 = *(py-1);
0002a6  f83aac02          LDRH     r10,[r10,#-2]
;;;434    
;;;435    #ifdef  ARM_MATH_BIG_ENDIAN
;;;436    
;;;437            c0 = c0 << 16u;
;;;438    #else
;;;439    
;;;440            c0 = c0 & 0x0000FFFF;
0002aa  fa1ffa8a          UXTH     r10,r10
;;;441    #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;442            /* Read x[10] */
;;;443            x3 =  _SIMD32_OFFSET(px+2);
0002ae  f8d88004          LDR      r8,[r8,#4]
;;;444    		px += 3u;
;;;445    
;;;446            /* Perform the multiply-accumulates */
;;;447            acc0 = __SMLALDX(x1, c0, acc0);
0002b2  fbc901da          SMLALDX  r0,r1,r9,r10
;;;448            acc1 = __SMLALD(x2, c0, acc1);
0002b6  f8dde024          LDR      lr,[sp,#0x24]
0002ba  fbce23ca          SMLALD   r2,r3,lr,r10
;;;449            acc2 = __SMLALDX(x2, c0, acc2);
0002be  f8dde024          LDR      lr,[sp,#0x24]
0002c2  fbce45da          SMLALDX  r4,r5,lr,r10
;;;450            acc3 = __SMLALDX(x3, c0, acc3);
0002c6  fbc867da          SMLALDX  r6,r7,r8,r10
                  |L1.714|
;;;451          }
;;;452    
;;;453    
;;;454          /* Store the results in the accumulators in the destination buffer. */
;;;455    
;;;456    #ifndef  ARM_MATH_BIG_ENDIAN
;;;457    
;;;458          *__SIMD32(pOut)++ =
0002ca  0bc0              LSRS     r0,r0,#15
0002cc  ea404041          ORR      r0,r0,r1,LSL #17
0002d0  f300010f          SSAT     r1,#16,r0
0002d4  0bd0              LSRS     r0,r2,#15
0002d6  ea404043          ORR      r0,r0,r3,LSL #17
0002da  f300000f          SSAT     r0,#16,r0
0002de  eac14000          PKHBT    r0,r1,r0,LSL #16
0002e2  f84c0b04          STR      r0,[r12],#4
;;;459            __PKHBT(__SSAT((acc0 >> 15), 16), __SSAT((acc1 >> 15), 16), 16);
;;;460          *__SIMD32(pOut)++ =
0002e6  0be0              LSRS     r0,r4,#15
0002e8  ea404045          ORR      r0,r0,r5,LSL #17
0002ec  f300010f          SSAT     r1,#16,r0
0002f0  0bf0              LSRS     r0,r6,#15
0002f2  ea404047          ORR      r0,r0,r7,LSL #17
0002f6  f300000f          SSAT     r0,#16,r0
0002fa  eac14000          PKHBT    r0,r1,r0,LSL #16
0002fe  f84c0b04          STR      r0,[r12],#4
;;;461            __PKHBT(__SSAT((acc2 >> 15), 16), __SSAT((acc3 >> 15), 16), 16);
;;;462    
;;;463    #else
;;;464    
;;;465          *__SIMD32(pOut)++ =
;;;466            __PKHBT(__SSAT((acc1 >> 15), 16), __SSAT((acc0 >> 15), 16), 16);
;;;467          *__SIMD32(pOut)++ =
;;;468            __PKHBT(__SSAT((acc3 >> 15), 16), __SSAT((acc2 >> 15), 16), 16);
;;;469    
;;;470    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;471    
;;;472          /* Increment the pointer pIn1 index, count by 4 */
;;;473          count += 4u;
000302  9804              LDR      r0,[sp,#0x10]
000304  1d00              ADDS     r0,r0,#4
000306  9004              STR      r0,[sp,#0x10]
;;;474    
;;;475          /* Update the inputA and inputB pointers for next MAC calculation */
;;;476          px = pIn1 + count;
000308  9904              LDR      r1,[sp,#0x10]
00030a  980d              LDR      r0,[sp,#0x34]
00030c  eb000841          ADD      r8,r0,r1,LSL #1
;;;477          py = pSrc2;
000310  f8dda02c          LDR      r10,[sp,#0x2c]
;;;478    
;;;479           /* Decrement the loop counter */
;;;480          blkCnt--;
000314  9803              LDR      r0,[sp,#0xc]
000316  1e40              SUBS     r0,r0,#1
000318  9003              STR      r0,[sp,#0xc]
                  |L1.794|
00031a  9803              LDR      r0,[sp,#0xc]          ;294
00031c  2800              CMP      r0,#0                 ;294
00031e  f47faeef          BNE      |L1.256|
;;;481        }
;;;482    
;;;483        /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.   
;;;484         ** No loop unrolling is used. */
;;;485        blkCnt = blockSize2 % 0x4u;
000322  9806              LDR      r0,[sp,#0x18]
000324  f0000103          AND      r1,r0,#3
;;;486    
;;;487        while(blkCnt > 0u)
000328  e03d              B        |L1.934|
                  |L1.810|
;;;488        {
;;;489          /* Accumulator is made zero for every iteration */
;;;490          sum = 0;
00032a  2300              MOVS     r3,#0
00032c  461c              MOV      r4,r3
;;;491    
;;;492          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;493          k = srcBLen >> 2u;
00032e  9818              LDR      r0,[sp,#0x60]
000330  0880              LSRS     r0,r0,#2
;;;494    
;;;495          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;496           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;497          while(k > 0u)
000332  e018              B        |L1.870|
                  |L1.820|
;;;498          {
;;;499            /* Perform the multiply-accumulates */
;;;500            sum += (q63_t) ((q31_t) * px++ * *py--);
000334  f9382b02          LDRSH    r2,[r8],#2
000338  f93a5902          LDRSH    r5,[r10],#-2
00033c  fbc23485          SMLALBB  r3,r4,r2,r5
;;;501            sum += (q63_t) ((q31_t) * px++ * *py--);
000340  f9382b02          LDRSH    r2,[r8],#2
000344  f93a5902          LDRSH    r5,[r10],#-2
000348  fbc23485          SMLALBB  r3,r4,r2,r5
;;;502            sum += (q63_t) ((q31_t) * px++ * *py--);
00034c  f9382b02          LDRSH    r2,[r8],#2
000350  f93a5902          LDRSH    r5,[r10],#-2
000354  fbc23485          SMLALBB  r3,r4,r2,r5
;;;503            sum += (q63_t) ((q31_t) * px++ * *py--);
000358  f9382b02          LDRSH    r2,[r8],#2
00035c  f93a5902          LDRSH    r5,[r10],#-2
000360  fbc23485          SMLALBB  r3,r4,r2,r5
;;;504    
;;;505            /* Decrement the loop counter */
;;;506            k--;
000364  1e40              SUBS     r0,r0,#1
                  |L1.870|
000366  2800              CMP      r0,#0                 ;497
000368  d1e4              BNE      |L1.820|
;;;507          }
;;;508    
;;;509          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;510           ** No loop unrolling is used. */
;;;511          k = srcBLen % 0x4u;
00036a  9818              LDR      r0,[sp,#0x60]
00036c  f0000003          AND      r0,r0,#3
;;;512    
;;;513          while(k > 0u)
000370  e006              B        |L1.896|
                  |L1.882|
;;;514          {
;;;515            /* Perform the multiply-accumulates */
;;;516            sum += (q63_t) ((q31_t) * px++ * *py--);
000372  f9386b02          LDRSH    r6,[r8],#2
000376  f93a5902          LDRSH    r5,[r10],#-2
00037a  fbc63485          SMLALBB  r3,r4,r6,r5
;;;517    
;;;518            /* Decrement the loop counter */
;;;519            k--;
00037e  1e40              SUBS     r0,r0,#1
                  |L1.896|
000380  2800              CMP      r0,#0                 ;513
000382  d1f6              BNE      |L1.882|
;;;520          }
;;;521    
;;;522          /* Store the result in the accumulator in the destination buffer. */
;;;523          *pOut++ = (q15_t) (__SSAT(sum >> 15, 16));
000384  0bd8              LSRS     r0,r3,#15
000386  ea404044          ORR      r0,r0,r4,LSL #17
00038a  f300000f          SSAT     r0,#16,r0
00038e  f82c0b02          STRH     r0,[r12],#2
;;;524    
;;;525          /* Increment the pointer pIn1 index, count by 1 */
;;;526          count++;
000392  9804              LDR      r0,[sp,#0x10]
000394  1c40              ADDS     r0,r0,#1
000396  9004              STR      r0,[sp,#0x10]
;;;527    
;;;528          /* Update the inputA and inputB pointers for next MAC calculation */
;;;529          px = pIn1 + count;
000398  9a04              LDR      r2,[sp,#0x10]
00039a  980d              LDR      r0,[sp,#0x34]
00039c  eb000842          ADD      r8,r0,r2,LSL #1
;;;530          py = pSrc2;
0003a0  f8dda02c          LDR      r10,[sp,#0x2c]
;;;531    
;;;532          /* Decrement the loop counter */
;;;533          blkCnt--;
0003a4  1e49              SUBS     r1,r1,#1
                  |L1.934|
0003a6  2900              CMP      r1,#0                 ;487
0003a8  d1bf              BNE      |L1.810|
0003aa  e021              B        |L1.1008|
                  |L1.940|
;;;534        }
;;;535      }
;;;536      else
;;;537      {
;;;538        /* If the srcBLen is not a multiple of 4,   
;;;539         * the blockSize2 loop cannot be unrolled by 4 */
;;;540        blkCnt = blockSize2;
0003ac  9906              LDR      r1,[sp,#0x18]
;;;541    
;;;542        while(blkCnt > 0u)
0003ae  e01d              B        |L1.1004|
                  |L1.944|
;;;543        {
;;;544          /* Accumulator is made zero for every iteration */
;;;545          sum = 0;
0003b0  2300              MOVS     r3,#0
0003b2  461c              MOV      r4,r3
;;;546    
;;;547          /* srcBLen number of MACS should be performed */
;;;548          k = srcBLen;
0003b4  9818              LDR      r0,[sp,#0x60]
;;;549    
;;;550          while(k > 0u)
0003b6  e006              B        |L1.966|
                  |L1.952|
;;;551          {
;;;552            /* Perform the multiply-accumulate */
;;;553            sum += (q63_t) ((q31_t) * px++ * *py--);
0003b8  f9386b02          LDRSH    r6,[r8],#2
0003bc  f93a5902          LDRSH    r5,[r10],#-2
0003c0  fbc63485          SMLALBB  r3,r4,r6,r5
;;;554    
;;;555            /* Decrement the loop counter */
;;;556            k--;
0003c4  1e40              SUBS     r0,r0,#1
                  |L1.966|
0003c6  2800              CMP      r0,#0                 ;550
0003c8  d1f6              BNE      |L1.952|
;;;557          }
;;;558    
;;;559          /* Store the result in the accumulator in the destination buffer. */
;;;560          *pOut++ = (q15_t) (__SSAT(sum >> 15, 16));
0003ca  0bd8              LSRS     r0,r3,#15
0003cc  ea404044          ORR      r0,r0,r4,LSL #17
0003d0  f300000f          SSAT     r0,#16,r0
0003d4  f82c0b02          STRH     r0,[r12],#2
;;;561    
;;;562          /* Increment the MAC count */
;;;563          count++;
0003d8  9804              LDR      r0,[sp,#0x10]
0003da  1c40              ADDS     r0,r0,#1
0003dc  9004              STR      r0,[sp,#0x10]
;;;564    
;;;565          /* Update the inputA and inputB pointers for next MAC calculation */
;;;566          px = pIn1 + count;
0003de  9a04              LDR      r2,[sp,#0x10]
0003e0  980d              LDR      r0,[sp,#0x34]
0003e2  eb000842          ADD      r8,r0,r2,LSL #1
;;;567          py = pSrc2;
0003e6  f8dda02c          LDR      r10,[sp,#0x2c]
;;;568    
;;;569          /* Decrement the loop counter */
;;;570          blkCnt--;
0003ea  1e49              SUBS     r1,r1,#1
                  |L1.1004|
0003ec  2900              CMP      r1,#0                 ;542
0003ee  d1df              BNE      |L1.944|
                  |L1.1008|
;;;571        }
;;;572      }
;;;573    
;;;574    
;;;575      /* --------------------------   
;;;576       * Initializations of stage3   
;;;577       * -------------------------*/
;;;578    
;;;579      /* sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1]   
;;;580       * sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2]   
;;;581       * ....   
;;;582       * sum +=  x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2]   
;;;583       * sum +=  x[srcALen-1] * y[srcBLen-1]   
;;;584       */
;;;585    
;;;586      /* In this stage the MAC operations are decreased by 1 for every iteration.   
;;;587         The blockSize3 variable holds the number of MAC operations performed */
;;;588    
;;;589      blockSize3 = srcBLen - 1u;
0003f0  9918              LDR      r1,[sp,#0x60]
0003f2  1e49              SUBS     r1,r1,#1
;;;590    
;;;591      /* Working pointer of inputA */
;;;592      pSrc1 = (pIn1 + srcALen) - (srcBLen - 1u);
0003f4  9a16              LDR      r2,[sp,#0x58]
0003f6  980d              LDR      r0,[sp,#0x34]
0003f8  eb000242          ADD      r2,r0,r2,LSL #1
0003fc  9813              LDR      r0,[sp,#0x4c]
0003fe  eba20240          SUB      r2,r2,r0,LSL #1
;;;593      px = pSrc1;
000402  4610              MOV      r0,r2
;;;594    
;;;595      /* Working pointer of inputB */
;;;596      pSrc2 = pIn2 + (srcBLen - 1u);
000404  f8dd8048          LDR      r8,[sp,#0x48]
;;;597      pIn2 = pSrc2 - 1u;
000408  f1a80b02          SUB      r11,r8,#2
;;;598      py = pIn2;
00040c  465e              MOV      r6,r11
;;;599    
;;;600      /* -------------------   
;;;601       * Stage3 process   
;;;602       * ------------------*/
;;;603    
;;;604      /* For loop unrolling by 4, this stage is divided into two. */
;;;605      /* First part of this stage computes the MAC operations greater than 4 */
;;;606      /* Second part of this stage computes the MAC operations less than or equal to 4 */
;;;607    
;;;608      /* The first part of the stage starts here */
;;;609      j = blockSize3 >> 2u;
00040e  088d              LSRS     r5,r1,#2
;;;610    
;;;611      while((j > 0u) && (blockSize3 > 0u))
000410  e02b              B        |L1.1130|
                  |L1.1042|
;;;612      {
;;;613        /* Accumulator is made zero for every iteration */
;;;614        sum = 0;
000412  2300              MOVS     r3,#0
000414  461c              MOV      r4,r3
;;;615    
;;;616        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;617        k = blockSize3 >> 2u;
000416  088f              LSRS     r7,r1,#2
;;;618    
;;;619        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;620         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;621        while(k > 0u)
000418  e00c              B        |L1.1076|
                  |L1.1050|
;;;622        {
;;;623          /* x[srcALen - srcBLen + 1], x[srcALen - srcBLen + 2] are multiplied   
;;;624           * with y[srcBLen - 1], y[srcBLen - 2] respectively */
;;;625          sum = __SMLALDX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
00041a  f8509b04          LDR      r9,[r0],#4
00041e  f856a904          LDR      r10,[r6],#-4
000422  fbc934da          SMLALDX  r3,r4,r9,r10
;;;626          /* x[srcALen - srcBLen + 3], x[srcALen - srcBLen + 4] are multiplied   
;;;627           * with y[srcBLen - 3], y[srcBLen - 4] respectively */
;;;628          sum = __SMLALDX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
000426  f8509b04          LDR      r9,[r0],#4
00042a  f856a904          LDR      r10,[r6],#-4
00042e  fbc934da          SMLALDX  r3,r4,r9,r10
;;;629    
;;;630          /* Decrement the loop counter */
;;;631          k--;
000432  1e7f              SUBS     r7,r7,#1
                  |L1.1076|
000434  2f00              CMP      r7,#0                 ;621
000436  d1f0              BNE      |L1.1050|
;;;632        }
;;;633    
;;;634        /* For the next MAC operations, the pointer py is used without SIMD   
;;;635         * So, py is incremented by 1 */
;;;636        py = py + 1u;
000438  1cb6              ADDS     r6,r6,#2
;;;637    
;;;638        /* If the blockSize3 is not a multiple of 4, compute any remaining MACs here.   
;;;639         ** No loop unrolling is used. */
;;;640        k = blockSize3 % 0x4u;
00043a  f0010703          AND      r7,r1,#3
;;;641    
;;;642        while(k > 0u)
00043e  e006              B        |L1.1102|
                  |L1.1088|
;;;643        {
;;;644          /* sum += x[srcALen - srcBLen + 5] * y[srcBLen - 5] */
;;;645          sum = __SMLALD(*px++, *py--, sum);
000440  f930ab02          LDRSH    r10,[r0],#2
000444  f9369902          LDRSH    r9,[r6],#-2
000448  fbca34c9          SMLALD   r3,r4,r10,r9
;;;646    
;;;647          /* Decrement the loop counter */
;;;648          k--;
00044c  1e7f              SUBS     r7,r7,#1
                  |L1.1102|
00044e  2f00              CMP      r7,#0                 ;642
000450  d1f6              BNE      |L1.1088|
;;;649        }
;;;650    
;;;651        /* Store the result in the accumulator in the destination buffer. */
;;;652        *pOut++ = (q15_t) (__SSAT((sum >> 15), 16));
000452  0bd8              LSRS     r0,r3,#15
000454  ea404044          ORR      r0,r0,r4,LSL #17
000458  f300000f          SSAT     r0,#16,r0
00045c  f82c0b02          STRH     r0,[r12],#2
;;;653    
;;;654        /* Update the inputA and inputB pointers for next MAC calculation */
;;;655        px = ++pSrc1;
000460  1c90              ADDS     r0,r2,#2
000462  4602              MOV      r2,r0
;;;656        py = pIn2;
000464  465e              MOV      r6,r11
;;;657    
;;;658        /* Decrement the loop counter */
;;;659        blockSize3--;
000466  1e49              SUBS     r1,r1,#1
;;;660    
;;;661        j--;
000468  1e6d              SUBS     r5,r5,#1
                  |L1.1130|
00046a  b10d              CBZ      r5,|L1.1136|
00046c  2900              CMP      r1,#0                 ;611
00046e  d1d0              BNE      |L1.1042|
                  |L1.1136|
;;;662      }
;;;663    
;;;664      /* The second part of the stage starts here */
;;;665      /* SIMD is not used for the next MAC operations,   
;;;666       * so pointer py is updated to read only one sample at a time */
;;;667      py = py + 1u;
000470  1cb6              ADDS     r6,r6,#2
;;;668    
;;;669      while(blockSize3 > 0u)
000472  e017              B        |L1.1188|
                  |L1.1140|
;;;670      {
;;;671        /* Accumulator is made zero for every iteration */
;;;672        sum = 0;
000474  2300              MOVS     r3,#0
000476  461c              MOV      r4,r3
;;;673    
;;;674        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;675        k = blockSize3;
000478  460d              MOV      r5,r1
;;;676    
;;;677        while(k > 0u)
00047a  e006              B        |L1.1162|
                  |L1.1148|
;;;678        {
;;;679          /* Perform the multiply-accumulates */
;;;680          /* sum +=  x[srcALen-1] * y[srcBLen-1] */
;;;681          sum = __SMLALD(*px++, *py--, sum);
00047c  f930ab02          LDRSH    r10,[r0],#2
000480  f9367902          LDRSH    r7,[r6],#-2
000484  fbca34c7          SMLALD   r3,r4,r10,r7
;;;682    
;;;683          /* Decrement the loop counter */
;;;684          k--;
000488  1e6d              SUBS     r5,r5,#1
                  |L1.1162|
00048a  2d00              CMP      r5,#0                 ;677
00048c  d1f6              BNE      |L1.1148|
;;;685        }
;;;686    
;;;687        /* Store the result in the accumulator in the destination buffer. */
;;;688        *pOut++ = (q15_t) (__SSAT((sum >> 15), 16));
00048e  0bd8              LSRS     r0,r3,#15
000490  ea404044          ORR      r0,r0,r4,LSL #17
000494  f300000f          SSAT     r0,#16,r0
000498  f82c0b02          STRH     r0,[r12],#2
;;;689    
;;;690        /* Update the inputA and inputB pointers for next MAC calculation */
;;;691        px = ++pSrc1;
00049c  1c90              ADDS     r0,r2,#2
00049e  4602              MOV      r2,r0
;;;692        py = pSrc2;
0004a0  4646              MOV      r6,r8
;;;693    
;;;694        /* Decrement the loop counter */
;;;695        blockSize3--;
0004a2  1e49              SUBS     r1,r1,#1
                  |L1.1188|
0004a4  2900              CMP      r1,#0                 ;669
0004a6  d1e5              BNE      |L1.1140|
;;;696      }
;;;697    
;;;698    #else
;;;699    
;;;700    /* Run the below code for Cortex-M0 */
;;;701    
;;;702      q15_t *pIn1 = pSrcA;                           /* input pointer */
;;;703      q15_t *pIn2 = pSrcB;                           /* coefficient pointer */
;;;704      q63_t sum;                                     /* Accumulator */
;;;705      uint32_t i, j;                                 /* loop counter */
;;;706    
;;;707      /* Loop to calculate output of convolution for output length number of times */
;;;708      for (i = 0; i < (srcALen + srcBLen - 1); i++)
;;;709      {
;;;710        /* Initialize sum with zero to carry on MAC operations */
;;;711        sum = 0;
;;;712    
;;;713        /* Loop to perform MAC operations according to convolution equation */
;;;714        for (j = 0; j <= i; j++)
;;;715        {
;;;716          /* Check the array limitations */
;;;717          if(((i - j) < srcBLen) && (j < srcALen))
;;;718          {
;;;719            /* z[i] += x[i-j] * y[j] */
;;;720            sum += (q31_t) pIn1[j] * (pIn2[i - j]);
;;;721          }
;;;722        }
;;;723    
;;;724        /* Store the output in the destination buffer */
;;;725        pDst[i] = (q15_t) __SSAT((sum >> 15u), 16u);
;;;726      }
;;;727    
;;;728    #endif /*  #if (defined(ARM_MATH_CM4) || defined(ARM_MATH_CM3)) && !defined(UNALIGNED_SUPPORT_DISABLE)*/
;;;729    
;;;730    }
0004a8  b019              ADD      sp,sp,#0x64
0004aa  e8bd8ff0          POP      {r4-r11,pc}
;;;731    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_conv_q15_c_d6db324e____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___14_arm_conv_q15_c_d6db324e____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_conv_q15_c_d6db324e____REVSH|
#line 144
|__asm___14_arm_conv_q15_c_d6db324e____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_conv_q15_c_d6db324e____RRX|
#line 300
|__asm___14_arm_conv_q15_c_d6db324e____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
