; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_correlate_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_correlate_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_correlate_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_correlate_q15.c]
                          THUMB

                          AREA ||i.arm_correlate_q15||, CODE, READONLY, ALIGN=1

                  arm_correlate_q15 PROC
;;;78     
;;;79     void arm_correlate_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;80       q15_t * pSrcA,
;;;81       uint32_t srcALen,
;;;82       q15_t * pSrcB,
;;;83       uint32_t srcBLen,
;;;84       q15_t * pDst)
;;;85     {
000004  b095              SUB      sp,sp,#0x54
000006  9922              LDR      r1,[sp,#0x88]
;;;86     
;;;87     #if (defined(ARM_MATH_CM4) || defined(ARM_MATH_CM3)) && !defined(UNALIGNED_SUPPORT_DISABLE)
;;;88     
;;;89       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;90     
;;;91       q15_t *pIn1;                                   /* inputA pointer               */
;;;92       q15_t *pIn2;                                   /* inputB pointer               */
;;;93       q15_t *pOut = pDst;                            /* output pointer               */
;;;94       q63_t sum, acc0, acc1, acc2, acc3;             /* Accumulators                  */
;;;95       q15_t *px;                                     /* Intermediate inputA pointer  */
;;;96       q15_t *py;                                     /* Intermediate inputB pointer  */
;;;97       q15_t *pSrc1;                                  /* Intermediate pointers        */
;;;98       q31_t x0, x1, x2, x3, c0;                      /* temporary variables for holding input and coefficient values */
;;;99       uint32_t j, k = 0u, count, blkCnt, outBlockSize, blockSize1, blockSize2, blockSize3;  /* loop counter                 */
;;;100      int32_t inc = 1;                               /* Destination address modifier */
000008  2301              MOVS     r3,#1
00000a  9303              STR      r3,[sp,#0xc]
;;;101    
;;;102    
;;;103      /* The algorithm implementation is based on the lengths of the inputs. */
;;;104      /* srcB is always made to slide across srcA. */
;;;105      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;106      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;107      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;108      /* and the destination pointer modifier, inc is set to -1 */
;;;109      /* If srcALen > srcBLen, zero pad has to be done to srcB to make the two inputs of same length */
;;;110      /* But to improve the performance,   
;;;111       * we include zeroes in the output instead of zero padding either of the the inputs*/
;;;112      /* If srcALen > srcBLen,   
;;;113       * (srcALen - srcBLen) zeroes has to included in the starting of the output buffer */
;;;114      /* If srcALen < srcBLen,   
;;;115       * (srcALen - srcBLen) zeroes has to included in the ending of the output buffer */
;;;116      if(srcALen >= srcBLen)
00000c  9d18              LDR      r5,[sp,#0x60]
00000e  9c16              LDR      r4,[sp,#0x58]
;;;117      {
;;;118        /* Initialization of inputA pointer */
;;;119        pIn1 = (pSrcA);
;;;120    
;;;121        /* Initialization of inputB pointer */
;;;122        pIn2 = (pSrcB);
;;;123    
;;;124        /* Number of output samples is calculated */
;;;125        outBlockSize = (2u * srcALen) - 1u;
000010  1e9b              SUBS     r3,r3,#2
000012  42ac              CMP      r4,r5                 ;116
000014  d30c              BCC      |L1.48|
000016  900f              STR      r0,[sp,#0x3c]         ;119
000018  920e              STR      r2,[sp,#0x38]         ;122
00001a  9816              LDR      r0,[sp,#0x58]
00001c  eb030040          ADD      r0,r3,r0,LSL #1
;;;126    
;;;127        /* When srcALen > srcBLen, zero padding is done to srcB   
;;;128         * to make their lengths equal.   
;;;129         * Instead, (outBlockSize - (srcALen + srcBLen - 1))   
;;;130         * number of output samples are made zero */
;;;131        j = outBlockSize - (srcALen + (srcBLen - 1u));
000020  9b18              LDR      r3,[sp,#0x60]
000022  9a16              LDR      r2,[sp,#0x58]
000024  441a              ADD      r2,r2,r3
000026  1a80              SUBS     r0,r0,r2
000028  1c40              ADDS     r0,r0,#1
;;;132    
;;;133        /* Updating the pointer position to non zero value */
;;;134        pOut += j;
00002a  eb010840          ADD      r8,r1,r0,LSL #1
00002e  e00c              B        |L1.74|
                  |L1.48|
;;;135    
;;;136      }
;;;137      else
;;;138      {
;;;139        /* Initialization of inputA pointer */
;;;140        pIn1 = (pSrcB);
000030  920f              STR      r2,[sp,#0x3c]
;;;141    
;;;142        /* Initialization of inputB pointer */
;;;143        pIn2 = (pSrcA);
000032  900e              STR      r0,[sp,#0x38]
;;;144    
;;;145        /* srcBLen is always considered as shorter or equal to srcALen */
;;;146        j = srcBLen;
000034  9818              LDR      r0,[sp,#0x60]
;;;147        srcBLen = srcALen;
000036  9a16              LDR      r2,[sp,#0x58]
000038  9218              STR      r2,[sp,#0x60]
;;;148        srcALen = j;
00003a  9016              STR      r0,[sp,#0x58]
;;;149    
;;;150        /* CORR(x, y) = Reverse order(CORR(y, x)) */
;;;151        /* Hence set the destination pointer to point to the last output sample */
;;;152        pOut = pDst + ((srcALen + srcBLen) - 2u);
00003c  9a18              LDR      r2,[sp,#0x60]
00003e  9816              LDR      r0,[sp,#0x58]
000040  4410              ADD      r0,r0,r2
000042  1e80              SUBS     r0,r0,#2
000044  eb010840          ADD      r8,r1,r0,LSL #1
;;;153    
;;;154        /* Destination address modifier is set to -1 */
;;;155        inc = -1;
000048  9303              STR      r3,[sp,#0xc]
                  |L1.74|
;;;156    
;;;157      }
;;;158    
;;;159      /* The function is internally   
;;;160       * divided into three parts according to the number of multiplications that has to be   
;;;161       * taken place between inputA samples and inputB samples. In the first part of the   
;;;162       * algorithm, the multiplications increase by one for every iteration.   
;;;163       * In the second part of the algorithm, srcBLen number of multiplications are done.   
;;;164       * In the third part of the algorithm, the multiplications decrease by one   
;;;165       * for every iteration.*/
;;;166      /* The algorithm is implemented in three stages.   
;;;167       * The loop counters of each stage is initiated here. */
;;;168      blockSize1 = srcBLen - 1u;
00004a  9b18              LDR      r3,[sp,#0x60]
00004c  1e5b              SUBS     r3,r3,#1
;;;169      blockSize2 = srcALen - (srcBLen - 1u);
00004e  9918              LDR      r1,[sp,#0x60]
000050  9816              LDR      r0,[sp,#0x58]
000052  1a40              SUBS     r0,r0,r1
000054  1c40              ADDS     r0,r0,#1
000056  9005              STR      r0,[sp,#0x14]
;;;170      blockSize3 = blockSize1;
000058  9304              STR      r3,[sp,#0x10]
;;;171    
;;;172      /* --------------------------   
;;;173       * Initializations of stage1   
;;;174       * -------------------------*/
;;;175    
;;;176      /* sum = x[0] * y[srcBlen - 1]   
;;;177       * sum = x[0] * y[srcBlen - 2] + x[1] * y[srcBlen - 1]   
;;;178       * ....   
;;;179       * sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen - 1] * y[srcBLen - 1]   
;;;180       */
;;;181    
;;;182      /* In this stage the MAC operations are increased by 1 for every iteration.   
;;;183         The count variable holds the number of MAC operations performed */
;;;184      count = 1u;
00005a  2201              MOVS     r2,#1
;;;185    
;;;186      /* Working pointer of inputA */
;;;187      px = pIn1;
00005c  f8ddc03c          LDR      r12,[sp,#0x3c]
;;;188    
;;;189      /* Working pointer of inputB */
;;;190      pSrc1 = pIn2 + (srcBLen - 1u);
000060  9818              LDR      r0,[sp,#0x60]
000062  990e              LDR      r1,[sp,#0x38]
000064  1e40              SUBS     r0,r0,#1
000066  eb010440          ADD      r4,r1,r0,LSL #1
00006a  9013              STR      r0,[sp,#0x4c]
;;;191      py = pSrc1;
00006c  4625              MOV      r5,r4
;;;192    
;;;193      /* ------------------------   
;;;194       * Stage1 process   
;;;195       * ----------------------*/
;;;196    
;;;197      /* The first loop starts here */
;;;198      while(blockSize1 > 0u)
00006e  e02e              B        |L1.206|
                  |L1.112|
;;;199      {
;;;200        /* Accumulator is made zero for every iteration */
;;;201        sum = 0;
000070  2000              MOVS     r0,#0
000072  4601              MOV      r1,r0
;;;202    
;;;203        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;204        k = count >> 2;
000074  0896              LSRS     r6,r2,#2
;;;205    
;;;206        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;207         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;208        while(k > 0u)
000076  e00c              B        |L1.146|
                  |L1.120|
;;;209        {
;;;210          /* x[0] * y[srcBLen - 4] , x[1] * y[srcBLen - 3] */
;;;211          sum = __SMLALD(*__SIMD32(px)++, *__SIMD32(py)++, sum);
000078  f85c7b04          LDR      r7,[r12],#4
00007c  f8559b04          LDR      r9,[r5],#4
000080  fbc701c9          SMLALD   r0,r1,r7,r9
;;;212          /* x[3] * y[srcBLen - 1] , x[2] * y[srcBLen - 2] */
;;;213          sum = __SMLALD(*__SIMD32(px)++, *__SIMD32(py)++, sum);
000084  f85c7b04          LDR      r7,[r12],#4
000088  f8559b04          LDR      r9,[r5],#4
00008c  fbc701c9          SMLALD   r0,r1,r7,r9
;;;214    
;;;215          /* Decrement the loop counter */
;;;216          k--;
000090  1e76              SUBS     r6,r6,#1
                  |L1.146|
000092  2e00              CMP      r6,#0                 ;208
000094  d1f0              BNE      |L1.120|
;;;217        }
;;;218    
;;;219        /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;220         ** No loop unrolling is used. */
;;;221        k = count % 0x4u;
000096  f0020603          AND      r6,r2,#3
;;;222    
;;;223        while(k > 0u)
00009a  e006              B        |L1.170|
                  |L1.156|
;;;224        {
;;;225          /* Perform the multiply-accumulates */
;;;226          /* x[0] * y[srcBLen - 1] */
;;;227          sum = __SMLALD(*px++, *py++, sum);
00009c  f93cab02          LDRSH    r10,[r12],#2
0000a0  f9357b02          LDRSH    r7,[r5],#2
0000a4  fbca01c7          SMLALD   r0,r1,r10,r7
;;;228    
;;;229          /* Decrement the loop counter */
;;;230          k--;
0000a8  1e76              SUBS     r6,r6,#1
                  |L1.170|
0000aa  2e00              CMP      r6,#0                 ;223
0000ac  d1f6              BNE      |L1.156|
;;;231        }
;;;232    
;;;233        /* Store the result in the accumulator in the destination buffer. */
;;;234        *pOut = (q15_t) (__SSAT((sum >> 15), 16));
0000ae  0bc0              LSRS     r0,r0,#15
0000b0  ea404041          ORR      r0,r0,r1,LSL #17
0000b4  f300000f          SSAT     r0,#16,r0
0000b8  f8a80000          STRH     r0,[r8,#0]
;;;235        /* Destination pointer is updated according to the address modifier, inc */
;;;236        pOut += inc;
0000bc  9803              LDR      r0,[sp,#0xc]
0000be  eb080840          ADD      r8,r8,r0,LSL #1
;;;237    
;;;238        /* Update the inputA and inputB pointers for next MAC calculation */
;;;239        py = pSrc1 - count;
0000c2  eba40542          SUB      r5,r4,r2,LSL #1
;;;240        px = pIn1;
0000c6  f8ddc03c          LDR      r12,[sp,#0x3c]
;;;241    
;;;242        /* Increment the MAC count */
;;;243        count++;
0000ca  1c52              ADDS     r2,r2,#1
;;;244    
;;;245        /* Decrement the loop counter */
;;;246        blockSize1--;
0000cc  1e5b              SUBS     r3,r3,#1
                  |L1.206|
0000ce  2b00              CMP      r3,#0                 ;198
0000d0  d1ce              BNE      |L1.112|
;;;247      }
;;;248    
;;;249      /* --------------------------   
;;;250       * Initializations of stage2   
;;;251       * ------------------------*/
;;;252    
;;;253      /* sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen-1] * y[srcBLen-1]   
;;;254       * sum = x[1] * y[0] + x[2] * y[1] +...+ x[srcBLen] * y[srcBLen-1]   
;;;255       * ....   
;;;256       * sum = x[srcALen-srcBLen-2] * y[0] + x[srcALen-srcBLen-1] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]   
;;;257       */
;;;258    
;;;259      /* Working pointer of inputA */
;;;260      px = pIn1;
;;;261    
;;;262      /* Working pointer of inputB */
;;;263      py = pIn2;
0000d2  f8dd9038          LDR      r9,[sp,#0x38]
;;;264    
;;;265      /* count is index by which the pointer pIn1 to be incremented */
;;;266      count = 0u;
0000d6  2000              MOVS     r0,#0
0000d8  9007              STR      r0,[sp,#0x1c]
;;;267    
;;;268      /* -------------------   
;;;269       * Stage2 process   
;;;270       * ------------------*/
;;;271    
;;;272      /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.   
;;;273       * So, to loop unroll over blockSize2,   
;;;274       * srcBLen should be greater than or equal to 4, to loop unroll the srcBLen loop */
;;;275      if(srcBLen >= 4u)
0000da  9818              LDR      r0,[sp,#0x60]
0000dc  2804              CMP      r0,#4
0000de  d37d              BCC      |L1.476|
;;;276      {
;;;277        /* Loop unroll over blockSize2, by 4 */
;;;278        blkCnt = blockSize2 >> 2u;
0000e0  9805              LDR      r0,[sp,#0x14]
0000e2  0880              LSRS     r0,r0,#2
0000e4  9006              STR      r0,[sp,#0x18]
;;;279    
;;;280        while(blkCnt > 0u)
0000e6  e114              B        |L1.786|
                  |L1.232|
;;;281        {
;;;282          /* Set all accumulators to zero */
;;;283          acc0 = 0;
0000e8  2000              MOVS     r0,#0
0000ea  4601              MOV      r1,r0
;;;284          acc1 = 0;
0000ec  2200              MOVS     r2,#0
0000ee  4613              MOV      r3,r2
;;;285          acc2 = 0;
0000f0  2400              MOVS     r4,#0
0000f2  4625              MOV      r5,r4
;;;286          acc3 = 0;
0000f4  2600              MOVS     r6,#0
0000f6  4637              MOV      r7,r6
;;;287    
;;;288          /* read x[0], x[1] samples */
;;;289          x0 = *__SIMD32(px);
0000f8  f8dca000          LDR      r10,[r12,#0]
0000fc  f8cda030          STR      r10,[sp,#0x30]
;;;290          /* read x[1], x[2] samples */
;;;291          x1 = _SIMD32_OFFSET(px + 1);
000100  f8dca002          LDR      r10,[r12,#2]
;;;292    	  px += 2u;
000104  f10c0c04          ADD      r12,r12,#4
;;;293    
;;;294          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;295          k = srcBLen >> 2u;
000108  f8ddb060          LDR      r11,[sp,#0x60]
00010c  ea4f0b9b          LSR      r11,r11,#2
000110  f8cdb020          STR      r11,[sp,#0x20]
                  |L1.276|
;;;296    
;;;297          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;298           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;299          do
;;;300          {
;;;301            /* Read the first two inputB samples using SIMD:   
;;;302             * y[0] and y[1] */
;;;303            c0 = *__SIMD32(py)++;
000114  f859bb04          LDR      r11,[r9],#4
000118  f8cd9034          STR      r9,[sp,#0x34]
;;;304    
;;;305            /* acc0 +=  x[0] * y[0] + x[1] * y[1] */
;;;306            acc0 = __SMLALD(x0, c0, acc0);
00011c  f8dd9030          LDR      r9,[sp,#0x30]
000120  fbc901cb          SMLALD   r0,r1,r9,r11
;;;307    
;;;308            /* acc1 +=  x[1] * y[0] + x[2] * y[1] */
;;;309            acc1 = __SMLALD(x1, c0, acc1);
000124  fbca23cb          SMLALD   r2,r3,r10,r11
;;;310    
;;;311            /* Read x[2], x[3] */
;;;312            x2 = *__SIMD32(px);
000128  f8dce000          LDR      lr,[r12,#0]
;;;313    
;;;314            /* Read x[3], x[4] */
;;;315            x3 = _SIMD32_OFFSET(px + 1);
00012c  f8dca002          LDR      r10,[r12,#2]
000130  f8cda048          STR      r10,[sp,#0x48]
;;;316    
;;;317            /* acc2 +=  x[2] * y[0] + x[3] * y[1] */
;;;318            acc2 = __SMLALD(x2, c0, acc2);
000134  fbce45cb          SMLALD   r4,r5,lr,r11
;;;319    
;;;320            /* acc3 +=  x[3] * y[0] + x[4] * y[1] */
;;;321            acc3 = __SMLALD(x3, c0, acc3);
000138  f8dda048          LDR      r10,[sp,#0x48]
00013c  fbca67cb          SMLALD   r6,r7,r10,r11
;;;322    
;;;323            /* Read y[2] and y[3] */
;;;324            c0 = *__SIMD32(py)++;
000140  f8dd9034          LDR      r9,[sp,#0x34]
000144  f859bb04          LDR      r11,[r9],#4
;;;325    
;;;326            /* acc0 +=  x[2] * y[2] + x[3] * y[3] */
;;;327            acc0 = __SMLALD(x2, c0, acc0);
000148  fbce01cb          SMLALD   r0,r1,lr,r11
;;;328    
;;;329            /* acc1 +=  x[3] * y[2] + x[4] * y[3] */
;;;330            acc1 = __SMLALD(x3, c0, acc1);
00014c  f8dda048          LDR      r10,[sp,#0x48]
000150  fbca23cb          SMLALD   r2,r3,r10,r11
;;;331    
;;;332            /* Read x[4], x[5] */
;;;333            x0 = _SIMD32_OFFSET(px + 2);
000154  f8dca004          LDR      r10,[r12,#4]
000158  f8cda030          STR      r10,[sp,#0x30]
;;;334    
;;;335            /* Read x[5], x[6] */
;;;336            x1 = _SIMD32_OFFSET(px + 3);
00015c  f8dca006          LDR      r10,[r12,#6]
;;;337    
;;;338    		px += 4u;
000160  f10c0c08          ADD      r12,r12,#8
;;;339    
;;;340            /* acc2 +=  x[4] * y[2] + x[5] * y[3] */
;;;341            acc2 = __SMLALD(x0, c0, acc2);
000164  9502              STR      r5,[sp,#8]
000166  f8dde030          LDR      lr,[sp,#0x30]
00016a  fbce45cb          SMLALD   r4,r5,lr,r11
;;;342    
;;;343            /* acc3 +=  x[5] * y[2] + x[6] * y[3] */
;;;344            acc3 = __SMLALD(x1, c0, acc3);
00016e  fbca67cb          SMLALD   r6,r7,r10,r11
;;;345    
;;;346          } while(--k);
000172  f8ddb020          LDR      r11,[sp,#0x20]
000176  f1bb0b01          SUBS     r11,r11,#1
00017a  f8cdb020          STR      r11,[sp,#0x20]
00017e  d1c9              BNE      |L1.276|
;;;347    
;;;348          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;349           ** No loop unrolling is used. */
;;;350          k = srcBLen % 0x4u;
000180  f8ddb060          LDR      r11,[sp,#0x60]
000184  f00b0b03          AND      r11,r11,#3
000188  f8cdb020          STR      r11,[sp,#0x20]
;;;351    
;;;352          if(k == 1u)
00018c  f8ddb020          LDR      r11,[sp,#0x20]
000190  f1bb0f01          CMP      r11,#1
000194  d12a              BNE      |L1.492|
;;;353          {
;;;354            /* Read y[4] */
;;;355            c0 = *py;
000196  f8b9b000          LDRH     r11,[r9,#0]
;;;356    #ifdef  ARM_MATH_BIG_ENDIAN
;;;357    
;;;358            c0 = c0 << 16u;
;;;359    
;;;360    #else
;;;361    
;;;362            c0 = c0 & 0x0000FFFF;
00019a  fa1ffb8b          UXTH     r11,r11
00019e  f8cdb024          STR      r11,[sp,#0x24]
;;;363    
;;;364    #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;365            /* Read x[7] */
;;;366            x3 = *__SIMD32(px);
0001a2  f8dcb000          LDR      r11,[r12,#0]
0001a6  f8cdb028          STR      r11,[sp,#0x28]
;;;367    		px++;
0001aa  f10c0c02          ADD      r12,r12,#2
;;;368    
;;;369            /* Perform the multiply-accumulates */
;;;370            acc0 = __SMLALD(x0, c0, acc0);
0001ae  9102              STR      r1,[sp,#8]
0001b0  e9cd0100          STRD     r0,r1,[sp,#0]
0001b4  f8dde008          LDR      lr,[sp,#8]
0001b8  f8ddb024          LDR      r11,[sp,#0x24]
0001bc  990c              LDR      r1,[sp,#0x30]
0001be  fbc10ecb          SMLALD   r0,lr,r1,r11
0001c2  4671              MOV      r1,lr
;;;371            acc1 = __SMLALD(x1, c0, acc1);
0001c4  f8ddb024          LDR      r11,[sp,#0x24]
0001c8  fbca23cb          SMLALD   r2,r3,r10,r11
;;;372            acc2 = __SMLALDX(x1, c0, acc2);
0001cc  f8ddb024          LDR      r11,[sp,#0x24]
0001d0  fbca45db          SMLALDX  r4,r5,r10,r11
;;;373            acc3 = __SMLALDX(x3, c0, acc3);
0001d4  e9cd6700          STRD     r6,r7,[sp,#0]
0001d8  9702              STR      r7,[sp,#8]
0001da  e000              B        |L1.478|
                  |L1.476|
0001dc  e0ef              B        |L1.958|
                  |L1.478|
0001de  e9ddb709          LDRD     r11,r7,[sp,#0x24]
0001e2  f8dde008          LDR      lr,[sp,#8]
0001e6  fbc76edb          SMLALDX  r6,lr,r7,r11
0001ea  4677              MOV      r7,lr
                  |L1.492|
;;;374          }
;;;375    
;;;376          if(k == 2u)
0001ec  f8ddb020          LDR      r11,[sp,#0x20]
0001f0  f1bb0f02          CMP      r11,#2
0001f4  d123              BNE      |L1.574|
;;;377          {
;;;378            /* Read y[4], y[5] */
;;;379            c0 = *__SIMD32(py);
0001f6  f8d9e000          LDR      lr,[r9,#0]
0001fa  f8cde044          STR      lr,[sp,#0x44]
;;;380    
;;;381            /* Read x[7], x[8] */
;;;382            x3 = *__SIMD32(px);
0001fe  f8dcb000          LDR      r11,[r12,#0]
000202  f8cdb028          STR      r11,[sp,#0x28]
;;;383    
;;;384            /* Read x[9] */
;;;385            x2 = _SIMD32_OFFSET(px + 1);
000206  f8dcb002          LDR      r11,[r12,#2]
00020a  f8cdb02c          STR      r11,[sp,#0x2c]
;;;386    		px += 2u;
00020e  f10c0c04          ADD      r12,r12,#4
;;;387    
;;;388            /* Perform the multiply-accumulates */
;;;389            acc0 = __SMLALD(x0, c0, acc0);
000212  f8dde044          LDR      lr,[sp,#0x44]
000216  f8ddb030          LDR      r11,[sp,#0x30]
00021a  fbcb01ce          SMLALD   r0,r1,r11,lr
;;;390            acc1 = __SMLALD(x1, c0, acc1);
00021e  f8dde044          LDR      lr,[sp,#0x44]
000222  fbca23ce          SMLALD   r2,r3,r10,lr
;;;391            acc2 = __SMLALD(x3, c0, acc2);
000226  f8dde044          LDR      lr,[sp,#0x44]
00022a  f8ddb028          LDR      r11,[sp,#0x28]
00022e  fbcb45ce          SMLALD   r4,r5,r11,lr
;;;392            acc3 = __SMLALD(x2, c0, acc3);
000232  f8dde044          LDR      lr,[sp,#0x44]
000236  f8ddb02c          LDR      r11,[sp,#0x2c]
00023a  fbcb67ce          SMLALD   r6,r7,r11,lr
                  |L1.574|
;;;393          }
;;;394    
;;;395          if(k == 3u)
00023e  f8ddb020          LDR      r11,[sp,#0x20]
000242  f1bb0f03          CMP      r11,#3
000246  d133              BNE      |L1.688|
;;;396          {
;;;397            /* Read y[4], y[5] */
;;;398            c0 = *__SIMD32(py)++;
000248  f859eb04          LDR      lr,[r9],#4
00024c  f8cde024          STR      lr,[sp,#0x24]
000250  f8cd9034          STR      r9,[sp,#0x34]
;;;399    
;;;400            /* Read x[7], x[8] */
;;;401            x3 = *__SIMD32(px);
000254  f8dc9000          LDR      r9,[r12,#0]
000258  f8cd9040          STR      r9,[sp,#0x40]
;;;402    
;;;403            /* Read x[9] */
;;;404            x2 = _SIMD32_OFFSET(px + 1);
00025c  f8dcb002          LDR      r11,[r12,#2]
;;;405    
;;;406            /* Perform the multiply-accumulates */
;;;407            acc0 = __SMLALD(x0, c0, acc0);
000260  f8dde030          LDR      lr,[sp,#0x30]
000264  f8cde008          STR      lr,[sp,#8]
000268  f8dde024          LDR      lr,[sp,#0x24]
00026c  f8dd9008          LDR      r9,[sp,#8]
000270  fbc901ce          SMLALD   r0,r1,r9,lr
;;;408            acc1 = __SMLALD(x1, c0, acc1);
000274  f8dde024          LDR      lr,[sp,#0x24]
000278  fbca23ce          SMLALD   r2,r3,r10,lr
;;;409            acc2 = __SMLALD(x3, c0, acc2);
00027c  f8dde024          LDR      lr,[sp,#0x24]
000280  f8dd9040          LDR      r9,[sp,#0x40]
000284  fbc945ce          SMLALD   r4,r5,r9,lr
;;;410            acc3 = __SMLALD(x2, c0, acc3);
000288  f8dde024          LDR      lr,[sp,#0x24]
00028c  fbcb67ce          SMLALD   r6,r7,r11,lr
;;;411    
;;;412            c0 = (*py);
000290  f8dd9034          LDR      r9,[sp,#0x34]
000294  f8b99000          LDRH     r9,[r9,#0]
;;;413    
;;;414            /* Read y[6] */
;;;415    #ifdef  ARM_MATH_BIG_ENDIAN
;;;416    
;;;417            c0 = c0 << 16u;
;;;418    #else
;;;419    
;;;420            c0 = c0 & 0x0000FFFF;
000298  fa1ff989          UXTH     r9,r9
;;;421    #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;422            /* Read x[10] */
;;;423            x3 = _SIMD32_OFFSET(px + 2);
00029c  f8dce004          LDR      lr,[r12,#4]
;;;424    		px += 3u;
;;;425    
;;;426            /* Perform the multiply-accumulates */
;;;427            acc0 = __SMLALDX(x1, c0, acc0);
0002a0  fbca01d9          SMLALDX  r0,r1,r10,r9
;;;428            acc1 = __SMLALD(x2, c0, acc1);
0002a4  fbcb23c9          SMLALD   r2,r3,r11,r9
;;;429            acc2 = __SMLALDX(x2, c0, acc2);
0002a8  fbcb45d9          SMLALDX  r4,r5,r11,r9
;;;430            acc3 = __SMLALDX(x3, c0, acc3);
0002ac  fbce67d9          SMLALDX  r6,r7,lr,r9
                  |L1.688|
;;;431          }
;;;432    
;;;433          /* Store the result in the accumulator in the destination buffer. */
;;;434          *pOut = (q15_t) (__SSAT(acc0 >> 15, 16));
0002b0  0bc0              LSRS     r0,r0,#15
0002b2  ea404041          ORR      r0,r0,r1,LSL #17
0002b6  f300000f          SSAT     r0,#16,r0
0002ba  f8a80000          STRH     r0,[r8,#0]
;;;435          /* Destination pointer is updated according to the address modifier, inc */
;;;436          pOut += inc;
0002be  9803              LDR      r0,[sp,#0xc]
0002c0  eb080040          ADD      r0,r8,r0,LSL #1
;;;437    
;;;438          *pOut = (q15_t) (__SSAT(acc1 >> 15, 16));
0002c4  0bd1              LSRS     r1,r2,#15
0002c6  ea414143          ORR      r1,r1,r3,LSL #17
0002ca  f301010f          SSAT     r1,#16,r1
0002ce  8001              STRH     r1,[r0,#0]
;;;439          pOut += inc;
0002d0  9903              LDR      r1,[sp,#0xc]
0002d2  eb000041          ADD      r0,r0,r1,LSL #1
;;;440    
;;;441          *pOut = (q15_t) (__SSAT(acc2 >> 15, 16));
0002d6  0be1              LSRS     r1,r4,#15
0002d8  ea414145          ORR      r1,r1,r5,LSL #17
0002dc  f301010f          SSAT     r1,#16,r1
0002e0  8001              STRH     r1,[r0,#0]
;;;442          pOut += inc;
0002e2  9903              LDR      r1,[sp,#0xc]
0002e4  eb000041          ADD      r0,r0,r1,LSL #1
;;;443    
;;;444          *pOut = (q15_t) (__SSAT(acc3 >> 15, 16));
0002e8  0bf1              LSRS     r1,r6,#15
0002ea  ea414147          ORR      r1,r1,r7,LSL #17
0002ee  f301010f          SSAT     r1,#16,r1
0002f2  8001              STRH     r1,[r0,#0]
;;;445          pOut += inc;
0002f4  9903              LDR      r1,[sp,#0xc]
0002f6  eb000841          ADD      r8,r0,r1,LSL #1
;;;446    
;;;447          /* Increment the count by 4 as 4 output values are computed */
;;;448          count += 4u;
0002fa  9807              LDR      r0,[sp,#0x1c]
0002fc  1d00              ADDS     r0,r0,#4
0002fe  9007              STR      r0,[sp,#0x1c]
;;;449    
;;;450          /* Update the inputA and inputB pointers for next MAC calculation */
;;;451          px = pIn1 + count;
000300  9907              LDR      r1,[sp,#0x1c]
000302  980f              LDR      r0,[sp,#0x3c]
000304  eb000c41          ADD      r12,r0,r1,LSL #1
;;;452          py = pIn2;
000308  f8dd9038          LDR      r9,[sp,#0x38]
;;;453    
;;;454          /* Decrement the loop counter */
;;;455          blkCnt--;
00030c  9806              LDR      r0,[sp,#0x18]
00030e  1e40              SUBS     r0,r0,#1
000310  9006              STR      r0,[sp,#0x18]
                  |L1.786|
000312  9806              LDR      r0,[sp,#0x18]         ;280
000314  2800              CMP      r0,#0                 ;280
000316  f47faee7          BNE      |L1.232|
;;;456        }
;;;457    
;;;458        /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.   
;;;459         ** No loop unrolling is used. */
;;;460        blkCnt = blockSize2 % 0x4u;
00031a  9805              LDR      r0,[sp,#0x14]
00031c  f0000303          AND      r3,r0,#3
;;;461    
;;;462        while(blkCnt > 0u)
000320  e04a              B        |L1.952|
                  |L1.802|
;;;463        {
;;;464          /* Accumulator is made zero for every iteration */
;;;465          sum = 0;
000322  2000              MOVS     r0,#0
000324  4601              MOV      r1,r0
;;;466    
;;;467          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;468          k = srcBLen >> 2u;
000326  9a18              LDR      r2,[sp,#0x60]
000328  0892              LSRS     r2,r2,#2
;;;469    
;;;470          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;471           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;472          while(k > 0u)
00032a  e020              B        |L1.878|
                  |L1.812|
;;;473          {
;;;474            /* Perform the multiply-accumulates */
;;;475            sum += ((q63_t) * px++ * *py++);
00032c  f93c4b02          LDRSH    r4,[r12],#2
000330  f9395b02          LDRSH    r5,[r9],#2
000334  fb845405          SMULL    r5,r4,r4,r5
000338  1828              ADDS     r0,r5,r0
00033a  4161              ADCS     r1,r1,r4
;;;476            sum += ((q63_t) * px++ * *py++);
00033c  f93c4b02          LDRSH    r4,[r12],#2
000340  f9395b02          LDRSH    r5,[r9],#2
000344  fb845405          SMULL    r5,r4,r4,r5
000348  1828              ADDS     r0,r5,r0
00034a  4161              ADCS     r1,r1,r4
;;;477            sum += ((q63_t) * px++ * *py++);
00034c  f93c4b02          LDRSH    r4,[r12],#2
000350  f9395b02          LDRSH    r5,[r9],#2
000354  fb845405          SMULL    r5,r4,r4,r5
000358  1828              ADDS     r0,r5,r0
00035a  4161              ADCS     r1,r1,r4
;;;478            sum += ((q63_t) * px++ * *py++);
00035c  f93c4b02          LDRSH    r4,[r12],#2
000360  f9395b02          LDRSH    r5,[r9],#2
000364  fb845405          SMULL    r5,r4,r4,r5
000368  1828              ADDS     r0,r5,r0
00036a  4161              ADCS     r1,r1,r4
;;;479    
;;;480            /* Decrement the loop counter */
;;;481            k--;
00036c  1e52              SUBS     r2,r2,#1
                  |L1.878|
00036e  2a00              CMP      r2,#0                 ;472
000370  d1dc              BNE      |L1.812|
;;;482          }
;;;483    
;;;484          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;485           ** No loop unrolling is used. */
;;;486          k = srcBLen % 0x4u;
000372  9a18              LDR      r2,[sp,#0x60]
000374  f0020203          AND      r2,r2,#3
;;;487    
;;;488          while(k > 0u)
000378  e008              B        |L1.908|
                  |L1.890|
;;;489          {
;;;490            /* Perform the multiply-accumulates */
;;;491            sum += ((q63_t) * px++ * *py++);
00037a  f93c4b02          LDRSH    r4,[r12],#2
00037e  f9395b02          LDRSH    r5,[r9],#2
000382  fb845405          SMULL    r5,r4,r4,r5
000386  1828              ADDS     r0,r5,r0
000388  4161              ADCS     r1,r1,r4
;;;492    
;;;493            /* Decrement the loop counter */
;;;494            k--;
00038a  1e52              SUBS     r2,r2,#1
                  |L1.908|
00038c  2a00              CMP      r2,#0                 ;488
00038e  d1f4              BNE      |L1.890|
;;;495          }
;;;496    
;;;497          /* Store the result in the accumulator in the destination buffer. */
;;;498          *pOut = (q15_t) (__SSAT(sum >> 15, 16));
000390  0bc0              LSRS     r0,r0,#15
000392  ea404041          ORR      r0,r0,r1,LSL #17
000396  f300000f          SSAT     r0,#16,r0
00039a  f8a80000          STRH     r0,[r8,#0]
;;;499          /* Destination pointer is updated according to the address modifier, inc */
;;;500          pOut += inc;
00039e  9803              LDR      r0,[sp,#0xc]
0003a0  eb080840          ADD      r8,r8,r0,LSL #1
;;;501    
;;;502          /* Increment count by 1, as one output value is computed */
;;;503          count++;
0003a4  9807              LDR      r0,[sp,#0x1c]
0003a6  1c40              ADDS     r0,r0,#1
0003a8  9007              STR      r0,[sp,#0x1c]
;;;504    
;;;505          /* Update the inputA and inputB pointers for next MAC calculation */
;;;506          px = pIn1 + count;
0003aa  9907              LDR      r1,[sp,#0x1c]
0003ac  980f              LDR      r0,[sp,#0x3c]
0003ae  eb000c41          ADD      r12,r0,r1,LSL #1
;;;507          py = pIn2;
0003b2  f8dd9038          LDR      r9,[sp,#0x38]
;;;508    
;;;509          /* Decrement the loop counter */
;;;510          blkCnt--;
0003b6  1e5b              SUBS     r3,r3,#1
                  |L1.952|
0003b8  2b00              CMP      r3,#0                 ;462
0003ba  d1b2              BNE      |L1.802|
0003bc  e026              B        |L1.1036|
                  |L1.958|
;;;511        }
;;;512      }
;;;513      else
;;;514      {
;;;515        /* If the srcBLen is not a multiple of 4,   
;;;516         * the blockSize2 loop cannot be unrolled by 4 */
;;;517        blkCnt = blockSize2;
0003be  9b05              LDR      r3,[sp,#0x14]
;;;518    
;;;519        while(blkCnt > 0u)
0003c0  e022              B        |L1.1032|
                  |L1.962|
;;;520        {
;;;521          /* Accumulator is made zero for every iteration */
;;;522          sum = 0;
0003c2  2000              MOVS     r0,#0
0003c4  4601              MOV      r1,r0
;;;523    
;;;524          /* Loop over srcBLen */
;;;525          k = srcBLen;
0003c6  9a18              LDR      r2,[sp,#0x60]
;;;526    
;;;527          while(k > 0u)
0003c8  e008              B        |L1.988|
                  |L1.970|
;;;528          {
;;;529            /* Perform the multiply-accumulate */
;;;530            sum += ((q63_t) * px++ * *py++);
0003ca  f93c4b02          LDRSH    r4,[r12],#2
0003ce  f9395b02          LDRSH    r5,[r9],#2
0003d2  fb845405          SMULL    r5,r4,r4,r5
0003d6  1828              ADDS     r0,r5,r0
0003d8  4161              ADCS     r1,r1,r4
;;;531    
;;;532            /* Decrement the loop counter */
;;;533            k--;
0003da  1e52              SUBS     r2,r2,#1
                  |L1.988|
0003dc  2a00              CMP      r2,#0                 ;527
0003de  d1f4              BNE      |L1.970|
;;;534          }
;;;535    
;;;536          /* Store the result in the accumulator in the destination buffer. */
;;;537          *pOut = (q15_t) (__SSAT(sum >> 15, 16));
0003e0  0bc0              LSRS     r0,r0,#15
0003e2  ea404041          ORR      r0,r0,r1,LSL #17
0003e6  f300000f          SSAT     r0,#16,r0
0003ea  f8a80000          STRH     r0,[r8,#0]
;;;538          /* Destination pointer is updated according to the address modifier, inc */
;;;539          pOut += inc;
0003ee  9803              LDR      r0,[sp,#0xc]
0003f0  eb080840          ADD      r8,r8,r0,LSL #1
;;;540    
;;;541          /* Increment the MAC count */
;;;542          count++;
0003f4  9807              LDR      r0,[sp,#0x1c]
0003f6  1c40              ADDS     r0,r0,#1
0003f8  9007              STR      r0,[sp,#0x1c]
;;;543    
;;;544          /* Update the inputA and inputB pointers for next MAC calculation */
;;;545          px = pIn1 + count;
0003fa  9907              LDR      r1,[sp,#0x1c]
0003fc  980f              LDR      r0,[sp,#0x3c]
0003fe  eb000c41          ADD      r12,r0,r1,LSL #1
;;;546          py = pIn2;
000402  f8dd9038          LDR      r9,[sp,#0x38]
;;;547    
;;;548          /* Decrement the loop counter */
;;;549          blkCnt--;
000406  1e5b              SUBS     r3,r3,#1
                  |L1.1032|
000408  2b00              CMP      r3,#0                 ;519
00040a  d1da              BNE      |L1.962|
                  |L1.1036|
;;;550        }
;;;551      }
;;;552    
;;;553      /* --------------------------   
;;;554       * Initializations of stage3   
;;;555       * -------------------------*/
;;;556    
;;;557      /* sum += x[srcALen-srcBLen+1] * y[0] + x[srcALen-srcBLen+2] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]   
;;;558       * sum += x[srcALen-srcBLen+2] * y[0] + x[srcALen-srcBLen+3] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]   
;;;559       * ....   
;;;560       * sum +=  x[srcALen-2] * y[0] + x[srcALen-1] * y[1]   
;;;561       * sum +=  x[srcALen-1] * y[0]   
;;;562       */
;;;563    
;;;564      /* In this stage the MAC operations are decreased by 1 for every iteration.   
;;;565         The count variable holds the number of MAC operations performed */
;;;566      count = srcBLen - 1u;
00040c  9b18              LDR      r3,[sp,#0x60]
00040e  1e5b              SUBS     r3,r3,#1
;;;567    
;;;568      /* Working pointer of inputA */
;;;569      pSrc1 = (pIn1 + srcALen) - (srcBLen - 1u);
000410  9916              LDR      r1,[sp,#0x58]
000412  980f              LDR      r0,[sp,#0x3c]
000414  eb000141          ADD      r1,r0,r1,LSL #1
000418  9813              LDR      r0,[sp,#0x4c]
00041a  eba10440          SUB      r4,r1,r0,LSL #1
;;;570      px = pSrc1;
00041e  4622              MOV      r2,r4
;;;571    
;;;572      /* Working pointer of inputB */
;;;573      py = pIn2;
;;;574    
;;;575      /* -------------------   
;;;576       * Stage3 process   
;;;577       * ------------------*/
;;;578    
;;;579      while(blockSize3 > 0u)
000420  e02f              B        |L1.1154|
                  |L1.1058|
;;;580      {
;;;581        /* Accumulator is made zero for every iteration */
;;;582        sum = 0;
000422  2000              MOVS     r0,#0
000424  4601              MOV      r1,r0
;;;583    
;;;584        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;585        k = count >> 2u;
000426  089d              LSRS     r5,r3,#2
;;;586    
;;;587        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;588         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;589        while(k > 0u)
000428  e00b              B        |L1.1090|
                  |L1.1066|
;;;590        {
;;;591          /* Perform the multiply-accumulates */
;;;592          /* sum += x[srcALen - srcBLen + 4] * y[3] , sum += x[srcALen - srcBLen + 3] * y[2] */
;;;593          sum = __SMLALD(*__SIMD32(px)++, *__SIMD32(py)++, sum);
00042a  6816              LDR      r6,[r2,#0]
00042c  f8597b04          LDR      r7,[r9],#4
000430  fbc601c7          SMLALD   r0,r1,r6,r7
;;;594          /* sum += x[srcALen - srcBLen + 2] * y[1] , sum += x[srcALen - srcBLen + 1] * y[0] */
;;;595          sum = __SMLALD(*__SIMD32(px)++, *__SIMD32(py)++, sum);
000434  6856              LDR      r6,[r2,#4]
000436  f8597b04          LDR      r7,[r9],#4
00043a  3208              ADDS     r2,r2,#8
00043c  fbc601c7          SMLALD   r0,r1,r6,r7
;;;596    
;;;597          /* Decrement the loop counter */
;;;598          k--;
000440  1e6d              SUBS     r5,r5,#1
                  |L1.1090|
000442  2d00              CMP      r5,#0                 ;589
000444  d1f1              BNE      |L1.1066|
;;;599        }
;;;600    
;;;601        /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;602         ** No loop unrolling is used. */
;;;603        k = count % 0x4u;
000446  f0030503          AND      r5,r3,#3
;;;604    
;;;605        while(k > 0u)
00044a  e006              B        |L1.1114|
                  |L1.1100|
;;;606        {
;;;607          /* Perform the multiply-accumulates */
;;;608          sum = __SMLALD(*px++, *py++, sum);
00044c  f932cb02          LDRSH    r12,[r2],#2
000450  f9396b02          LDRSH    r6,[r9],#2
000454  fbcc01c6          SMLALD   r0,r1,r12,r6
;;;609    
;;;610          /* Decrement the loop counter */
;;;611          k--;
000458  1e6d              SUBS     r5,r5,#1
                  |L1.1114|
00045a  2d00              CMP      r5,#0                 ;605
00045c  d1f6              BNE      |L1.1100|
;;;612        }
;;;613    
;;;614        /* Store the result in the accumulator in the destination buffer. */
;;;615        *pOut = (q15_t) (__SSAT((sum >> 15), 16));
00045e  0bc0              LSRS     r0,r0,#15
000460  ea404041          ORR      r0,r0,r1,LSL #17
000464  f300000f          SSAT     r0,#16,r0
000468  f8a80000          STRH     r0,[r8,#0]
;;;616        /* Destination pointer is updated according to the address modifier, inc */
;;;617        pOut += inc;
00046c  9803              LDR      r0,[sp,#0xc]
00046e  eb080840          ADD      r8,r8,r0,LSL #1
;;;618    
;;;619        /* Update the inputA and inputB pointers for next MAC calculation */
;;;620        px = ++pSrc1;
000472  1ca2              ADDS     r2,r4,#2
000474  4614              MOV      r4,r2
;;;621        py = pIn2;
000476  f8dd9038          LDR      r9,[sp,#0x38]
;;;622    
;;;623        /* Decrement the MAC count */
;;;624        count--;
00047a  1e5b              SUBS     r3,r3,#1
;;;625    
;;;626        /* Decrement the loop counter */
;;;627        blockSize3--;
00047c  9804              LDR      r0,[sp,#0x10]
00047e  1e40              SUBS     r0,r0,#1
000480  9004              STR      r0,[sp,#0x10]
                  |L1.1154|
000482  9804              LDR      r0,[sp,#0x10]         ;579
000484  2800              CMP      r0,#0                 ;579
000486  d1cc              BNE      |L1.1058|
;;;628      }
;;;629    
;;;630    #else
;;;631    
;;;632    /* Run the below code for Cortex-M0 */
;;;633    
;;;634      q15_t *pIn1 = pSrcA;                           /* inputA pointer               */
;;;635      q15_t *pIn2 = pSrcB + (srcBLen - 1u);          /* inputB pointer               */
;;;636      q63_t sum;                                     /* Accumulators                  */
;;;637      uint32_t i = 0u, j;                            /* loop counters */
;;;638      uint32_t inv = 0u;                             /* Reverse order flag */
;;;639      uint32_t tot = 0u;                             /* Length */
;;;640    
;;;641      /* The algorithm implementation is based on the lengths of the inputs. */
;;;642      /* srcB is always made to slide across srcA. */
;;;643      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;644      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;645      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;646      /* and a varaible, inv is set to 1 */
;;;647      /* If lengths are not equal then zero pad has to be done to  make the two   
;;;648       * inputs of same length. But to improve the performance, we include zeroes   
;;;649       * in the output instead of zero padding either of the the inputs*/
;;;650      /* If srcALen > srcBLen, (srcALen - srcBLen) zeroes has to included in the   
;;;651       * starting of the output buffer */
;;;652      /* If srcALen < srcBLen, (srcALen - srcBLen) zeroes has to included in the  
;;;653       * ending of the output buffer */
;;;654      /* Once the zero padding is done the remaining of the output is calcualted  
;;;655       * using convolution but with the shorter signal time shifted. */
;;;656    
;;;657      /* Calculate the length of the remaining sequence */
;;;658      tot = ((srcALen + srcBLen) - 2u);
;;;659    
;;;660      if(srcALen > srcBLen)
;;;661      {
;;;662        /* Calculating the number of zeros to be padded to the output */
;;;663        j = srcALen - srcBLen;
;;;664    
;;;665        /* Initialise the pointer after zero padding */
;;;666        pDst += j;
;;;667      }
;;;668    
;;;669      else if(srcALen < srcBLen)
;;;670      {
;;;671        /* Initialization to inputB pointer */
;;;672        pIn1 = pSrcB;
;;;673    
;;;674        /* Initialization to the end of inputA pointer */
;;;675        pIn2 = pSrcA + (srcALen - 1u);
;;;676    
;;;677        /* Initialisation of the pointer after zero padding */
;;;678        pDst = pDst + tot;
;;;679    
;;;680        /* Swapping the lengths */
;;;681        j = srcALen;
;;;682        srcALen = srcBLen;
;;;683        srcBLen = j;
;;;684    
;;;685        /* Setting the reverse flag */
;;;686        inv = 1;
;;;687    
;;;688      }
;;;689    
;;;690      /* Loop to calculate convolution for output length number of times */
;;;691      for (i = 0u; i <= tot; i++)
;;;692      {
;;;693        /* Initialize sum with zero to carry on MAC operations */
;;;694        sum = 0;
;;;695    
;;;696        /* Loop to perform MAC operations according to convolution equation */
;;;697        for (j = 0u; j <= i; j++)
;;;698        {
;;;699          /* Check the array limitations */
;;;700          if((((i - j) < srcBLen) && (j < srcALen)))
;;;701          {
;;;702            /* z[i] += x[i-j] * y[j] */
;;;703            sum += ((q31_t) pIn1[j] * pIn2[-((int32_t) i - j)]);
;;;704          }
;;;705        }
;;;706        /* Store the output in the destination buffer */
;;;707        if(inv == 1)
;;;708          *pDst-- = (q15_t) __SSAT((sum >> 15u), 16u);
;;;709        else
;;;710          *pDst++ = (q15_t) __SSAT((sum >> 15u), 16u);
;;;711      }
;;;712    
;;;713    #endif /*#if (defined(ARM_MATH_CM4) || defined(ARM_MATH_CM3)) && !defined(UNALIGNED_SUPPORT_DISABLE) */
;;;714    
;;;715    }
000488  b019              ADD      sp,sp,#0x64
00048a  e8bd8ff0          POP      {r4-r11,pc}
;;;716    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_correlate_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_correlate_q15_c_3c6b17d6____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___19_arm_correlate_q15_c_3c6b17d6____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_correlate_q15_c_3c6b17d6____REVSH|
#line 144
|__asm___19_arm_correlate_q15_c_3c6b17d6____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_correlate_q15_c_3c6b17d6____RRX|
#line 300
|__asm___19_arm_correlate_q15_c_3c6b17d6____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
