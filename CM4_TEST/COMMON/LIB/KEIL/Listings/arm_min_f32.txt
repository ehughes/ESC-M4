; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_min_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_min_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_min_f32.crf ..\..\SRC\CMSIS_DSP_4_5\src\StatisticsFunctions\arm_min_f32.c]
                          THUMB

                          AREA ||i.arm_min_f32||, CODE, READONLY, ALIGN=1

                  arm_min_f32 PROC
;;;70     
;;;71     void arm_min_f32(
000000  b5f0              PUSH     {r4-r7,lr}
;;;72       float32_t * pSrc,
;;;73       uint32_t blockSize,
;;;74       float32_t * pResult,
;;;75       uint32_t * pIndex)
;;;76     {
;;;77     #ifndef ARM_MATH_CM0_FAMILY
;;;78     
;;;79       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;80     
;;;81       float32_t minVal1, minVal2, out;               /* Temporary variables to store the output value. */
;;;82       uint32_t blkCnt, outIndex, count;              /* loop counter */
;;;83     
;;;84       /* Initialise the count value. */
;;;85       count = 0u;
000002  2400              MOVS     r4,#0
;;;86       /* Initialise the index value to zero. */
;;;87       outIndex = 0u;
000004  2500              MOVS     r5,#0
;;;88       /* Load first input value that act as reference value for comparision */
;;;89       out = *pSrc++;
000006  ecb00a01          VLDM     r0!,{s0}
;;;90     
;;;91       /* Loop unrolling */
;;;92       blkCnt = (blockSize - 1u) >> 2u;
00000a  1e4f              SUBS     r7,r1,#1
00000c  08be              LSRS     r6,r7,#2
00000e  e029              B        |L1.100|
                  |L1.16|
;;;93     
;;;94       while(blkCnt > 0)
;;;95       {
;;;96         /* Initialize minVal to the next consecutive values one by one */
;;;97         minVal1 = *pSrc++;
000010  ecf00a01          VLDM     r0!,{s1}
;;;98         minVal2 = *pSrc++;
000014  ecb01a01          VLDM     r0!,{s2}
;;;99     
;;;100        /* compare for the minimum value */
;;;101        if(out > minVal1)
000018  eeb40ae0          VCMPE.F32 s0,s1
00001c  eef1fa10          VMRS     APSR_nzcv,FPSCR
000020  dd02              BLE      |L1.40|
;;;102        {
;;;103          /* Update the minimum value and its index */
;;;104          out = minVal1;
000022  eeb00a60          VMOV.F32 s0,s1
;;;105          outIndex = count + 1u;
000026  1c65              ADDS     r5,r4,#1
                  |L1.40|
;;;106        }
;;;107    
;;;108        minVal1 = *pSrc++;
000028  ecf00a01          VLDM     r0!,{s1}
;;;109    
;;;110        /* compare for the minimum value */
;;;111        if(out > minVal2)
00002c  eeb40ac1          VCMPE.F32 s0,s2
000030  eef1fa10          VMRS     APSR_nzcv,FPSCR
000034  dd02              BLE      |L1.60|
;;;112        {
;;;113          /* Update the minimum value and its index */
;;;114          out = minVal2;
000036  eeb00a41          VMOV.F32 s0,s2
;;;115          outIndex = count + 2u;
00003a  1ca5              ADDS     r5,r4,#2
                  |L1.60|
;;;116        }
;;;117    
;;;118        minVal2 = *pSrc++;
00003c  ecb01a01          VLDM     r0!,{s2}
;;;119    
;;;120        /* compare for the minimum value */
;;;121        if(out > minVal1)
000040  eeb40ae0          VCMPE.F32 s0,s1
000044  eef1fa10          VMRS     APSR_nzcv,FPSCR
000048  dd02              BLE      |L1.80|
;;;122        {
;;;123          /* Update the minimum value and its index */
;;;124          out = minVal1;
00004a  eeb00a60          VMOV.F32 s0,s1
;;;125          outIndex = count + 3u;
00004e  1ce5              ADDS     r5,r4,#3
                  |L1.80|
;;;126        }
;;;127    
;;;128        /* compare for the minimum value */
;;;129        if(out > minVal2)
000050  eeb40ac1          VCMPE.F32 s0,s2
000054  eef1fa10          VMRS     APSR_nzcv,FPSCR
000058  dd02              BLE      |L1.96|
;;;130        {
;;;131          /* Update the minimum value and its index */
;;;132          out = minVal2;
00005a  eeb00a41          VMOV.F32 s0,s2
;;;133          outIndex = count + 4u;
00005e  1d25              ADDS     r5,r4,#4
                  |L1.96|
;;;134        }
;;;135    
;;;136        count += 4u;
000060  1d24              ADDS     r4,r4,#4
;;;137    
;;;138        blkCnt--;
000062  1e76              SUBS     r6,r6,#1
                  |L1.100|
000064  2e00              CMP      r6,#0                 ;94
000066  d1d3              BNE      |L1.16|
;;;139      }
;;;140    
;;;141      /* if (blockSize - 1u ) is not multiple of 4 */
;;;142      blkCnt = (blockSize - 1u) % 4u;
000068  f0070403          AND      r4,r7,#3
;;;143    
;;;144    #else
;;;145    
;;;146      /* Run the below code for Cortex-M0 */
;;;147      float32_t minVal1, out;                        /* Temporary variables to store the output value. */
;;;148      uint32_t blkCnt, outIndex;                     /* loop counter */
;;;149    
;;;150      /* Initialise the index value to zero. */
;;;151      outIndex = 0u;
;;;152      /* Load first input value that act as reference value for comparision */
;;;153      out = *pSrc++;
;;;154    
;;;155      blkCnt = (blockSize - 1u);
;;;156    
;;;157    #endif //      #ifndef ARM_MATH_CM0_FAMILY
;;;158    
;;;159      while(blkCnt > 0)
00006c  e00a              B        |L1.132|
                  |L1.110|
;;;160      {
;;;161        /* Initialize minVal to the next consecutive values one by one */
;;;162        minVal1 = *pSrc++;
00006e  ecf00a01          VLDM     r0!,{s1}
;;;163    
;;;164        /* compare for the minimum value */
;;;165        if(out > minVal1)
000072  eeb40ae0          VCMPE.F32 s0,s1
000076  eef1fa10          VMRS     APSR_nzcv,FPSCR
00007a  dd02              BLE      |L1.130|
;;;166        {
;;;167          /* Update the minimum value and it's index */
;;;168          out = minVal1;
00007c  eeb00a60          VMOV.F32 s0,s1
;;;169          outIndex = blockSize - blkCnt;
000080  1b0d              SUBS     r5,r1,r4
                  |L1.130|
;;;170        }
;;;171    
;;;172        blkCnt--;
000082  1e64              SUBS     r4,r4,#1
                  |L1.132|
000084  2c00              CMP      r4,#0                 ;159
000086  d1f2              BNE      |L1.110|
;;;173    
;;;174      }
;;;175    
;;;176      /* Store the minimum value and it's index into destination pointers */
;;;177      *pResult = out;
000088  ed820a00          VSTR     s0,[r2,#0]
;;;178      *pIndex = outIndex;
00008c  601d              STR      r5,[r3,#0]
;;;179    }
00008e  bdf0              POP      {r4-r7,pc}
;;;180    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\StatisticsFunctions\\arm_min_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_min_f32_c_295b0c65____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___13_arm_min_f32_c_295b0c65____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_min_f32_c_295b0c65____REVSH|
#line 144
|__asm___13_arm_min_f32_c_295b0c65____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_min_f32_c_295b0c65____RRX|
#line 300
|__asm___13_arm_min_f32_c_295b0c65____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
