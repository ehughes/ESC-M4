; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_partial_q7.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_partial_q7.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_conv_partial_q7.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_partial_q7.c]
                          THUMB

                          AREA ||i.arm_conv_partial_q7||, CODE, READONLY, ALIGN=1

                  arm_conv_partial_q7 PROC
;;;67     
;;;68     arm_status arm_conv_partial_q7(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;69       q7_t * pSrcA,
;;;70       uint32_t srcALen,
;;;71       q7_t * pSrcB,
;;;72       uint32_t srcBLen,
;;;73       q7_t * pDst,
;;;74       uint32_t firstIndex,
;;;75       uint32_t numPoints)
;;;76     {
000004  b08b              SUB      sp,sp,#0x2c
000006  e9dd7519          LDRD     r7,r5,[sp,#0x64]
00000a  9c18              LDR      r4,[sp,#0x60]
;;;77     
;;;78     
;;;79     #ifndef ARM_MATH_CM0_FAMILY
;;;80     
;;;81       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;82     
;;;83       q7_t *pIn1;                                    /* inputA pointer */
;;;84       q7_t *pIn2;                                    /* inputB pointer */
;;;85       q7_t *pOut = pDst;                             /* output pointer */
;;;86       q7_t *px;                                      /* Intermediate inputA pointer */
;;;87       q7_t *py;                                      /* Intermediate inputB pointer */
;;;88       q7_t *pSrc1, *pSrc2;                           /* Intermediate pointers */
;;;89       q31_t sum, acc0, acc1, acc2, acc3;             /* Accumulator */
;;;90       q31_t input1, input2;
;;;91       q15_t in1, in2;
;;;92       q7_t x0, x1, x2, x3, c0, c1;
;;;93       uint32_t j, k, count, check, blkCnt;
;;;94       int32_t blockSize1, blockSize2, blockSize3;    /* loop counter */
;;;95       arm_status status;
;;;96     
;;;97     
;;;98       /* Check for range of output samples to be calculated */
;;;99       if((firstIndex + numPoints) > ((srcALen + (srcBLen - 1u))))
00000c  9e0c              LDR      r6,[sp,#0x30]
00000e  1979              ADDS     r1,r7,r5
000010  441e              ADD      r6,r6,r3
000012  1e76              SUBS     r6,r6,#1
000014  42b1              CMP      r1,r6
000016  d904              BLS      |L1.34|
;;;100      {
;;;101        /* Set status as ARM_MATH_ARGUMENT_ERROR */
;;;102        status = ARM_MATH_ARGUMENT_ERROR;
000018  f04f30ff          MOV      r0,#0xffffffff
                  |L1.28|
;;;103      }
;;;104      else
;;;105      {
;;;106    
;;;107        /* The algorithm implementation is based on the lengths of the inputs. */
;;;108        /* srcB is always made to slide across srcA. */
;;;109        /* So srcBLen is always considered as shorter or equal to srcALen */
;;;110        if(srcALen >= srcBLen)
;;;111        {
;;;112          /* Initialization of inputA pointer */
;;;113          pIn1 = pSrcA;
;;;114    
;;;115          /* Initialization of inputB pointer */
;;;116          pIn2 = pSrcB;
;;;117        }
;;;118        else
;;;119        {
;;;120          /* Initialization of inputA pointer */
;;;121          pIn1 = pSrcB;
;;;122    
;;;123          /* Initialization of inputB pointer */
;;;124          pIn2 = pSrcA;
;;;125    
;;;126          /* srcBLen is always considered as shorter or equal to srcALen */
;;;127          j = srcBLen;
;;;128          srcBLen = srcALen;
;;;129          srcALen = j;
;;;130        }
;;;131    
;;;132        /* Conditions to check which loopCounter holds   
;;;133         * the first and last indices of the output samples to be calculated. */
;;;134        check = firstIndex + numPoints;
;;;135        blockSize3 = ((int32_t)check > (int32_t)srcALen) ? (int32_t)check - (int32_t)srcALen : 0;
;;;136        blockSize3 = ((int32_t)firstIndex > (int32_t)srcALen - 1) ? blockSize3 - (int32_t)firstIndex + (int32_t)srcALen : blockSize3;
;;;137        blockSize1 = (((int32_t) srcBLen - 1) - (int32_t) firstIndex);
;;;138        blockSize1 = (blockSize1 > 0) ? ((check > (srcBLen - 1u)) ? blockSize1 :
;;;139                                         (int32_t) numPoints) : 0;
;;;140        blockSize2 = (int32_t) check - ((blockSize3 + blockSize1) +
;;;141                                        (int32_t) firstIndex);
;;;142        blockSize2 = (blockSize2 > 0) ? blockSize2 : 0;
;;;143    
;;;144        /* conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1] */
;;;145        /* The function is internally   
;;;146         * divided into three stages according to the number of multiplications that has to be   
;;;147         * taken place between inputA samples and inputB samples. In the first stage of the   
;;;148         * algorithm, the multiplications increase by one for every iteration.   
;;;149         * In the second stage of the algorithm, srcBLen number of multiplications are done.   
;;;150         * In the third stage of the algorithm, the multiplications decrease by one   
;;;151         * for every iteration. */
;;;152    
;;;153        /* Set the output pointer to point to the firstIndex   
;;;154         * of the output sample to be calculated. */
;;;155        pOut = pDst + firstIndex;
;;;156    
;;;157        /* --------------------------   
;;;158         * Initializations of stage1   
;;;159         * -------------------------*/
;;;160    
;;;161        /* sum = x[0] * y[0]   
;;;162         * sum = x[0] * y[1] + x[1] * y[0]   
;;;163         * ....   
;;;164         * sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]   
;;;165         */
;;;166    
;;;167        /* In this stage the MAC operations are increased by 1 for every iteration.   
;;;168           The count variable holds the number of MAC operations performed.   
;;;169           Since the partial convolution starts from from firstIndex   
;;;170           Number of Macs to be performed is firstIndex + 1 */
;;;171        count = 1u + firstIndex;
;;;172    
;;;173        /* Working pointer of inputA */
;;;174        px = pIn1;
;;;175    
;;;176        /* Working pointer of inputB */
;;;177        pSrc2 = pIn2 + firstIndex;
;;;178        py = pSrc2;
;;;179    
;;;180        /* ------------------------   
;;;181         * Stage1 process   
;;;182         * ----------------------*/
;;;183    
;;;184        /* The first stage starts here */
;;;185        while(blockSize1 > 0)
;;;186        {
;;;187          /* Accumulator is made zero for every iteration */
;;;188          sum = 0;
;;;189    
;;;190          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;191          k = count >> 2u;
;;;192    
;;;193          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;194           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;195          while(k > 0u)
;;;196          {
;;;197            /* x[0] , x[1] */
;;;198            in1 = (q15_t) * px++;
;;;199            in2 = (q15_t) * px++;
;;;200            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;201    
;;;202            /* y[srcBLen - 1] , y[srcBLen - 2] */
;;;203            in1 = (q15_t) * py--;
;;;204            in2 = (q15_t) * py--;
;;;205            input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;206    
;;;207            /* x[0] * y[srcBLen - 1] */
;;;208            /* x[1] * y[srcBLen - 2] */
;;;209            sum = __SMLAD(input1, input2, sum);
;;;210    
;;;211            /* x[2] , x[3] */
;;;212            in1 = (q15_t) * px++;
;;;213            in2 = (q15_t) * px++;
;;;214            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;215    
;;;216            /* y[srcBLen - 3] , y[srcBLen - 4] */
;;;217            in1 = (q15_t) * py--;
;;;218            in2 = (q15_t) * py--;
;;;219            input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;220    
;;;221            /* x[2] * y[srcBLen - 3] */
;;;222            /* x[3] * y[srcBLen - 4] */
;;;223            sum = __SMLAD(input1, input2, sum);
;;;224    
;;;225            /* Decrement the loop counter */
;;;226            k--;
;;;227          }
;;;228    
;;;229          /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;230           ** No loop unrolling is used. */
;;;231          k = count % 0x4u;
;;;232    
;;;233          while(k > 0u)
;;;234          {
;;;235            /* Perform the multiply-accumulates */
;;;236            sum += ((q31_t) * px++ * *py--);
;;;237    
;;;238            /* Decrement the loop counter */
;;;239            k--;
;;;240          }
;;;241    
;;;242          /* Store the result in the accumulator in the destination buffer. */
;;;243          *pOut++ = (q7_t) (__SSAT(sum >> 7, 8));
;;;244    
;;;245          /* Update the inputA and inputB pointers for next MAC calculation */
;;;246          py = ++pSrc2;
;;;247          px = pIn1;
;;;248    
;;;249          /* Increment the MAC count */
;;;250          count++;
;;;251    
;;;252          /* Decrement the loop counter */
;;;253          blockSize1--;
;;;254        }
;;;255    
;;;256        /* --------------------------   
;;;257         * Initializations of stage2   
;;;258         * ------------------------*/
;;;259    
;;;260        /* sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0]   
;;;261         * sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0]   
;;;262         * ....   
;;;263         * sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]   
;;;264         */
;;;265    
;;;266        /* Working pointer of inputA */
;;;267        if((int32_t)firstIndex - (int32_t)srcBLen + 1 > 0)
;;;268        {
;;;269          px = pIn1 + firstIndex - srcBLen + 1;
;;;270        }
;;;271        else
;;;272        {
;;;273          px = pIn1;
;;;274        }
;;;275    
;;;276        /* Working pointer of inputB */
;;;277        pSrc2 = pIn2 + (srcBLen - 1u);
;;;278        py = pSrc2;
;;;279    
;;;280        /* count is index by which the pointer pIn1 to be incremented */
;;;281        count = 0u;
;;;282    
;;;283        /* -------------------   
;;;284         * Stage2 process   
;;;285         * ------------------*/
;;;286    
;;;287        /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.   
;;;288         * So, to loop unroll over blockSize2,   
;;;289         * srcBLen should be greater than or equal to 4 */
;;;290        if(srcBLen >= 4u)
;;;291        {
;;;292          /* Loop unroll over blockSize2, by 4 */
;;;293          blkCnt = ((uint32_t) blockSize2 >> 2u);
;;;294    
;;;295          while(blkCnt > 0u)
;;;296          {
;;;297            /* Set all accumulators to zero */
;;;298            acc0 = 0;
;;;299            acc1 = 0;
;;;300            acc2 = 0;
;;;301            acc3 = 0;
;;;302    
;;;303            /* read x[0], x[1], x[2] samples */
;;;304            x0 = *(px++);
;;;305            x1 = *(px++);
;;;306            x2 = *(px++);
;;;307    
;;;308            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;309            k = srcBLen >> 2u;
;;;310    
;;;311            /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;312             ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;313            do
;;;314            {
;;;315              /* Read y[srcBLen - 1] sample */
;;;316              c0 = *(py--);
;;;317              /* Read y[srcBLen - 2] sample */
;;;318              c1 = *(py--);
;;;319    
;;;320              /* Read x[3] sample */
;;;321              x3 = *(px++);
;;;322    
;;;323              /* x[0] and x[1] are packed */
;;;324              in1 = (q15_t) x0;
;;;325              in2 = (q15_t) x1;
;;;326    
;;;327              input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;328    
;;;329              /* y[srcBLen - 1]   and y[srcBLen - 2] are packed */
;;;330              in1 = (q15_t) c0;
;;;331              in2 = (q15_t) c1;
;;;332    
;;;333              input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;334    
;;;335              /* acc0 += x[0] * y[srcBLen - 1] + x[1] * y[srcBLen - 2]  */
;;;336              acc0 = __SMLAD(input1, input2, acc0);
;;;337    
;;;338              /* x[1] and x[2] are packed */
;;;339              in1 = (q15_t) x1;
;;;340              in2 = (q15_t) x2;
;;;341    
;;;342              input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;343    
;;;344              /* acc1 += x[1] * y[srcBLen - 1] + x[2] * y[srcBLen - 2]  */
;;;345              acc1 = __SMLAD(input1, input2, acc1);
;;;346    
;;;347              /* x[2] and x[3] are packed */
;;;348              in1 = (q15_t) x2;
;;;349              in2 = (q15_t) x3;
;;;350    
;;;351              input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;352    
;;;353              /* acc2 += x[2] * y[srcBLen - 1] + x[3] * y[srcBLen - 2]  */
;;;354              acc2 = __SMLAD(input1, input2, acc2);
;;;355    
;;;356              /* Read x[4] sample */
;;;357              x0 = *(px++);
;;;358    
;;;359              /* x[3] and x[4] are packed */
;;;360              in1 = (q15_t) x3;
;;;361              in2 = (q15_t) x0;
;;;362    
;;;363              input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;364    
;;;365              /* acc3 += x[3] * y[srcBLen - 1] + x[4] * y[srcBLen - 2]  */
;;;366              acc3 = __SMLAD(input1, input2, acc3);
;;;367    
;;;368              /* Read y[srcBLen - 3] sample */
;;;369              c0 = *(py--);
;;;370              /* Read y[srcBLen - 4] sample */
;;;371              c1 = *(py--);
;;;372    
;;;373              /* Read x[5] sample */
;;;374              x1 = *(px++);
;;;375    
;;;376              /* x[2] and x[3] are packed */
;;;377              in1 = (q15_t) x2;
;;;378              in2 = (q15_t) x3;
;;;379    
;;;380              input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;381    
;;;382              /* y[srcBLen - 3] and y[srcBLen - 4] are packed */
;;;383              in1 = (q15_t) c0;
;;;384              in2 = (q15_t) c1;
;;;385    
;;;386              input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;387    
;;;388              /* acc0 += x[2] * y[srcBLen - 3] + x[3] * y[srcBLen - 4]  */
;;;389              acc0 = __SMLAD(input1, input2, acc0);
;;;390    
;;;391              /* x[3] and x[4] are packed */
;;;392              in1 = (q15_t) x3;
;;;393              in2 = (q15_t) x0;
;;;394    
;;;395              input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;396    
;;;397              /* acc1 += x[3] * y[srcBLen - 3] + x[4] * y[srcBLen - 4]  */
;;;398              acc1 = __SMLAD(input1, input2, acc1);
;;;399    
;;;400              /* x[4] and x[5] are packed */
;;;401              in1 = (q15_t) x0;
;;;402              in2 = (q15_t) x1;
;;;403    
;;;404              input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;405    
;;;406              /* acc2 += x[4] * y[srcBLen - 3] + x[5] * y[srcBLen - 4]  */
;;;407              acc2 = __SMLAD(input1, input2, acc2);
;;;408    
;;;409              /* Read x[6] sample */
;;;410              x2 = *(px++);
;;;411    
;;;412              /* x[5] and x[6] are packed */
;;;413              in1 = (q15_t) x1;
;;;414              in2 = (q15_t) x2;
;;;415    
;;;416              input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;417    
;;;418              /* acc3 += x[5] * y[srcBLen - 3] + x[6] * y[srcBLen - 4]  */
;;;419              acc3 = __SMLAD(input1, input2, acc3);
;;;420    
;;;421            } while(--k);
;;;422    
;;;423            /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;424             ** No loop unrolling is used. */
;;;425            k = srcBLen % 0x4u;
;;;426    
;;;427            while(k > 0u)
;;;428            {
;;;429              /* Read y[srcBLen - 5] sample */
;;;430              c0 = *(py--);
;;;431    
;;;432              /* Read x[7] sample */
;;;433              x3 = *(px++);
;;;434    
;;;435              /* Perform the multiply-accumulates */
;;;436              /* acc0 +=  x[4] * y[srcBLen - 5] */
;;;437              acc0 += ((q31_t) x0 * c0);
;;;438              /* acc1 +=  x[5] * y[srcBLen - 5] */
;;;439              acc1 += ((q31_t) x1 * c0);
;;;440              /* acc2 +=  x[6] * y[srcBLen - 5] */
;;;441              acc2 += ((q31_t) x2 * c0);
;;;442              /* acc3 +=  x[7] * y[srcBLen - 5] */
;;;443              acc3 += ((q31_t) x3 * c0);
;;;444    
;;;445              /* Reuse the present samples for the next MAC */
;;;446              x0 = x1;
;;;447              x1 = x2;
;;;448              x2 = x3;
;;;449    
;;;450              /* Decrement the loop counter */
;;;451              k--;
;;;452            }
;;;453    
;;;454            /* Store the result in the accumulator in the destination buffer. */
;;;455            *pOut++ = (q7_t) (__SSAT(acc0 >> 7, 8));
;;;456            *pOut++ = (q7_t) (__SSAT(acc1 >> 7, 8));
;;;457            *pOut++ = (q7_t) (__SSAT(acc2 >> 7, 8));
;;;458            *pOut++ = (q7_t) (__SSAT(acc3 >> 7, 8));
;;;459    
;;;460            /* Increment the pointer pIn1 index, count by 4 */
;;;461            count += 4u;
;;;462    
;;;463            /* Update the inputA and inputB pointers for next MAC calculation */
;;;464            px = pIn1 + count;
;;;465            py = pSrc2;
;;;466    
;;;467    
;;;468            /* Decrement the loop counter */
;;;469            blkCnt--;
;;;470          }
;;;471    
;;;472          /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.   
;;;473           ** No loop unrolling is used. */
;;;474          blkCnt = (uint32_t) blockSize2 % 0x4u;
;;;475    
;;;476          while(blkCnt > 0u)
;;;477          {
;;;478            /* Accumulator is made zero for every iteration */
;;;479            sum = 0;
;;;480    
;;;481            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;482            k = srcBLen >> 2u;
;;;483    
;;;484            /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;485             ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;486            while(k > 0u)
;;;487            {
;;;488    
;;;489              /* Reading two inputs of SrcA buffer and packing */
;;;490              in1 = (q15_t) * px++;
;;;491              in2 = (q15_t) * px++;
;;;492              input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;493    
;;;494              /* Reading two inputs of SrcB buffer and packing */
;;;495              in1 = (q15_t) * py--;
;;;496              in2 = (q15_t) * py--;
;;;497              input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;498    
;;;499              /* Perform the multiply-accumulates */
;;;500              sum = __SMLAD(input1, input2, sum);
;;;501    
;;;502              /* Reading two inputs of SrcA buffer and packing */
;;;503              in1 = (q15_t) * px++;
;;;504              in2 = (q15_t) * px++;
;;;505              input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;506    
;;;507              /* Reading two inputs of SrcB buffer and packing */
;;;508              in1 = (q15_t) * py--;
;;;509              in2 = (q15_t) * py--;
;;;510              input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;511    
;;;512              /* Perform the multiply-accumulates */
;;;513              sum = __SMLAD(input1, input2, sum);
;;;514    
;;;515              /* Decrement the loop counter */
;;;516              k--;
;;;517            }
;;;518    
;;;519            /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;520             ** No loop unrolling is used. */
;;;521            k = srcBLen % 0x4u;
;;;522    
;;;523            while(k > 0u)
;;;524            {
;;;525              /* Perform the multiply-accumulates */
;;;526              sum += ((q31_t) * px++ * *py--);
;;;527    
;;;528              /* Decrement the loop counter */
;;;529              k--;
;;;530            }
;;;531    
;;;532            /* Store the result in the accumulator in the destination buffer. */
;;;533            *pOut++ = (q7_t) (__SSAT(sum >> 7, 8));
;;;534    
;;;535            /* Increment the pointer pIn1 index, count by 1 */
;;;536     	    count++;
;;;537    
;;;538            /* Update the inputA and inputB pointers for next MAC calculation */
;;;539          	px = pIn1 + count;
;;;540            py = pSrc2;	
;;;541    
;;;542            /* Decrement the loop counter */
;;;543            blkCnt--;
;;;544          }
;;;545        }
;;;546        else
;;;547        {
;;;548          /* If the srcBLen is not a multiple of 4,   
;;;549           * the blockSize2 loop cannot be unrolled by 4 */
;;;550          blkCnt = (uint32_t) blockSize2;
;;;551    
;;;552          while(blkCnt > 0u)
;;;553          {
;;;554            /* Accumulator is made zero for every iteration */
;;;555            sum = 0;
;;;556    
;;;557            /* srcBLen number of MACS should be performed */
;;;558            k = srcBLen;
;;;559    
;;;560            while(k > 0u)
;;;561            {
;;;562              /* Perform the multiply-accumulate */
;;;563              sum += ((q31_t) * px++ * *py--);
;;;564    
;;;565              /* Decrement the loop counter */
;;;566              k--;
;;;567            }
;;;568    
;;;569            /* Store the result in the accumulator in the destination buffer. */
;;;570            *pOut++ = (q7_t) (__SSAT(sum >> 7, 8));
;;;571    
;;;572            /* Increment the MAC count */
;;;573            count++;
;;;574    
;;;575            /* Update the inputA and inputB pointers for next MAC calculation */
;;;576            px = pIn1 + count;
;;;577            py = pSrc2;
;;;578    
;;;579            /* Decrement the loop counter */
;;;580            blkCnt--;
;;;581          }
;;;582        }
;;;583    
;;;584    
;;;585        /* --------------------------   
;;;586         * Initializations of stage3   
;;;587         * -------------------------*/
;;;588    
;;;589        /* sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1]   
;;;590         * sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2]   
;;;591         * ....   
;;;592         * sum +=  x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2]   
;;;593         * sum +=  x[srcALen-1] * y[srcBLen-1]   
;;;594         */
;;;595    
;;;596        /* In this stage the MAC operations are decreased by 1 for every iteration.   
;;;597           The count variable holds the number of MAC operations performed */
;;;598        count = srcBLen - 1u;
;;;599    
;;;600        /* Working pointer of inputA */
;;;601        pSrc1 = (pIn1 + srcALen) - (srcBLen - 1u);
;;;602        px = pSrc1;
;;;603    
;;;604        /* Working pointer of inputB */
;;;605        pSrc2 = pIn2 + (srcBLen - 1u);
;;;606        py = pSrc2;
;;;607    
;;;608        /* -------------------   
;;;609         * Stage3 process   
;;;610         * ------------------*/
;;;611    
;;;612        while(blockSize3 > 0)
;;;613        {
;;;614          /* Accumulator is made zero for every iteration */
;;;615          sum = 0;
;;;616    
;;;617          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;618          k = count >> 2u;
;;;619    
;;;620          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;621           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;622          while(k > 0u)
;;;623          {
;;;624            /* Reading two inputs, x[srcALen - srcBLen + 1] and x[srcALen - srcBLen + 2] of SrcA buffer and packing */
;;;625            in1 = (q15_t) * px++;
;;;626            in2 = (q15_t) * px++;
;;;627            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;628    
;;;629            /* Reading two inputs, y[srcBLen - 1] and y[srcBLen - 2] of SrcB buffer and packing */
;;;630            in1 = (q15_t) * py--;
;;;631            in2 = (q15_t) * py--;
;;;632            input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;633    
;;;634            /* sum += x[srcALen - srcBLen + 1] * y[srcBLen - 1] */
;;;635            /* sum += x[srcALen - srcBLen + 2] * y[srcBLen - 2] */
;;;636            sum = __SMLAD(input1, input2, sum);
;;;637    
;;;638            /* Reading two inputs, x[srcALen - srcBLen + 3] and x[srcALen - srcBLen + 4] of SrcA buffer and packing */
;;;639            in1 = (q15_t) * px++;
;;;640            in2 = (q15_t) * px++;
;;;641            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;642    
;;;643            /* Reading two inputs, y[srcBLen - 3] and y[srcBLen - 4] of SrcB buffer and packing */
;;;644            in1 = (q15_t) * py--;
;;;645            in2 = (q15_t) * py--;
;;;646            input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;647    
;;;648            /* sum += x[srcALen - srcBLen + 3] * y[srcBLen - 3] */
;;;649            /* sum += x[srcALen - srcBLen + 4] * y[srcBLen - 4] */
;;;650            sum = __SMLAD(input1, input2, sum);
;;;651    
;;;652            /* Decrement the loop counter */
;;;653            k--;
;;;654          }
;;;655    
;;;656          /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;657           ** No loop unrolling is used. */
;;;658          k = count % 0x4u;
;;;659    
;;;660          while(k > 0u)
;;;661          {
;;;662            /* Perform the multiply-accumulates */
;;;663            /* sum +=  x[srcALen-1] * y[srcBLen-1] */
;;;664            sum += ((q31_t) * px++ * *py--);
;;;665    
;;;666            /* Decrement the loop counter */
;;;667            k--;
;;;668          }
;;;669    
;;;670          /* Store the result in the accumulator in the destination buffer. */
;;;671          *pOut++ = (q7_t) (__SSAT(sum >> 7, 8));
;;;672    
;;;673          /* Update the inputA and inputB pointers for next MAC calculation */
;;;674          px = ++pSrc1;
;;;675          py = pSrc2;
;;;676    
;;;677          /* Decrement the MAC count */
;;;678          count--;
;;;679    
;;;680          /* Decrement the loop counter */
;;;681          blockSize3--;
;;;682    
;;;683        }
;;;684    
;;;685        /* set status as ARM_MATH_SUCCESS */
;;;686        status = ARM_MATH_SUCCESS;
;;;687      }
;;;688    
;;;689      /* Return to application */
;;;690      return (status);
;;;691    
;;;692    #else
;;;693    
;;;694      /* Run the below code for Cortex-M0 */
;;;695    
;;;696      q7_t *pIn1 = pSrcA;                            /* inputA pointer */
;;;697      q7_t *pIn2 = pSrcB;                            /* inputB pointer */
;;;698      q31_t sum;                                     /* Accumulator */
;;;699      uint32_t i, j;                                 /* loop counters */
;;;700      arm_status status;                             /* status of Partial convolution */
;;;701    
;;;702      /* Check for range of output samples to be calculated */
;;;703      if((firstIndex + numPoints) > ((srcALen + (srcBLen - 1u))))
;;;704      {
;;;705        /* Set status as ARM_ARGUMENT_ERROR */
;;;706        status = ARM_MATH_ARGUMENT_ERROR;
;;;707      }
;;;708      else
;;;709      {
;;;710        /* Loop to calculate convolution for output length number of values */
;;;711        for (i = firstIndex; i <= (firstIndex + numPoints - 1); i++)
;;;712        {
;;;713          /* Initialize sum with zero to carry on MAC operations */
;;;714          sum = 0;
;;;715    
;;;716          /* Loop to perform MAC operations according to convolution equation */
;;;717          for (j = 0; j <= i; j++)
;;;718          {
;;;719            /* Check the array limitations */
;;;720            if(((i - j) < srcBLen) && (j < srcALen))
;;;721            {
;;;722              /* z[i] += x[i-j] * y[j] */
;;;723              sum += ((q15_t) pIn1[j] * (pIn2[i - j]));
;;;724            }
;;;725          }
;;;726    
;;;727          /* Store the output in the destination buffer */
;;;728          pDst[i] = (q7_t) __SSAT((sum >> 7u), 8u);
;;;729        }
;;;730        /* set status as ARM_SUCCESS as there are no argument errors */
;;;731        status = ARM_MATH_SUCCESS;
;;;732      }
;;;733      return (status);
;;;734    
;;;735    #endif /*  #ifndef ARM_MATH_CM0_FAMILY */
;;;736    
;;;737    }
00001c  b00f              ADD      sp,sp,#0x3c
00001e  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.34|
000022  9e0c              LDR      r6,[sp,#0x30]         ;110
000024  429e              CMP      r6,r3                 ;110
000026  d302              BCC      |L1.46|
000028  9009              STR      r0,[sp,#0x24]         ;113
00002a  4610              MOV      r0,r2                 ;116
00002c  e003              B        |L1.54|
                  |L1.46|
00002e  9209              STR      r2,[sp,#0x24]         ;121
000030  461a              MOV      r2,r3                 ;127
000032  9b0c              LDR      r3,[sp,#0x30]         ;128
000034  920c              STR      r2,[sp,#0x30]         ;129
                  |L1.54|
000036  9a0c              LDR      r2,[sp,#0x30]         ;135
000038  4291              CMP      r1,r2                 ;135
00003a  dd02              BLE      |L1.66|
00003c  9a0c              LDR      r2,[sp,#0x30]         ;135
00003e  1a8a              SUBS     r2,r1,r2              ;135
000040  e000              B        |L1.68|
                  |L1.66|
000042  2200              MOVS     r2,#0                 ;135
                  |L1.68|
000044  9e0c              LDR      r6,[sp,#0x30]         ;136
000046  1e76              SUBS     r6,r6,#1              ;136
000048  42b7              CMP      r7,r6                 ;136
00004a  dd02              BLE      |L1.82|
00004c  1bd6              SUBS     r6,r2,r7              ;136
00004e  9a0c              LDR      r2,[sp,#0x30]         ;136
000050  4432              ADD      r2,r2,r6              ;136
                  |L1.82|
000052  9200              STR      r2,[sp,#0]            ;136
000054  eba30807          SUB      r8,r3,r7              ;137
000058  f1a80801          SUB      r8,r8,#1              ;137
00005c  f1b80f00          CMP      r8,#0                 ;138
000060  dd04              BLE      |L1.108|
000062  1e5a              SUBS     r2,r3,#1              ;138
000064  4291              CMP      r1,r2                 ;138
000066  d803              BHI      |L1.112|
000068  46a8              MOV      r8,r5                 ;139
00006a  e001              B        |L1.112|
                  |L1.108|
00006c  f04f0800          MOV      r8,#0                 ;139
                  |L1.112|
000070  9a00              LDR      r2,[sp,#0]            ;140
000072  4442              ADD      r2,r2,r8              ;140
000074  443a              ADD      r2,r2,r7              ;140
000076  1a89              SUBS     r1,r1,r2              ;140
000078  2900              CMP      r1,#0                 ;142
00007a  dc00              BGT      |L1.126|
00007c  2100              MOVS     r1,#0                 ;142
                  |L1.126|
00007e  9101              STR      r1,[sp,#4]            ;142
000080  19e1              ADDS     r1,r4,r7              ;155
000082  f1070c01          ADD      r12,r7,#1             ;171
000086  f8dde024          LDR      lr,[sp,#0x24]         ;174
00008a  eb000907          ADD      r9,r0,r7              ;177
00008e  464c              MOV      r4,r9                 ;178
000090  e03b              B        |L1.266|
                  |L1.146|
000092  2500              MOVS     r5,#0                 ;188
000094  ea4f069c          LSR      r6,r12,#2             ;191
000098  e01c              B        |L1.212|
                  |L1.154|
00009a  f91eab01          LDRSB    r10,[lr],#1           ;198
00009e  f91e2b01          LDRSB    r2,[lr],#1            ;199
0000a2  f3624a1f          BFI      r10,r2,#16,#16        ;200
0000a6  f9142901          LDRSB    r2,[r4],#-1           ;203
0000aa  f914b901          LDRSB    r11,[r4],#-1          ;204
0000ae  f36b421f          BFI      r2,r11,#16,#16        ;205
0000b2  fb2a5502          SMLAD    r5,r10,r2,r5          ;209
0000b6  f91e2b01          LDRSB    r2,[lr],#1            ;212
0000ba  f91eab01          LDRSB    r10,[lr],#1           ;213
0000be  f36a421f          BFI      r2,r10,#16,#16        ;214
0000c2  f914a901          LDRSB    r10,[r4],#-1          ;217
0000c6  f914b901          LDRSB    r11,[r4],#-1          ;218
0000ca  f36b4a1f          BFI      r10,r11,#16,#16       ;219
0000ce  fb22550a          SMLAD    r5,r2,r10,r5          ;223
0000d2  1e76              SUBS     r6,r6,#1              ;226
                  |L1.212|
0000d4  2e00              CMP      r6,#0                 ;195
0000d6  d1e0              BNE      |L1.154|
0000d8  f00c0203          AND      r2,r12,#3             ;231
0000dc  e006              B        |L1.236|
                  |L1.222|
0000de  f91e6b01          LDRSB    r6,[lr],#1            ;236
0000e2  f914a901          LDRSB    r10,[r4],#-1          ;236
0000e6  fb16550a          SMLABB   r5,r6,r10,r5          ;236
0000ea  1e52              SUBS     r2,r2,#1              ;239
                  |L1.236|
0000ec  2a00              CMP      r2,#0                 ;233
0000ee  d1f6              BNE      |L1.222|
0000f0  f32512c7          SSAT     r2,#8,r5,ASR #7       ;243
0000f4  f8012b01          STRB     r2,[r1],#1            ;243
0000f8  f1090401          ADD      r4,r9,#1              ;246
0000fc  46a1              MOV      r9,r4                 ;246
0000fe  f8dde024          LDR      lr,[sp,#0x24]         ;247
000102  f10c0c01          ADD      r12,r12,#1            ;250
000106  f1a80801          SUB      r8,r8,#1              ;253
                  |L1.266|
00010a  f1b80f00          CMP      r8,#0                 ;185
00010e  dcc0              BGT      |L1.146|
000110  1afa              SUBS     r2,r7,r3              ;267
000112  1c52              ADDS     r2,r2,#1              ;267
000114  2a00              CMP      r2,#0                 ;267
000116  dd05              BLE      |L1.292|
000118  9a09              LDR      r2,[sp,#0x24]         ;269
00011a  443a              ADD      r2,r2,r7              ;269
00011c  eba20e03          SUB      lr,r2,r3              ;269
000120  f10e0e01          ADD      lr,lr,#1              ;269
                  |L1.292|
000124  4418              ADD      r0,r0,r3              ;277
000126  900a              STR      r0,[sp,#0x28]         ;277
000128  1e40              SUBS     r0,r0,#1              ;277
00012a  9007              STR      r0,[sp,#0x1c]         ;277
00012c  9807              LDR      r0,[sp,#0x1c]         ;278
00012e  2600              MOVS     r6,#0                 ;281
000130  2b04              CMP      r3,#4                 ;290
000132  d37d              BCC      |L1.560|
000134  9a01              LDR      r2,[sp,#4]            ;293
000136  0892              LSRS     r2,r2,#2              ;293
000138  9202              STR      r2,[sp,#8]            ;293
00013a  e096              B        |L1.618|
                  |L1.316|
00013c  2700              MOVS     r7,#0                 ;298
00013e  46bc              MOV      r12,r7                ;299
000140  46b8              MOV      r8,r7                 ;300
000142  46b9              MOV      r9,r7                 ;301
000144  f91e5b01          LDRSB    r5,[lr],#1            ;304
000148  f91e4b01          LDRSB    r4,[lr],#1            ;305
00014c  f91e2b01          LDRSB    r2,[lr],#1            ;306
000150  ea4f0a93          LSR      r10,r3,#2             ;309
000154  f8cda00c          STR      r10,[sp,#0xc]         ;309
                  |L1.344|
000158  f990b000          LDRSB    r11,[r0,#0]           ;316
00015c  f8cdb010          STR      r11,[sp,#0x10]        ;316
000160  f1a00b01          SUB      r11,r0,#1             ;316
000164  f91b0901          LDRSB    r0,[r11],#-1          ;318
000168  f8cdb020          STR      r11,[sp,#0x20]        ;318
00016c  f91eab01          LDRSB    r10,[lr],#1           ;321
000170  f364451f          BFI      r5,r4,#16,#16         ;327
000174  f8ddb010          LDR      r11,[sp,#0x10]        ;330
000178  f3604b1f          BFI      r11,r0,#16,#16        ;333
00017c  fb25770b          SMLAD    r7,r5,r11,r7          ;336
000180  f362441f          BFI      r4,r2,#16,#16         ;342
000184  fb24cc0b          SMLAD    r12,r4,r11,r12        ;345
000188  4610              MOV      r0,r2                 ;351
00018a  f36a401f          BFI      r0,r10,#16,#16        ;351
00018e  fb20880b          SMLAD    r8,r0,r11,r8          ;354
000192  f8cd8018          STR      r8,[sp,#0x18]         ;354
000196  f91e5b01          LDRSB    r5,[lr],#1            ;357
00019a  4650              MOV      r0,r10                ;363
00019c  f365401f          BFI      r0,r5,#16,#16         ;363
0001a0  fb209b0b          SMLAD    r11,r0,r11,r9         ;366
0001a4  f8cdb014          STR      r11,[sp,#0x14]        ;366
0001a8  f8ddb020          LDR      r11,[sp,#0x20]        ;369
0001ac  f1ab0001          SUB      r0,r11,#1             ;369
0001b0  f99b9000          LDRSB    r9,[r11,#0]           ;369
0001b4  f9108901          LDRSB    r8,[r0],#-1           ;371
0001b8  f91e4b01          LDRSB    r4,[lr],#1            ;374
0001bc  f36a421f          BFI      r2,r10,#16,#16        ;380
0001c0  f368491f          BFI      r9,r8,#16,#16         ;386
0001c4  fb227709          SMLAD    r7,r2,r9,r7           ;389
0001c8  f3654a1f          BFI      r10,r5,#16,#16        ;395
0001cc  fb2acc09          SMLAD    r12,r10,r9,r12        ;398
0001d0  462a              MOV      r2,r5                 ;404
0001d2  f364421f          BFI      r2,r4,#16,#16         ;404
0001d6  f8dd8018          LDR      r8,[sp,#0x18]         ;407
0001da  fb228809          SMLAD    r8,r2,r9,r8           ;407
0001de  f91e2b01          LDRSB    r2,[lr],#1            ;410
0001e2  46a2              MOV      r10,r4                ;413
0001e4  f3624a1f          BFI      r10,r2,#16,#16        ;416
0001e8  f8ddb014          LDR      r11,[sp,#0x14]        ;419
0001ec  fb2ab909          SMLAD    r9,r10,r9,r11         ;419
0001f0  f8dda00c          LDR      r10,[sp,#0xc]         ;421
0001f4  f1ba0a01          SUBS     r10,r10,#1            ;421
0001f8  f8cda00c          STR      r10,[sp,#0xc]         ;421
0001fc  d1ac              BNE      |L1.344|
0001fe  f0030a03          AND      r10,r3,#3             ;425
000202  f8cda00c          STR      r10,[sp,#0xc]         ;425
000206  e016              B        |L1.566|
                  |L1.520|
000208  f910a901          LDRSB    r10,[r0],#-1          ;430
00020c  f91ebb01          LDRSB    r11,[lr],#1           ;433
000210  fb05770a          MLA      r7,r5,r10,r7          ;437
000214  fb04cc0a          MLA      r12,r4,r10,r12        ;439
000218  fb02880a          MLA      r8,r2,r10,r8          ;441
00021c  fb1b990a          SMLABB   r9,r11,r10,r9         ;443
000220  4625              MOV      r5,r4                 ;446
000222  4614              MOV      r4,r2                 ;447
000224  465a              MOV      r2,r11                ;448
000226  f8dda00c          LDR      r10,[sp,#0xc]         ;451
00022a  f1aa0a01          SUB      r10,r10,#1            ;451
00022e  e000              B        |L1.562|
                  |L1.560|
000230  e05e              B        |L1.752|
                  |L1.562|
000232  f8cda00c          STR      r10,[sp,#0xc]         ;451
                  |L1.566|
000236  f8dda00c          LDR      r10,[sp,#0xc]         ;427
00023a  f1ba0f00          CMP      r10,#0                ;427
00023e  d1e3              BNE      |L1.520|
000240  f32710c7          SSAT     r0,#8,r7,ASR #7       ;455
000244  7008              STRB     r0,[r1,#0]            ;455
000246  f32c10c7          SSAT     r0,#8,r12,ASR #7      ;456
00024a  7048              STRB     r0,[r1,#1]            ;456
00024c  f32810c7          SSAT     r0,#8,r8,ASR #7       ;457
000250  7088              STRB     r0,[r1,#2]            ;457
000252  f32910c7          SSAT     r0,#8,r9,ASR #7       ;458
000256  70c8              STRB     r0,[r1,#3]            ;458
000258  1d09              ADDS     r1,r1,#4              ;458
00025a  1d36              ADDS     r6,r6,#4              ;461
00025c  9809              LDR      r0,[sp,#0x24]         ;464
00025e  eb000e06          ADD      lr,r0,r6              ;464
000262  9807              LDR      r0,[sp,#0x1c]         ;465
000264  9a02              LDR      r2,[sp,#8]            ;469
000266  1e52              SUBS     r2,r2,#1              ;469
000268  9202              STR      r2,[sp,#8]            ;469
                  |L1.618|
00026a  9a02              LDR      r2,[sp,#8]            ;295
00026c  2a00              CMP      r2,#0                 ;295
00026e  f47faf65          BNE      |L1.316|
000272  9a01              LDR      r2,[sp,#4]            ;474
000274  f0020503          AND      r5,r2,#3              ;474
000278  e037              B        |L1.746|
                  |L1.634|
00027a  2200              MOVS     r2,#0                 ;479
00027c  089c              LSRS     r4,r3,#2              ;482
00027e  e01c              B        |L1.698|
                  |L1.640|
000280  f91e7b01          LDRSB    r7,[lr],#1            ;490
000284  f91ecb01          LDRSB    r12,[lr],#1           ;491
000288  f36c471f          BFI      r7,r12,#16,#16        ;492
00028c  f910c901          LDRSB    r12,[r0],#-1          ;495
000290  f9108901          LDRSB    r8,[r0],#-1           ;496
000294  f3684c1f          BFI      r12,r8,#16,#16        ;497
000298  fb27270c          SMLAD    r7,r7,r12,r2          ;500
00029c  f91e2b01          LDRSB    r2,[lr],#1            ;503
0002a0  f91ecb01          LDRSB    r12,[lr],#1           ;504
0002a4  f36c421f          BFI      r2,r12,#16,#16        ;505
0002a8  f910c901          LDRSB    r12,[r0],#-1          ;508
0002ac  f9108901          LDRSB    r8,[r0],#-1           ;509
0002b0  f3684c1f          BFI      r12,r8,#16,#16        ;510
0002b4  fb22720c          SMLAD    r2,r2,r12,r7          ;513
0002b8  1e64              SUBS     r4,r4,#1              ;516
                  |L1.698|
0002ba  2c00              CMP      r4,#0                 ;486
0002bc  d1e0              BNE      |L1.640|
0002be  f0030403          AND      r4,r3,#3              ;521
0002c2  e006              B        |L1.722|
                  |L1.708|
0002c4  f91e7b01          LDRSB    r7,[lr],#1            ;526
0002c8  f910c901          LDRSB    r12,[r0],#-1          ;526
0002cc  fb17220c          SMLABB   r2,r7,r12,r2          ;526
0002d0  1e64              SUBS     r4,r4,#1              ;529
                  |L1.722|
0002d2  2c00              CMP      r4,#0                 ;523
0002d4  d1f6              BNE      |L1.708|
0002d6  f32210c7          SSAT     r0,#8,r2,ASR #7       ;533
0002da  f8010b01          STRB     r0,[r1],#1            ;533
0002de  1c76              ADDS     r6,r6,#1              ;536
0002e0  9809              LDR      r0,[sp,#0x24]         ;539
0002e2  eb000e06          ADD      lr,r0,r6              ;539
0002e6  9807              LDR      r0,[sp,#0x1c]         ;540
0002e8  1e6d              SUBS     r5,r5,#1              ;543
                  |L1.746|
0002ea  2d00              CMP      r5,#0                 ;476
0002ec  d1c5              BNE      |L1.634|
0002ee  e019              B        |L1.804|
                  |L1.752|
0002f0  9d01              LDR      r5,[sp,#4]            ;550
0002f2  e015              B        |L1.800|
                  |L1.756|
0002f4  2400              MOVS     r4,#0                 ;555
0002f6  461a              MOV      r2,r3                 ;558
0002f8  e006              B        |L1.776|
                  |L1.762|
0002fa  f91e7b01          LDRSB    r7,[lr],#1            ;563
0002fe  f910c901          LDRSB    r12,[r0],#-1          ;563
000302  fb17440c          SMLABB   r4,r7,r12,r4          ;563
000306  1e52              SUBS     r2,r2,#1              ;566
                  |L1.776|
000308  2a00              CMP      r2,#0                 ;560
00030a  d1f6              BNE      |L1.762|
00030c  f32410c7          SSAT     r0,#8,r4,ASR #7       ;570
000310  f8010b01          STRB     r0,[r1],#1            ;570
000314  1c76              ADDS     r6,r6,#1              ;573
000316  9809              LDR      r0,[sp,#0x24]         ;576
000318  eb000e06          ADD      lr,r0,r6              ;576
00031c  9807              LDR      r0,[sp,#0x1c]         ;577
00031e  1e6d              SUBS     r5,r5,#1              ;580
                  |L1.800|
000320  2d00              CMP      r5,#0                 ;552
000322  d1e7              BNE      |L1.756|
                  |L1.804|
000324  1e5e              SUBS     r6,r3,#1              ;598
000326  9a0c              LDR      r2,[sp,#0x30]         ;601
000328  9809              LDR      r0,[sp,#0x24]         ;601
00032a  4410              ADD      r0,r0,r2              ;601
00032c  1ac3              SUBS     r3,r0,r3              ;601
00032e  1c5b              ADDS     r3,r3,#1              ;601
000330  4618              MOV      r0,r3                 ;602
000332  9f0a              LDR      r7,[sp,#0x28]         ;605
000334  1e7f              SUBS     r7,r7,#1              ;605
000336  463a              MOV      r2,r7                 ;606
000338  e039              B        |L1.942|
                  |L1.826|
00033a  2400              MOVS     r4,#0                 ;615
00033c  08b5              LSRS     r5,r6,#2              ;618
00033e  e01d              B        |L1.892|
                  |L1.832|
000340  f990c000          LDRSB    r12,[r0,#0]           ;625
000344  f9908001          LDRSB    r8,[r0,#1]            ;626
000348  f3684c1f          BFI      r12,r8,#16,#16        ;627
00034c  f9128901          LDRSB    r8,[r2],#-1           ;630
000350  f9129901          LDRSB    r9,[r2],#-1           ;631
000354  f369481f          BFI      r8,r9,#16,#16         ;632
000358  fb2c4c08          SMLAD    r12,r12,r8,r4         ;636
00035c  f9904002          LDRSB    r4,[r0,#2]            ;639
000360  1cc0              ADDS     r0,r0,#3              ;639
000362  f9108b01          LDRSB    r8,[r0],#1            ;640
000366  f368441f          BFI      r4,r8,#16,#16         ;641
00036a  f9128901          LDRSB    r8,[r2],#-1           ;644
00036e  f9129901          LDRSB    r9,[r2],#-1           ;645
000372  f369481f          BFI      r8,r9,#16,#16         ;646
000376  fb24c408          SMLAD    r4,r4,r8,r12          ;650
00037a  1e6d              SUBS     r5,r5,#1              ;653
                  |L1.892|
00037c  2d00              CMP      r5,#0                 ;622
00037e  d1df              BNE      |L1.832|
000380  f0060503          AND      r5,r6,#3              ;658
000384  e006              B        |L1.916|
                  |L1.902|
000386  f910cb01          LDRSB    r12,[r0],#1           ;664
00038a  f9128901          LDRSB    r8,[r2],#-1           ;664
00038e  fb1c4408          SMLABB   r4,r12,r8,r4          ;664
000392  1e6d              SUBS     r5,r5,#1              ;667
                  |L1.916|
000394  2d00              CMP      r5,#0                 ;660
000396  d1f6              BNE      |L1.902|
000398  f32410c7          SSAT     r0,#8,r4,ASR #7       ;671
00039c  f8010b01          STRB     r0,[r1],#1            ;671
0003a0  1c58              ADDS     r0,r3,#1              ;674
0003a2  4603              MOV      r3,r0                 ;674
0003a4  463a              MOV      r2,r7                 ;675
0003a6  1e76              SUBS     r6,r6,#1              ;678
0003a8  9c00              LDR      r4,[sp,#0]            ;681
0003aa  1e64              SUBS     r4,r4,#1              ;681
0003ac  9400              STR      r4,[sp,#0]            ;681
                  |L1.942|
0003ae  9c00              LDR      r4,[sp,#0]            ;612
0003b0  2c00              CMP      r4,#0                 ;612
0003b2  dcc2              BGT      |L1.826|
0003b4  2000              MOVS     r0,#0                 ;686
0003b6  e631              B        |L1.28|
;;;738    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_partial_q7.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_conv_partial_q7_c_883f0694____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___21_arm_conv_partial_q7_c_883f0694____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_conv_partial_q7_c_883f0694____REVSH|
#line 144
|__asm___21_arm_conv_partial_q7_c_883f0694____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_conv_partial_q7_c_883f0694____RRX|
#line 300
|__asm___21_arm_conv_partial_q7_c_883f0694____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
