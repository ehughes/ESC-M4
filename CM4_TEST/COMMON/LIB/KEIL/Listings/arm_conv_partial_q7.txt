; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_partial_q7.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_partial_q7.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE\_CMSIS_DSP_4_5_O3 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_conv_partial_q7.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_partial_q7.c]
                          THUMB

                          AREA ||i.arm_conv_partial_q7||, CODE, READONLY, ALIGN=2

                  arm_conv_partial_q7 PROC
;;;67     
;;;68     arm_status arm_conv_partial_q7(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;69       q7_t * pSrcA,
;;;70       uint32_t srcALen,
;;;71       q7_t * pSrcB,
;;;72       uint32_t srcBLen,
;;;73       q7_t * pDst,
;;;74       uint32_t firstIndex,
;;;75       uint32_t numPoints)
;;;76     {
000004  b098              SUB      sp,sp,#0x60
000006  468e              MOV      lr,r1
000008  e9dd1422          LDRD     r1,r4,[sp,#0x88]
;;;77     
;;;78     
;;;79     #ifndef ARM_MATH_CM0_FAMILY
;;;80     
;;;81       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;82     
;;;83       q7_t *pIn1;                                    /* inputA pointer */
;;;84       q7_t *pIn2;                                    /* inputB pointer */
;;;85       q7_t *pOut = pDst;                             /* output pointer */
;;;86       q7_t *px;                                      /* Intermediate inputA pointer */
;;;87       q7_t *py;                                      /* Intermediate inputB pointer */
;;;88       q7_t *pSrc1, *pSrc2;                           /* Intermediate pointers */
;;;89       q31_t sum, acc0, acc1, acc2, acc3;             /* Accumulator */
;;;90       q31_t input1, input2;
;;;91       q15_t in1, in2;
;;;92       q7_t x0, x1, x2, x3, c0, c1;
;;;93       uint32_t j, k, count, check, blkCnt;
;;;94       int32_t blockSize1, blockSize2, blockSize3;    /* loop counter */
;;;95       arm_status status;
;;;96     
;;;97     
;;;98       /* Check for range of output samples to be calculated */
;;;99       if((firstIndex + numPoints) > ((srcALen + (srcBLen - 1u))))
00000c  eb0e0703          ADD      r7,lr,r3
000010  190d              ADDS     r5,r1,r4
000012  1e7f              SUBS     r7,r7,#1
000014  9e21              LDR      r6,[sp,#0x84]
000016  42bd              CMP      r5,r7
000018  d904              BLS      |L1.36|
;;;100      {
;;;101        /* Set status as ARM_MATH_ARGUMENT_ERROR */
;;;102        status = ARM_MATH_ARGUMENT_ERROR;
00001a  f04f30ff          MOV      r0,#0xffffffff
                  |L1.30|
;;;103      }
;;;104      else
;;;105      {
;;;106    
;;;107        /* The algorithm implementation is based on the lengths of the inputs. */
;;;108        /* srcB is always made to slide across srcA. */
;;;109        /* So srcBLen is always considered as shorter or equal to srcALen */
;;;110        if(srcALen >= srcBLen)
;;;111        {
;;;112          /* Initialization of inputA pointer */
;;;113          pIn1 = pSrcA;
;;;114    
;;;115          /* Initialization of inputB pointer */
;;;116          pIn2 = pSrcB;
;;;117        }
;;;118        else
;;;119        {
;;;120          /* Initialization of inputA pointer */
;;;121          pIn1 = pSrcB;
;;;122    
;;;123          /* Initialization of inputB pointer */
;;;124          pIn2 = pSrcA;
;;;125    
;;;126          /* srcBLen is always considered as shorter or equal to srcALen */
;;;127          j = srcBLen;
;;;128          srcBLen = srcALen;
;;;129          srcALen = j;
;;;130        }
;;;131    
;;;132        /* Conditions to check which loopCounter holds   
;;;133         * the first and last indices of the output samples to be calculated. */
;;;134        check = firstIndex + numPoints;
;;;135        blockSize3 = ((int32_t)check > (int32_t)srcALen) ? (int32_t)check - (int32_t)srcALen : 0;
;;;136        blockSize3 = ((int32_t)firstIndex > (int32_t)srcALen - 1) ? blockSize3 - (int32_t)firstIndex + (int32_t)srcALen : blockSize3;
;;;137        blockSize1 = (((int32_t) srcBLen - 1) - (int32_t) firstIndex);
;;;138        blockSize1 = (blockSize1 > 0) ? ((check > (srcBLen - 1u)) ? blockSize1 :
;;;139                                         (int32_t) numPoints) : 0;
;;;140        blockSize2 = (int32_t) check - ((blockSize3 + blockSize1) +
;;;141                                        (int32_t) firstIndex);
;;;142        blockSize2 = (blockSize2 > 0) ? blockSize2 : 0;
;;;143    
;;;144        /* conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1] */
;;;145        /* The function is internally   
;;;146         * divided into three stages according to the number of multiplications that has to be   
;;;147         * taken place between inputA samples and inputB samples. In the first stage of the   
;;;148         * algorithm, the multiplications increase by one for every iteration.   
;;;149         * In the second stage of the algorithm, srcBLen number of multiplications are done.   
;;;150         * In the third stage of the algorithm, the multiplications decrease by one   
;;;151         * for every iteration. */
;;;152    
;;;153        /* Set the output pointer to point to the firstIndex   
;;;154         * of the output sample to be calculated. */
;;;155        pOut = pDst + firstIndex;
;;;156    
;;;157        /* --------------------------   
;;;158         * Initializations of stage1   
;;;159         * -------------------------*/
;;;160    
;;;161        /* sum = x[0] * y[0]   
;;;162         * sum = x[0] * y[1] + x[1] * y[0]   
;;;163         * ....   
;;;164         * sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]   
;;;165         */
;;;166    
;;;167        /* In this stage the MAC operations are increased by 1 for every iteration.   
;;;168           The count variable holds the number of MAC operations performed.   
;;;169           Since the partial convolution starts from from firstIndex   
;;;170           Number of Macs to be performed is firstIndex + 1 */
;;;171        count = 1u + firstIndex;
;;;172    
;;;173        /* Working pointer of inputA */
;;;174        px = pIn1;
;;;175    
;;;176        /* Working pointer of inputB */
;;;177        pSrc2 = pIn2 + firstIndex;
;;;178        py = pSrc2;
;;;179    
;;;180        /* ------------------------   
;;;181         * Stage1 process   
;;;182         * ----------------------*/
;;;183    
;;;184        /* The first stage starts here */
;;;185        while(blockSize1 > 0)
;;;186        {
;;;187          /* Accumulator is made zero for every iteration */
;;;188          sum = 0;
;;;189    
;;;190          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;191          k = count >> 2u;
;;;192    
;;;193          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;194           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;195          while(k > 0u)
;;;196          {
;;;197            /* x[0] , x[1] */
;;;198            in1 = (q15_t) * px++;
;;;199            in2 = (q15_t) * px++;
;;;200            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;201    
;;;202            /* y[srcBLen - 1] , y[srcBLen - 2] */
;;;203            in1 = (q15_t) * py--;
;;;204            in2 = (q15_t) * py--;
;;;205            input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;206    
;;;207            /* x[0] * y[srcBLen - 1] */
;;;208            /* x[1] * y[srcBLen - 2] */
;;;209            sum = __SMLAD(input1, input2, sum);
;;;210    
;;;211            /* x[2] , x[3] */
;;;212            in1 = (q15_t) * px++;
;;;213            in2 = (q15_t) * px++;
;;;214            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;215    
;;;216            /* y[srcBLen - 3] , y[srcBLen - 4] */
;;;217            in1 = (q15_t) * py--;
;;;218            in2 = (q15_t) * py--;
;;;219            input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;220    
;;;221            /* x[2] * y[srcBLen - 3] */
;;;222            /* x[3] * y[srcBLen - 4] */
;;;223            sum = __SMLAD(input1, input2, sum);
;;;224    
;;;225            /* Decrement the loop counter */
;;;226            k--;
;;;227          }
;;;228    
;;;229          /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;230           ** No loop unrolling is used. */
;;;231          k = count % 0x4u;
;;;232    
;;;233          while(k > 0u)
;;;234          {
;;;235            /* Perform the multiply-accumulates */
;;;236            sum += ((q31_t) * px++ * *py--);
;;;237    
;;;238            /* Decrement the loop counter */
;;;239            k--;
;;;240          }
;;;241    
;;;242          /* Store the result in the accumulator in the destination buffer. */
;;;243          *pOut++ = (q7_t) (__SSAT(sum >> 7, 8));
;;;244    
;;;245          /* Update the inputA and inputB pointers for next MAC calculation */
;;;246          py = ++pSrc2;
;;;247          px = pIn1;
;;;248    
;;;249          /* Increment the MAC count */
;;;250          count++;
;;;251    
;;;252          /* Decrement the loop counter */
;;;253          blockSize1--;
;;;254        }
;;;255    
;;;256        /* --------------------------   
;;;257         * Initializations of stage2   
;;;258         * ------------------------*/
;;;259    
;;;260        /* sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0]   
;;;261         * sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0]   
;;;262         * ....   
;;;263         * sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]   
;;;264         */
;;;265    
;;;266        /* Working pointer of inputA */
;;;267        if((int32_t)firstIndex - (int32_t)srcBLen + 1 > 0)
;;;268        {
;;;269          px = pIn1 + firstIndex - srcBLen + 1;
;;;270        }
;;;271        else
;;;272        {
;;;273          px = pIn1;
;;;274        }
;;;275    
;;;276        /* Working pointer of inputB */
;;;277        pSrc2 = pIn2 + (srcBLen - 1u);
;;;278        py = pSrc2;
;;;279    
;;;280        /* count is index by which the pointer pIn1 to be incremented */
;;;281        count = 0u;
;;;282    
;;;283        /* -------------------   
;;;284         * Stage2 process   
;;;285         * ------------------*/
;;;286    
;;;287        /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.   
;;;288         * So, to loop unroll over blockSize2,   
;;;289         * srcBLen should be greater than or equal to 4 */
;;;290        if(srcBLen >= 4u)
;;;291        {
;;;292          /* Loop unroll over blockSize2, by 4 */
;;;293          blkCnt = ((uint32_t) blockSize2 >> 2u);
;;;294    
;;;295          while(blkCnt > 0u)
;;;296          {
;;;297            /* Set all accumulators to zero */
;;;298            acc0 = 0;
;;;299            acc1 = 0;
;;;300            acc2 = 0;
;;;301            acc3 = 0;
;;;302    
;;;303            /* read x[0], x[1], x[2] samples */
;;;304            x0 = *(px++);
;;;305            x1 = *(px++);
;;;306            x2 = *(px++);
;;;307    
;;;308            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;309            k = srcBLen >> 2u;
;;;310    
;;;311            /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;312             ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;313            do
;;;314            {
;;;315              /* Read y[srcBLen - 1] sample */
;;;316              c0 = *(py--);
;;;317              /* Read y[srcBLen - 2] sample */
;;;318              c1 = *(py--);
;;;319    
;;;320              /* Read x[3] sample */
;;;321              x3 = *(px++);
;;;322    
;;;323              /* x[0] and x[1] are packed */
;;;324              in1 = (q15_t) x0;
;;;325              in2 = (q15_t) x1;
;;;326    
;;;327              input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;328    
;;;329              /* y[srcBLen - 1]   and y[srcBLen - 2] are packed */
;;;330              in1 = (q15_t) c0;
;;;331              in2 = (q15_t) c1;
;;;332    
;;;333              input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;334    
;;;335              /* acc0 += x[0] * y[srcBLen - 1] + x[1] * y[srcBLen - 2]  */
;;;336              acc0 = __SMLAD(input1, input2, acc0);
;;;337    
;;;338              /* x[1] and x[2] are packed */
;;;339              in1 = (q15_t) x1;
;;;340              in2 = (q15_t) x2;
;;;341    
;;;342              input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;343    
;;;344              /* acc1 += x[1] * y[srcBLen - 1] + x[2] * y[srcBLen - 2]  */
;;;345              acc1 = __SMLAD(input1, input2, acc1);
;;;346    
;;;347              /* x[2] and x[3] are packed */
;;;348              in1 = (q15_t) x2;
;;;349              in2 = (q15_t) x3;
;;;350    
;;;351              input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;352    
;;;353              /* acc2 += x[2] * y[srcBLen - 1] + x[3] * y[srcBLen - 2]  */
;;;354              acc2 = __SMLAD(input1, input2, acc2);
;;;355    
;;;356              /* Read x[4] sample */
;;;357              x0 = *(px++);
;;;358    
;;;359              /* x[3] and x[4] are packed */
;;;360              in1 = (q15_t) x3;
;;;361              in2 = (q15_t) x0;
;;;362    
;;;363              input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;364    
;;;365              /* acc3 += x[3] * y[srcBLen - 1] + x[4] * y[srcBLen - 2]  */
;;;366              acc3 = __SMLAD(input1, input2, acc3);
;;;367    
;;;368              /* Read y[srcBLen - 3] sample */
;;;369              c0 = *(py--);
;;;370              /* Read y[srcBLen - 4] sample */
;;;371              c1 = *(py--);
;;;372    
;;;373              /* Read x[5] sample */
;;;374              x1 = *(px++);
;;;375    
;;;376              /* x[2] and x[3] are packed */
;;;377              in1 = (q15_t) x2;
;;;378              in2 = (q15_t) x3;
;;;379    
;;;380              input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;381    
;;;382              /* y[srcBLen - 3] and y[srcBLen - 4] are packed */
;;;383              in1 = (q15_t) c0;
;;;384              in2 = (q15_t) c1;
;;;385    
;;;386              input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;387    
;;;388              /* acc0 += x[2] * y[srcBLen - 3] + x[3] * y[srcBLen - 4]  */
;;;389              acc0 = __SMLAD(input1, input2, acc0);
;;;390    
;;;391              /* x[3] and x[4] are packed */
;;;392              in1 = (q15_t) x3;
;;;393              in2 = (q15_t) x0;
;;;394    
;;;395              input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;396    
;;;397              /* acc1 += x[3] * y[srcBLen - 3] + x[4] * y[srcBLen - 4]  */
;;;398              acc1 = __SMLAD(input1, input2, acc1);
;;;399    
;;;400              /* x[4] and x[5] are packed */
;;;401              in1 = (q15_t) x0;
;;;402              in2 = (q15_t) x1;
;;;403    
;;;404              input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;405    
;;;406              /* acc2 += x[4] * y[srcBLen - 3] + x[5] * y[srcBLen - 4]  */
;;;407              acc2 = __SMLAD(input1, input2, acc2);
;;;408    
;;;409              /* Read x[6] sample */
;;;410              x2 = *(px++);
;;;411    
;;;412              /* x[5] and x[6] are packed */
;;;413              in1 = (q15_t) x1;
;;;414              in2 = (q15_t) x2;
;;;415    
;;;416              input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;417    
;;;418              /* acc3 += x[5] * y[srcBLen - 3] + x[6] * y[srcBLen - 4]  */
;;;419              acc3 = __SMLAD(input1, input2, acc3);
;;;420    
;;;421            } while(--k);
;;;422    
;;;423            /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;424             ** No loop unrolling is used. */
;;;425            k = srcBLen % 0x4u;
;;;426    
;;;427            while(k > 0u)
;;;428            {
;;;429              /* Read y[srcBLen - 5] sample */
;;;430              c0 = *(py--);
;;;431    
;;;432              /* Read x[7] sample */
;;;433              x3 = *(px++);
;;;434    
;;;435              /* Perform the multiply-accumulates */
;;;436              /* acc0 +=  x[4] * y[srcBLen - 5] */
;;;437              acc0 += ((q31_t) x0 * c0);
;;;438              /* acc1 +=  x[5] * y[srcBLen - 5] */
;;;439              acc1 += ((q31_t) x1 * c0);
;;;440              /* acc2 +=  x[6] * y[srcBLen - 5] */
;;;441              acc2 += ((q31_t) x2 * c0);
;;;442              /* acc3 +=  x[7] * y[srcBLen - 5] */
;;;443              acc3 += ((q31_t) x3 * c0);
;;;444    
;;;445              /* Reuse the present samples for the next MAC */
;;;446              x0 = x1;
;;;447              x1 = x2;
;;;448              x2 = x3;
;;;449    
;;;450              /* Decrement the loop counter */
;;;451              k--;
;;;452            }
;;;453    
;;;454            /* Store the result in the accumulator in the destination buffer. */
;;;455            *pOut++ = (q7_t) (__SSAT(acc0 >> 7, 8));
;;;456            *pOut++ = (q7_t) (__SSAT(acc1 >> 7, 8));
;;;457            *pOut++ = (q7_t) (__SSAT(acc2 >> 7, 8));
;;;458            *pOut++ = (q7_t) (__SSAT(acc3 >> 7, 8));
;;;459    
;;;460            /* Increment the pointer pIn1 index, count by 4 */
;;;461            count += 4u;
;;;462    
;;;463            /* Update the inputA and inputB pointers for next MAC calculation */
;;;464            px = pIn1 + count;
;;;465            py = pSrc2;
;;;466    
;;;467    
;;;468            /* Decrement the loop counter */
;;;469            blkCnt--;
;;;470          }
;;;471    
;;;472          /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.   
;;;473           ** No loop unrolling is used. */
;;;474          blkCnt = (uint32_t) blockSize2 % 0x4u;
;;;475    
;;;476          while(blkCnt > 0u)
;;;477          {
;;;478            /* Accumulator is made zero for every iteration */
;;;479            sum = 0;
;;;480    
;;;481            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;482            k = srcBLen >> 2u;
;;;483    
;;;484            /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;485             ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;486            while(k > 0u)
;;;487            {
;;;488    
;;;489              /* Reading two inputs of SrcA buffer and packing */
;;;490              in1 = (q15_t) * px++;
;;;491              in2 = (q15_t) * px++;
;;;492              input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;493    
;;;494              /* Reading two inputs of SrcB buffer and packing */
;;;495              in1 = (q15_t) * py--;
;;;496              in2 = (q15_t) * py--;
;;;497              input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;498    
;;;499              /* Perform the multiply-accumulates */
;;;500              sum = __SMLAD(input1, input2, sum);
;;;501    
;;;502              /* Reading two inputs of SrcA buffer and packing */
;;;503              in1 = (q15_t) * px++;
;;;504              in2 = (q15_t) * px++;
;;;505              input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;506    
;;;507              /* Reading two inputs of SrcB buffer and packing */
;;;508              in1 = (q15_t) * py--;
;;;509              in2 = (q15_t) * py--;
;;;510              input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;511    
;;;512              /* Perform the multiply-accumulates */
;;;513              sum = __SMLAD(input1, input2, sum);
;;;514    
;;;515              /* Decrement the loop counter */
;;;516              k--;
;;;517            }
;;;518    
;;;519            /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;520             ** No loop unrolling is used. */
;;;521            k = srcBLen % 0x4u;
;;;522    
;;;523            while(k > 0u)
;;;524            {
;;;525              /* Perform the multiply-accumulates */
;;;526              sum += ((q31_t) * px++ * *py--);
;;;527    
;;;528              /* Decrement the loop counter */
;;;529              k--;
;;;530            }
;;;531    
;;;532            /* Store the result in the accumulator in the destination buffer. */
;;;533            *pOut++ = (q7_t) (__SSAT(sum >> 7, 8));
;;;534    
;;;535            /* Increment the pointer pIn1 index, count by 1 */
;;;536     	    count++;
;;;537    
;;;538            /* Update the inputA and inputB pointers for next MAC calculation */
;;;539          	px = pIn1 + count;
;;;540            py = pSrc2;	
;;;541    
;;;542            /* Decrement the loop counter */
;;;543            blkCnt--;
;;;544          }
;;;545        }
;;;546        else
;;;547        {
;;;548          /* If the srcBLen is not a multiple of 4,   
;;;549           * the blockSize2 loop cannot be unrolled by 4 */
;;;550          blkCnt = (uint32_t) blockSize2;
;;;551    
;;;552          while(blkCnt > 0u)
;;;553          {
;;;554            /* Accumulator is made zero for every iteration */
;;;555            sum = 0;
;;;556    
;;;557            /* srcBLen number of MACS should be performed */
;;;558            k = srcBLen;
;;;559    
;;;560            while(k > 0u)
;;;561            {
;;;562              /* Perform the multiply-accumulate */
;;;563              sum += ((q31_t) * px++ * *py--);
;;;564    
;;;565              /* Decrement the loop counter */
;;;566              k--;
;;;567            }
;;;568    
;;;569            /* Store the result in the accumulator in the destination buffer. */
;;;570            *pOut++ = (q7_t) (__SSAT(sum >> 7, 8));
;;;571    
;;;572            /* Increment the MAC count */
;;;573            count++;
;;;574    
;;;575            /* Update the inputA and inputB pointers for next MAC calculation */
;;;576            px = pIn1 + count;
;;;577            py = pSrc2;
;;;578    
;;;579            /* Decrement the loop counter */
;;;580            blkCnt--;
;;;581          }
;;;582        }
;;;583    
;;;584    
;;;585        /* --------------------------   
;;;586         * Initializations of stage3   
;;;587         * -------------------------*/
;;;588    
;;;589        /* sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1]   
;;;590         * sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2]   
;;;591         * ....   
;;;592         * sum +=  x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2]   
;;;593         * sum +=  x[srcALen-1] * y[srcBLen-1]   
;;;594         */
;;;595    
;;;596        /* In this stage the MAC operations are decreased by 1 for every iteration.   
;;;597           The count variable holds the number of MAC operations performed */
;;;598        count = srcBLen - 1u;
;;;599    
;;;600        /* Working pointer of inputA */
;;;601        pSrc1 = (pIn1 + srcALen) - (srcBLen - 1u);
;;;602        px = pSrc1;
;;;603    
;;;604        /* Working pointer of inputB */
;;;605        pSrc2 = pIn2 + (srcBLen - 1u);
;;;606        py = pSrc2;
;;;607    
;;;608        /* -------------------   
;;;609         * Stage3 process   
;;;610         * ------------------*/
;;;611    
;;;612        while(blockSize3 > 0)
;;;613        {
;;;614          /* Accumulator is made zero for every iteration */
;;;615          sum = 0;
;;;616    
;;;617          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;618          k = count >> 2u;
;;;619    
;;;620          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;621           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;622          while(k > 0u)
;;;623          {
;;;624            /* Reading two inputs, x[srcALen - srcBLen + 1] and x[srcALen - srcBLen + 2] of SrcA buffer and packing */
;;;625            in1 = (q15_t) * px++;
;;;626            in2 = (q15_t) * px++;
;;;627            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;628    
;;;629            /* Reading two inputs, y[srcBLen - 1] and y[srcBLen - 2] of SrcB buffer and packing */
;;;630            in1 = (q15_t) * py--;
;;;631            in2 = (q15_t) * py--;
;;;632            input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;633    
;;;634            /* sum += x[srcALen - srcBLen + 1] * y[srcBLen - 1] */
;;;635            /* sum += x[srcALen - srcBLen + 2] * y[srcBLen - 2] */
;;;636            sum = __SMLAD(input1, input2, sum);
;;;637    
;;;638            /* Reading two inputs, x[srcALen - srcBLen + 3] and x[srcALen - srcBLen + 4] of SrcA buffer and packing */
;;;639            in1 = (q15_t) * px++;
;;;640            in2 = (q15_t) * px++;
;;;641            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;642    
;;;643            /* Reading two inputs, y[srcBLen - 3] and y[srcBLen - 4] of SrcB buffer and packing */
;;;644            in1 = (q15_t) * py--;
;;;645            in2 = (q15_t) * py--;
;;;646            input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
;;;647    
;;;648            /* sum += x[srcALen - srcBLen + 3] * y[srcBLen - 3] */
;;;649            /* sum += x[srcALen - srcBLen + 4] * y[srcBLen - 4] */
;;;650            sum = __SMLAD(input1, input2, sum);
;;;651    
;;;652            /* Decrement the loop counter */
;;;653            k--;
;;;654          }
;;;655    
;;;656          /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;657           ** No loop unrolling is used. */
;;;658          k = count % 0x4u;
;;;659    
;;;660          while(k > 0u)
;;;661          {
;;;662            /* Perform the multiply-accumulates */
;;;663            /* sum +=  x[srcALen-1] * y[srcBLen-1] */
;;;664            sum += ((q31_t) * px++ * *py--);
;;;665    
;;;666            /* Decrement the loop counter */
;;;667            k--;
;;;668          }
;;;669    
;;;670          /* Store the result in the accumulator in the destination buffer. */
;;;671          *pOut++ = (q7_t) (__SSAT(sum >> 7, 8));
;;;672    
;;;673          /* Update the inputA and inputB pointers for next MAC calculation */
;;;674          px = ++pSrc1;
;;;675          py = pSrc2;
;;;676    
;;;677          /* Decrement the MAC count */
;;;678          count--;
;;;679    
;;;680          /* Decrement the loop counter */
;;;681          blockSize3--;
;;;682    
;;;683        }
;;;684    
;;;685        /* set status as ARM_MATH_SUCCESS */
;;;686        status = ARM_MATH_SUCCESS;
;;;687      }
;;;688    
;;;689      /* Return to application */
;;;690      return (status);
;;;691    
;;;692    #else
;;;693    
;;;694      /* Run the below code for Cortex-M0 */
;;;695    
;;;696      q7_t *pIn1 = pSrcA;                            /* inputA pointer */
;;;697      q7_t *pIn2 = pSrcB;                            /* inputB pointer */
;;;698      q31_t sum;                                     /* Accumulator */
;;;699      uint32_t i, j;                                 /* loop counters */
;;;700      arm_status status;                             /* status of Partial convolution */
;;;701    
;;;702      /* Check for range of output samples to be calculated */
;;;703      if((firstIndex + numPoints) > ((srcALen + (srcBLen - 1u))))
;;;704      {
;;;705        /* Set status as ARM_ARGUMENT_ERROR */
;;;706        status = ARM_MATH_ARGUMENT_ERROR;
;;;707      }
;;;708      else
;;;709      {
;;;710        /* Loop to calculate convolution for output length number of values */
;;;711        for (i = firstIndex; i <= (firstIndex + numPoints - 1); i++)
;;;712        {
;;;713          /* Initialize sum with zero to carry on MAC operations */
;;;714          sum = 0;
;;;715    
;;;716          /* Loop to perform MAC operations according to convolution equation */
;;;717          for (j = 0; j <= i; j++)
;;;718          {
;;;719            /* Check the array limitations */
;;;720            if(((i - j) < srcBLen) && (j < srcALen))
;;;721            {
;;;722              /* z[i] += x[i-j] * y[j] */
;;;723              sum += ((q15_t) pIn1[j] * (pIn2[i - j]));
;;;724            }
;;;725          }
;;;726    
;;;727          /* Store the output in the destination buffer */
;;;728          pDst[i] = (q7_t) __SSAT((sum >> 7u), 8u);
;;;729        }
;;;730        /* set status as ARM_SUCCESS as there are no argument errors */
;;;731        status = ARM_MATH_SUCCESS;
;;;732      }
;;;733      return (status);
;;;734    
;;;735    #endif /*  #ifndef ARM_MATH_CM0_FAMILY */
;;;736    
;;;737    }
00001e  b018              ADD      sp,sp,#0x60
000020  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.36|
000024  4677              MOV      r7,lr                 ;110
000026  459e              CMP      lr,r3                 ;110
000028  d302              BCC      |L1.48|
00002a  4692              MOV      r10,r2                ;116
00002c  900f              STR      r0,[sp,#0x3c]         ;116
00002e  e003              B        |L1.56|
                  |L1.48|
000030  469e              MOV      lr,r3                 ;127
000032  4682              MOV      r10,r0                ;124
000034  463b              MOV      r3,r7                 ;128
000036  920f              STR      r2,[sp,#0x3c]         ;128
                  |L1.56|
000038  4575              CMP      r5,lr                 ;135
00003a  dd02              BLE      |L1.66|
00003c  eba5000e          SUB      r0,r5,lr              ;135
000040  e000              B        |L1.68|
                  |L1.66|
000042  2000              MOVS     r0,#0                 ;135
                  |L1.68|
000044  f1ae0201          SUB      r2,lr,#1              ;136
000048  4291              CMP      r1,r2                 ;136
00004a  dd02              BLE      |L1.82|
00004c  1a42              SUBS     r2,r0,r1              ;136
00004e  eb02000e          ADD      r0,r2,lr              ;136
                  |L1.82|
000052  900e              STR      r0,[sp,#0x38]         ;137
000054  1a58              SUBS     r0,r3,r1              ;137
000056  1e40              SUBS     r0,r0,#1              ;137
000058  2800              CMP      r0,#0                 ;138
00005a  dd04              BLE      |L1.102|
00005c  1e5a              SUBS     r2,r3,#1              ;138
00005e  4295              CMP      r5,r2                 ;138
000060  d902              BLS      |L1.104|
000062  4604              MOV      r4,r0                 ;138
000064  e000              B        |L1.104|
                  |L1.102|
000066  2400              MOVS     r4,#0                 ;139
                  |L1.104|
000068  980e              LDR      r0,[sp,#0x38]         ;140
00006a  46a1              MOV      r9,r4                 ;139
00006c  4448              ADD      r0,r0,r9              ;140
00006e  4408              ADD      r0,r0,r1              ;140
000070  1a28              SUBS     r0,r5,r0              ;140
000072  2800              CMP      r0,#0                 ;142
000074  dc00              BGT      |L1.120|
000076  2000              MOVS     r0,#0                 ;142
                  |L1.120|
000078  9014              STR      r0,[sp,#0x50]         ;155
00007a  1870              ADDS     r0,r6,r1              ;155
00007c  9013              STR      r0,[sp,#0x4c]         ;174
00007e  eb0a0201          ADD      r2,r10,r1             ;177
000082  1c4c              ADDS     r4,r1,#1              ;171
000084  980f              LDR      r0,[sp,#0x3c]         ;177
000086  9209              STR      r2,[sp,#0x24]         ;185
000088  e041              B        |L1.270|
                  |L1.138|
00008a  2500              MOVS     r5,#0                 ;188
00008c  ea4f0c94          LSR      r12,r4,#2             ;191
000090  e020              B        |L1.212|
000092  bf00              NOP                            ;198
                  |L1.148|
000094  f9106b01          LDRSB    r6,[r0],#1            ;198
000098  f9107b01          LDRSB    r7,[r0],#1            ;199
00009c  f367461f          BFI      r6,r7,#16,#16         ;200
0000a0  9601              STR      r6,[sp,#4]            ;203
0000a2  f9927000          LDRSB    r7,[r2,#0]            ;203
0000a6  f9128c01          LDRSB    r8,[r2,#-1]           ;204
0000aa  f368471f          BFI      r7,r8,#16,#16         ;205
0000ae  fb265807          SMLAD    r8,r6,r7,r5           ;209
0000b2  f9105b02          LDRSB    r5,[r0],#2            ;212
0000b6  f9127c02          LDRSB    r7,[r2,#-2]           ;217
0000ba  f9106c01          LDRSB    r6,[r0,#-1]           ;213
0000be  f366451f          BFI      r5,r6,#16,#16         ;214
0000c2  f9126c03          LDRSB    r6,[r2,#-3]           ;218
0000c6  f366471f          BFI      r7,r6,#16,#16         ;219
0000ca  fb258507          SMLAD    r5,r5,r7,r8           ;223
0000ce  1f12              SUBS     r2,r2,#4              ;223
0000d0  f1ac0c01          SUB      r12,r12,#1            ;223
                  |L1.212|
0000d4  f1bc0f00          CMP      r12,#0                ;195
0000d8  d1dc              BNE      |L1.148|
0000da  f0040603          AND      r6,r4,#3              ;231
0000de  e006              B        |L1.238|
                  |L1.224|
0000e0  f9107b01          LDRSB    r7,[r0],#1            ;236
0000e4  f912c901          LDRSB    r12,[r2],#-1          ;236
0000e8  fb17550c          SMLABB   r5,r7,r12,r5          ;236
0000ec  1e76              SUBS     r6,r6,#1              ;236
                  |L1.238|
0000ee  2e00              CMP      r6,#0                 ;233
0000f0  d1f6              BNE      |L1.224|
0000f2  9813              LDR      r0,[sp,#0x4c]         ;243
0000f4  f32512c7          SSAT     r2,#8,r5,ASR #7       ;243
0000f8  f1a90901          SUB      r9,r9,#1              ;253
0000fc  7002              STRB     r2,[r0,#0]            ;243
0000fe  9813              LDR      r0,[sp,#0x4c]         ;243
000100  1c40              ADDS     r0,r0,#1              ;243
000102  9013              STR      r0,[sp,#0x4c]         ;246
000104  9a09              LDR      r2,[sp,#0x24]         ;246
000106  980f              LDR      r0,[sp,#0x3c]         ;253
000108  1c52              ADDS     r2,r2,#1              ;246
00010a  9209              STR      r2,[sp,#0x24]         ;247
00010c  1c64              ADDS     r4,r4,#1              ;253
                  |L1.270|
00010e  f1b90f00          CMP      r9,#0                 ;185
000112  dcba              BGT      |L1.138|
000114  1aca              SUBS     r2,r1,r3              ;267
000116  1c52              ADDS     r2,r2,#1              ;267
000118  2a00              CMP      r2,#0                 ;267
00011a  dd02              BLE      |L1.290|
00011c  4408              ADD      r0,r0,r1              ;269
00011e  1ac0              SUBS     r0,r0,r3              ;269
000120  1c40              ADDS     r0,r0,#1              ;269
                  |L1.290|
000122  eb0a0403          ADD      r4,r10,r3             ;277
000126  9416              STR      r4,[sp,#0x58]         ;281
000128  2100              MOVS     r1,#0                 ;281
00012a  1e64              SUBS     r4,r4,#1              ;281
00012c  e9cd1408          STRD     r1,r4,[sp,#0x20]      ;290
000130  2b04              CMP      r3,#4                 ;290
000132  d37c              BCC      |L1.558|
000134  9914              LDR      r1,[sp,#0x50]         ;293
000136  0889              LSRS     r1,r1,#2              ;293
000138  e08b              B        |L1.594|
                  |L1.314|
00013a  2500              MOVS     r5,#0                 ;298
00013c  f910cb01          LDRSB    r12,[r0],#1           ;304
000140  089f              LSRS     r7,r3,#2              ;309
000142  f9101b01          LDRSB    r1,[r0],#1            ;305
000146  46aa              MOV      r10,r5                ;299
000148  f9102b01          LDRSB    r2,[r0],#1            ;306
00014c  46ab              MOV      r11,r5                ;300
00014e  462e              MOV      r6,r5                 ;301
000150  f8cd702c          STR.W    r7,[sp,#0x2c]         ;309
                  |L1.340|
000154  f9948000          LDRSB    r8,[r4,#0]            ;316
000158  f9149c01          LDRSB    r9,[r4,#-1]           ;318
00015c  f8cd905c          STR      r9,[sp,#0x5c]
000160  f1a40902          SUB      r9,r4,#2
000164  f8cd900c          STR      r9,[sp,#0xc]          ;321
000168  f8dd905c          LDR      r9,[sp,#0x5c]         ;333
00016c  f9107b01          LDRSB    r7,[r0],#1            ;321
000170  f3614c1f          BFI      r12,r1,#16,#16        ;327
000174  9002              STR      r0,[sp,#8]            ;331
000176  f369481f          BFI      r8,r9,#16,#16         ;333
00017a  fb2c5508          SMLAD    r5,r12,r8,r5          ;336
00017e  f362411f          BFI      r1,r2,#16,#16         ;342
000182  fb21aa08          SMLAD    r10,r1,r8,r10         ;345
000186  4610              MOV      r0,r2                 ;345
000188  f367401f          BFI      r0,r7,#16,#16         ;351
00018c  fb20bb08          SMLAD    r11,r0,r8,r11         ;354
000190  9802              LDR      r0,[sp,#8]            ;357
000192  950d              STR      r5,[sp,#0x34]         ;357
000194  4639              MOV      r1,r7                 ;360
000196  f910cb01          LDRSB    r12,[r0],#1           ;357
00019a  f36c411f          BFI      r1,r12,#16,#16        ;363
00019e  fb216808          SMLAD    r8,r1,r8,r6           ;366
0001a2  f8dd900c          LDR      r9,[sp,#0xc]          ;369
0001a6  f9145c03          LDRSB    r5,[r4,#-3]           ;371
0001aa  f9101b01          LDRSB    r1,[r0],#1            ;374
0001ae  f9996000          LDRSB    r6,[r9,#0]            ;369
0001b2  f367421f          BFI      r2,r7,#16,#16         ;380
0001b6  f365461f          BFI      r6,r5,#16,#16         ;386
0001ba  9d0d              LDR      r5,[sp,#0x34]         ;389
0001bc  fb225506          SMLAD    r5,r2,r6,r5           ;389
0001c0  f36c471f          BFI      r7,r12,#16,#16        ;395
0001c4  fb27aa06          SMLAD    r10,r7,r6,r10         ;398
0001c8  4662              MOV      r2,r12                ;398
0001ca  f361421f          BFI      r2,r1,#16,#16         ;404
0001ce  fb22bb06          SMLAD    r11,r2,r6,r11         ;407
0001d2  f9102b01          LDRSB    r2,[r0],#1            ;410
0001d6  460f              MOV      r7,r1                 ;410
0001d8  f362471f          BFI      r7,r2,#16,#16         ;416
0001dc  fb278606          SMLAD    r6,r7,r6,r8           ;419
0001e0  9f0b              LDR      r7,[sp,#0x2c]         ;421
0001e2  f1a40404          SUB      r4,r4,#4              ;421
0001e6  1e7f              SUBS     r7,r7,#1              ;421
0001e8  970b              STR      r7,[sp,#0x2c]         ;421
0001ea  d1b3              BNE      |L1.340|
0001ec  f0030703          AND      r7,r3,#3              ;425
0001f0  e011              B        |L1.534|
0001f2  bf00              NOP                            ;430
                  |L1.500|
0001f4  f9147901          LDRSB    r7,[r4],#-1           ;430
0001f8  f9108b01          LDRSB    r8,[r0],#1            ;433
0001fc  fb0c5507          MLA      r5,r12,r7,r5          ;437
000200  fb01aa07          MLA      r10,r1,r7,r10         ;439
000204  fb12bb07          SMLABB   r11,r2,r7,r11         ;441
000208  fb186607          SMLABB   r6,r8,r7,r6           ;443
00020c  468c              MOV      r12,r1                ;446
00020e  4611              MOV      r1,r2                 ;447
000210  4642              MOV      r2,r8                 ;448
000212  f1a90701          SUB      r7,r9,#1              ;451
                  |L1.534|
000216  ea5f0907          MOVS     r9,r7                 ;425
00021a  d1eb              BNE      |L1.500|
00021c  9813              LDR      r0,[sp,#0x4c]         ;455
00021e  f32511c7          SSAT     r1,#8,r5,ASR #7       ;455
000222  7001              STRB     r1,[r0,#0]            ;455
000224  9813              LDR      r0,[sp,#0x4c]         ;456
000226  f32a11c7          SSAT     r1,#8,r10,ASR #7      ;456
00022a  7041              STRB     r1,[r0,#1]            ;456
00022c  e000              B        |L1.560|
                  |L1.558|
00022e  e05a              B        |L1.742|
                  |L1.560|
000230  f32b11c7          SSAT     r1,#8,r11,ASR #7      ;457
000234  7081              STRB     r1,[r0,#2]            ;457
000236  f32611c7          SSAT     r1,#8,r6,ASR #7       ;458
00023a  70c1              STRB     r1,[r0,#3]            ;458
00023c  1d00              ADDS     r0,r0,#4              ;458
00023e  9013              STR      r0,[sp,#0x4c]         ;461
000240  9808              LDR      r0,[sp,#0x20]         ;461
000242  9c09              LDR      r4,[sp,#0x24]         ;469
000244  1d00              ADDS     r0,r0,#4              ;461
000246  9008              STR      r0,[sp,#0x20]         ;464
000248  9908              LDR      r1,[sp,#0x20]         ;464
00024a  980f              LDR      r0,[sp,#0x3c]         ;464
00024c  4408              ADD      r0,r0,r1              ;464
00024e  9915              LDR      r1,[sp,#0x54]         ;469
000250  1e49              SUBS     r1,r1,#1              ;469
                  |L1.594|
000252  9115              STR      r1,[sp,#0x54]         ;293
000254  2900              CMP      r1,#0                 ;293
000256  f47faf70          BNE      |L1.314|
00025a  9914              LDR      r1,[sp,#0x50]         ;474
00025c  f0010703          AND      r7,r1,#3              ;474
000260  e03e              B        |L1.736|
                  |L1.610|
000262  2100              MOVS     r1,#0                 ;479
000264  089e              LSRS     r6,r3,#2              ;482
000266  e01d              B        |L1.676|
                  |L1.616|
000268  f9102b01          LDRSB    r2,[r0],#1            ;490
00026c  f9148c01          LDRSB    r8,[r4,#-1]           ;496
000270  f9105b01          LDRSB    r5,[r0],#1            ;491
000274  f365421f          BFI      r2,r5,#16,#16         ;492
000278  f9945000          LDRSB    r5,[r4,#0]            ;495
00027c  f368451f          BFI      r5,r8,#16,#16         ;497
000280  fb221205          SMLAD    r2,r2,r5,r1           ;500
000284  f9101b02          LDRSB    r1,[r0],#2            ;503
000288  f914cc03          LDRSB    r12,[r4,#-3]          ;509
00028c  f9105c01          LDRSB    r5,[r0,#-1]           ;504
000290  f365411f          BFI      r1,r5,#16,#16         ;505
000294  f9145c02          LDRSB    r5,[r4,#-2]           ;508
000298  f36c451f          BFI      r5,r12,#16,#16        ;510
00029c  fb212105          SMLAD    r1,r1,r5,r2           ;513
0002a0  1f24              SUBS     r4,r4,#4              ;513
0002a2  1e76              SUBS     r6,r6,#1              ;513
                  |L1.676|
0002a4  2e00              CMP      r6,#0                 ;486
0002a6  d1df              BNE      |L1.616|
0002a8  f0030203          AND      r2,r3,#3              ;521
0002ac  e007              B        |L1.702|
0002ae  bf00              NOP                            ;526
                  |L1.688|
0002b0  f9105b01          LDRSB    r5,[r0],#1            ;526
0002b4  f9146901          LDRSB    r6,[r4],#-1           ;526
0002b8  fb151106          SMLABB   r1,r5,r6,r1           ;526
0002bc  1e52              SUBS     r2,r2,#1              ;526
                  |L1.702|
0002be  2a00              CMP      r2,#0                 ;523
0002c0  d1f6              BNE      |L1.688|
0002c2  9813              LDR      r0,[sp,#0x4c]         ;533
0002c4  f32111c7          SSAT     r1,#8,r1,ASR #7       ;533
0002c8  7001              STRB     r1,[r0,#0]            ;533
0002ca  9813              LDR      r0,[sp,#0x4c]         ;533
0002cc  1c40              ADDS     r0,r0,#1              ;533
0002ce  9013              STR      r0,[sp,#0x4c]         ;536
0002d0  9808              LDR      r0,[sp,#0x20]         ;536
0002d2  9c09              LDR      r4,[sp,#0x24]         ;540
0002d4  1c40              ADDS     r0,r0,#1              ;536
0002d6  9008              STR      r0,[sp,#0x20]         ;539
0002d8  9908              LDR      r1,[sp,#0x20]         ;539
0002da  980f              LDR      r0,[sp,#0x3c]         ;539
0002dc  1e7f              SUBS     r7,r7,#1              ;540
0002de  4408              ADD      r0,r0,r1              ;539
                  |L1.736|
0002e0  2f00              CMP      r7,#0                 ;476
0002e2  d1be              BNE      |L1.610|
0002e4  e01e              B        |L1.804|
                  |L1.742|
0002e6  9a14              LDR      r2,[sp,#0x50]         ;552
0002e8  e01a              B        |L1.800|
                  |L1.746|
0002ea  2500              MOVS     r5,#0                 ;555
0002ec  4619              MOV      r1,r3                 ;558
0002ee  e006              B        |L1.766|
                  |L1.752|
0002f0  f9106b01          LDRSB    r6,[r0],#1            ;563
0002f4  f9147901          LDRSB    r7,[r4],#-1           ;563
0002f8  fb165507          SMLABB   r5,r6,r7,r5           ;563
0002fc  1e49              SUBS     r1,r1,#1              ;563
                  |L1.766|
0002fe  2900              CMP      r1,#0                 ;560
000300  d1f6              BNE      |L1.752|
000302  9813              LDR      r0,[sp,#0x4c]         ;570
000304  f32511c7          SSAT     r1,#8,r5,ASR #7       ;570
000308  7001              STRB     r1,[r0,#0]            ;570
00030a  9813              LDR      r0,[sp,#0x4c]         ;570
00030c  1c40              ADDS     r0,r0,#1              ;570
00030e  9013              STR      r0,[sp,#0x4c]         ;573
000310  9808              LDR      r0,[sp,#0x20]         ;573
000312  9c09              LDR      r4,[sp,#0x24]         ;577
000314  1c40              ADDS     r0,r0,#1              ;573
000316  9008              STR      r0,[sp,#0x20]         ;576
000318  9908              LDR      r1,[sp,#0x20]         ;576
00031a  980f              LDR      r0,[sp,#0x3c]         ;576
00031c  1e52              SUBS     r2,r2,#1              ;577
00031e  4408              ADD      r0,r0,r1              ;576
                  |L1.800|
000320  2a00              CMP      r2,#0                 ;552
000322  d1e2              BNE      |L1.746|
                  |L1.804|
000324  980f              LDR      r0,[sp,#0x3c]         ;601
000326  1e5c              SUBS     r4,r3,#1              ;598
000328  4470              ADD      r0,r0,lr              ;601
00032a  1ac1              SUBS     r1,r0,r3              ;601
00032c  1c49              ADDS     r1,r1,#1              ;601
00032e  9a16              LDR      r2,[sp,#0x58]         ;602
000330  4608              MOV      r0,r1                 ;602
000332  1e52              SUBS     r2,r2,#1              ;602
000334  4691              MOV      r9,r2                 ;605
000336  9b0e              LDR      r3,[sp,#0x38]         ;612
000338  e03d              B        |L1.950|
                  |L1.826|
00033a  2300              MOVS     r3,#0                 ;615
00033c  08a7              LSRS     r7,r4,#2              ;618
00033e  e01d              B        |L1.892|
                  |L1.832|
000340  f9106b01          LDRSB    r6,[r0],#1            ;625
000344  f9128c01          LDRSB    r8,[r2,#-1]           ;631
000348  f9105b01          LDRSB    r5,[r0],#1            ;626
00034c  f365461f          BFI      r6,r5,#16,#16         ;627
000350  f9925000          LDRSB    r5,[r2,#0]            ;630
000354  f368451f          BFI      r5,r8,#16,#16         ;632
000358  fb263505          SMLAD    r5,r6,r5,r3           ;636
00035c  f9103b02          LDRSB    r3,[r0],#2            ;639
000360  f912cc03          LDRSB    r12,[r2,#-3]          ;645
000364  f9106c01          LDRSB    r6,[r0,#-1]           ;640
000368  f366431f          BFI      r3,r6,#16,#16         ;641
00036c  f9126c02          LDRSB    r6,[r2,#-2]           ;644
000370  f36c461f          BFI      r6,r12,#16,#16        ;646
000374  fb235306          SMLAD    r3,r3,r6,r5           ;650
000378  1f12              SUBS     r2,r2,#4              ;650
00037a  1e7f              SUBS     r7,r7,#1              ;650
                  |L1.892|
00037c  2f00              CMP      r7,#0                 ;622
00037e  d1df              BNE      |L1.832|
000380  f0040503          AND      r5,r4,#3              ;658
000384  e007              B        |L1.918|
000386  bf00              NOP                            ;664
                  |L1.904|
000388  f9106b01          LDRSB    r6,[r0],#1            ;664
00038c  f9127901          LDRSB    r7,[r2],#-1           ;664
000390  fb163307          SMLABB   r3,r6,r7,r3           ;664
000394  1e6d              SUBS     r5,r5,#1              ;664
                  |L1.918|
000396  2d00              CMP      r5,#0                 ;660
000398  d1f6              BNE      |L1.904|
00039a  9813              LDR      r0,[sp,#0x4c]         ;671
00039c  f32312c7          SSAT     r2,#8,r3,ASR #7       ;671
0003a0  7002              STRB     r2,[r0,#0]            ;671
0003a2  9813              LDR      r0,[sp,#0x4c]         ;671
0003a4  464a              MOV      r2,r9                 ;675
0003a6  1c40              ADDS     r0,r0,#1              ;671
0003a8  9013              STR      r0,[sp,#0x4c]         ;674
0003aa  9b0e              LDR      r3,[sp,#0x38]         ;681
0003ac  1c48              ADDS     r0,r1,#1              ;674
0003ae  1e5b              SUBS     r3,r3,#1              ;681
0003b0  4601              MOV      r1,r0                 ;674
0003b2  1e64              SUBS     r4,r4,#1              ;681
0003b4  930e              STR      r3,[sp,#0x38]         ;681
                  |L1.950|
0003b6  2b00              CMP      r3,#0                 ;612
0003b8  dcbf              BGT      |L1.826|
0003ba  2000              MOVS     r0,#0                 ;686
0003bc  e62f              B        |L1.30|
;;;738    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_partial_q7.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_conv_partial_q7_c_883f0694____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___21_arm_conv_partial_q7_c_883f0694____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_conv_partial_q7_c_883f0694____REVSH|
#line 144
|__asm___21_arm_conv_partial_q7_c_883f0694____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_conv_partial_q7_c_883f0694____RRX|
#line 300
|__asm___21_arm_conv_partial_q7_c_883f0694____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
