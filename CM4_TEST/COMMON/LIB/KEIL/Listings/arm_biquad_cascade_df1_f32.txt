; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_biquad_cascade_df1_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_biquad_cascade_df1_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_biquad_cascade_df1_f32.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_biquad_cascade_df1_f32.c]
                          THUMB

                          AREA ||i.arm_biquad_cascade_df1_f32||, CODE, READONLY, ALIGN=1

                  arm_biquad_cascade_df1_f32 PROC
;;;177    
;;;178    void arm_biquad_cascade_df1_f32(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;179      const arm_biquad_casd_df1_inst_f32 * S,
;;;180      float32_t * pSrc,
;;;181      float32_t * pDst,
;;;182      uint32_t blockSize)
;;;183    {
;;;184      float32_t *pIn = pSrc;                         /*  source pointer            */
;;;185      float32_t *pOut = pDst;                        /*  destination pointer       */
000004  4614              MOV      r4,r2
;;;186      float32_t *pState = S->pState;                 /*  pState pointer            */
000006  6845              LDR      r5,[r0,#4]
;;;187      float32_t *pCoeffs = S->pCoeffs;               /*  coefficient pointer       */
000008  6887              LDR      r7,[r0,#8]
;;;188      float32_t acc;                                 /*  Simulates the accumulator */
;;;189      float32_t b0, b1, b2, a1, a2;                  /*  Filter coefficients       */
;;;190      float32_t Xn1, Xn2, Yn1, Yn2;                  /*  Filter pState variables   */
;;;191      float32_t Xn;                                  /*  temporary input           */
;;;192      uint32_t sample, stage = S->numStages;         /*  loop counters             */
00000a  f8d0c000          LDR      r12,[r0,#0]
;;;193    
;;;194    
;;;195    #ifndef ARM_MATH_CM0_FAMILY
;;;196    
;;;197      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;198    
;;;199      do
;;;200      {
;;;201        /* Reading the coefficients */
;;;202        b0 = *pCoeffs++;
;;;203        b1 = *pCoeffs++;
;;;204        b2 = *pCoeffs++;
;;;205        a1 = *pCoeffs++;
;;;206        a2 = *pCoeffs++;
;;;207    
;;;208        /* Reading the pState values */
;;;209        Xn1 = pState[0];
;;;210        Xn2 = pState[1];
;;;211        Yn1 = pState[2];
;;;212        Yn2 = pState[3];
;;;213    
;;;214        /* Apply loop unrolling and compute 4 output values simultaneously. */
;;;215        /*      The variable acc hold output values that are being computed:    
;;;216         *    
;;;217         *    acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1]   + a2 * y[n-2]    
;;;218         *    acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1]   + a2 * y[n-2]    
;;;219         *    acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1]   + a2 * y[n-2]    
;;;220         *    acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1]   + a2 * y[n-2]    
;;;221         */
;;;222    
;;;223        sample = blockSize >> 2u;
00000e  ea4f0893          LSR      r8,r3,#2
                  |L1.18|
000012  ecf71a01          VLDM     r7!,{s3}              ;202
000016  ecb72a01          VLDM     r7!,{s4}              ;203
00001a  ecf72a01          VLDM     r7!,{s5}              ;204
00001e  ecb73a01          VLDM     r7!,{s6}              ;205
000022  ecf73a01          VLDM     r7!,{s7}              ;206
000026  edd50a00          VLDR     s1,[r5,#0]            ;209
00002a  ed954a01          VLDR     s8,[r5,#4]            ;210
00002e  ed950a02          VLDR     s0,[r5,#8]            ;211
000032  ed951a03          VLDR     s2,[r5,#0xc]          ;212
000036  4640              MOV      r0,r8
;;;224    
;;;225        /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;226         ** a second loop below computes the remaining 1 to 3 samples. */
;;;227        while(sample > 0u)
000038  e038              B        |L1.172|
                  |L1.58|
;;;228        {
;;;229          /* Read the first input */
;;;230          Xn = *pIn++;
00003a  ecf15a01          VLDM     r1!,{s11}
;;;231    
;;;232          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;233          Yn2 = (b0 * Xn) + (b1 * Xn1) + (b2 * Xn2) + (a1 * Yn1) + (a2 * Yn2);
00003e  ee614aa5          VMUL.F32 s9,s3,s11
000042  ee424a20          VMLA.F32 s9,s4,s1
000046  ee424a84          VMLA.F32 s9,s5,s8
00004a  ee434a00          VMLA.F32 s9,s6,s0
00004e  ee434a81          VMLA.F32 s9,s7,s2
;;;234    
;;;235          /* Store the result in the accumulator in the destination buffer. */
;;;236          *pOut++ = Yn2;
000052  ece44a01          VSTM     r4!,{s9}
;;;237    
;;;238          /* Every time after the output is computed state should be updated. */
;;;239          /* The states should be updated as:  */
;;;240          /* Xn2 = Xn1    */
;;;241          /* Xn1 = Xn     */
;;;242          /* Yn2 = Yn1    */
;;;243          /* Yn1 = acc   */
;;;244    
;;;245          /* Read the second input */
;;;246          Xn2 = *pIn++;
000056  ecb16a01          VLDM     r1!,{s12}
;;;247    
;;;248          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;249          Yn1 = (b0 * Xn2) + (b1 * Xn) + (b2 * Xn1) + (a1 * Yn2) + (a2 * Yn1);
00005a  ee215a86          VMUL.F32 s10,s3,s12
00005e  ee025a25          VMLA.F32 s10,s4,s11
000062  ee025aa0          VMLA.F32 s10,s5,s1
000066  ee035a24          VMLA.F32 s10,s6,s9
00006a  ee035a80          VMLA.F32 s10,s7,s0
;;;250    
;;;251          /* Store the result in the accumulator in the destination buffer. */
;;;252          *pOut++ = Yn1;
00006e  eca45a01          VSTM     r4!,{s10}
;;;253    
;;;254          /* Every time after the output is computed state should be updated. */
;;;255          /* The states should be updated as:  */
;;;256          /* Xn2 = Xn1    */
;;;257          /* Xn1 = Xn     */
;;;258          /* Yn2 = Yn1    */
;;;259          /* Yn1 = acc   */
;;;260    
;;;261          /* Read the third input */
;;;262          Xn1 = *pIn++;
000072  ecb14a01          VLDM     r1!,{s8}
;;;263    
;;;264          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;265          Yn2 = (b0 * Xn1) + (b1 * Xn2) + (b2 * Xn) + (a1 * Yn1) + (a2 * Yn2);
000076  ee211a84          VMUL.F32 s2,s3,s8
00007a  ee021a06          VMLA.F32 s2,s4,s12
00007e  ee021aa5          VMLA.F32 s2,s5,s11
000082  ee031a05          VMLA.F32 s2,s6,s10
000086  ee031aa4          VMLA.F32 s2,s7,s9
;;;266    
;;;267          /* Store the result in the accumulator in the destination buffer. */
;;;268          *pOut++ = Yn2;
00008a  eca41a01          VSTM     r4!,{s2}
;;;269    
;;;270          /* Every time after the output is computed state should be updated. */
;;;271          /* The states should be updated as: */
;;;272          /* Xn2 = Xn1    */
;;;273          /* Xn1 = Xn     */
;;;274          /* Yn2 = Yn1    */
;;;275          /* Yn1 = acc   */
;;;276    
;;;277          /* Read the forth input */
;;;278          Xn = *pIn++;
00008e  ecf10a01          VLDM     r1!,{s1}
;;;279    
;;;280          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;281          Yn1 = (b0 * Xn) + (b1 * Xn1) + (b2 * Xn2) + (a1 * Yn2) + (a2 * Yn1);
000092  ee210aa0          VMUL.F32 s0,s3,s1
000096  ee020a04          VMLA.F32 s0,s4,s8
00009a  ee020a86          VMLA.F32 s0,s5,s12
00009e  ee030a01          VMLA.F32 s0,s6,s2
0000a2  ee030a85          VMLA.F32 s0,s7,s10
;;;282    
;;;283          /* Store the result in the accumulator in the destination buffer. */
;;;284          *pOut++ = Yn1;
0000a6  eca40a01          VSTM     r4!,{s0}
;;;285    
;;;286          /* Every time after the output is computed state should be updated. */
;;;287          /* The states should be updated as:  */
;;;288          /* Xn2 = Xn1    */
;;;289          /* Xn1 = Xn     */
;;;290          /* Yn2 = Yn1    */
;;;291          /* Yn1 = acc   */
;;;292          Xn2 = Xn1;
;;;293          Xn1 = Xn;
;;;294    
;;;295          /* decrement the loop counter */
;;;296          sample--;
0000aa  1e40              SUBS     r0,r0,#1
                  |L1.172|
0000ac  2800              CMP      r0,#0                 ;227
0000ae  d1c4              BNE      |L1.58|
;;;297    
;;;298        }
;;;299    
;;;300        /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;301         ** No loop unrolling is used. */
;;;302        sample = blockSize & 0x3u;
0000b0  f0030603          AND      r6,r3,#3
;;;303    
;;;304        while(sample > 0u)
0000b4  e016              B        |L1.228|
                  |L1.182|
;;;305        {
;;;306          /* Read the input */
;;;307          Xn = *pIn++;
0000b6  ecb15a01          VLDM     r1!,{s10}
;;;308    
;;;309          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;310          acc = (b0 * Xn) + (b1 * Xn1) + (b2 * Xn2) + (a1 * Yn1) + (a2 * Yn2);
0000ba  ee614a85          VMUL.F32 s9,s3,s10
0000be  ee424a20          VMLA.F32 s9,s4,s1
0000c2  ee424a84          VMLA.F32 s9,s5,s8
0000c6  ee434a00          VMLA.F32 s9,s6,s0
0000ca  ee434a81          VMLA.F32 s9,s7,s2
;;;311    
;;;312          /* Store the result in the accumulator in the destination buffer. */
;;;313          *pOut++ = acc;
0000ce  ece44a01          VSTM     r4!,{s9}
;;;314    
;;;315          /* Every time after the output is computed state should be updated. */
;;;316          /* The states should be updated as:    */
;;;317          /* Xn2 = Xn1    */
;;;318          /* Xn1 = Xn     */
;;;319          /* Yn2 = Yn1    */
;;;320          /* Yn1 = acc   */
;;;321          Xn2 = Xn1;
0000d2  eeb04a60          VMOV.F32 s8,s1
;;;322          Xn1 = Xn;
0000d6  eef00a45          VMOV.F32 s1,s10
;;;323          Yn2 = Yn1;
0000da  eeb01a40          VMOV.F32 s2,s0
;;;324          Yn1 = acc;
0000de  eeb00a64          VMOV.F32 s0,s9
;;;325    
;;;326          /* decrement the loop counter */
;;;327          sample--;
0000e2  1e76              SUBS     r6,r6,#1
                  |L1.228|
0000e4  2e00              CMP      r6,#0                 ;304
0000e6  d1e6              BNE      |L1.182|
;;;328    
;;;329        }
;;;330    
;;;331        /*  Store the updated state variables back into the pState array */
;;;332        *pState++ = Xn1;
0000e8  ece50a01          VSTM     r5!,{s1}
;;;333        *pState++ = Xn2;
0000ec  eca54a01          VSTM     r5!,{s8}
;;;334        *pState++ = Yn1;
0000f0  eca50a01          VSTM     r5!,{s0}
;;;335        *pState++ = Yn2;
0000f4  eca51a01          VSTM     r5!,{s2}
;;;336    
;;;337        /*  The first stage goes from the input buffer to the output buffer. */
;;;338        /*  Subsequent numStages  occur in-place in the output buffer */
;;;339        pIn = pDst;
;;;340    
;;;341        /* Reset the output pointer */
;;;342        pOut = pDst;
0000f8  4611              MOV      r1,r2
0000fa  460c              MOV      r4,r1
;;;343    
;;;344        /* decrement the loop counter */
;;;345        stage--;
0000fc  f1ac0c01          SUB      r12,r12,#1
;;;346    
;;;347      } while(stage > 0u);
000100  f1bc0f00          CMP      r12,#0
000104  d185              BNE      |L1.18|
;;;348    
;;;349    #else
;;;350    
;;;351      /* Run the below code for Cortex-M0 */
;;;352    
;;;353      do
;;;354      {
;;;355        /* Reading the coefficients */
;;;356        b0 = *pCoeffs++;
;;;357        b1 = *pCoeffs++;
;;;358        b2 = *pCoeffs++;
;;;359        a1 = *pCoeffs++;
;;;360        a2 = *pCoeffs++;
;;;361    
;;;362        /* Reading the pState values */
;;;363        Xn1 = pState[0];
;;;364        Xn2 = pState[1];
;;;365        Yn1 = pState[2];
;;;366        Yn2 = pState[3];
;;;367    
;;;368        /*      The variables acc holds the output value that is computed:        
;;;369         *    acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1]   + a2 * y[n-2]        
;;;370         */
;;;371    
;;;372        sample = blockSize;
;;;373    
;;;374        while(sample > 0u)
;;;375        {
;;;376          /* Read the input */
;;;377          Xn = *pIn++;
;;;378    
;;;379          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;380          acc = (b0 * Xn) + (b1 * Xn1) + (b2 * Xn2) + (a1 * Yn1) + (a2 * Yn2);
;;;381    
;;;382          /* Store the result in the accumulator in the destination buffer. */
;;;383          *pOut++ = acc;
;;;384    
;;;385          /* Every time after the output is computed state should be updated. */
;;;386          /* The states should be updated as:    */
;;;387          /* Xn2 = Xn1    */
;;;388          /* Xn1 = Xn     */
;;;389          /* Yn2 = Yn1    */
;;;390          /* Yn1 = acc   */
;;;391          Xn2 = Xn1;
;;;392          Xn1 = Xn;
;;;393          Yn2 = Yn1;
;;;394          Yn1 = acc;
;;;395    
;;;396          /* decrement the loop counter */
;;;397          sample--;
;;;398        }
;;;399    
;;;400        /*  Store the updated state variables back into the pState array */
;;;401        *pState++ = Xn1;
;;;402        *pState++ = Xn2;
;;;403        *pState++ = Yn1;
;;;404        *pState++ = Yn2;
;;;405    
;;;406        /*  The first stage goes from the input buffer to the output buffer. */
;;;407        /*  Subsequent numStages  occur in-place in the output buffer */
;;;408        pIn = pDst;
;;;409    
;;;410        /* Reset the output pointer */
;;;411        pOut = pDst;
;;;412    
;;;413        /* decrement the loop counter */
;;;414        stage--;
;;;415    
;;;416      } while(stage > 0u);
;;;417    
;;;418    #endif /*   #ifndef ARM_MATH_CM0_FAMILY         */
;;;419    
;;;420    }
000106  e8bd81f0          POP      {r4-r8,pc}
;;;421    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_biquad_cascade_df1_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___28_arm_biquad_cascade_df1_f32_c_50ec4510____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___28_arm_biquad_cascade_df1_f32_c_50ec4510____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___28_arm_biquad_cascade_df1_f32_c_50ec4510____REVSH|
#line 144
|__asm___28_arm_biquad_cascade_df1_f32_c_50ec4510____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___28_arm_biquad_cascade_df1_f32_c_50ec4510____RRX|
#line 300
|__asm___28_arm_biquad_cascade_df1_f32_c_50ec4510____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
