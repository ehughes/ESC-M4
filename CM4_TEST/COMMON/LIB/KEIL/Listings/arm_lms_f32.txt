; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_lms_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_lms_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_lms_f32.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_lms_f32.c]
                          THUMB

                          AREA ||i.arm_lms_f32||, CODE, READONLY, ALIGN=2

                  arm_lms_f32 PROC
;;;180    
;;;181    void arm_lms_f32(
000000  e92d4ffc          PUSH     {r2-r11,lr}
;;;182      const arm_lms_instance_f32 * S,
;;;183      float32_t * pSrc,
;;;184      float32_t * pRef,
;;;185      float32_t * pOut,
;;;186      float32_t * pErr,
;;;187      uint32_t blockSize)
;;;188    {
000004  e9ddac0b          LDRD     r10,r12,[sp,#0x2c]
;;;189      float32_t *pState = S->pState;                 /* State pointer */
000008  6844              LDR      r4,[r0,#4]
;;;190      float32_t *pCoeffs = S->pCoeffs;               /* Coefficient pointer */
00000a  f8d0b008          LDR      r11,[r0,#8]
;;;191      float32_t *pStateCurnt;                        /* Points to the current sample of the state */
;;;192      float32_t *px, *pb;                            /* Temporary pointers for state and coefficient buffers */
;;;193      float32_t mu = S->mu;                          /* Adaptive factor */
00000e  ed901a03          VLDR     s2,[r0,#0xc]
;;;194      uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
000012  f8b09000          LDRH     r9,[r0,#0]
;;;195      uint32_t tapCnt, blkCnt;                       /* Loop counters */
;;;196      float32_t sum, e, d;                           /* accumulator, error, reference data sample */
;;;197      float32_t w = 0.0f;                            /* weight factor */
000016  eddf1a55          VLDR     s3,|L1.364|
;;;198    
;;;199      e = 0.0f;
;;;200      d = 0.0f;
;;;201    
;;;202      /* S->pState points to state array which contains previous frame (numTaps - 1) samples */
;;;203      /* pStateCurnt points to the location where the new input data should be written */
;;;204      pStateCurnt = &(S->pState[(numTaps - 1u)]);
00001a  f1a90501          SUB      r5,r9,#1
00001e  eb040885          ADD      r8,r4,r5,LSL #2
000022  9501              STR      r5,[sp,#4]
000024  e07a              B        |L1.284|
                  |L1.38|
;;;205    
;;;206      blkCnt = blockSize;
;;;207    
;;;208    
;;;209    #ifndef ARM_MATH_CM0_FAMILY
;;;210    
;;;211      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;212    
;;;213      while(blkCnt > 0u)
;;;214      {
;;;215        /* Copy the new input sample into the state buffer */
;;;216        *pStateCurnt++ = *pSrc++;
000026  ecb10a01          VLDM     r1!,{s0}
00002a  eca80a01          VSTM     r8!,{s0}
;;;217    
;;;218        /* Initialize pState pointer */
;;;219        px = pState;
00002e  4626              MOV      r6,r4
;;;220    
;;;221        /* Initialize coeff pointer */
;;;222        pb = (pCoeffs);
000030  465d              MOV      r5,r11
;;;223    
;;;224        /* Set the accumulator to zero */
;;;225        sum = 0.0f;
000032  eeb00a61          VMOV.F32 s0,s3
;;;226    
;;;227        /* Loop unrolling.  Process 4 taps at a time. */
;;;228        tapCnt = numTaps >> 2;
000036  ea4f0799          LSR      r7,r9,#2
00003a  46be              MOV      lr,r7
;;;229    
;;;230        while(tapCnt > 0u)
00003c  e018              B        |L1.112|
                  |L1.62|
;;;231        {
;;;232          /* Perform the multiply-accumulate */
;;;233          sum += (*px++) * (*pb++);
00003e  ecf60a01          VLDM     r6!,{s1}
000042  ecb52a01          VLDM     r5!,{s4}
000046  ee000a82          VMLA.F32 s0,s1,s4
;;;234          sum += (*px++) * (*pb++);
00004a  ecf60a01          VLDM     r6!,{s1}
00004e  ecb52a01          VLDM     r5!,{s4}
000052  ee000a82          VMLA.F32 s0,s1,s4
;;;235          sum += (*px++) * (*pb++);
000056  ecf60a01          VLDM     r6!,{s1}
00005a  ecb52a01          VLDM     r5!,{s4}
00005e  ee000a82          VMLA.F32 s0,s1,s4
;;;236          sum += (*px++) * (*pb++);
000062  ecf60a01          VLDM     r6!,{s1}
000066  ecb52a01          VLDM     r5!,{s4}
00006a  ee000a82          VMLA.F32 s0,s1,s4
;;;237    
;;;238          /* Decrement the loop counter */
;;;239          tapCnt--;
00006e  1e7f              SUBS     r7,r7,#1
                  |L1.112|
000070  2f00              CMP      r7,#0                 ;230
000072  d1e4              BNE      |L1.62|
;;;240        }
;;;241    
;;;242        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;243        tapCnt = numTaps % 0x4u;
000074  f0090703          AND      r7,r9,#3
000078  9700              STR      r7,[sp,#0]
;;;244    
;;;245        while(tapCnt > 0u)
00007a  e006              B        |L1.138|
                  |L1.124|
;;;246        {
;;;247          /* Perform the multiply-accumulate */
;;;248          sum += (*px++) * (*pb++);
00007c  ecf60a01          VLDM     r6!,{s1}
000080  ecb52a01          VLDM     r5!,{s4}
000084  ee000a82          VMLA.F32 s0,s1,s4
;;;249    
;;;250          /* Decrement the loop counter */
;;;251          tapCnt--;
000088  1e7f              SUBS     r7,r7,#1
                  |L1.138|
00008a  2f00              CMP      r7,#0                 ;245
00008c  d1f6              BNE      |L1.124|
;;;252        }
;;;253    
;;;254        /* The result in the accumulator, store in the destination buffer. */
;;;255        *pOut++ = sum;
00008e  eca30a01          VSTM     r3!,{s0}
;;;256    
;;;257        /* Compute and store error */
;;;258        d = (float32_t) (*pRef++);
000092  ecf20a01          VLDM     r2!,{s1}
;;;259        e = d - sum;
000096  ee300ac0          VSUB.F32 s0,s1,s0
;;;260        *pErr++ = e;
00009a  ecaa0a01          VSTM     r10!,{s0}
;;;261    
;;;262        /* Calculation of Weighting factor for the updating filter coefficients */
;;;263        w = e * mu;
00009e  ee200a01          VMUL.F32 s0,s0,s2
;;;264    
;;;265        /* Initialize pState pointer */
;;;266        px = pState;
0000a2  4626              MOV      r6,r4
;;;267    
;;;268        /* Initialize coeff pointer */
;;;269        pb = (pCoeffs);
0000a4  465d              MOV      r5,r11
;;;270    
;;;271        /* Loop unrolling.  Process 4 taps at a time. */
;;;272        tapCnt = numTaps >> 2;
;;;273    
;;;274        /* Update filter coefficients */
;;;275        while(tapCnt > 0u)
0000a6  e025              B        |L1.244|
                  |L1.168|
;;;276        {
;;;277          /* Perform the multiply-accumulate */
;;;278          *pb = *pb + (w * (*px++));
0000a8  ecb62a01          VLDM     r6!,{s4}
0000ac  edd50a00          VLDR     s1,[r5,#0]
0000b0  ee400a02          VMLA.F32 s1,s0,s4
0000b4  edc50a00          VSTR     s1,[r5,#0]
;;;279          pb++;
0000b8  1d2d              ADDS     r5,r5,#4
;;;280    
;;;281          *pb = *pb + (w * (*px++));
0000ba  ecb62a01          VLDM     r6!,{s4}
0000be  edd50a00          VLDR     s1,[r5,#0]
0000c2  ee400a02          VMLA.F32 s1,s0,s4
0000c6  edc50a00          VSTR     s1,[r5,#0]
;;;282          pb++;
0000ca  1d2d              ADDS     r5,r5,#4
;;;283    
;;;284          *pb = *pb + (w * (*px++));
0000cc  ecb62a01          VLDM     r6!,{s4}
0000d0  edd50a00          VLDR     s1,[r5,#0]
0000d4  ee400a02          VMLA.F32 s1,s0,s4
0000d8  edc50a00          VSTR     s1,[r5,#0]
;;;285          pb++;
0000dc  1d2d              ADDS     r5,r5,#4
;;;286    
;;;287          *pb = *pb + (w * (*px++));
0000de  ecb62a01          VLDM     r6!,{s4}
0000e2  edd50a00          VLDR     s1,[r5,#0]
0000e6  ee400a02          VMLA.F32 s1,s0,s4
0000ea  edc50a00          VSTR     s1,[r5,#0]
;;;288          pb++;
0000ee  1d2d              ADDS     r5,r5,#4
;;;289    
;;;290          /* Decrement the loop counter */
;;;291          tapCnt--;
0000f0  f1ae0e01          SUB      lr,lr,#1
                  |L1.244|
0000f4  f1be0f00          CMP      lr,#0                 ;275
0000f8  d1d6              BNE      |L1.168|
;;;292        }
;;;293    
;;;294        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;295        tapCnt = numTaps % 0x4u;
0000fa  9f00              LDR      r7,[sp,#0]
;;;296    
;;;297        while(tapCnt > 0u)
0000fc  e009              B        |L1.274|
                  |L1.254|
;;;298        {
;;;299          /* Perform the multiply-accumulate */
;;;300          *pb = *pb + (w * (*px++));
0000fe  ecb62a01          VLDM     r6!,{s4}
000102  edd50a00          VLDR     s1,[r5,#0]
000106  ee400a02          VMLA.F32 s1,s0,s4
00010a  edc50a00          VSTR     s1,[r5,#0]
;;;301          pb++;
00010e  1d2d              ADDS     r5,r5,#4
;;;302    
;;;303          /* Decrement the loop counter */
;;;304          tapCnt--;
000110  1e7f              SUBS     r7,r7,#1
                  |L1.274|
000112  2f00              CMP      r7,#0                 ;297
000114  d1f3              BNE      |L1.254|
;;;305        }
;;;306    
;;;307        /* Advance state pointer by 1 for the next sample */
;;;308        pState = pState + 1;
000116  1d24              ADDS     r4,r4,#4
;;;309    
;;;310        /* Decrement the loop counter */
;;;311        blkCnt--;
000118  f1ac0c01          SUB      r12,r12,#1
                  |L1.284|
00011c  f1bc0f00          CMP      r12,#0                ;213
000120  d181              BNE      |L1.38|
;;;312      }
;;;313    
;;;314    
;;;315      /* Processing is complete. Now copy the last numTaps - 1 samples to the    
;;;316         satrt of the state buffer. This prepares the state buffer for the    
;;;317         next function call. */
;;;318    
;;;319      /* Points to the start of the pState buffer */
;;;320      pStateCurnt = S->pState;
000122  6840              LDR      r0,[r0,#4]
;;;321    
;;;322      /* Loop unrolling for (numTaps - 1u) samples copy */
;;;323      tapCnt = (numTaps - 1u) >> 2u;
000124  9901              LDR      r1,[sp,#4]
000126  0889              LSRS     r1,r1,#2
;;;324    
;;;325      /* copy data */
;;;326      while(tapCnt > 0u)
000128  e010              B        |L1.332|
                  |L1.298|
;;;327      {
;;;328        *pStateCurnt++ = *pState++;
00012a  ecb40a01          VLDM     r4!,{s0}
00012e  eca00a01          VSTM     r0!,{s0}
;;;329        *pStateCurnt++ = *pState++;
000132  ecb40a01          VLDM     r4!,{s0}
000136  eca00a01          VSTM     r0!,{s0}
;;;330        *pStateCurnt++ = *pState++;
00013a  ecb40a01          VLDM     r4!,{s0}
00013e  eca00a01          VSTM     r0!,{s0}
;;;331        *pStateCurnt++ = *pState++;
000142  ecb40a01          VLDM     r4!,{s0}
000146  eca00a01          VSTM     r0!,{s0}
;;;332    
;;;333        /* Decrement the loop counter */
;;;334        tapCnt--;
00014a  1e49              SUBS     r1,r1,#1
                  |L1.332|
00014c  2900              CMP      r1,#0                 ;326
00014e  d1ec              BNE      |L1.298|
;;;335      }
;;;336    
;;;337      /* Calculate remaining number of copies */
;;;338      tapCnt = (numTaps - 1u) % 0x4u;
000150  9901              LDR      r1,[sp,#4]
000152  f0010103          AND      r1,r1,#3
;;;339    
;;;340      /* Copy the remaining q31_t data */
;;;341      while(tapCnt > 0u)
000156  e004              B        |L1.354|
                  |L1.344|
;;;342      {
;;;343        *pStateCurnt++ = *pState++;
000158  ecb40a01          VLDM     r4!,{s0}
00015c  eca00a01          VSTM     r0!,{s0}
;;;344    
;;;345        /* Decrement the loop counter */
;;;346        tapCnt--;
000160  1e49              SUBS     r1,r1,#1
                  |L1.354|
000162  2900              CMP      r1,#0                 ;341
000164  d1f8              BNE      |L1.344|
;;;347      }
;;;348    
;;;349    #else
;;;350    
;;;351      /* Run the below code for Cortex-M0 */
;;;352    
;;;353      while(blkCnt > 0u)
;;;354      {
;;;355        /* Copy the new input sample into the state buffer */
;;;356        *pStateCurnt++ = *pSrc++;
;;;357    
;;;358        /* Initialize pState pointer */
;;;359        px = pState;
;;;360    
;;;361        /* Initialize pCoeffs pointer */
;;;362        pb = pCoeffs;
;;;363    
;;;364        /* Set the accumulator to zero */
;;;365        sum = 0.0f;
;;;366    
;;;367        /* Loop over numTaps number of values */
;;;368        tapCnt = numTaps;
;;;369    
;;;370        while(tapCnt > 0u)
;;;371        {
;;;372          /* Perform the multiply-accumulate */
;;;373          sum += (*px++) * (*pb++);
;;;374    
;;;375          /* Decrement the loop counter */
;;;376          tapCnt--;
;;;377        }
;;;378    
;;;379        /* The result is stored in the destination buffer. */
;;;380        *pOut++ = sum;
;;;381    
;;;382        /* Compute and store error */
;;;383        d = (float32_t) (*pRef++);
;;;384        e = d - sum;
;;;385        *pErr++ = e;
;;;386    
;;;387        /* Weighting factor for the LMS version */
;;;388        w = e * mu;
;;;389    
;;;390        /* Initialize pState pointer */
;;;391        px = pState;
;;;392    
;;;393        /* Initialize pCoeffs pointer */
;;;394        pb = pCoeffs;
;;;395    
;;;396        /* Loop over numTaps number of values */
;;;397        tapCnt = numTaps;
;;;398    
;;;399        while(tapCnt > 0u)
;;;400        {
;;;401          /* Perform the multiply-accumulate */
;;;402          *pb = *pb + (w * (*px++));
;;;403          pb++;
;;;404    
;;;405          /* Decrement the loop counter */
;;;406          tapCnt--;
;;;407        }
;;;408    
;;;409        /* Advance state pointer by 1 for the next sample */
;;;410        pState = pState + 1;
;;;411    
;;;412        /* Decrement the loop counter */
;;;413        blkCnt--;
;;;414      }
;;;415    
;;;416    
;;;417      /* Processing is complete. Now copy the last numTaps - 1 samples to the        
;;;418       * start of the state buffer. This prepares the state buffer for the        
;;;419       * next function call. */
;;;420    
;;;421      /* Points to the start of the pState buffer */
;;;422      pStateCurnt = S->pState;
;;;423    
;;;424      /*  Copy (numTaps - 1u) samples  */
;;;425      tapCnt = (numTaps - 1u);
;;;426    
;;;427      /* Copy the data */
;;;428      while(tapCnt > 0u)
;;;429      {
;;;430        *pStateCurnt++ = *pState++;
;;;431    
;;;432        /* Decrement the loop counter */
;;;433        tapCnt--;
;;;434      }
;;;435    
;;;436    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;437    
;;;438    }
000166  e8bd8ffc          POP      {r2-r11,pc}
;;;439    
                          ENDP

00016a  0000              DCW      0x0000
                  |L1.364|
00016c  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_lms_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_lms_f32_c_8ccd16f4____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___13_arm_lms_f32_c_8ccd16f4____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_lms_f32_c_8ccd16f4____REVSH|
#line 144
|__asm___13_arm_lms_f32_c_8ccd16f4____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_lms_f32_c_8ccd16f4____RRX|
#line 300
|__asm___13_arm_lms_f32_c_8ccd16f4____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
