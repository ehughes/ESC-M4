; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_fast_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_fast_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_conv_fast_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_fast_q15.c]
                          THUMB

                          AREA ||i.arm_conv_fast_q15||, CODE, READONLY, ALIGN=1

                  arm_conv_fast_q15 PROC
;;;76     
;;;77     void arm_conv_fast_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;78       q15_t * pSrcA,
;;;79       uint32_t srcALen,
;;;80       q15_t * pSrcB,
;;;81       uint32_t srcBLen,
;;;82       q15_t * pDst)
;;;83     {
000004  b089              SUB      sp,sp,#0x24
000006  9916              LDR      r1,[sp,#0x58]
;;;84     #ifndef UNALIGNED_SUPPORT_DISABLE
;;;85       q15_t *pIn1;                                   /* inputA pointer */
;;;86       q15_t *pIn2;                                   /* inputB pointer */
;;;87       q15_t *pOut = pDst;                            /* output pointer */
;;;88       q31_t sum, acc0, acc1, acc2, acc3;             /* Accumulator */
;;;89       q15_t *px;                                     /* Intermediate inputA pointer  */
;;;90       q15_t *py;                                     /* Intermediate inputB pointer  */
;;;91       q15_t *pSrc1, *pSrc2;                          /* Intermediate pointers */
;;;92       q31_t x0, x1, x2, x3, c0;                      /* Temporary variables to hold state and coefficient values */
;;;93       uint32_t blockSize1, blockSize2, blockSize3, j, k, count, blkCnt;     /* loop counter */
;;;94     
;;;95       /* The algorithm implementation is based on the lengths of the inputs. */
;;;96       /* srcB is always made to slide across srcA. */
;;;97       /* So srcBLen is always considered as shorter or equal to srcALen */
;;;98       if(srcALen >= srcBLen)
000008  9c0a              LDR      r4,[sp,#0x28]
00000a  429c              CMP      r4,r3
00000c  d302              BCC      |L1.20|
;;;99       {
;;;100        /* Initialization of inputA pointer */
;;;101        pIn1 = pSrcA;
00000e  9006              STR      r0,[sp,#0x18]
;;;102    
;;;103        /* Initialization of inputB pointer */
;;;104        pIn2 = pSrcB;
000010  4610              MOV      r0,r2
000012  e003              B        |L1.28|
                  |L1.20|
;;;105      }
;;;106      else
;;;107      {
;;;108        /* Initialization of inputA pointer */
;;;109        pIn1 = pSrcB;
000014  9206              STR      r2,[sp,#0x18]
;;;110    
;;;111        /* Initialization of inputB pointer */
;;;112        pIn2 = pSrcA;
;;;113    
;;;114        /* srcBLen is always considered as shorter or equal to srcALen */
;;;115        j = srcBLen;
000016  461a              MOV      r2,r3
;;;116        srcBLen = srcALen;
000018  9b0a              LDR      r3,[sp,#0x28]
;;;117        srcALen = j;
00001a  920a              STR      r2,[sp,#0x28]
                  |L1.28|
;;;118      }
;;;119    
;;;120      /* conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1] */
;;;121      /* The function is internally   
;;;122       * divided into three stages according to the number of multiplications that has to be   
;;;123       * taken place between inputA samples and inputB samples. In the first stage of the   
;;;124       * algorithm, the multiplications increase by one for every iteration.   
;;;125       * In the second stage of the algorithm, srcBLen number of multiplications are done.   
;;;126       * In the third stage of the algorithm, the multiplications decrease by one   
;;;127       * for every iteration. */
;;;128    
;;;129      /* The algorithm is implemented in three stages.   
;;;130         The loop counters of each stage is initiated here. */
;;;131      blockSize1 = srcBLen - 1u;
00001c  f1a30801          SUB      r8,r3,#1
;;;132      blockSize2 = srcALen - (srcBLen - 1u);
000020  9a0a              LDR      r2,[sp,#0x28]
000022  1ad2              SUBS     r2,r2,r3
000024  1c52              ADDS     r2,r2,#1
000026  9202              STR      r2,[sp,#8]
;;;133      blockSize3 = blockSize1;
000028  46c4              MOV      r12,r8
;;;134    
;;;135      /* --------------------------   
;;;136       * Initializations of stage1   
;;;137       * -------------------------*/
;;;138    
;;;139      /* sum = x[0] * y[0]   
;;;140       * sum = x[0] * y[1] + x[1] * y[0]   
;;;141       * ....   
;;;142       * sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]   
;;;143       */
;;;144    
;;;145      /* In this stage the MAC operations are increased by 1 for every iteration.   
;;;146         The count variable holds the number of MAC operations performed */
;;;147      count = 1u;
00002a  2501              MOVS     r5,#1
;;;148    
;;;149      /* Working pointer of inputA */
;;;150      px = pIn1;
00002c  9c06              LDR      r4,[sp,#0x18]
;;;151    
;;;152      /* Working pointer of inputB */
;;;153      py = pIn2;
00002e  4607              MOV      r7,r0
;;;154    
;;;155    
;;;156      /* ------------------------   
;;;157       * Stage1 process   
;;;158       * ----------------------*/
;;;159    
;;;160      /* For loop unrolling by 4, this stage is divided into two. */
;;;161      /* First part of this stage computes the MAC operations less than 4 */
;;;162      /* Second part of this stage computes the MAC operations greater than or equal to 4 */
;;;163    
;;;164      /* The first part of the stage starts here */
;;;165      while((count < 4u) && (blockSize1 > 0u))
000030  e014              B        |L1.92|
                  |L1.50|
;;;166      {
;;;167        /* Accumulator is made zero for every iteration */
;;;168        sum = 0;
000032  2200              MOVS     r2,#0
;;;169    
;;;170        /* Loop over number of MAC operations between   
;;;171         * inputA samples and inputB samples */
;;;172        k = count;
000034  462e              MOV      r6,r5
;;;173    
;;;174        while(k > 0u)
000036  e006              B        |L1.70|
                  |L1.56|
;;;175        {
;;;176          /* Perform the multiply-accumulates */
;;;177          sum = __SMLAD(*px++, *py--, sum);
000038  f9349b02          LDRSH    r9,[r4],#2
00003c  f937a902          LDRSH    r10,[r7],#-2
000040  fb29220a          SMLAD    r2,r9,r10,r2
;;;178    
;;;179          /* Decrement the loop counter */
;;;180          k--;
000044  1e76              SUBS     r6,r6,#1
                  |L1.70|
000046  2e00              CMP      r6,#0                 ;174
000048  d1f6              BNE      |L1.56|
;;;181        }
;;;182    
;;;183        /* Store the result in the accumulator in the destination buffer. */
;;;184        *pOut++ = (q15_t) (sum >> 15);
00004a  13d2              ASRS     r2,r2,#15
00004c  f8212b02          STRH     r2,[r1],#2
;;;185    
;;;186        /* Update the inputA and inputB pointers for next MAC calculation */
;;;187        py = pIn2 + count;
000050  eb000745          ADD      r7,r0,r5,LSL #1
;;;188        px = pIn1;
000054  9c06              LDR      r4,[sp,#0x18]
;;;189    
;;;190        /* Increment the MAC count */
;;;191        count++;
000056  1c6d              ADDS     r5,r5,#1
;;;192    
;;;193        /* Decrement the loop counter */
;;;194        blockSize1--;
000058  f1a80801          SUB      r8,r8,#1
                  |L1.92|
00005c  2d04              CMP      r5,#4                 ;165
00005e  d202              BCS      |L1.102|
000060  f1b80f00          CMP      r8,#0                 ;165
000064  d1e5              BNE      |L1.50|
                  |L1.102|
;;;195      }
;;;196    
;;;197      /* The second part of the stage starts here */
;;;198      /* The internal loop, over count, is unrolled by 4 */
;;;199      /* To, read the last two inputB samples using SIMD:   
;;;200       * y[srcBLen] and y[srcBLen-1] coefficients, py is decremented by 1 */
;;;201      py = py - 1;
000066  1ebf              SUBS     r7,r7,#2
;;;202    
;;;203      while(blockSize1 > 0u)
000068  e02c              B        |L1.196|
                  |L1.106|
;;;204      {
;;;205        /* Accumulator is made zero for every iteration */
;;;206        sum = 0;
00006a  2600              MOVS     r6,#0
;;;207    
;;;208        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;209        k = count >> 2u;
00006c  ea4f0995          LSR      r9,r5,#2
;;;210    
;;;211        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;212         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;213        while(k > 0u)
000070  e00c              B        |L1.140|
                  |L1.114|
;;;214        {
;;;215          /* Perform the multiply-accumulates */
;;;216          /* x[0], x[1] are multiplied with y[srcBLen - 1], y[srcBLen - 2] respectively */
;;;217          sum = __SMLADX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
000072  6822              LDR      r2,[r4,#0]
000074  f857a904          LDR      r10,[r7],#-4
000078  fb22621a          SMLADX   r2,r2,r10,r6
;;;218          /* x[2], x[3] are multiplied with y[srcBLen - 3], y[srcBLen - 4] respectively */
;;;219          sum = __SMLADX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
00007c  6866              LDR      r6,[r4,#4]
00007e  f857a904          LDR      r10,[r7],#-4
000082  3408              ADDS     r4,r4,#8
000084  fb26261a          SMLADX   r6,r6,r10,r2
;;;220    
;;;221          /* Decrement the loop counter */
;;;222          k--;
000088  f1a90901          SUB      r9,r9,#1
                  |L1.140|
00008c  f1b90f00          CMP      r9,#0                 ;213
000090  d1ef              BNE      |L1.114|
;;;223        }
;;;224    
;;;225        /* For the next MAC operations, the pointer py is used without SIMD   
;;;226         * So, py is incremented by 1 */
;;;227        py = py + 1u;
000092  1cbf              ADDS     r7,r7,#2
;;;228    
;;;229        /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;230         ** No loop unrolling is used. */
;;;231        k = count % 0x4u;
000094  f0050903          AND      r9,r5,#3
;;;232    
;;;233        while(k > 0u)
000098  e007              B        |L1.170|
                  |L1.154|
;;;234        {
;;;235          /* Perform the multiply-accumulates */
;;;236          sum = __SMLAD(*px++, *py--, sum);
00009a  f9342b02          LDRSH    r2,[r4],#2
00009e  f937a902          LDRSH    r10,[r7],#-2
0000a2  fb22660a          SMLAD    r6,r2,r10,r6
;;;237    
;;;238          /* Decrement the loop counter */
;;;239          k--;
0000a6  f1a90901          SUB      r9,r9,#1
                  |L1.170|
0000aa  f1b90f00          CMP      r9,#0                 ;233
0000ae  d1f4              BNE      |L1.154|
;;;240        }
;;;241    
;;;242        /* Store the result in the accumulator in the destination buffer. */
;;;243        *pOut++ = (q15_t) (sum >> 15);
0000b0  13f2              ASRS     r2,r6,#15
0000b2  f8212b02          STRH     r2,[r1],#2
;;;244    
;;;245        /* Update the inputA and inputB pointers for next MAC calculation */
;;;246        py = pIn2 + (count - 1u);
0000b6  1e6a              SUBS     r2,r5,#1
0000b8  eb000742          ADD      r7,r0,r2,LSL #1
;;;247        px = pIn1;
0000bc  9c06              LDR      r4,[sp,#0x18]
;;;248    
;;;249        /* Increment the MAC count */
;;;250        count++;
0000be  1c6d              ADDS     r5,r5,#1
;;;251    
;;;252        /* Decrement the loop counter */
;;;253        blockSize1--;
0000c0  f1a80801          SUB      r8,r8,#1
                  |L1.196|
0000c4  f1b80f00          CMP      r8,#0                 ;203
0000c8  d1cf              BNE      |L1.106|
;;;254      }
;;;255    
;;;256      /* --------------------------   
;;;257       * Initializations of stage2   
;;;258       * ------------------------*/
;;;259    
;;;260      /* sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0]   
;;;261       * sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0]   
;;;262       * ....   
;;;263       * sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]   
;;;264       */
;;;265    
;;;266      /* Working pointer of inputA */
;;;267      px = pIn1;
;;;268    
;;;269      /* Working pointer of inputB */
;;;270      pSrc2 = pIn2 + (srcBLen - 1u);
0000ca  1e5a              SUBS     r2,r3,#1
0000cc  eb000842          ADD      r8,r0,r2,LSL #1
0000d0  e9cd8207          STRD     r8,r2,[sp,#0x1c]
0000d4  f8cd8014          STR      r8,[sp,#0x14]
;;;271      py = pSrc2;
0000d8  f8dd8014          LDR      r8,[sp,#0x14]
;;;272    
;;;273      /* count is the index by which the pointer pIn1 to be incremented */
;;;274      count = 0u;
0000dc  f04f0900          MOV      r9,#0
;;;275    
;;;276    
;;;277      /* --------------------   
;;;278       * Stage2 process   
;;;279       * -------------------*/
;;;280    
;;;281      /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.   
;;;282       * So, to loop unroll over blockSize2,   
;;;283       * srcBLen should be greater than or equal to 4 */
;;;284      if(srcBLen >= 4u)
0000e0  2b04              CMP      r3,#4
0000e2  d37d              BCC      |L1.480|
;;;285      {
;;;286        /* Loop unroll over blockSize2, by 4 */
;;;287        blkCnt = blockSize2 >> 2u;
0000e4  9802              LDR      r0,[sp,#8]
0000e6  0880              LSRS     r0,r0,#2
0000e8  9000              STR      r0,[sp,#0]
;;;288    
;;;289        while(blkCnt > 0u)
0000ea  e09a              B        |L1.546|
                  |L1.236|
;;;290        {
;;;291          py = py - 1u;
0000ec  f1a80802          SUB      r8,r8,#2
;;;292    
;;;293          /* Set all accumulators to zero */
;;;294          acc0 = 0;
0000f0  2000              MOVS     r0,#0
;;;295          acc1 = 0;
0000f2  2200              MOVS     r2,#0
;;;296          acc2 = 0;
0000f4  2500              MOVS     r5,#0
;;;297          acc3 = 0;
0000f6  2600              MOVS     r6,#0
;;;298    
;;;299    
;;;300          /* read x[0], x[1] samples */
;;;301          x0 = *__SIMD32(px);
0000f8  f8d4a000          LDR      r10,[r4,#0]
;;;302          /* read x[1], x[2] samples */
;;;303          x1 = _SIMD32_OFFSET(px+1);
0000fc  f8d47002          LDR      r7,[r4,#2]
;;;304    	  px+= 2u;
000100  1d24              ADDS     r4,r4,#4
;;;305    
;;;306    
;;;307          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;308          k = srcBLen >> 2u;
000102  ea4f0e93          LSR      lr,r3,#2
                  |L1.262|
;;;309    
;;;310          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;311           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;312          do
;;;313          {
;;;314            /* Read the last two inputB samples using SIMD:   
;;;315             * y[srcBLen - 1] and y[srcBLen - 2] */
;;;316            c0 = *__SIMD32(py)--;
000106  f858b904          LDR      r11,[r8],#-4
;;;317    
;;;318            /* acc0 +=  x[0] * y[srcBLen - 1] + x[1] * y[srcBLen - 2] */
;;;319            acc0 = __SMLADX(x0, c0, acc0);
00010a  fb2a0a1b          SMLADX   r10,r10,r11,r0
;;;320    
;;;321            /* acc1 +=  x[1] * y[srcBLen - 1] + x[2] * y[srcBLen - 2] */
;;;322            acc1 = __SMLADX(x1, c0, acc1);
00010e  fb27271b          SMLADX   r7,r7,r11,r2
;;;323    
;;;324            /* Read x[2], x[3] */
;;;325            x2 = *__SIMD32(px);
000112  6820              LDR      r0,[r4,#0]
;;;326    
;;;327            /* Read x[3], x[4] */
;;;328            x3 = _SIMD32_OFFSET(px+1);
000114  f8d42002          LDR      r2,[r4,#2]
;;;329    
;;;330            /* acc2 +=  x[2] * y[srcBLen - 1] + x[3] * y[srcBLen - 2] */
;;;331            acc2 = __SMLADX(x2, c0, acc2);
000118  fb20551b          SMLADX   r5,r0,r11,r5
;;;332    
;;;333            /* acc3 +=  x[3] * y[srcBLen - 1] + x[4] * y[srcBLen - 2] */
;;;334            acc3 = __SMLADX(x3, c0, acc3);
00011c  fb226b1b          SMLADX   r11,r2,r11,r6
;;;335    
;;;336            /* Read y[srcBLen - 3] and y[srcBLen - 4] */
;;;337            c0 = *__SIMD32(py)--;
000120  f8586904          LDR      r6,[r8],#-4
;;;338    
;;;339            /* acc0 +=  x[2] * y[srcBLen - 3] + x[3] * y[srcBLen - 4] */
;;;340            acc0 = __SMLADX(x2, c0, acc0);
000124  fb20a016          SMLADX   r0,r0,r6,r10
;;;341    
;;;342            /* acc1 +=  x[3] * y[srcBLen - 3] + x[4] * y[srcBLen - 4] */
;;;343            acc1 = __SMLADX(x3, c0, acc1);
000128  fb227216          SMLADX   r2,r2,r6,r7
;;;344    
;;;345            /* Read x[4], x[5] */
;;;346            x0 = _SIMD32_OFFSET(px+2);
00012c  f8d4a004          LDR      r10,[r4,#4]
;;;347    
;;;348            /* Read x[5], x[6] */
;;;349            x1 = _SIMD32_OFFSET(px+3);
000130  f8d47006          LDR      r7,[r4,#6]
;;;350    		px += 4u;
000134  3408              ADDS     r4,r4,#8
;;;351    
;;;352            /* acc2 +=  x[4] * y[srcBLen - 3] + x[5] * y[srcBLen - 4] */
;;;353            acc2 = __SMLADX(x0, c0, acc2);
000136  fb2a5516          SMLADX   r5,r10,r6,r5
;;;354    
;;;355            /* acc3 +=  x[5] * y[srcBLen - 3] + x[6] * y[srcBLen - 4] */
;;;356            acc3 = __SMLADX(x1, c0, acc3);
00013a  fb27b616          SMLADX   r6,r7,r6,r11
;;;357    
;;;358          } while(--k);
00013e  f1be0e01          SUBS     lr,lr,#1
000142  d1e0              BNE      |L1.262|
;;;359    
;;;360          /* For the next MAC operations, SIMD is not used   
;;;361           * So, the 16 bit pointer if inputB, py is updated */
;;;362    
;;;363          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;364           ** No loop unrolling is used. */
;;;365          k = srcBLen % 0x4u;
000144  f0030b03          AND      r11,r3,#3
000148  f8cdb004          STR      r11,[sp,#4]
;;;366    
;;;367          if(k == 1u)
00014c  f8ddb004          LDR      r11,[sp,#4]
000150  f1bb0f01          CMP      r11,#1
000154  d10e              BNE      |L1.372|
;;;368          {
;;;369            /* Read y[srcBLen - 5] */
;;;370            c0 = *(py+1);
000156  f8b8b002          LDRH     r11,[r8,#2]
;;;371    
;;;372    #ifdef  ARM_MATH_BIG_ENDIAN
;;;373    
;;;374            c0 = c0 << 16u;
;;;375    
;;;376    #else
;;;377    
;;;378            c0 = c0 & 0x0000FFFF;
00015a  fa1ffb8b          UXTH     r11,r11
;;;379    
;;;380    #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;381    
;;;382            /* Read x[7] */
;;;383            x3 = *__SIMD32(px);
00015e  f8d4e000          LDR      lr,[r4,#0]
;;;384    		px++;
000162  1ca4              ADDS     r4,r4,#2
;;;385    
;;;386            /* Perform the multiply-accumulates */
;;;387            acc0 = __SMLAD(x0, c0, acc0);
000164  fb2a000b          SMLAD    r0,r10,r11,r0
;;;388            acc1 = __SMLAD(x1, c0, acc1);
000168  fb27220b          SMLAD    r2,r7,r11,r2
;;;389            acc2 = __SMLADX(x1, c0, acc2);
00016c  fb27551b          SMLADX   r5,r7,r11,r5
;;;390            acc3 = __SMLADX(x3, c0, acc3);
000170  fb2e661b          SMLADX   r6,lr,r11,r6
                  |L1.372|
;;;391          }
;;;392    
;;;393          if(k == 2u)
000174  f8ddb004          LDR      r11,[sp,#4]
000178  f1bb0f02          CMP      r11,#2
00017c  d116              BNE      |L1.428|
;;;394          {
;;;395            /* Read y[srcBLen - 5], y[srcBLen - 6] */
;;;396            c0 = _SIMD32_OFFSET(py);
00017e  f8d8b000          LDR      r11,[r8,#0]
;;;397    
;;;398            /* Read x[7], x[8] */
;;;399            x3 = *__SIMD32(px);
000182  f8d4e000          LDR      lr,[r4,#0]
000186  f8cde00c          STR      lr,[sp,#0xc]
;;;400    
;;;401            /* Read x[9] */
;;;402            x2 = _SIMD32_OFFSET(px+1);
00018a  f8d4e002          LDR      lr,[r4,#2]
00018e  f8cde010          STR      lr,[sp,#0x10]
;;;403    		px += 2u;
000192  1d24              ADDS     r4,r4,#4
;;;404    
;;;405            /* Perform the multiply-accumulates */
;;;406            acc0 = __SMLADX(x0, c0, acc0);
000194  fb2a001b          SMLADX   r0,r10,r11,r0
;;;407            acc1 = __SMLADX(x1, c0, acc1);
000198  fb27221b          SMLADX   r2,r7,r11,r2
;;;408            acc2 = __SMLADX(x3, c0, acc2);
00019c  f8dde00c          LDR      lr,[sp,#0xc]
0001a0  fb2e551b          SMLADX   r5,lr,r11,r5
;;;409            acc3 = __SMLADX(x2, c0, acc3);
0001a4  f8dde010          LDR      lr,[sp,#0x10]
0001a8  fb2e661b          SMLADX   r6,lr,r11,r6
                  |L1.428|
;;;410          }
;;;411    
;;;412          if(k == 3u)
0001ac  f8ddb004          LDR      r11,[sp,#4]
0001b0  f1bb0f03          CMP      r11,#3
0001b4  d120              BNE      |L1.504|
;;;413          {
;;;414            /* Read y[srcBLen - 5], y[srcBLen - 6] */
;;;415            c0 = _SIMD32_OFFSET(py);
0001b6  f8d8e000          LDR      lr,[r8,#0]
;;;416    
;;;417            /* Read x[7], x[8] */
;;;418            x3 = *__SIMD32(px);
0001ba  f8d4b000          LDR      r11,[r4,#0]
0001be  f8cdb00c          STR      r11,[sp,#0xc]
;;;419    
;;;420            /* Read x[9] */
;;;421            x2 = _SIMD32_OFFSET(px+1);
0001c2  f8d4b002          LDR      r11,[r4,#2]
;;;422    
;;;423            /* Perform the multiply-accumulates */
;;;424            acc0 = __SMLADX(x0, c0, acc0);
0001c6  fb2a001e          SMLADX   r0,r10,lr,r0
;;;425            acc1 = __SMLADX(x1, c0, acc1);
0001ca  fb27221e          SMLADX   r2,r7,lr,r2
;;;426            acc2 = __SMLADX(x3, c0, acc2);
0001ce  f8dda00c          LDR      r10,[sp,#0xc]
0001d2  fb2a551e          SMLADX   r5,r10,lr,r5
;;;427            acc3 = __SMLADX(x2, c0, acc3);
0001d6  fb2b661e          SMLADX   r6,r11,lr,r6
;;;428    
;;;429            /* Read y[srcBLen - 7] */
;;;430    		c0 = *(py-1);
0001da  f8388c02          LDRH     r8,[r8,#-2]
;;;431    #ifdef  ARM_MATH_BIG_ENDIAN
;;;432    
;;;433            c0 = c0 << 16u;
;;;434    #else
;;;435    
;;;436            c0 = c0 & 0x0000FFFF;
0001de  e000              B        |L1.482|
                  |L1.480|
0001e0  e05c              B        |L1.668|
                  |L1.482|
0001e2  fa1ff888          UXTH     r8,r8
;;;437    #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;438    
;;;439            /* Read x[10] */
;;;440            x3 =  _SIMD32_OFFSET(px+2);
0001e6  6864              LDR      r4,[r4,#4]
;;;441    		px += 3u;
;;;442    
;;;443            /* Perform the multiply-accumulates */
;;;444            acc0 = __SMLADX(x1, c0, acc0);
0001e8  fb270018          SMLADX   r0,r7,r8,r0
;;;445            acc1 = __SMLAD(x2, c0, acc1);
0001ec  fb2b2208          SMLAD    r2,r11,r8,r2
;;;446            acc2 = __SMLADX(x2, c0, acc2);
0001f0  fb2b5518          SMLADX   r5,r11,r8,r5
;;;447            acc3 = __SMLADX(x3, c0, acc3);
0001f4  fb246618          SMLADX   r6,r4,r8,r6
                  |L1.504|
;;;448          }
;;;449    
;;;450          /* Store the results in the accumulators in the destination buffer. */
;;;451    #ifndef ARM_MATH_BIG_ENDIAN
;;;452    
;;;453          *__SIMD32(pOut)++ = __PKHBT((acc0 >> 15), (acc1 >> 15), 16);
0001f8  13c0              ASRS     r0,r0,#15
0001fa  13d2              ASRS     r2,r2,#15
0001fc  eac04002          PKHBT    r0,r0,r2,LSL #16
000200  6008              STR      r0,[r1,#0]
;;;454          *__SIMD32(pOut)++ = __PKHBT((acc2 >> 15), (acc3 >> 15), 16);
000202  13e8              ASRS     r0,r5,#15
000204  13f2              ASRS     r2,r6,#15
000206  eac04002          PKHBT    r0,r0,r2,LSL #16
00020a  6048              STR      r0,[r1,#4]
00020c  3108              ADDS     r1,r1,#8
;;;455    
;;;456    #else
;;;457    
;;;458          *__SIMD32(pOut)++ = __PKHBT((acc1 >> 15), (acc0 >> 15), 16);
;;;459          *__SIMD32(pOut)++ = __PKHBT((acc3 >> 15), (acc2 >> 15), 16);
;;;460    
;;;461    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;462    
;;;463          /* Increment the pointer pIn1 index, count by 4 */
;;;464          count += 4u;
00020e  f1090904          ADD      r9,r9,#4
;;;465    
;;;466          /* Update the inputA and inputB pointers for next MAC calculation */
;;;467          px = pIn1 + count;
000212  9806              LDR      r0,[sp,#0x18]
000214  eb000449          ADD      r4,r0,r9,LSL #1
;;;468          py = pSrc2;
000218  f8dd8014          LDR      r8,[sp,#0x14]
;;;469    
;;;470          /* Decrement the loop counter */
;;;471          blkCnt--;
00021c  9800              LDR      r0,[sp,#0]
00021e  1e40              SUBS     r0,r0,#1
000220  9000              STR      r0,[sp,#0]
                  |L1.546|
000222  9800              LDR      r0,[sp,#0]            ;289
000224  2800              CMP      r0,#0                 ;289
000226  f47faf61          BNE      |L1.236|
;;;472        }
;;;473    
;;;474        /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.   
;;;475         ** No loop unrolling is used. */
;;;476        blkCnt = blockSize2 % 0x4u;
00022a  9802              LDR      r0,[sp,#8]
00022c  f0000203          AND      r2,r0,#3
;;;477    
;;;478        while(blkCnt > 0u)
000230  e031              B        |L1.662|
                  |L1.562|
;;;479        {
;;;480          /* Accumulator is made zero for every iteration */
;;;481          sum = 0;
000232  2500              MOVS     r5,#0
;;;482    
;;;483          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;484          k = srcBLen >> 2u;
000234  0898              LSRS     r0,r3,#2
;;;485    
;;;486          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;487           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;488          while(k > 0u)
000236  e015              B        |L1.612|
                  |L1.568|
;;;489          {
;;;490            /* Perform the multiply-accumulates */
;;;491            sum += ((q31_t) * px++ * *py--);
000238  8826              LDRH     r6,[r4,#0]
00023a  f8387902          LDRH     r7,[r8],#-2
00023e  fb165507          SMLABB   r5,r6,r7,r5
;;;492            sum += ((q31_t) * px++ * *py--);
000242  8866              LDRH     r6,[r4,#2]
000244  f8387902          LDRH     r7,[r8],#-2
000248  fb165507          SMLABB   r5,r6,r7,r5
;;;493            sum += ((q31_t) * px++ * *py--);
00024c  88a6              LDRH     r6,[r4,#4]
00024e  f8387902          LDRH     r7,[r8],#-2
000252  fb165507          SMLABB   r5,r6,r7,r5
;;;494            sum += ((q31_t) * px++ * *py--);
000256  88e6              LDRH     r6,[r4,#6]
000258  f8387902          LDRH     r7,[r8],#-2
00025c  3408              ADDS     r4,r4,#8
00025e  fb165507          SMLABB   r5,r6,r7,r5
;;;495    
;;;496            /* Decrement the loop counter */
;;;497            k--;
000262  1e40              SUBS     r0,r0,#1
                  |L1.612|
000264  2800              CMP      r0,#0                 ;488
000266  d1e7              BNE      |L1.568|
;;;498          }
;;;499    
;;;500          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;501           ** No loop unrolling is used. */
;;;502          k = srcBLen % 0x4u;
000268  f0030003          AND      r0,r3,#3
;;;503    
;;;504          while(k > 0u)
00026c  e006              B        |L1.636|
                  |L1.622|
;;;505          {
;;;506            /* Perform the multiply-accumulates */
;;;507            sum += ((q31_t) * px++ * *py--);
00026e  f8346b02          LDRH     r6,[r4],#2
000272  f8387902          LDRH     r7,[r8],#-2
000276  fb165507          SMLABB   r5,r6,r7,r5
;;;508    
;;;509            /* Decrement the loop counter */
;;;510            k--;
00027a  1e40              SUBS     r0,r0,#1
                  |L1.636|
00027c  2800              CMP      r0,#0                 ;504
00027e  d1f6              BNE      |L1.622|
;;;511          }
;;;512    
;;;513          /* Store the result in the accumulator in the destination buffer. */
;;;514          *pOut++ = (q15_t) (sum >> 15);
000280  13e8              ASRS     r0,r5,#15
000282  f8210b02          STRH     r0,[r1],#2
;;;515    
;;;516          /* Increment the pointer pIn1 index, count by 1 */
;;;517          count++;
000286  f1090901          ADD      r9,r9,#1
;;;518    
;;;519          /* Update the inputA and inputB pointers for next MAC calculation */
;;;520          px = pIn1 + count;
00028a  9806              LDR      r0,[sp,#0x18]
00028c  eb000449          ADD      r4,r0,r9,LSL #1
;;;521          py = pSrc2;
000290  f8dd8014          LDR      r8,[sp,#0x14]
;;;522    
;;;523          /* Decrement the loop counter */
;;;524          blkCnt--;
000294  1e52              SUBS     r2,r2,#1
                  |L1.662|
000296  2a00              CMP      r2,#0                 ;478
000298  d1cb              BNE      |L1.562|
00029a  e01a              B        |L1.722|
                  |L1.668|
;;;525        }
;;;526      }
;;;527      else
;;;528      {
;;;529        /* If the srcBLen is not a multiple of 4,   
;;;530         * the blockSize2 loop cannot be unrolled by 4 */
;;;531        blkCnt = blockSize2;
00029c  9d02              LDR      r5,[sp,#8]
;;;532    
;;;533        while(blkCnt > 0u)
00029e  e016              B        |L1.718|
                  |L1.672|
;;;534        {
;;;535          /* Accumulator is made zero for every iteration */
;;;536          sum = 0;
0002a0  2200              MOVS     r2,#0
;;;537    
;;;538          /* srcBLen number of MACS should be performed */
;;;539          k = srcBLen;
0002a2  4618              MOV      r0,r3
;;;540    
;;;541          while(k > 0u)
0002a4  e006              B        |L1.692|
                  |L1.678|
;;;542          {
;;;543            /* Perform the multiply-accumulate */
;;;544            sum += ((q31_t) * px++ * *py--);
0002a6  f8346b02          LDRH     r6,[r4],#2
0002aa  f8387902          LDRH     r7,[r8],#-2
0002ae  fb162207          SMLABB   r2,r6,r7,r2
;;;545    
;;;546            /* Decrement the loop counter */
;;;547            k--;
0002b2  1e40              SUBS     r0,r0,#1
                  |L1.692|
0002b4  2800              CMP      r0,#0                 ;541
0002b6  d1f6              BNE      |L1.678|
;;;548          }
;;;549    
;;;550          /* Store the result in the accumulator in the destination buffer. */
;;;551          *pOut++ = (q15_t) (sum >> 15);
0002b8  13d0              ASRS     r0,r2,#15
0002ba  f8210b02          STRH     r0,[r1],#2
;;;552    
;;;553          /* Increment the MAC count */
;;;554          count++;
0002be  f1090901          ADD      r9,r9,#1
;;;555    
;;;556          /* Update the inputA and inputB pointers for next MAC calculation */
;;;557          px = pIn1 + count;
0002c2  9806              LDR      r0,[sp,#0x18]
0002c4  eb000449          ADD      r4,r0,r9,LSL #1
;;;558          py = pSrc2;
0002c8  f8dd8014          LDR      r8,[sp,#0x14]
;;;559    
;;;560          /* Decrement the loop counter */
;;;561          blkCnt--;
0002cc  1e6d              SUBS     r5,r5,#1
                  |L1.718|
0002ce  2d00              CMP      r5,#0                 ;533
0002d0  d1e6              BNE      |L1.672|
                  |L1.722|
;;;562        }
;;;563      }
;;;564    
;;;565    
;;;566      /* --------------------------   
;;;567       * Initializations of stage3   
;;;568       * -------------------------*/
;;;569    
;;;570      /* sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1]   
;;;571       * sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2]   
;;;572       * ....   
;;;573       * sum +=  x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2]   
;;;574       * sum +=  x[srcALen-1] * y[srcBLen-1]   
;;;575       */
;;;576    
;;;577      /* In this stage the MAC operations are decreased by 1 for every iteration.   
;;;578         The blockSize3 variable holds the number of MAC operations performed */
;;;579    
;;;580      /* Working pointer of inputA */
;;;581      pSrc1 = (pIn1 + srcALen) - (srcBLen - 1u);
0002d2  9a0a              LDR      r2,[sp,#0x28]
0002d4  9806              LDR      r0,[sp,#0x18]
0002d6  eb000242          ADD      r2,r0,r2,LSL #1
0002da  9808              LDR      r0,[sp,#0x20]
0002dc  eba20540          SUB      r5,r2,r0,LSL #1
;;;582      px = pSrc1;
0002e0  4628              MOV      r0,r5
;;;583    
;;;584      /* Working pointer of inputB */
;;;585      pSrc2 = pIn2 + (srcBLen - 1u);
0002e2  9e07              LDR      r6,[sp,#0x1c]
;;;586      pIn2 = pSrc2 - 1u;
0002e4  f1a60802          SUB      r8,r6,#2
;;;587      py = pIn2;
0002e8  4643              MOV      r3,r8
;;;588    
;;;589      /* -------------------   
;;;590       * Stage3 process   
;;;591       * ------------------*/
;;;592    
;;;593      /* For loop unrolling by 4, this stage is divided into two. */
;;;594      /* First part of this stage computes the MAC operations greater than 4 */
;;;595      /* Second part of this stage computes the MAC operations less than or equal to 4 */
;;;596    
;;;597      /* The first part of the stage starts here */
;;;598      j = blockSize3 >> 2u;
0002ea  ea4f079c          LSR      r7,r12,#2
;;;599    
;;;600      while((j > 0u) && (blockSize3 > 0u))
0002ee  e028              B        |L1.834|
                  |L1.752|
;;;601      {
;;;602        /* Accumulator is made zero for every iteration */
;;;603        sum = 0;
0002f0  2200              MOVS     r2,#0
;;;604    
;;;605        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;606        k = blockSize3 >> 2u;
0002f2  ea4f049c          LSR      r4,r12,#2
;;;607    
;;;608        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;609         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;610        while(k > 0u)
0002f6  e00c              B        |L1.786|
                  |L1.760|
;;;611        {
;;;612          /* x[srcALen - srcBLen + 1], x[srcALen - srcBLen + 2] are multiplied   
;;;613           * with y[srcBLen - 1], y[srcBLen - 2] respectively */
;;;614          sum = __SMLADX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
0002f8  f8509b04          LDR      r9,[r0],#4
0002fc  f853a904          LDR      r10,[r3],#-4
000300  fb29221a          SMLADX   r2,r9,r10,r2
;;;615          /* x[srcALen - srcBLen + 3], x[srcALen - srcBLen + 4] are multiplied   
;;;616           * with y[srcBLen - 3], y[srcBLen - 4] respectively */
;;;617          sum = __SMLADX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
000304  f8509b04          LDR      r9,[r0],#4
000308  f853a904          LDR      r10,[r3],#-4
00030c  fb29221a          SMLADX   r2,r9,r10,r2
;;;618    
;;;619          /* Decrement the loop counter */
;;;620          k--;
000310  1e64              SUBS     r4,r4,#1
                  |L1.786|
000312  2c00              CMP      r4,#0                 ;610
000314  d1f0              BNE      |L1.760|
;;;621        }
;;;622    
;;;623        /* For the next MAC operations, the pointer py is used without SIMD   
;;;624         * So, py is incremented by 1 */
;;;625        py = py + 1u;
000316  1c9b              ADDS     r3,r3,#2
;;;626    
;;;627        /* If the blockSize3 is not a multiple of 4, compute any remaining MACs here.   
;;;628         ** No loop unrolling is used. */
;;;629        k = blockSize3 % 0x4u;
000318  f00c0403          AND      r4,r12,#3
;;;630    
;;;631        while(k > 0u)
00031c  e006              B        |L1.812|
                  |L1.798|
;;;632        {
;;;633          /* sum += x[srcALen - srcBLen + 5] * y[srcBLen - 5] */
;;;634          sum = __SMLAD(*px++, *py--, sum);
00031e  f9309b02          LDRSH    r9,[r0],#2
000322  f933a902          LDRSH    r10,[r3],#-2
000326  fb29220a          SMLAD    r2,r9,r10,r2
;;;635    
;;;636          /* Decrement the loop counter */
;;;637          k--;
00032a  1e64              SUBS     r4,r4,#1
                  |L1.812|
00032c  2c00              CMP      r4,#0                 ;631
00032e  d1f6              BNE      |L1.798|
;;;638        }
;;;639    
;;;640        /* Store the result in the accumulator in the destination buffer. */
;;;641        *pOut++ = (q15_t) (sum >> 15);
000330  13d0              ASRS     r0,r2,#15
000332  f8210b02          STRH     r0,[r1],#2
;;;642    
;;;643        /* Update the inputA and inputB pointers for next MAC calculation */
;;;644        px = ++pSrc1;
000336  1ca8              ADDS     r0,r5,#2
000338  4605              MOV      r5,r0
;;;645        py = pIn2;
00033a  4643              MOV      r3,r8
;;;646    
;;;647        /* Decrement the loop counter */
;;;648        blockSize3--;
00033c  f1ac0c01          SUB      r12,r12,#1
;;;649    
;;;650        j--;
000340  1e7f              SUBS     r7,r7,#1
                  |L1.834|
000342  b117              CBZ      r7,|L1.842|
000344  f1bc0f00          CMP      r12,#0                ;600
000348  d1d2              BNE      |L1.752|
                  |L1.842|
;;;651      }
;;;652    
;;;653      /* The second part of the stage starts here */
;;;654      /* SIMD is not used for the next MAC operations,   
;;;655       * so pointer py is updated to read only one sample at a time */
;;;656      py = py + 1u;
00034a  1c9b              ADDS     r3,r3,#2
;;;657    
;;;658      while(blockSize3 > 0u)
00034c  e013              B        |L1.886|
                  |L1.846|
;;;659      {
;;;660        /* Accumulator is made zero for every iteration */
;;;661        sum = 0;
00034e  2400              MOVS     r4,#0
;;;662    
;;;663        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;664        k = blockSize3;
000350  4662              MOV      r2,r12
;;;665    
;;;666        while(k > 0u)
000352  e006              B        |L1.866|
                  |L1.852|
;;;667        {
;;;668          /* Perform the multiply-accumulates */
;;;669          /* sum +=  x[srcALen-1] * y[srcBLen-1] */
;;;670          sum = __SMLAD(*px++, *py--, sum);
000354  f9307b02          LDRSH    r7,[r0],#2
000358  f9338902          LDRSH    r8,[r3],#-2
00035c  fb274408          SMLAD    r4,r7,r8,r4
;;;671    
;;;672          /* Decrement the loop counter */
;;;673          k--;
000360  1e52              SUBS     r2,r2,#1
                  |L1.866|
000362  2a00              CMP      r2,#0                 ;666
000364  d1f6              BNE      |L1.852|
;;;674        }
;;;675    
;;;676        /* Store the result in the accumulator in the destination buffer. */
;;;677        *pOut++ = (q15_t) (sum >> 15);
000366  13e0              ASRS     r0,r4,#15
000368  f8210b02          STRH     r0,[r1],#2
;;;678    
;;;679        /* Update the inputA and inputB pointers for next MAC calculation */
;;;680        px = ++pSrc1;
00036c  1ca8              ADDS     r0,r5,#2
00036e  4605              MOV      r5,r0
;;;681        py = pSrc2;
000370  4633              MOV      r3,r6
;;;682    
;;;683        /* Decrement the loop counter */
;;;684        blockSize3--;
000372  f1ac0c01          SUB      r12,r12,#1
                  |L1.886|
000376  f1bc0f00          CMP      r12,#0                ;658
00037a  d1e8              BNE      |L1.846|
;;;685      }
;;;686    
;;;687    #else
;;;688      q15_t *pIn1;                                   /* inputA pointer */
;;;689      q15_t *pIn2;                                   /* inputB pointer */
;;;690      q15_t *pOut = pDst;                            /* output pointer */
;;;691      q31_t sum, acc0, acc1, acc2, acc3;             /* Accumulator */
;;;692      q15_t *px;                                     /* Intermediate inputA pointer  */
;;;693      q15_t *py;                                     /* Intermediate inputB pointer  */
;;;694      q15_t *pSrc1, *pSrc2;                          /* Intermediate pointers */
;;;695      q31_t x0, x1, x2, x3, c0;                      /* Temporary variables to hold state and coefficient values */
;;;696      uint32_t blockSize1, blockSize2, blockSize3, j, k, count, blkCnt;     /* loop counter */
;;;697      q15_t a, b;
;;;698    
;;;699      /* The algorithm implementation is based on the lengths of the inputs. */
;;;700      /* srcB is always made to slide across srcA. */
;;;701      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;702      if(srcALen >= srcBLen)
;;;703      {
;;;704        /* Initialization of inputA pointer */
;;;705        pIn1 = pSrcA;
;;;706    
;;;707        /* Initialization of inputB pointer */
;;;708        pIn2 = pSrcB;
;;;709      }
;;;710      else
;;;711      {
;;;712        /* Initialization of inputA pointer */
;;;713        pIn1 = pSrcB;
;;;714    
;;;715        /* Initialization of inputB pointer */
;;;716        pIn2 = pSrcA;
;;;717    
;;;718        /* srcBLen is always considered as shorter or equal to srcALen */
;;;719        j = srcBLen;
;;;720        srcBLen = srcALen;
;;;721        srcALen = j;
;;;722      }
;;;723    
;;;724      /* conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1] */
;;;725      /* The function is internally   
;;;726       * divided into three stages according to the number of multiplications that has to be   
;;;727       * taken place between inputA samples and inputB samples. In the first stage of the   
;;;728       * algorithm, the multiplications increase by one for every iteration.   
;;;729       * In the second stage of the algorithm, srcBLen number of multiplications are done.   
;;;730       * In the third stage of the algorithm, the multiplications decrease by one   
;;;731       * for every iteration. */
;;;732    
;;;733      /* The algorithm is implemented in three stages.   
;;;734         The loop counters of each stage is initiated here. */
;;;735      blockSize1 = srcBLen - 1u;
;;;736      blockSize2 = srcALen - (srcBLen - 1u);
;;;737      blockSize3 = blockSize1;
;;;738    
;;;739      /* --------------------------   
;;;740       * Initializations of stage1   
;;;741       * -------------------------*/
;;;742    
;;;743      /* sum = x[0] * y[0]   
;;;744       * sum = x[0] * y[1] + x[1] * y[0]   
;;;745       * ....   
;;;746       * sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]   
;;;747       */
;;;748    
;;;749      /* In this stage the MAC operations are increased by 1 for every iteration.   
;;;750         The count variable holds the number of MAC operations performed */
;;;751      count = 1u;
;;;752    
;;;753      /* Working pointer of inputA */
;;;754      px = pIn1;
;;;755    
;;;756      /* Working pointer of inputB */
;;;757      py = pIn2;
;;;758    
;;;759    
;;;760      /* ------------------------   
;;;761       * Stage1 process   
;;;762       * ----------------------*/
;;;763    
;;;764      /* For loop unrolling by 4, this stage is divided into two. */
;;;765      /* First part of this stage computes the MAC operations less than 4 */
;;;766      /* Second part of this stage computes the MAC operations greater than or equal to 4 */
;;;767    
;;;768      /* The first part of the stage starts here */
;;;769      while((count < 4u) && (blockSize1 > 0u))
;;;770      {
;;;771        /* Accumulator is made zero for every iteration */
;;;772        sum = 0;
;;;773    
;;;774        /* Loop over number of MAC operations between   
;;;775         * inputA samples and inputB samples */
;;;776        k = count;
;;;777    
;;;778        while(k > 0u)
;;;779        {
;;;780          /* Perform the multiply-accumulates */
;;;781          sum += ((q31_t) * px++ * *py--);
;;;782    
;;;783          /* Decrement the loop counter */
;;;784          k--;
;;;785        }
;;;786    
;;;787        /* Store the result in the accumulator in the destination buffer. */
;;;788        *pOut++ = (q15_t) (sum >> 15);
;;;789    
;;;790        /* Update the inputA and inputB pointers for next MAC calculation */
;;;791        py = pIn2 + count;
;;;792        px = pIn1;
;;;793    
;;;794        /* Increment the MAC count */
;;;795        count++;
;;;796    
;;;797        /* Decrement the loop counter */
;;;798        blockSize1--;
;;;799      }
;;;800    
;;;801      /* The second part of the stage starts here */
;;;802      /* The internal loop, over count, is unrolled by 4 */
;;;803      /* To, read the last two inputB samples using SIMD:   
;;;804       * y[srcBLen] and y[srcBLen-1] coefficients, py is decremented by 1 */
;;;805      py = py - 1;
;;;806    
;;;807      while(blockSize1 > 0u)
;;;808      {
;;;809        /* Accumulator is made zero for every iteration */
;;;810        sum = 0;
;;;811    
;;;812        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;813        k = count >> 2u;
;;;814    
;;;815        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;816         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;817    	py++;
;;;818    
;;;819        while(k > 0u)
;;;820        {
;;;821          /* Perform the multiply-accumulates */
;;;822            sum += ((q31_t) * px++ * *py--);
;;;823            sum += ((q31_t) * px++ * *py--);
;;;824            sum += ((q31_t) * px++ * *py--);
;;;825            sum += ((q31_t) * px++ * *py--);
;;;826    
;;;827          /* Decrement the loop counter */
;;;828          k--;
;;;829        }
;;;830    
;;;831        /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;832         ** No loop unrolling is used. */
;;;833        k = count % 0x4u;
;;;834    
;;;835        while(k > 0u)
;;;836        {
;;;837          /* Perform the multiply-accumulates */
;;;838          sum += ((q31_t) * px++ * *py--);
;;;839    
;;;840          /* Decrement the loop counter */
;;;841          k--;
;;;842        }
;;;843    
;;;844        /* Store the result in the accumulator in the destination buffer. */
;;;845        *pOut++ = (q15_t) (sum >> 15);
;;;846    
;;;847        /* Update the inputA and inputB pointers for next MAC calculation */
;;;848        py = pIn2 + (count - 1u);
;;;849        px = pIn1;
;;;850    
;;;851        /* Increment the MAC count */
;;;852        count++;
;;;853    
;;;854        /* Decrement the loop counter */
;;;855        blockSize1--;
;;;856      }
;;;857    
;;;858      /* --------------------------   
;;;859       * Initializations of stage2   
;;;860       * ------------------------*/
;;;861    
;;;862      /* sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0]   
;;;863       * sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0]   
;;;864       * ....   
;;;865       * sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]   
;;;866       */
;;;867    
;;;868      /* Working pointer of inputA */
;;;869      px = pIn1;
;;;870    
;;;871      /* Working pointer of inputB */
;;;872      pSrc2 = pIn2 + (srcBLen - 1u);
;;;873      py = pSrc2;
;;;874    
;;;875      /* count is the index by which the pointer pIn1 to be incremented */
;;;876      count = 0u;
;;;877    
;;;878    
;;;879      /* --------------------   
;;;880       * Stage2 process   
;;;881       * -------------------*/
;;;882    
;;;883      /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.   
;;;884       * So, to loop unroll over blockSize2,   
;;;885       * srcBLen should be greater than or equal to 4 */
;;;886      if(srcBLen >= 4u)
;;;887      {
;;;888        /* Loop unroll over blockSize2, by 4 */
;;;889        blkCnt = blockSize2 >> 2u;
;;;890    
;;;891        while(blkCnt > 0u)
;;;892        {
;;;893          py = py - 1u;
;;;894    
;;;895          /* Set all accumulators to zero */
;;;896          acc0 = 0;
;;;897          acc1 = 0;
;;;898          acc2 = 0;
;;;899          acc3 = 0;	  
;;;900    
;;;901          /* read x[0], x[1] samples */
;;;902    	  a = *px++;
;;;903    	  b = *px++;
;;;904    
;;;905    #ifndef ARM_MATH_BIG_ENDIAN
;;;906    	
;;;907    	  x0 = __PKHBT(a, b, 16);
;;;908    	  a = *px;
;;;909    	  x1 = __PKHBT(b, a, 16);
;;;910    
;;;911    #else
;;;912    
;;;913    	  x0 = __PKHBT(b, a, 16);
;;;914    	  a = *px;
;;;915    	  x1 = __PKHBT(a, b, 16);
;;;916    
;;;917    #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	   */
;;;918    
;;;919          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;920          k = srcBLen >> 2u;
;;;921    
;;;922          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;923           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;924          do
;;;925          {
;;;926            /* Read the last two inputB samples using SIMD:   
;;;927             * y[srcBLen - 1] and y[srcBLen - 2] */
;;;928    		a = *py;
;;;929    		b = *(py+1);
;;;930    		py -= 2;
;;;931    
;;;932    #ifndef ARM_MATH_BIG_ENDIAN
;;;933    
;;;934    		c0 = __PKHBT(a, b, 16);
;;;935    
;;;936    #else
;;;937    
;;;938     		c0 = __PKHBT(b, a, 16);;
;;;939    
;;;940    #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;941    
;;;942            /* acc0 +=  x[0] * y[srcBLen - 1] + x[1] * y[srcBLen - 2] */
;;;943            acc0 = __SMLADX(x0, c0, acc0);
;;;944    
;;;945            /* acc1 +=  x[1] * y[srcBLen - 1] + x[2] * y[srcBLen - 2] */
;;;946            acc1 = __SMLADX(x1, c0, acc1);
;;;947    
;;;948    	  a = *px;
;;;949    	  b = *(px + 1);
;;;950    
;;;951    #ifndef ARM_MATH_BIG_ENDIAN
;;;952    	
;;;953    	  x2 = __PKHBT(a, b, 16);
;;;954    	  a = *(px + 2);
;;;955    	  x3 = __PKHBT(b, a, 16);
;;;956    
;;;957    #else
;;;958    
;;;959    	  x2 = __PKHBT(b, a, 16);
;;;960    	  a = *(px + 2);
;;;961    	  x3 = __PKHBT(a, b, 16);
;;;962    
;;;963    #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	   */
;;;964    
;;;965            /* acc2 +=  x[2] * y[srcBLen - 1] + x[3] * y[srcBLen - 2] */
;;;966            acc2 = __SMLADX(x2, c0, acc2);
;;;967    
;;;968            /* acc3 +=  x[3] * y[srcBLen - 1] + x[4] * y[srcBLen - 2] */
;;;969            acc3 = __SMLADX(x3, c0, acc3);
;;;970    
;;;971            /* Read y[srcBLen - 3] and y[srcBLen - 4] */
;;;972    		a = *py;
;;;973    		b = *(py+1);
;;;974    		py -= 2;
;;;975    
;;;976    #ifndef ARM_MATH_BIG_ENDIAN
;;;977    
;;;978    		c0 = __PKHBT(a, b, 16);
;;;979    
;;;980    #else
;;;981    
;;;982     		c0 = __PKHBT(b, a, 16);;
;;;983    
;;;984    #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;985    
;;;986            /* acc0 +=  x[2] * y[srcBLen - 3] + x[3] * y[srcBLen - 4] */
;;;987            acc0 = __SMLADX(x2, c0, acc0);
;;;988    
;;;989            /* acc1 +=  x[3] * y[srcBLen - 3] + x[4] * y[srcBLen - 4] */
;;;990            acc1 = __SMLADX(x3, c0, acc1);
;;;991    
;;;992            /* Read x[4], x[5], x[6] */
;;;993    	  a = *(px + 2);
;;;994    	  b = *(px + 3);
;;;995    
;;;996    #ifndef ARM_MATH_BIG_ENDIAN
;;;997    	
;;;998    	  x0 = __PKHBT(a, b, 16);
;;;999    	  a = *(px + 4);
;;;1000   	  x1 = __PKHBT(b, a, 16);
;;;1001   
;;;1002   #else
;;;1003   
;;;1004   	  x0 = __PKHBT(b, a, 16);
;;;1005   	  a = *(px + 4);
;;;1006   	  x1 = __PKHBT(a, b, 16);
;;;1007   
;;;1008   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	   */
;;;1009   
;;;1010   		px += 4u;
;;;1011   
;;;1012           /* acc2 +=  x[4] * y[srcBLen - 3] + x[5] * y[srcBLen - 4] */
;;;1013           acc2 = __SMLADX(x0, c0, acc2);
;;;1014   
;;;1015           /* acc3 +=  x[5] * y[srcBLen - 3] + x[6] * y[srcBLen - 4] */
;;;1016           acc3 = __SMLADX(x1, c0, acc3);
;;;1017   
;;;1018         } while(--k);
;;;1019   
;;;1020         /* For the next MAC operations, SIMD is not used   
;;;1021          * So, the 16 bit pointer if inputB, py is updated */
;;;1022   
;;;1023         /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;1024          ** No loop unrolling is used. */
;;;1025         k = srcBLen % 0x4u;
;;;1026   
;;;1027         if(k == 1u)
;;;1028         {
;;;1029           /* Read y[srcBLen - 5] */
;;;1030           c0 = *(py+1);
;;;1031   
;;;1032   #ifdef  ARM_MATH_BIG_ENDIAN
;;;1033   
;;;1034           c0 = c0 << 16u;
;;;1035   
;;;1036   #else
;;;1037   
;;;1038           c0 = c0 & 0x0000FFFF;
;;;1039   
;;;1040   #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;1041   
;;;1042           /* Read x[7] */
;;;1043   		a = *px;
;;;1044   		b = *(px+1);
;;;1045   		px++;
;;;1046   
;;;1047   #ifndef ARM_MATH_BIG_ENDIAN
;;;1048   
;;;1049   		x3 = __PKHBT(a, b, 16);
;;;1050   
;;;1051   #else
;;;1052   
;;;1053    		x3 = __PKHBT(b, a, 16);;
;;;1054   
;;;1055   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;1056   
;;;1057   
;;;1058           /* Perform the multiply-accumulates */
;;;1059           acc0 = __SMLAD(x0, c0, acc0);
;;;1060           acc1 = __SMLAD(x1, c0, acc1);
;;;1061           acc2 = __SMLADX(x1, c0, acc2);
;;;1062           acc3 = __SMLADX(x3, c0, acc3);
;;;1063         }
;;;1064   
;;;1065         if(k == 2u)
;;;1066         {
;;;1067           /* Read y[srcBLen - 5], y[srcBLen - 6] */
;;;1068   		a = *py;
;;;1069   		b = *(py+1);
;;;1070   
;;;1071   #ifndef ARM_MATH_BIG_ENDIAN
;;;1072   
;;;1073   		c0 = __PKHBT(a, b, 16);
;;;1074   
;;;1075   #else
;;;1076   
;;;1077    		c0 = __PKHBT(b, a, 16);;
;;;1078   
;;;1079   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;1080   
;;;1081           /* Read x[7], x[8], x[9] */
;;;1082   	  a = *px;
;;;1083   	  b = *(px + 1);
;;;1084   
;;;1085   #ifndef ARM_MATH_BIG_ENDIAN
;;;1086   	
;;;1087   	  x3 = __PKHBT(a, b, 16);
;;;1088   	  a = *(px + 2);
;;;1089   	  x2 = __PKHBT(b, a, 16);
;;;1090   
;;;1091   #else
;;;1092   
;;;1093   	  x3 = __PKHBT(b, a, 16);
;;;1094   	  a = *(px + 2);
;;;1095   	  x2 = __PKHBT(a, b, 16);
;;;1096   
;;;1097   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	   */
;;;1098   		px += 2u;
;;;1099   
;;;1100           /* Perform the multiply-accumulates */
;;;1101           acc0 = __SMLADX(x0, c0, acc0);
;;;1102           acc1 = __SMLADX(x1, c0, acc1);
;;;1103           acc2 = __SMLADX(x3, c0, acc2);
;;;1104           acc3 = __SMLADX(x2, c0, acc3);
;;;1105         }
;;;1106   
;;;1107         if(k == 3u)
;;;1108         {
;;;1109           /* Read y[srcBLen - 5], y[srcBLen - 6] */
;;;1110   		a = *py;
;;;1111   		b = *(py+1);
;;;1112   
;;;1113   #ifndef ARM_MATH_BIG_ENDIAN
;;;1114   
;;;1115   		c0 = __PKHBT(a, b, 16);
;;;1116   
;;;1117   #else
;;;1118   
;;;1119    		c0 = __PKHBT(b, a, 16);;
;;;1120   
;;;1121   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;1122   
;;;1123           /* Read x[7], x[8], x[9] */
;;;1124   	  a = *px;
;;;1125   	  b = *(px + 1);
;;;1126   
;;;1127   #ifndef ARM_MATH_BIG_ENDIAN
;;;1128   	
;;;1129   	  x3 = __PKHBT(a, b, 16);
;;;1130   	  a = *(px + 2);
;;;1131   	  x2 = __PKHBT(b, a, 16);
;;;1132   
;;;1133   #else
;;;1134   
;;;1135   	  x3 = __PKHBT(b, a, 16);
;;;1136   	  a = *(px + 2);
;;;1137   	  x2 = __PKHBT(a, b, 16);
;;;1138   
;;;1139   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	   */
;;;1140   
;;;1141           /* Perform the multiply-accumulates */
;;;1142           acc0 = __SMLADX(x0, c0, acc0);
;;;1143           acc1 = __SMLADX(x1, c0, acc1);
;;;1144           acc2 = __SMLADX(x3, c0, acc2);
;;;1145           acc3 = __SMLADX(x2, c0, acc3);
;;;1146   
;;;1147           /* Read y[srcBLen - 7] */
;;;1148   		c0 = *(py-1);
;;;1149   #ifdef  ARM_MATH_BIG_ENDIAN
;;;1150   
;;;1151           c0 = c0 << 16u;
;;;1152   #else
;;;1153   
;;;1154           c0 = c0 & 0x0000FFFF;
;;;1155   #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;1156   
;;;1157           /* Read x[10] */
;;;1158   		a = *(px+2);
;;;1159   		b = *(px+3);
;;;1160   
;;;1161   #ifndef ARM_MATH_BIG_ENDIAN
;;;1162   
;;;1163   		x3 = __PKHBT(a, b, 16);
;;;1164   
;;;1165   #else
;;;1166   
;;;1167    		x3 = __PKHBT(b, a, 16);;
;;;1168   
;;;1169   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;1170   
;;;1171   		px += 3u;
;;;1172   
;;;1173           /* Perform the multiply-accumulates */
;;;1174           acc0 = __SMLADX(x1, c0, acc0);
;;;1175           acc1 = __SMLAD(x2, c0, acc1);
;;;1176           acc2 = __SMLADX(x2, c0, acc2);
;;;1177           acc3 = __SMLADX(x3, c0, acc3);
;;;1178         }
;;;1179   
;;;1180         /* Store the results in the accumulators in the destination buffer. */
;;;1181   	  *pOut++ = (q15_t)(acc0 >> 15);
;;;1182   	  *pOut++ = (q15_t)(acc1 >> 15);
;;;1183   	  *pOut++ = (q15_t)(acc2 >> 15);
;;;1184   	  *pOut++ = (q15_t)(acc3 >> 15);
;;;1185   
;;;1186         /* Increment the pointer pIn1 index, count by 4 */
;;;1187         count += 4u;
;;;1188   
;;;1189         /* Update the inputA and inputB pointers for next MAC calculation */
;;;1190         px = pIn1 + count;
;;;1191         py = pSrc2;
;;;1192   
;;;1193         /* Decrement the loop counter */
;;;1194         blkCnt--;
;;;1195       }
;;;1196   
;;;1197       /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.   
;;;1198        ** No loop unrolling is used. */
;;;1199       blkCnt = blockSize2 % 0x4u;
;;;1200   
;;;1201       while(blkCnt > 0u)
;;;1202       {
;;;1203         /* Accumulator is made zero for every iteration */
;;;1204         sum = 0;
;;;1205   
;;;1206         /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;1207         k = srcBLen >> 2u;
;;;1208   
;;;1209         /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;1210          ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;1211         while(k > 0u)
;;;1212         {
;;;1213           /* Perform the multiply-accumulates */
;;;1214           sum += ((q31_t) * px++ * *py--);
;;;1215           sum += ((q31_t) * px++ * *py--);
;;;1216           sum += ((q31_t) * px++ * *py--);
;;;1217           sum += ((q31_t) * px++ * *py--);
;;;1218   
;;;1219           /* Decrement the loop counter */
;;;1220           k--;
;;;1221         }
;;;1222   
;;;1223         /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;1224          ** No loop unrolling is used. */
;;;1225         k = srcBLen % 0x4u;
;;;1226   
;;;1227         while(k > 0u)
;;;1228         {
;;;1229           /* Perform the multiply-accumulates */
;;;1230           sum += ((q31_t) * px++ * *py--);
;;;1231   
;;;1232           /* Decrement the loop counter */
;;;1233           k--;
;;;1234         }
;;;1235   
;;;1236         /* Store the result in the accumulator in the destination buffer. */
;;;1237         *pOut++ = (q15_t) (sum >> 15);
;;;1238   
;;;1239         /* Increment the pointer pIn1 index, count by 1 */
;;;1240         count++;
;;;1241   
;;;1242         /* Update the inputA and inputB pointers for next MAC calculation */
;;;1243         px = pIn1 + count;
;;;1244         py = pSrc2;
;;;1245   
;;;1246         /* Decrement the loop counter */
;;;1247         blkCnt--;
;;;1248       }
;;;1249     }
;;;1250     else
;;;1251     {
;;;1252       /* If the srcBLen is not a multiple of 4,   
;;;1253        * the blockSize2 loop cannot be unrolled by 4 */
;;;1254       blkCnt = blockSize2;
;;;1255   
;;;1256       while(blkCnt > 0u)
;;;1257       {
;;;1258         /* Accumulator is made zero for every iteration */
;;;1259         sum = 0;
;;;1260   
;;;1261         /* srcBLen number of MACS should be performed */
;;;1262         k = srcBLen;
;;;1263   
;;;1264         while(k > 0u)
;;;1265         {
;;;1266           /* Perform the multiply-accumulate */
;;;1267           sum += ((q31_t) * px++ * *py--);
;;;1268   
;;;1269           /* Decrement the loop counter */
;;;1270           k--;
;;;1271         }
;;;1272   
;;;1273         /* Store the result in the accumulator in the destination buffer. */
;;;1274         *pOut++ = (q15_t) (sum >> 15);
;;;1275   
;;;1276         /* Increment the MAC count */
;;;1277         count++;
;;;1278   
;;;1279         /* Update the inputA and inputB pointers for next MAC calculation */
;;;1280         px = pIn1 + count;
;;;1281         py = pSrc2;
;;;1282   
;;;1283         /* Decrement the loop counter */
;;;1284         blkCnt--;
;;;1285       }
;;;1286     }
;;;1287   
;;;1288   
;;;1289     /* --------------------------   
;;;1290      * Initializations of stage3   
;;;1291      * -------------------------*/
;;;1292   
;;;1293     /* sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1]   
;;;1294      * sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2]   
;;;1295      * ....   
;;;1296      * sum +=  x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2]   
;;;1297      * sum +=  x[srcALen-1] * y[srcBLen-1]   
;;;1298      */
;;;1299   
;;;1300     /* In this stage the MAC operations are decreased by 1 for every iteration.   
;;;1301        The blockSize3 variable holds the number of MAC operations performed */
;;;1302   
;;;1303     /* Working pointer of inputA */
;;;1304     pSrc1 = (pIn1 + srcALen) - (srcBLen - 1u);
;;;1305     px = pSrc1;
;;;1306   
;;;1307     /* Working pointer of inputB */
;;;1308     pSrc2 = pIn2 + (srcBLen - 1u);
;;;1309     pIn2 = pSrc2 - 1u;
;;;1310     py = pIn2;
;;;1311   
;;;1312     /* -------------------   
;;;1313      * Stage3 process   
;;;1314      * ------------------*/
;;;1315   
;;;1316     /* For loop unrolling by 4, this stage is divided into two. */
;;;1317     /* First part of this stage computes the MAC operations greater than 4 */
;;;1318     /* Second part of this stage computes the MAC operations less than or equal to 4 */
;;;1319   
;;;1320     /* The first part of the stage starts here */
;;;1321     j = blockSize3 >> 2u;
;;;1322   
;;;1323     while((j > 0u) && (blockSize3 > 0u))
;;;1324     {
;;;1325       /* Accumulator is made zero for every iteration */
;;;1326       sum = 0;
;;;1327   
;;;1328       /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;1329       k = blockSize3 >> 2u;
;;;1330   
;;;1331       /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;1332        ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;1333   	py++;
;;;1334   
;;;1335       while(k > 0u)
;;;1336       {	
;;;1337           sum += ((q31_t) * px++ * *py--);
;;;1338           sum += ((q31_t) * px++ * *py--);
;;;1339           sum += ((q31_t) * px++ * *py--);
;;;1340           sum += ((q31_t) * px++ * *py--);
;;;1341         /* Decrement the loop counter */
;;;1342         k--;
;;;1343       }
;;;1344   
;;;1345       /* If the blockSize3 is not a multiple of 4, compute any remaining MACs here.   
;;;1346        ** No loop unrolling is used. */
;;;1347       k = blockSize3 % 0x4u;
;;;1348   
;;;1349       while(k > 0u)
;;;1350       {
;;;1351         /* sum += x[srcALen - srcBLen + 5] * y[srcBLen - 5] */
;;;1352           sum += ((q31_t) * px++ * *py--);
;;;1353   
;;;1354         /* Decrement the loop counter */
;;;1355         k--;
;;;1356       }
;;;1357   
;;;1358       /* Store the result in the accumulator in the destination buffer. */
;;;1359       *pOut++ = (q15_t) (sum >> 15);
;;;1360   
;;;1361       /* Update the inputA and inputB pointers for next MAC calculation */
;;;1362       px = ++pSrc1;
;;;1363       py = pIn2;
;;;1364   
;;;1365       /* Decrement the loop counter */
;;;1366       blockSize3--;
;;;1367   
;;;1368       j--;
;;;1369     }
;;;1370   
;;;1371     /* The second part of the stage starts here */
;;;1372     /* SIMD is not used for the next MAC operations,   
;;;1373      * so pointer py is updated to read only one sample at a time */
;;;1374     py = py + 1u;
;;;1375   
;;;1376     while(blockSize3 > 0u)
;;;1377     {
;;;1378       /* Accumulator is made zero for every iteration */
;;;1379       sum = 0;
;;;1380   
;;;1381       /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;1382       k = blockSize3;
;;;1383   
;;;1384       while(k > 0u)
;;;1385       {
;;;1386         /* Perform the multiply-accumulates */
;;;1387         /* sum +=  x[srcALen-1] * y[srcBLen-1] */
;;;1388           sum += ((q31_t) * px++ * *py--);
;;;1389   
;;;1390         /* Decrement the loop counter */
;;;1391         k--;
;;;1392       }
;;;1393   
;;;1394       /* Store the result in the accumulator in the destination buffer. */
;;;1395       *pOut++ = (q15_t) (sum >> 15);
;;;1396   
;;;1397       /* Update the inputA and inputB pointers for next MAC calculation */
;;;1398       px = ++pSrc1;
;;;1399       py = pSrc2;
;;;1400   
;;;1401       /* Decrement the loop counter */
;;;1402       blockSize3--;
;;;1403     }
;;;1404   
;;;1405   #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;1406   }
00037c  b00d              ADD      sp,sp,#0x34
00037e  e8bd8ff0          POP      {r4-r11,pc}
;;;1407   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_fast_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_conv_fast_q15_c_fb3639ae____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___19_arm_conv_fast_q15_c_fb3639ae____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_conv_fast_q15_c_fb3639ae____REVSH|
#line 144
|__asm___19_arm_conv_fast_q15_c_fb3639ae____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_conv_fast_q15_c_fb3639ae____RRX|
#line 300
|__asm___19_arm_conv_fast_q15_c_fb3639ae____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
