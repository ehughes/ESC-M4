; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_dct4_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_dct4_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_dct4_f32.crf ..\..\SRC\CMSIS_DSP_4_5\src\TransformFunctions\arm_dct4_f32.c]
                          THUMB

                          AREA ||i.arm_dct4_f32||, CODE, READONLY, ALIGN=1

                  arm_dct4_f32 PROC
;;;136    
;;;137    void arm_dct4_f32(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;138      const arm_dct4_instance_f32 * S,
;;;139      float32_t * pState,
;;;140      float32_t * pInlineBuffer)
;;;141    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;142      uint32_t i;                                    /* Loop counter */
;;;143      float32_t *weights = S->pTwiddle;              /* Pointer to the Weights table */
00000a  f8d48008          LDR      r8,[r4,#8]
;;;144      float32_t *cosFact = S->pCosFactor;            /* Pointer to the cos factors table */
00000e  68e5              LDR      r5,[r4,#0xc]
;;;145      float32_t *pS1, *pS2, *pbuff;                  /* Temporary pointers for input buffer and pState buffer */
;;;146      float32_t in;                                  /* Temporary variable */
;;;147    
;;;148    
;;;149      /* DCT4 computation involves DCT2 (which is calculated using RFFT)    
;;;150       * along with some pre-processing and post-processing.    
;;;151       * Computational procedure is explained as follows:    
;;;152       * (a) Pre-processing involves multiplying input with cos factor,    
;;;153       *     r(n) = 2 * u(n) * cos(pi*(2*n+1)/(4*n))    
;;;154       *              where,    
;;;155       *                 r(n) -- output of preprocessing    
;;;156       *                 u(n) -- input to preprocessing(actual Source buffer)    
;;;157       * (b) Calculation of DCT2 using FFT is divided into three steps:    
;;;158       *                  Step1: Re-ordering of even and odd elements of input.    
;;;159       *                  Step2: Calculating FFT of the re-ordered input.    
;;;160       *                  Step3: Taking the real part of the product of FFT output and weights.    
;;;161       * (c) Post-processing - DCT4 can be obtained from DCT2 output using the following equation:    
;;;162       *                   Y4(k) = Y2(k) - Y4(k-1) and Y4(-1) = Y4(0)    
;;;163       *                        where,    
;;;164       *                           Y4 -- DCT4 output,   Y2 -- DCT2 output    
;;;165       * (d) Multiplying the output with the normalizing factor sqrt(2/N).    
;;;166       */
;;;167    
;;;168            /*-------- Pre-processing ------------*/
;;;169      /* Multiplying input with cos factor i.e. r(n) = 2 * x(n) * cos(pi*(2*n+1)/(4*n)) */
;;;170      arm_scale_f32(pInlineBuffer, 2.0f, pInlineBuffer, S->N);
000010  8822              LDRH     r2,[r4,#0]
000012  4631              MOV      r1,r6
000014  eeb00a00          VMOV.F32 s0,#2.00000000
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       arm_scale_f32
;;;171      arm_mult_f32(pInlineBuffer, cosFact, pInlineBuffer, S->N);
00001e  8823              LDRH     r3,[r4,#0]
000020  4632              MOV      r2,r6
000022  4629              MOV      r1,r5
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       arm_mult_f32
;;;172    
;;;173      /* ----------------------------------------------------------------    
;;;174       * Step1: Re-ordering of even and odd elements as,    
;;;175       *             pState[i] =  pInlineBuffer[2*i] and    
;;;176       *             pState[N-i-1] = pInlineBuffer[2*i+1] where i = 0 to N/2    
;;;177       ---------------------------------------------------------------------*/
;;;178    
;;;179      /* pS1 initialized to pState */
;;;180      pS1 = pState;
;;;181    
;;;182      /* pS2 initialized to pState+N-1, so that it points to the end of the state buffer */
;;;183      pS2 = pState + (S->N - 1u);
00002a  8820              LDRH     r0,[r4,#0]
00002c  463d              MOV      r5,r7
00002e  1e40              SUBS     r0,r0,#1
000030  eb070080          ADD      r0,r7,r0,LSL #2
;;;184    
;;;185      /* pbuff initialized to input buffer */
;;;186      pbuff = pInlineBuffer;
000034  4632              MOV      r2,r6
;;;187    
;;;188    #ifndef ARM_MATH_CM0_FAMILY
;;;189    
;;;190      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;191    
;;;192      /* Initializing the loop counter to N/2 >> 2 for loop unrolling by 4 */
;;;193      i = (uint32_t) S->Nby2 >> 2u;
000036  8861              LDRH     r1,[r4,#2]
000038  0889              LSRS     r1,r1,#2
                  |L1.58|
;;;194    
;;;195      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;196       ** a second loop below computes the remaining 1 to 3 samples. */
;;;197      do
;;;198      {
;;;199        /* Re-ordering of even and odd elements */
;;;200        /* pState[i] =  pInlineBuffer[2*i] */
;;;201        *pS1++ = *pbuff++;
00003a  ecb20a01          VLDM     r2!,{s0}
00003e  eca50a01          VSTM     r5!,{s0}
;;;202        /* pState[N-i-1] = pInlineBuffer[2*i+1] */
;;;203        *pS2-- = *pbuff++;
000042  ecb20a01          VLDM     r2!,{s0}
000046  ed800a00          VSTR     s0,[r0,#0]
00004a  1f00              SUBS     r0,r0,#4
;;;204    
;;;205        *pS1++ = *pbuff++;
00004c  ecb20a01          VLDM     r2!,{s0}
000050  eca50a01          VSTM     r5!,{s0}
;;;206        *pS2-- = *pbuff++;
000054  ecb20a01          VLDM     r2!,{s0}
000058  ed800a00          VSTR     s0,[r0,#0]
00005c  1f00              SUBS     r0,r0,#4
;;;207    
;;;208        *pS1++ = *pbuff++;
00005e  ecb20a01          VLDM     r2!,{s0}
000062  eca50a01          VSTM     r5!,{s0}
;;;209        *pS2-- = *pbuff++;
000066  ecb20a01          VLDM     r2!,{s0}
00006a  ed800a00          VSTR     s0,[r0,#0]
00006e  1f00              SUBS     r0,r0,#4
;;;210    
;;;211        *pS1++ = *pbuff++;
000070  ecb20a01          VLDM     r2!,{s0}
000074  eca50a01          VSTM     r5!,{s0}
;;;212        *pS2-- = *pbuff++;
000078  ecb20a01          VLDM     r2!,{s0}
00007c  ed800a00          VSTR     s0,[r0,#0]
000080  1f00              SUBS     r0,r0,#4
;;;213    
;;;214        /* Decrement the loop counter */
;;;215        i--;
000082  1e49              SUBS     r1,r1,#1
;;;216      } while(i > 0u);
000084  2900              CMP      r1,#0
000086  d1d8              BNE      |L1.58|
;;;217    
;;;218      /* pbuff initialized to input buffer */
;;;219      pbuff = pInlineBuffer;
000088  4631              MOV      r1,r6
;;;220    
;;;221      /* pS1 initialized to pState */
;;;222      pS1 = pState;
00008a  4638              MOV      r0,r7
;;;223    
;;;224      /* Initializing the loop counter to N/4 instead of N for loop unrolling */
;;;225      i = (uint32_t) S->N >> 2u;
00008c  8822              LDRH     r2,[r4,#0]
00008e  0892              LSRS     r2,r2,#2
                  |L1.144|
;;;226    
;;;227      /* Processing with loop unrolling 4 times as N is always multiple of 4.    
;;;228       * Compute 4 outputs at a time */
;;;229      do
;;;230      {
;;;231        /* Writing the re-ordered output back to inplace input buffer */
;;;232        *pbuff++ = *pS1++;
000090  ecb00a01          VLDM     r0!,{s0}
000094  eca10a01          VSTM     r1!,{s0}
;;;233        *pbuff++ = *pS1++;
000098  ecb00a01          VLDM     r0!,{s0}
00009c  eca10a01          VSTM     r1!,{s0}
;;;234        *pbuff++ = *pS1++;
0000a0  ecb00a01          VLDM     r0!,{s0}
0000a4  eca10a01          VSTM     r1!,{s0}
;;;235        *pbuff++ = *pS1++;
0000a8  ecb00a01          VLDM     r0!,{s0}
0000ac  eca10a01          VSTM     r1!,{s0}
;;;236    
;;;237        /* Decrement the loop counter */
;;;238        i--;
0000b0  1e52              SUBS     r2,r2,#1
;;;239      } while(i > 0u);
0000b2  2a00              CMP      r2,#0
0000b4  d1ec              BNE      |L1.144|
;;;240    
;;;241    
;;;242      /* ---------------------------------------------------------    
;;;243       *     Step2: Calculate RFFT for N-point input    
;;;244       * ---------------------------------------------------------- */
;;;245      /* pInlineBuffer is real input of length N , pState is the complex output of length 2N */
;;;246      arm_rfft_f32(S->pRfft, pInlineBuffer, pState);
0000b6  463a              MOV      r2,r7
0000b8  4631              MOV      r1,r6
0000ba  6920              LDR      r0,[r4,#0x10]
0000bc  f7fffffe          BL       arm_rfft_f32
;;;247    
;;;248            /*----------------------------------------------------------------------    
;;;249    	 *  Step3: Multiply the FFT output with the weights.    
;;;250    	 *----------------------------------------------------------------------*/
;;;251      arm_cmplx_mult_cmplx_f32(pState, weights, pState, S->N);
0000c0  8823              LDRH     r3,[r4,#0]
0000c2  463a              MOV      r2,r7
0000c4  4641              MOV      r1,r8
0000c6  4638              MOV      r0,r7
0000c8  f7fffffe          BL       arm_cmplx_mult_cmplx_f32
;;;252    
;;;253      /* ----------- Post-processing ---------- */
;;;254      /* DCT-IV can be obtained from DCT-II by the equation,    
;;;255       *       Y4(k) = Y2(k) - Y4(k-1) and Y4(-1) = Y4(0)    
;;;256       *       Hence, Y4(0) = Y2(0)/2  */
;;;257      /* Getting only real part from the output and Converting to DCT-IV */
;;;258    
;;;259      /* Initializing the loop counter to N >> 2 for loop unrolling by 4 */
;;;260      i = ((uint32_t) S->N - 1u) >> 2u;
0000cc  8820              LDRH     r0,[r4,#0]
0000ce  1e40              SUBS     r0,r0,#1
0000d0  0881              LSRS     r1,r0,#2
;;;261    
;;;262      /* pbuff initialized to input buffer. */
;;;263      pbuff = pInlineBuffer;
0000d2  4630              MOV      r0,r6
;;;264    
;;;265      /* pS1 initialized to pState */
;;;266      pS1 = pState;
;;;267    
;;;268      /* Calculating Y4(0) from Y2(0) using Y4(0) = Y2(0)/2 */
;;;269      in = *pS1++ * (float32_t) 0.5;
0000d4  ecb70a01          VLDM     r7!,{s0}
0000d8  eef60a00          VMOV.F32 s1,#0.50000000
0000dc  ee200a20          VMUL.F32 s0,s0,s1
;;;270      /* input buffer acts as inplace, so output values are stored in the input itself. */
;;;271      *pbuff++ = in;
0000e0  eca00a01          VSTM     r0!,{s0}
;;;272    
;;;273      /* pState pointer is incremented twice as the real values are located alternatively in the array */
;;;274      pS1++;
0000e4  1d3f              ADDS     r7,r7,#4
                  |L1.230|
;;;275    
;;;276      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;277       ** a second loop below computes the remaining 1 to 3 samples. */
;;;278      do
;;;279      {
;;;280        /* Calculating Y4(1) to Y4(N-1) from Y2 using equation Y4(k) = Y2(k) - Y4(k-1) */
;;;281        /* pState pointer (pS1) is incremented twice as the real values are located alternatively in the array */
;;;282        in = *pS1++ - in;
0000e6  ecf70a01          VLDM     r7!,{s1}
0000ea  ee300ac0          VSUB.F32 s0,s1,s0
;;;283        *pbuff++ = in;
0000ee  eca00a01          VSTM     r0!,{s0}
;;;284        /* points to the next real value */
;;;285        pS1++;
0000f2  1d3f              ADDS     r7,r7,#4
;;;286    
;;;287        in = *pS1++ - in;
0000f4  ecf70a01          VLDM     r7!,{s1}
0000f8  ee300ac0          VSUB.F32 s0,s1,s0
;;;288        *pbuff++ = in;
0000fc  eca00a01          VSTM     r0!,{s0}
;;;289        pS1++;
000100  1d3f              ADDS     r7,r7,#4
;;;290    
;;;291        in = *pS1++ - in;
000102  ecf70a01          VLDM     r7!,{s1}
000106  ee300ac0          VSUB.F32 s0,s1,s0
;;;292        *pbuff++ = in;
00010a  eca00a01          VSTM     r0!,{s0}
;;;293        pS1++;
00010e  1d3f              ADDS     r7,r7,#4
;;;294    
;;;295        in = *pS1++ - in;
000110  ecf70a01          VLDM     r7!,{s1}
000114  ee300ac0          VSUB.F32 s0,s1,s0
;;;296        *pbuff++ = in;
000118  eca00a01          VSTM     r0!,{s0}
;;;297        pS1++;
00011c  1d3f              ADDS     r7,r7,#4
;;;298    
;;;299        /* Decrement the loop counter */
;;;300        i--;
00011e  1e49              SUBS     r1,r1,#1
;;;301      } while(i > 0u);
000120  2900              CMP      r1,#0
000122  d1e0              BNE      |L1.230|
;;;302    
;;;303      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;304       ** No loop unrolling is used. */
;;;305      i = ((uint32_t) S->N - 1u) % 0x4u;
000124  7821              LDRB     r1,[r4,#0]
000126  1e49              SUBS     r1,r1,#1
000128  f0010103          AND      r1,r1,#3
;;;306    
;;;307      while(i > 0u)
00012c  e007              B        |L1.318|
                  |L1.302|
;;;308      {
;;;309        /* Calculating Y4(1) to Y4(N-1) from Y2 using equation Y4(k) = Y2(k) - Y4(k-1) */
;;;310        /* pState pointer (pS1) is incremented twice as the real values are located alternatively in the array */
;;;311        in = *pS1++ - in;
00012e  ecf70a01          VLDM     r7!,{s1}
000132  ee300ac0          VSUB.F32 s0,s1,s0
;;;312        *pbuff++ = in;
000136  eca00a01          VSTM     r0!,{s0}
;;;313        /* points to the next real value */
;;;314        pS1++;
00013a  1d3f              ADDS     r7,r7,#4
;;;315    
;;;316        /* Decrement the loop counter */
;;;317        i--;
00013c  1e49              SUBS     r1,r1,#1
                  |L1.318|
00013e  2900              CMP      r1,#0                 ;307
000140  d1f5              BNE      |L1.302|
;;;318      }
;;;319    
;;;320    
;;;321            /*------------ Normalizing the output by multiplying with the normalizing factor ----------*/
;;;322    
;;;323      /* Initializing the loop counter to N/4 instead of N for loop unrolling */
;;;324      i = (uint32_t) S->N >> 2u;
000142  8820              LDRH     r0,[r4,#0]
000144  0880              LSRS     r0,r0,#2
                  |L1.326|
;;;325    
;;;326      /* pbuff initialized to the pInlineBuffer(now contains the output values) */
;;;327      pbuff = pInlineBuffer;
;;;328    
;;;329      /* Processing with loop unrolling 4 times as N is always multiple of 4.  Compute 4 outputs at a time */
;;;330      do
;;;331      {
;;;332        /* Multiplying pInlineBuffer with the normalizing factor sqrt(2/N) */
;;;333        in = *pbuff;
000146  ed960a00          VLDR     s0,[r6,#0]
;;;334        *pbuff++ = in * S->normalize;
00014a  edd40a01          VLDR     s1,[r4,#4]
00014e  ee200a80          VMUL.F32 s0,s1,s0
000152  eca60a01          VSTM     r6!,{s0}
;;;335    
;;;336        in = *pbuff;
000156  ed960a00          VLDR     s0,[r6,#0]
;;;337        *pbuff++ = in * S->normalize;
00015a  edd40a01          VLDR     s1,[r4,#4]
00015e  ee200a80          VMUL.F32 s0,s1,s0
000162  eca60a01          VSTM     r6!,{s0}
;;;338    
;;;339        in = *pbuff;
000166  ed960a00          VLDR     s0,[r6,#0]
;;;340        *pbuff++ = in * S->normalize;
00016a  edd40a01          VLDR     s1,[r4,#4]
00016e  ee200a80          VMUL.F32 s0,s1,s0
000172  eca60a01          VSTM     r6!,{s0}
;;;341    
;;;342        in = *pbuff;
000176  ed960a00          VLDR     s0,[r6,#0]
;;;343        *pbuff++ = in * S->normalize;
00017a  edd40a01          VLDR     s1,[r4,#4]
00017e  ee200a80          VMUL.F32 s0,s1,s0
000182  eca60a01          VSTM     r6!,{s0}
;;;344    
;;;345        /* Decrement the loop counter */
;;;346        i--;
000186  1e40              SUBS     r0,r0,#1
;;;347      } while(i > 0u);
000188  2800              CMP      r0,#0
00018a  d1dc              BNE      |L1.326|
;;;348    
;;;349    
;;;350    #else
;;;351    
;;;352      /* Run the below code for Cortex-M0 */
;;;353    
;;;354      /* Initializing the loop counter to N/2 */
;;;355      i = (uint32_t) S->Nby2;
;;;356    
;;;357      do
;;;358      {
;;;359        /* Re-ordering of even and odd elements */
;;;360        /* pState[i] =  pInlineBuffer[2*i] */
;;;361        *pS1++ = *pbuff++;
;;;362        /* pState[N-i-1] = pInlineBuffer[2*i+1] */
;;;363        *pS2-- = *pbuff++;
;;;364    
;;;365        /* Decrement the loop counter */
;;;366        i--;
;;;367      } while(i > 0u);
;;;368    
;;;369      /* pbuff initialized to input buffer */
;;;370      pbuff = pInlineBuffer;
;;;371    
;;;372      /* pS1 initialized to pState */
;;;373      pS1 = pState;
;;;374    
;;;375      /* Initializing the loop counter */
;;;376      i = (uint32_t) S->N;
;;;377    
;;;378      do
;;;379      {
;;;380        /* Writing the re-ordered output back to inplace input buffer */
;;;381        *pbuff++ = *pS1++;
;;;382    
;;;383        /* Decrement the loop counter */
;;;384        i--;
;;;385      } while(i > 0u);
;;;386    
;;;387    
;;;388      /* ---------------------------------------------------------    
;;;389       *     Step2: Calculate RFFT for N-point input    
;;;390       * ---------------------------------------------------------- */
;;;391      /* pInlineBuffer is real input of length N , pState is the complex output of length 2N */
;;;392      arm_rfft_f32(S->pRfft, pInlineBuffer, pState);
;;;393    
;;;394            /*----------------------------------------------------------------------    
;;;395    	 *  Step3: Multiply the FFT output with the weights.    
;;;396    	 *----------------------------------------------------------------------*/
;;;397      arm_cmplx_mult_cmplx_f32(pState, weights, pState, S->N);
;;;398    
;;;399      /* ----------- Post-processing ---------- */
;;;400      /* DCT-IV can be obtained from DCT-II by the equation,    
;;;401       *       Y4(k) = Y2(k) - Y4(k-1) and Y4(-1) = Y4(0)    
;;;402       *       Hence, Y4(0) = Y2(0)/2  */
;;;403      /* Getting only real part from the output and Converting to DCT-IV */
;;;404    
;;;405      /* pbuff initialized to input buffer. */
;;;406      pbuff = pInlineBuffer;
;;;407    
;;;408      /* pS1 initialized to pState */
;;;409      pS1 = pState;
;;;410    
;;;411      /* Calculating Y4(0) from Y2(0) using Y4(0) = Y2(0)/2 */
;;;412      in = *pS1++ * (float32_t) 0.5;
;;;413      /* input buffer acts as inplace, so output values are stored in the input itself. */
;;;414      *pbuff++ = in;
;;;415    
;;;416      /* pState pointer is incremented twice as the real values are located alternatively in the array */
;;;417      pS1++;
;;;418    
;;;419      /* Initializing the loop counter */
;;;420      i = ((uint32_t) S->N - 1u);
;;;421    
;;;422      do
;;;423      {
;;;424        /* Calculating Y4(1) to Y4(N-1) from Y2 using equation Y4(k) = Y2(k) - Y4(k-1) */
;;;425        /* pState pointer (pS1) is incremented twice as the real values are located alternatively in the array */
;;;426        in = *pS1++ - in;
;;;427        *pbuff++ = in;
;;;428        /* points to the next real value */
;;;429        pS1++;
;;;430    
;;;431    
;;;432        /* Decrement the loop counter */
;;;433        i--;
;;;434      } while(i > 0u);
;;;435    
;;;436    
;;;437            /*------------ Normalizing the output by multiplying with the normalizing factor ----------*/
;;;438    
;;;439      /* Initializing the loop counter */
;;;440      i = (uint32_t) S->N;
;;;441    
;;;442      /* pbuff initialized to the pInlineBuffer(now contains the output values) */
;;;443      pbuff = pInlineBuffer;
;;;444    
;;;445      do
;;;446      {
;;;447        /* Multiplying pInlineBuffer with the normalizing factor sqrt(2/N) */
;;;448        in = *pbuff;
;;;449        *pbuff++ = in * S->normalize;
;;;450    
;;;451        /* Decrement the loop counter */
;;;452        i--;
;;;453      } while(i > 0u);
;;;454    
;;;455    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;456    
;;;457    }
00018c  e8bd81f0          POP      {r4-r8,pc}
;;;458    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\TransformFunctions\\arm_dct4_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_dct4_f32_c_2efb3923____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___14_arm_dct4_f32_c_2efb3923____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_dct4_f32_c_2efb3923____REVSH|
#line 144
|__asm___14_arm_dct4_f32_c_2efb3923____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_dct4_f32_c_2efb3923____RRX|
#line 300
|__asm___14_arm_dct4_f32_c_2efb3923____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
