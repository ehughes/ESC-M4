; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_trans_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_trans_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_mat_trans_f32.crf ..\..\SRC\CMSIS_DSP_4_5\src\MatrixFunctions\arm_mat_trans_f32.c]
                          THUMB

                          AREA ||i.arm_mat_trans_f32||, CODE, READONLY, ALIGN=1

                  arm_mat_trans_f32 PROC
;;;68     
;;;69     arm_status arm_mat_trans_f32(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;70       const arm_matrix_instance_f32 * pSrc,
;;;71       arm_matrix_instance_f32 * pDst)
;;;72     {
;;;73       float32_t *pIn = pSrc->pData;                  /* input data matrix pointer */
000004  6842              LDR      r2,[r0,#4]
;;;74       float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
000006  f8d1c004          LDR      r12,[r1,#4]
;;;75       float32_t *px;                                 /* Temporary output data matrix pointer */
;;;76       uint16_t nRows = pSrc->numRows;                /* number of rows */
00000a  8801              LDRH     r1,[r0,#0]
;;;77       uint16_t nColumns = pSrc->numCols;             /* number of columns */
00000c  8847              LDRH     r7,[r0,#2]
;;;78     
;;;79     #ifndef ARM_MATH_CM0_FAMILY
;;;80     
;;;81       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;82     
;;;83       uint16_t blkCnt, i = 0u, row = nRows;          /* loop counters */
00000e  2600              MOVS     r6,#0
000010  460d              MOV      r5,r1
;;;84       arm_status status;                             /* status of matrix transpose  */
;;;85     
;;;86     
;;;87     #ifdef ARM_MATH_MATRIX_CHECK
;;;88     
;;;89     
;;;90       /* Check for matrix mismatch condition */
;;;91       if((pSrc->numRows != pDst->numCols) || (pSrc->numCols != pDst->numRows))
;;;92       {
;;;93         /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;94         status = ARM_MATH_SIZE_MISMATCH;
;;;95       }
;;;96       else
;;;97     #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;98     
;;;99       {
;;;100        /* Matrix transpose by exchanging the rows with columns */
;;;101        /* row loop     */
;;;102        do
;;;103        {
;;;104          /* Loop Unrolling */
;;;105          blkCnt = nColumns >> 2;
000012  ea4f0897          LSR      r8,r7,#2
                  |L1.22|
000016  4643              MOV      r3,r8
;;;106    
;;;107          /* The pointer px is set to starting address of the column being processed */
;;;108          px = pOut + i;
000018  eb0c0086          ADD      r0,r12,r6,LSL #2
;;;109    
;;;110          /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;111           ** a second loop below computes the remaining 1 to 3 samples. */
;;;112          while(blkCnt > 0u)        /* column loop */
00001c  e019              B        |L1.82|
                  |L1.30|
;;;113          {
;;;114            /* Read and store the input element in the destination */
;;;115            *px = *pIn++;
00001e  ecb20a01          VLDM     r2!,{s0}
000022  ed800a00          VSTR     s0,[r0,#0]
;;;116    
;;;117            /* Update the pointer px to point to the next row of the transposed matrix */
;;;118            px += nRows;
000026  eb000081          ADD      r0,r0,r1,LSL #2
;;;119    
;;;120            /* Read and store the input element in the destination */
;;;121            *px = *pIn++;
00002a  ecb20a01          VLDM     r2!,{s0}
00002e  ed800a00          VSTR     s0,[r0,#0]
;;;122    
;;;123            /* Update the pointer px to point to the next row of the transposed matrix */
;;;124            px += nRows;
000032  eb000081          ADD      r0,r0,r1,LSL #2
;;;125    
;;;126            /* Read and store the input element in the destination */
;;;127            *px = *pIn++;
000036  ecb20a01          VLDM     r2!,{s0}
00003a  ed800a00          VSTR     s0,[r0,#0]
;;;128    
;;;129            /* Update the pointer px to point to the next row of the transposed matrix */
;;;130            px += nRows;
00003e  eb000081          ADD      r0,r0,r1,LSL #2
;;;131    
;;;132            /* Read and store the input element in the destination */
;;;133            *px = *pIn++;
000042  ecb20a01          VLDM     r2!,{s0}
000046  ed800a00          VSTR     s0,[r0,#0]
;;;134    
;;;135            /* Update the pointer px to point to the next row of the transposed matrix */
;;;136            px += nRows;
00004a  eb000081          ADD      r0,r0,r1,LSL #2
;;;137    
;;;138            /* Decrement the column loop counter */
;;;139            blkCnt--;
00004e  1e5b              SUBS     r3,r3,#1
000050  b29b              UXTH     r3,r3
                  |L1.82|
000052  2b00              CMP      r3,#0                 ;112
000054  d1e3              BNE      |L1.30|
;;;140          }
;;;141    
;;;142          /* Perform matrix transpose for last 3 samples here. */
;;;143          blkCnt = nColumns % 0x4u;
000056  f0070403          AND      r4,r7,#3
;;;144    
;;;145          while(blkCnt > 0u)
00005a  e007              B        |L1.108|
                  |L1.92|
;;;146          {
;;;147            /* Read and store the input element in the destination */
;;;148            *px = *pIn++;
00005c  ecb20a01          VLDM     r2!,{s0}
000060  ed800a00          VSTR     s0,[r0,#0]
;;;149    
;;;150            /* Update the pointer px to point to the next row of the transposed matrix */
;;;151            px += nRows;
000064  eb000081          ADD      r0,r0,r1,LSL #2
;;;152    
;;;153            /* Decrement the column loop counter */
;;;154            blkCnt--;
000068  1e64              SUBS     r4,r4,#1
00006a  b2a4              UXTH     r4,r4
                  |L1.108|
00006c  2c00              CMP      r4,#0                 ;145
00006e  d1f5              BNE      |L1.92|
;;;155          }
;;;156    
;;;157    #else
;;;158    
;;;159      /* Run the below code for Cortex-M0 */
;;;160    
;;;161      uint16_t col, i = 0u, row = nRows;             /* loop counters */
;;;162      arm_status status;                             /* status of matrix transpose  */
;;;163    
;;;164    
;;;165    #ifdef ARM_MATH_MATRIX_CHECK
;;;166    
;;;167      /* Check for matrix mismatch condition */
;;;168      if((pSrc->numRows != pDst->numCols) || (pSrc->numCols != pDst->numRows))
;;;169      {
;;;170        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;171        status = ARM_MATH_SIZE_MISMATCH;
;;;172      }
;;;173      else
;;;174    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;175    
;;;176      {
;;;177        /* Matrix transpose by exchanging the rows with columns */
;;;178        /* row loop     */
;;;179        do
;;;180        {
;;;181          /* The pointer px is set to starting address of the column being processed */
;;;182          px = pOut + i;
;;;183    
;;;184          /* Initialize column loop counter */
;;;185          col = nColumns;
;;;186    
;;;187          while(col > 0u)
;;;188          {
;;;189            /* Read and store the input element in the destination */
;;;190            *px = *pIn++;
;;;191    
;;;192            /* Update the pointer px to point to the next row of the transposed matrix */
;;;193            px += nRows;
;;;194    
;;;195            /* Decrement the column loop counter */
;;;196            col--;
;;;197          }
;;;198    
;;;199    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;200    
;;;201          i++;
000070  1c76              ADDS     r6,r6,#1
000072  b2b6              UXTH     r6,r6
;;;202    
;;;203          /* Decrement the row loop counter */
;;;204          row--;
000074  1e6d              SUBS     r5,r5,#1
000076  b2ad              UXTH     r5,r5
;;;205    
;;;206        } while(row > 0u);          /* row loop end  */
000078  2d00              CMP      r5,#0
00007a  d1cc              BNE      |L1.22|
;;;207    
;;;208        /* Set status as ARM_MATH_SUCCESS */
;;;209        status = ARM_MATH_SUCCESS;
00007c  2000              MOVS     r0,#0
;;;210      }
;;;211    
;;;212      /* Return to application */
;;;213      return (status);
;;;214    }
00007e  e8bd81f0          POP      {r4-r8,pc}
;;;215    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\MatrixFunctions\\arm_mat_trans_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_mat_trans_f32_c_57f6fe7b____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___19_arm_mat_trans_f32_c_57f6fe7b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_mat_trans_f32_c_57f6fe7b____REVSH|
#line 144
|__asm___19_arm_mat_trans_f32_c_57f6fe7b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_mat_trans_f32_c_57f6fe7b____RRX|
#line 300
|__asm___19_arm_mat_trans_f32_c_57f6fe7b____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
