; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_partial_fast_opt_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_partial_fast_opt_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_conv_partial_fast_opt_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_partial_fast_opt_q15.c]
                          THUMB

                          AREA ||i.arm_conv_partial_fast_opt_q15||, CODE, READONLY, ALIGN=1

                  arm_conv_partial_fast_opt_q15 PROC
;;;74     
;;;75     arm_status arm_conv_partial_fast_opt_q15(
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;76       q15_t * pSrcA,
;;;77       uint32_t srcALen,
;;;78       q15_t * pSrcB,
;;;79       uint32_t srcBLen,
;;;80       q15_t * pDst,
;;;81       uint32_t firstIndex,
;;;82       uint32_t numPoints,
;;;83       q15_t * pScratch1,
;;;84       q15_t * pScratch2)
;;;85     {
000004  460c              MOV      r4,r1
000006  e9dd7111          LDRD     r7,r1,[sp,#0x44]
00000a  e9dd650e          LDRD     r6,r5,[sp,#0x38]
00000e  4698              MOV      r8,r3
;;;86     
;;;87       q15_t *pOut = pDst;                            /* output pointer */
;;;88       q15_t *pScr1 = pScratch1;                      /* Temporary pointer for scratch1 */
;;;89       q15_t *pScr2 = pScratch2;                      /* Temporary pointer for scratch1 */
;;;90       q31_t acc0, acc1, acc2, acc3;                  /* Accumulator */
;;;91       q31_t x1, x2, x3;                              /* Temporary variables to hold state and coefficient values */
;;;92       q31_t y1, y2;                                  /* State variables */
;;;93       q15_t *pIn1;                                   /* inputA pointer */
;;;94       q15_t *pIn2;                                   /* inputB pointer */
;;;95       q15_t *px;                                     /* Intermediate inputA pointer  */
;;;96       q15_t *py;                                     /* Intermediate inputB pointer  */
;;;97       uint32_t j, k, blkCnt;                         /* loop counter */
;;;98       arm_status status;
;;;99     
;;;100      uint32_t tapCnt;                               /* loop count */
;;;101    
;;;102      /* Check for range of output samples to be calculated */
;;;103      if((firstIndex + numPoints) > ((srcALen + (srcBLen - 1u))))
000010  9b10              LDR      r3,[sp,#0x40]
000012  eb050c03          ADD      r12,r5,r3
000016  eb040308          ADD      r3,r4,r8
00001a  1e5b              SUBS     r3,r3,#1
00001c  459c              CMP      r12,r3
00001e  d904              BLS      |L1.42|
;;;104      {
;;;105        /* Set status as ARM_MATH_ARGUMENT_ERROR */
;;;106        status = ARM_MATH_ARGUMENT_ERROR;
000020  f04f30ff          MOV      r0,#0xffffffff
                  |L1.36|
;;;107      }
;;;108      else
;;;109      {
;;;110    
;;;111        /* The algorithm implementation is based on the lengths of the inputs. */
;;;112        /* srcB is always made to slide across srcA. */
;;;113        /* So srcBLen is always considered as shorter or equal to srcALen */
;;;114        if(srcALen >= srcBLen)
;;;115        {
;;;116          /* Initialization of inputA pointer */
;;;117          pIn1 = pSrcA;
;;;118    
;;;119          /* Initialization of inputB pointer */
;;;120          pIn2 = pSrcB;
;;;121        }
;;;122        else
;;;123        {
;;;124          /* Initialization of inputA pointer */
;;;125          pIn1 = pSrcB;
;;;126    
;;;127          /* Initialization of inputB pointer */
;;;128          pIn2 = pSrcA;
;;;129    
;;;130          /* srcBLen is always considered as shorter or equal to srcALen */
;;;131          j = srcBLen;
;;;132          srcBLen = srcALen;
;;;133          srcALen = j;
;;;134        }
;;;135    
;;;136        /* Temporary pointer for scratch2 */
;;;137        py = pScratch2;
;;;138    
;;;139        /* pointer to take end of scratch2 buffer */
;;;140        pScr2 = pScratch2 + srcBLen - 1;
;;;141    
;;;142        /* points to smaller length sequence */
;;;143        px = pIn2;
;;;144    
;;;145        /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;146        k = srcBLen >> 2u;
;;;147    
;;;148        /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;149         ** a second loop below copies for the remaining 1 to 3 samples. */
;;;150    
;;;151        /* Copy smaller length input sequence in reverse order into second scratch buffer */
;;;152        while(k > 0u)
;;;153        {
;;;154          /* copy second buffer in reversal manner */
;;;155          *pScr2-- = *px++;
;;;156          *pScr2-- = *px++;
;;;157          *pScr2-- = *px++;
;;;158          *pScr2-- = *px++;
;;;159    
;;;160          /* Decrement the loop counter */
;;;161          k--;
;;;162        }
;;;163    
;;;164        /* If the count is not a multiple of 4, copy remaining samples here.       
;;;165         ** No loop unrolling is used. */
;;;166        k = srcBLen % 0x4u;
;;;167    
;;;168        while(k > 0u)
;;;169        {
;;;170          /* copy second buffer in reversal manner for remaining samples */
;;;171          *pScr2-- = *px++;
;;;172    
;;;173          /* Decrement the loop counter */
;;;174          k--;
;;;175        }
;;;176    
;;;177        /* Initialze temporary scratch pointer */
;;;178        pScr1 = pScratch1;
;;;179    
;;;180        /* Assuming scratch1 buffer is aligned by 32-bit */
;;;181        /* Fill (srcBLen - 1u) zeros in scratch buffer */
;;;182        arm_fill_q15(0, pScr1, (srcBLen - 1u));
;;;183    
;;;184        /* Update temporary scratch pointer */
;;;185        pScr1 += (srcBLen - 1u);
;;;186    
;;;187        /* Copy bigger length sequence(srcALen) samples in scratch1 buffer */
;;;188    
;;;189        /* Copy (srcALen) samples in scratch buffer */
;;;190        arm_copy_q15(pIn1, pScr1, srcALen);
;;;191    
;;;192        /* Update pointers */
;;;193        pScr1 += srcALen;
;;;194    
;;;195        /* Fill (srcBLen - 1u) zeros at end of scratch buffer */
;;;196        arm_fill_q15(0, pScr1, (srcBLen - 1u));
;;;197    
;;;198        /* Update pointer */
;;;199        pScr1 += (srcBLen - 1u);
;;;200    
;;;201        /* Initialization of pIn2 pointer */
;;;202        pIn2 = py;
;;;203    
;;;204        pScratch1 += firstIndex;
;;;205    
;;;206        pOut = pDst + firstIndex;
;;;207    
;;;208        /* First part of the processing with loop unrolling process 4 data points at a time.       
;;;209         ** a second loop below process for the remaining 1 to 3 samples. */
;;;210    
;;;211        /* Actual convolution process starts here */
;;;212        blkCnt = (numPoints) >> 2;
;;;213    
;;;214        while(blkCnt > 0)
;;;215        {
;;;216          /* Initialze temporary scratch pointer as scratch1 */
;;;217          pScr1 = pScratch1;
;;;218    
;;;219          /* Clear Accumlators */
;;;220          acc0 = 0;
;;;221          acc1 = 0;
;;;222          acc2 = 0;
;;;223          acc3 = 0;
;;;224    
;;;225          /* Read two samples from scratch1 buffer */
;;;226          x1 = *__SIMD32(pScr1)++;
;;;227    
;;;228          /* Read next two samples from scratch1 buffer */
;;;229          x2 = *__SIMD32(pScr1)++;
;;;230    
;;;231          tapCnt = (srcBLen) >> 2u;
;;;232    
;;;233          while(tapCnt > 0u)
;;;234          {
;;;235    
;;;236            /* Read four samples from smaller buffer */
;;;237            y1 = _SIMD32_OFFSET(pIn2);
;;;238            y2 = _SIMD32_OFFSET(pIn2 + 2u);
;;;239    
;;;240            /* multiply and accumlate */
;;;241            acc0 = __SMLAD(x1, y1, acc0);
;;;242            acc2 = __SMLAD(x2, y1, acc2);
;;;243    
;;;244            /* pack input data */
;;;245    #ifndef ARM_MATH_BIG_ENDIAN
;;;246            x3 = __PKHBT(x2, x1, 0);
;;;247    #else
;;;248            x3 = __PKHBT(x1, x2, 0);
;;;249    #endif
;;;250    
;;;251            /* multiply and accumlate */
;;;252            acc1 = __SMLADX(x3, y1, acc1);
;;;253    
;;;254            /* Read next two samples from scratch1 buffer */
;;;255            x1 = _SIMD32_OFFSET(pScr1);
;;;256    
;;;257            /* multiply and accumlate */
;;;258            acc0 = __SMLAD(x2, y2, acc0);
;;;259    
;;;260            acc2 = __SMLAD(x1, y2, acc2);
;;;261    
;;;262            /* pack input data */
;;;263    #ifndef ARM_MATH_BIG_ENDIAN
;;;264            x3 = __PKHBT(x1, x2, 0);
;;;265    #else
;;;266            x3 = __PKHBT(x2, x1, 0);
;;;267    #endif
;;;268    
;;;269            acc3 = __SMLADX(x3, y1, acc3);
;;;270            acc1 = __SMLADX(x3, y2, acc1);
;;;271    
;;;272            x2 = _SIMD32_OFFSET(pScr1 + 2u);
;;;273    
;;;274    #ifndef ARM_MATH_BIG_ENDIAN
;;;275            x3 = __PKHBT(x2, x1, 0);
;;;276    #else
;;;277            x3 = __PKHBT(x1, x2, 0);
;;;278    #endif
;;;279    
;;;280            acc3 = __SMLADX(x3, y2, acc3);
;;;281    
;;;282            /* update scratch pointers */
;;;283            pIn2 += 4u;
;;;284            pScr1 += 4u;
;;;285    
;;;286    
;;;287            /* Decrement the loop counter */
;;;288            tapCnt--;
;;;289          }
;;;290    
;;;291          /* Update scratch pointer for remaining samples of smaller length sequence */
;;;292          pScr1 -= 4u;
;;;293    
;;;294          /* apply same above for remaining samples of smaller length sequence */
;;;295          tapCnt = (srcBLen) & 3u;
;;;296    
;;;297          while(tapCnt > 0u)
;;;298          {
;;;299    
;;;300            /* accumlate the results */
;;;301            acc0 += (*pScr1++ * *pIn2);
;;;302            acc1 += (*pScr1++ * *pIn2);
;;;303            acc2 += (*pScr1++ * *pIn2);
;;;304            acc3 += (*pScr1++ * *pIn2++);
;;;305    
;;;306            pScr1 -= 3u;
;;;307    
;;;308            /* Decrement the loop counter */
;;;309            tapCnt--;
;;;310          }
;;;311    
;;;312          blkCnt--;
;;;313    
;;;314    
;;;315          /* Store the results in the accumulators in the destination buffer. */
;;;316    
;;;317    #ifndef  ARM_MATH_BIG_ENDIAN
;;;318    
;;;319          *__SIMD32(pOut)++ =
;;;320            __PKHBT(__SSAT((acc0 >> 15), 16), __SSAT((acc1 >> 15), 16), 16);
;;;321          *__SIMD32(pOut)++ =
;;;322            __PKHBT(__SSAT((acc2 >> 15), 16), __SSAT((acc3 >> 15), 16), 16);
;;;323    
;;;324    #else
;;;325    
;;;326          *__SIMD32(pOut)++ =
;;;327            __PKHBT(__SSAT((acc1 >> 15), 16), __SSAT((acc0 >> 15), 16), 16);
;;;328          *__SIMD32(pOut)++ =
;;;329            __PKHBT(__SSAT((acc3 >> 15), 16), __SSAT((acc2 >> 15), 16), 16);
;;;330    
;;;331    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;332    
;;;333          /* Initialization of inputB pointer */
;;;334          pIn2 = py;
;;;335    
;;;336          pScratch1 += 4u;
;;;337    
;;;338        }
;;;339    
;;;340    
;;;341        blkCnt = numPoints & 0x3;
;;;342    
;;;343        /* Calculate convolution for remaining samples of Bigger length sequence */
;;;344        while(blkCnt > 0)
;;;345        {
;;;346          /* Initialze temporary scratch pointer as scratch1 */
;;;347          pScr1 = pScratch1;
;;;348    
;;;349          /* Clear Accumlators */
;;;350          acc0 = 0;
;;;351    
;;;352          tapCnt = (srcBLen) >> 1u;
;;;353    
;;;354          while(tapCnt > 0u)
;;;355          {
;;;356    
;;;357            /* Read next two samples from scratch1 buffer */
;;;358            x1 = *__SIMD32(pScr1)++;
;;;359    
;;;360            /* Read two samples from smaller buffer */
;;;361            y1 = *__SIMD32(pIn2)++;
;;;362    
;;;363            acc0 = __SMLAD(x1, y1, acc0);
;;;364    
;;;365            /* Decrement the loop counter */
;;;366            tapCnt--;
;;;367          }
;;;368    
;;;369          tapCnt = (srcBLen) & 1u;
;;;370    
;;;371          /* apply same above for remaining samples of smaller length sequence */
;;;372          while(tapCnt > 0u)
;;;373          {
;;;374    
;;;375            /* accumlate the results */
;;;376            acc0 += (*pScr1++ * *pIn2++);
;;;377    
;;;378            /* Decrement the loop counter */
;;;379            tapCnt--;
;;;380          }
;;;381    
;;;382          blkCnt--;
;;;383    
;;;384          /* The result is in 2.30 format.  Convert to 1.15 with saturation.       
;;;385           ** Then store the output in the destination buffer. */
;;;386          *pOut++ = (q15_t) (__SSAT((acc0 >> 15), 16));
;;;387    
;;;388          /* Initialization of inputB pointer */
;;;389          pIn2 = py;
;;;390    
;;;391          pScratch1 += 1u;
;;;392    
;;;393        }
;;;394        /* set status as ARM_MATH_SUCCESS */
;;;395        status = ARM_MATH_SUCCESS;
;;;396      }
;;;397      /* Return to application */
;;;398      return (status);
;;;399    }
000024  b004              ADD      sp,sp,#0x10
000026  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.42|
00002a  4544              CMP      r4,r8                 ;114
00002c  d302              BCC      |L1.52|
00002e  4681              MOV      r9,r0                 ;117
000030  4610              MOV      r0,r2                 ;120
000032  e003              B        |L1.60|
                  |L1.52|
000034  4691              MOV      r9,r2                 ;125
000036  4642              MOV      r2,r8                 ;131
000038  46a0              MOV      r8,r4                 ;132
00003a  4614              MOV      r4,r2                 ;133
                  |L1.60|
00003c  9101              STR      r1,[sp,#4]            ;137
00003e  eb010248          ADD      r2,r1,r8,LSL #1       ;140
000042  1e92              SUBS     r2,r2,#2              ;140
000044  ea4f0198          LSR      r1,r8,#2              ;146
000048  9103              STR      r1,[sp,#0xc]          ;146
00004a  e00b              B        |L1.100|
                  |L1.76|
00004c  1f92              SUBS     r2,r2,#6              ;155
00004e  8803              LDRH     r3,[r0,#0]            ;155
000050  80d3              STRH     r3,[r2,#6]            ;155
000052  8843              LDRH     r3,[r0,#2]            ;156
000054  8093              STRH     r3,[r2,#4]            ;156
000056  8883              LDRH     r3,[r0,#4]            ;157
000058  8053              STRH     r3,[r2,#2]            ;157
00005a  88c3              LDRH     r3,[r0,#6]            ;158
00005c  3008              ADDS     r0,r0,#8              ;158
00005e  f8223902          STRH     r3,[r2],#-2           ;158
000062  1e49              SUBS     r1,r1,#1              ;161
                  |L1.100|
000064  2900              CMP      r1,#0                 ;152
000066  d1f1              BNE      |L1.76|
000068  f0080103          AND      r1,r8,#3              ;166
00006c  9102              STR      r1,[sp,#8]            ;166
00006e  e004              B        |L1.122|
                  |L1.112|
000070  f8303b02          LDRH     r3,[r0],#2            ;171
000074  f8223902          STRH     r3,[r2],#-2           ;171
000078  1e49              SUBS     r1,r1,#1              ;174
                  |L1.122|
00007a  2900              CMP      r1,#0                 ;168
00007c  d1f8              BNE      |L1.112|
00007e  f1a80201          SUB      r2,r8,#1              ;182
000082  4639              MOV      r1,r7                 ;182
000084  2000              MOVS     r0,#0                 ;182
000086  f7fffffe          BL       arm_fill_q15
00008a  f1a80001          SUB      r0,r8,#1              ;185
00008e  eb070a40          ADD      r10,r7,r0,LSL #1      ;185
000092  4622              MOV      r2,r4                 ;190
000094  4651              MOV      r1,r10                ;190
000096  4648              MOV      r0,r9                 ;190
000098  f7fffffe          BL       arm_copy_q15
00009c  eb0a0144          ADD      r1,r10,r4,LSL #1      ;193
0000a0  f1a80201          SUB      r2,r8,#1              ;196
0000a4  2000              MOVS     r0,#0                 ;196
0000a6  f7fffffe          BL       arm_fill_q15
0000aa  9801              LDR      r0,[sp,#4]            ;202
0000ac  eb070a45          ADD      r10,r7,r5,LSL #1      ;204
0000b0  eb060b45          ADD      r11,r6,r5,LSL #1      ;206
0000b4  9910              LDR      r1,[sp,#0x40]         ;212
0000b6  0889              LSRS     r1,r1,#2              ;212
0000b8  9100              STR      r1,[sp,#0]            ;212
0000ba  e05c              B        |L1.374|
                  |L1.188|
0000bc  4654              MOV      r4,r10                ;217
0000be  2500              MOVS     r5,#0                 ;220
0000c0  2600              MOVS     r6,#0                 ;221
0000c2  2700              MOVS     r7,#0                 ;222
0000c4  2300              MOVS     r3,#0                 ;223
0000c6  6822              LDR      r2,[r4,#0]            ;226
0000c8  6861              LDR      r1,[r4,#4]            ;229
0000ca  3408              ADDS     r4,r4,#8              ;229
0000cc  f8dde00c          LDR      lr,[sp,#0xc]          ;231
0000d0  e01f              B        |L1.274|
                  |L1.210|
0000d2  f8d09000          LDR      r9,[r0,#0]            ;237
0000d6  f8d0c004          LDR      r12,[r0,#4]           ;238
0000da  fb225509          SMLAD    r5,r2,r9,r5           ;241
0000de  fb217709          SMLAD    r7,r1,r9,r7           ;242
0000e2  eac10202          PKHBT    r2,r1,r2              ;246
0000e6  fb226619          SMLADX   r6,r2,r9,r6           ;252
0000ea  6822              LDR      r2,[r4,#0]            ;255
0000ec  fb21550c          SMLAD    r5,r1,r12,r5          ;258
0000f0  fb22770c          SMLAD    r7,r2,r12,r7          ;260
0000f4  eac20101          PKHBT    r1,r2,r1              ;264
0000f8  fb213319          SMLADX   r3,r1,r9,r3           ;269
0000fc  fb21661c          SMLADX   r6,r1,r12,r6          ;270
000100  6861              LDR      r1,[r4,#4]            ;272
000102  eac10902          PKHBT    r9,r1,r2              ;275
000106  fb29331c          SMLADX   r3,r9,r12,r3          ;280
00010a  3008              ADDS     r0,r0,#8              ;283
00010c  3408              ADDS     r4,r4,#8              ;284
00010e  f1ae0e01          SUB      lr,lr,#1              ;288
                  |L1.274|
000112  f1be0f00          CMP      lr,#0                 ;233
000116  d1dc              BNE      |L1.210|
000118  3c08              SUBS     r4,r4,#8              ;292
00011a  9a02              LDR      r2,[sp,#8]            ;295
00011c  e013              B        |L1.326|
                  |L1.286|
00011e  f834cb02          LDRH     r12,[r4],#2           ;301
000122  f8301b02          LDRH     r1,[r0],#2            ;301
000126  fb1c5501          SMLABB   r5,r12,r1,r5          ;301
00012a  f834cb02          LDRH     r12,[r4],#2           ;302
00012e  fb1c6601          SMLABB   r6,r12,r1,r6          ;302
000132  f834cb02          LDRH     r12,[r4],#2           ;303
000136  fb1c7701          SMLABB   r7,r12,r1,r7          ;303
00013a  f8b4c000          LDRH     r12,[r4,#0]           ;304
00013e  fb1c3301          SMLABB   r3,r12,r1,r3          ;304
000142  1f24              SUBS     r4,r4,#4              ;306
000144  1e52              SUBS     r2,r2,#1              ;309
                  |L1.326|
000146  2a00              CMP      r2,#0                 ;297
000148  d1e9              BNE      |L1.286|
00014a  9800              LDR      r0,[sp,#0]            ;312
00014c  1e40              SUBS     r0,r0,#1              ;312
00014e  9000              STR      r0,[sp,#0]            ;312
000150  f32530cf          SSAT     r0,#16,r5,ASR #15     ;319
000154  f32631cf          SSAT     r1,#16,r6,ASR #15     ;319
000158  eac04001          PKHBT    r0,r0,r1,LSL #16      ;319
00015c  f84b0b04          STR      r0,[r11],#4           ;319
000160  f32730cf          SSAT     r0,#16,r7,ASR #15     ;321
000164  f32331cf          SSAT     r1,#16,r3,ASR #15     ;321
000168  eac04001          PKHBT    r0,r0,r1,LSL #16      ;321
00016c  f84b0b04          STR      r0,[r11],#4           ;321
000170  9801              LDR      r0,[sp,#4]            ;334
000172  f10a0a08          ADD      r10,r10,#8            ;336
                  |L1.374|
000176  9900              LDR      r1,[sp,#0]            ;214
000178  2900              CMP      r1,#0                 ;214
00017a  d19f              BNE      |L1.188|
00017c  9910              LDR      r1,[sp,#0x40]         ;341
00017e  f0010403          AND      r4,r1,#3              ;341
000182  e021              B        |L1.456|
                  |L1.388|
000184  4651              MOV      r1,r10                ;347
000186  2200              MOVS     r2,#0                 ;350
000188  ea4f0358          LSR      r3,r8,#1              ;352
00018c  e006              B        |L1.412|
                  |L1.398|
00018e  f8515b04          LDR      r5,[r1],#4            ;358
000192  f8506b04          LDR      r6,[r0],#4            ;361
000196  fb252206          SMLAD    r2,r5,r6,r2           ;363
00019a  1e5b              SUBS     r3,r3,#1              ;366
                  |L1.412|
00019c  2b00              CMP      r3,#0                 ;354
00019e  d1f6              BNE      |L1.398|
0001a0  f0080301          AND      r3,r8,#1              ;369
0001a4  e006              B        |L1.436|
                  |L1.422|
0001a6  f8315b02          LDRH     r5,[r1],#2            ;376
0001aa  f8306b02          LDRH     r6,[r0],#2            ;376
0001ae  fb152206          SMLABB   r2,r5,r6,r2           ;376
0001b2  1e5b              SUBS     r3,r3,#1              ;379
                  |L1.436|
0001b4  2b00              CMP      r3,#0                 ;372
0001b6  d1f6              BNE      |L1.422|
0001b8  1e64              SUBS     r4,r4,#1              ;382
0001ba  f32230cf          SSAT     r0,#16,r2,ASR #15     ;386
0001be  f82b0b02          STRH     r0,[r11],#2           ;386
0001c2  9801              LDR      r0,[sp,#4]            ;389
0001c4  f10a0a02          ADD      r10,r10,#2            ;391
                  |L1.456|
0001c8  2c00              CMP      r4,#0                 ;344
0001ca  d1db              BNE      |L1.388|
0001cc  2000              MOVS     r0,#0                 ;395
0001ce  e729              B        |L1.36|
;;;400    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_partial_fast_opt_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___31_arm_conv_partial_fast_opt_q15_c_47452bd7____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___31_arm_conv_partial_fast_opt_q15_c_47452bd7____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___31_arm_conv_partial_fast_opt_q15_c_47452bd7____REVSH|
#line 144
|__asm___31_arm_conv_partial_fast_opt_q15_c_47452bd7____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___31_arm_conv_partial_fast_opt_q15_c_47452bd7____RRX|
#line 300
|__asm___31_arm_conv_partial_fast_opt_q15_c_47452bd7____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
