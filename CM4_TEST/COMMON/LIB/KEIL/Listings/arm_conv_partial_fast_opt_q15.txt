; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_partial_fast_opt_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_partial_fast_opt_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE\_CMSIS_DSP_4_5_O3 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_conv_partial_fast_opt_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_partial_fast_opt_q15.c]
                          THUMB

                          AREA ||i.arm_conv_partial_fast_opt_q15||, CODE, READONLY, ALIGN=2

                  arm_conv_partial_fast_opt_q15 PROC
;;;74     
;;;75     arm_status arm_conv_partial_fast_opt_q15(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;76       q15_t * pSrcA,
;;;77       uint32_t srcALen,
;;;78       q15_t * pSrcB,
;;;79       uint32_t srcBLen,
;;;80       q15_t * pDst,
;;;81       uint32_t firstIndex,
;;;82       uint32_t numPoints,
;;;83       q15_t * pScratch1,
;;;84       q15_t * pScratch2)
;;;85     {
000004  b087              SUB      sp,sp,#0x1c
000006  461c              MOV      r4,r3
000008  460f              MOV      r7,r1
00000a  e9dda610          LDRD     r10,r6,[sp,#0x40]
;;;86     
;;;87       q15_t *pOut = pDst;                            /* output pointer */
;;;88       q15_t *pScr1 = pScratch1;                      /* Temporary pointer for scratch1 */
;;;89       q15_t *pScr2 = pScratch2;                      /* Temporary pointer for scratch1 */
;;;90       q31_t acc0, acc1, acc2, acc3;                  /* Accumulator */
;;;91       q31_t x1, x2, x3;                              /* Temporary variables to hold state and coefficient values */
;;;92       q31_t y1, y2;                                  /* State variables */
;;;93       q15_t *pIn1;                                   /* inputA pointer */
;;;94       q15_t *pIn2;                                   /* inputB pointer */
;;;95       q15_t *px;                                     /* Intermediate inputA pointer  */
;;;96       q15_t *py;                                     /* Intermediate inputB pointer  */
;;;97       uint32_t j, k, blkCnt;                         /* loop counter */
;;;98       arm_status status;
;;;99     
;;;100      uint32_t tapCnt;                               /* loop count */
;;;101    
;;;102      /* Check for range of output samples to be calculated */
;;;103      if((firstIndex + numPoints) > ((srcALen + (srcBLen - 1u))))
00000e  9b12              LDR      r3,[sp,#0x48]
000010  e9dd8113          LDRD     r8,r1,[sp,#0x4c]      ;85
000014  18f5              ADDS     r5,r6,r3
000016  193b              ADDS     r3,r7,r4
000018  1e5b              SUBS     r3,r3,#1
00001a  429d              CMP      r5,r3
00001c  d904              BLS      |L1.40|
;;;104      {
;;;105        /* Set status as ARM_MATH_ARGUMENT_ERROR */
;;;106        status = ARM_MATH_ARGUMENT_ERROR;
00001e  f04f30ff          MOV      r0,#0xffffffff
                  |L1.34|
;;;107      }
;;;108      else
;;;109      {
;;;110    
;;;111        /* The algorithm implementation is based on the lengths of the inputs. */
;;;112        /* srcB is always made to slide across srcA. */
;;;113        /* So srcBLen is always considered as shorter or equal to srcALen */
;;;114        if(srcALen >= srcBLen)
;;;115        {
;;;116          /* Initialization of inputA pointer */
;;;117          pIn1 = pSrcA;
;;;118    
;;;119          /* Initialization of inputB pointer */
;;;120          pIn2 = pSrcB;
;;;121        }
;;;122        else
;;;123        {
;;;124          /* Initialization of inputA pointer */
;;;125          pIn1 = pSrcB;
;;;126    
;;;127          /* Initialization of inputB pointer */
;;;128          pIn2 = pSrcA;
;;;129    
;;;130          /* srcBLen is always considered as shorter or equal to srcALen */
;;;131          j = srcBLen;
;;;132          srcBLen = srcALen;
;;;133          srcALen = j;
;;;134        }
;;;135    
;;;136        /* Temporary pointer for scratch2 */
;;;137        py = pScratch2;
;;;138    
;;;139        /* pointer to take end of scratch2 buffer */
;;;140        pScr2 = pScratch2 + srcBLen - 1;
;;;141    
;;;142        /* points to smaller length sequence */
;;;143        px = pIn2;
;;;144    
;;;145        /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;146        k = srcBLen >> 2u;
;;;147    
;;;148        /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;149         ** a second loop below copies for the remaining 1 to 3 samples. */
;;;150    
;;;151        /* Copy smaller length input sequence in reverse order into second scratch buffer */
;;;152        while(k > 0u)
;;;153        {
;;;154          /* copy second buffer in reversal manner */
;;;155          *pScr2-- = *px++;
;;;156          *pScr2-- = *px++;
;;;157          *pScr2-- = *px++;
;;;158          *pScr2-- = *px++;
;;;159    
;;;160          /* Decrement the loop counter */
;;;161          k--;
;;;162        }
;;;163    
;;;164        /* If the count is not a multiple of 4, copy remaining samples here.       
;;;165         ** No loop unrolling is used. */
;;;166        k = srcBLen % 0x4u;
;;;167    
;;;168        while(k > 0u)
;;;169        {
;;;170          /* copy second buffer in reversal manner for remaining samples */
;;;171          *pScr2-- = *px++;
;;;172    
;;;173          /* Decrement the loop counter */
;;;174          k--;
;;;175        }
;;;176    
;;;177        /* Initialze temporary scratch pointer */
;;;178        pScr1 = pScratch1;
;;;179    
;;;180        /* Assuming scratch1 buffer is aligned by 32-bit */
;;;181        /* Fill (srcBLen - 1u) zeros in scratch buffer */
;;;182        arm_fill_q15(0, pScr1, (srcBLen - 1u));
;;;183    
;;;184        /* Update temporary scratch pointer */
;;;185        pScr1 += (srcBLen - 1u);
;;;186    
;;;187        /* Copy bigger length sequence(srcALen) samples in scratch1 buffer */
;;;188    
;;;189        /* Copy (srcALen) samples in scratch buffer */
;;;190        arm_copy_q15(pIn1, pScr1, srcALen);
;;;191    
;;;192        /* Update pointers */
;;;193        pScr1 += srcALen;
;;;194    
;;;195        /* Fill (srcBLen - 1u) zeros at end of scratch buffer */
;;;196        arm_fill_q15(0, pScr1, (srcBLen - 1u));
;;;197    
;;;198        /* Update pointer */
;;;199        pScr1 += (srcBLen - 1u);
;;;200    
;;;201        /* Initialization of pIn2 pointer */
;;;202        pIn2 = py;
;;;203    
;;;204        pScratch1 += firstIndex;
;;;205    
;;;206        pOut = pDst + firstIndex;
;;;207    
;;;208        /* First part of the processing with loop unrolling process 4 data points at a time.       
;;;209         ** a second loop below process for the remaining 1 to 3 samples. */
;;;210    
;;;211        /* Actual convolution process starts here */
;;;212        blkCnt = (numPoints) >> 2;
;;;213    
;;;214        while(blkCnt > 0)
;;;215        {
;;;216          /* Initialze temporary scratch pointer as scratch1 */
;;;217          pScr1 = pScratch1;
;;;218    
;;;219          /* Clear Accumlators */
;;;220          acc0 = 0;
;;;221          acc1 = 0;
;;;222          acc2 = 0;
;;;223          acc3 = 0;
;;;224    
;;;225          /* Read two samples from scratch1 buffer */
;;;226          x1 = *__SIMD32(pScr1)++;
;;;227    
;;;228          /* Read next two samples from scratch1 buffer */
;;;229          x2 = *__SIMD32(pScr1)++;
;;;230    
;;;231          tapCnt = (srcBLen) >> 2u;
;;;232    
;;;233          while(tapCnt > 0u)
;;;234          {
;;;235    
;;;236            /* Read four samples from smaller buffer */
;;;237            y1 = _SIMD32_OFFSET(pIn2);
;;;238            y2 = _SIMD32_OFFSET(pIn2 + 2u);
;;;239    
;;;240            /* multiply and accumlate */
;;;241            acc0 = __SMLAD(x1, y1, acc0);
;;;242            acc2 = __SMLAD(x2, y1, acc2);
;;;243    
;;;244            /* pack input data */
;;;245    #ifndef ARM_MATH_BIG_ENDIAN
;;;246            x3 = __PKHBT(x2, x1, 0);
;;;247    #else
;;;248            x3 = __PKHBT(x1, x2, 0);
;;;249    #endif
;;;250    
;;;251            /* multiply and accumlate */
;;;252            acc1 = __SMLADX(x3, y1, acc1);
;;;253    
;;;254            /* Read next two samples from scratch1 buffer */
;;;255            x1 = _SIMD32_OFFSET(pScr1);
;;;256    
;;;257            /* multiply and accumlate */
;;;258            acc0 = __SMLAD(x2, y2, acc0);
;;;259    
;;;260            acc2 = __SMLAD(x1, y2, acc2);
;;;261    
;;;262            /* pack input data */
;;;263    #ifndef ARM_MATH_BIG_ENDIAN
;;;264            x3 = __PKHBT(x1, x2, 0);
;;;265    #else
;;;266            x3 = __PKHBT(x2, x1, 0);
;;;267    #endif
;;;268    
;;;269            acc3 = __SMLADX(x3, y1, acc3);
;;;270            acc1 = __SMLADX(x3, y2, acc1);
;;;271    
;;;272            x2 = _SIMD32_OFFSET(pScr1 + 2u);
;;;273    
;;;274    #ifndef ARM_MATH_BIG_ENDIAN
;;;275            x3 = __PKHBT(x2, x1, 0);
;;;276    #else
;;;277            x3 = __PKHBT(x1, x2, 0);
;;;278    #endif
;;;279    
;;;280            acc3 = __SMLADX(x3, y2, acc3);
;;;281    
;;;282            /* update scratch pointers */
;;;283            pIn2 += 4u;
;;;284            pScr1 += 4u;
;;;285    
;;;286    
;;;287            /* Decrement the loop counter */
;;;288            tapCnt--;
;;;289          }
;;;290    
;;;291          /* Update scratch pointer for remaining samples of smaller length sequence */
;;;292          pScr1 -= 4u;
;;;293    
;;;294          /* apply same above for remaining samples of smaller length sequence */
;;;295          tapCnt = (srcBLen) & 3u;
;;;296    
;;;297          while(tapCnt > 0u)
;;;298          {
;;;299    
;;;300            /* accumlate the results */
;;;301            acc0 += (*pScr1++ * *pIn2);
;;;302            acc1 += (*pScr1++ * *pIn2);
;;;303            acc2 += (*pScr1++ * *pIn2);
;;;304            acc3 += (*pScr1++ * *pIn2++);
;;;305    
;;;306            pScr1 -= 3u;
;;;307    
;;;308            /* Decrement the loop counter */
;;;309            tapCnt--;
;;;310          }
;;;311    
;;;312          blkCnt--;
;;;313    
;;;314    
;;;315          /* Store the results in the accumulators in the destination buffer. */
;;;316    
;;;317    #ifndef  ARM_MATH_BIG_ENDIAN
;;;318    
;;;319          *__SIMD32(pOut)++ =
;;;320            __PKHBT(__SSAT((acc0 >> 15), 16), __SSAT((acc1 >> 15), 16), 16);
;;;321          *__SIMD32(pOut)++ =
;;;322            __PKHBT(__SSAT((acc2 >> 15), 16), __SSAT((acc3 >> 15), 16), 16);
;;;323    
;;;324    #else
;;;325    
;;;326          *__SIMD32(pOut)++ =
;;;327            __PKHBT(__SSAT((acc1 >> 15), 16), __SSAT((acc0 >> 15), 16), 16);
;;;328          *__SIMD32(pOut)++ =
;;;329            __PKHBT(__SSAT((acc3 >> 15), 16), __SSAT((acc2 >> 15), 16), 16);
;;;330    
;;;331    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;332    
;;;333          /* Initialization of inputB pointer */
;;;334          pIn2 = py;
;;;335    
;;;336          pScratch1 += 4u;
;;;337    
;;;338        }
;;;339    
;;;340    
;;;341        blkCnt = numPoints & 0x3;
;;;342    
;;;343        /* Calculate convolution for remaining samples of Bigger length sequence */
;;;344        while(blkCnt > 0)
;;;345        {
;;;346          /* Initialze temporary scratch pointer as scratch1 */
;;;347          pScr1 = pScratch1;
;;;348    
;;;349          /* Clear Accumlators */
;;;350          acc0 = 0;
;;;351    
;;;352          tapCnt = (srcBLen) >> 1u;
;;;353    
;;;354          while(tapCnt > 0u)
;;;355          {
;;;356    
;;;357            /* Read next two samples from scratch1 buffer */
;;;358            x1 = *__SIMD32(pScr1)++;
;;;359    
;;;360            /* Read two samples from smaller buffer */
;;;361            y1 = *__SIMD32(pIn2)++;
;;;362    
;;;363            acc0 = __SMLAD(x1, y1, acc0);
;;;364    
;;;365            /* Decrement the loop counter */
;;;366            tapCnt--;
;;;367          }
;;;368    
;;;369          tapCnt = (srcBLen) & 1u;
;;;370    
;;;371          /* apply same above for remaining samples of smaller length sequence */
;;;372          while(tapCnt > 0u)
;;;373          {
;;;374    
;;;375            /* accumlate the results */
;;;376            acc0 += (*pScr1++ * *pIn2++);
;;;377    
;;;378            /* Decrement the loop counter */
;;;379            tapCnt--;
;;;380          }
;;;381    
;;;382          blkCnt--;
;;;383    
;;;384          /* The result is in 2.30 format.  Convert to 1.15 with saturation.       
;;;385           ** Then store the output in the destination buffer. */
;;;386          *pOut++ = (q15_t) (__SSAT((acc0 >> 15), 16));
;;;387    
;;;388          /* Initialization of inputB pointer */
;;;389          pIn2 = py;
;;;390    
;;;391          pScratch1 += 1u;
;;;392    
;;;393        }
;;;394        /* set status as ARM_MATH_SUCCESS */
;;;395        status = ARM_MATH_SUCCESS;
;;;396      }
;;;397      /* Return to application */
;;;398      return (status);
;;;399    }
000022  b007              ADD      sp,sp,#0x1c
000024  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.40|
000028  42a7              CMP      r7,r4                 ;114
00002a  d302              BCC      |L1.50|
00002c  4605              MOV      r5,r0                 ;117
00002e  4610              MOV      r0,r2                 ;120
000030  e003              B        |L1.58|
                  |L1.50|
000032  4615              MOV      r5,r2                 ;125
000034  4622              MOV      r2,r4                 ;131
000036  463c              MOV      r4,r7                 ;132
000038  4617              MOV      r7,r2                 ;133
                  |L1.58|
00003a  9101              STR      r1,[sp,#4]            ;140
00003c  08a2              LSRS     r2,r4,#2              ;146
00003e  eb010144          ADD      r1,r1,r4,LSL #1       ;140
000042  1e89              SUBS     r1,r1,#2              ;146
000044  9204              STR      r2,[sp,#0x10]         ;152
000046  e010              B        |L1.106|
                  |L1.72|
000048  f8303b02          LDRH     r3,[r0],#2            ;155
00004c  800b              STRH     r3,[r1,#0]            ;155
00004e  f830cb02          LDRH     r12,[r0],#2           ;156
000052  f821cc02          STRH     r12,[r1,#-2]          ;156
000056  f830cb02          LDRH     r12,[r0],#2           ;157
00005a  f821cc04          STRH     r12,[r1,#-4]          ;157
00005e  f830cb02          LDRH     r12,[r0],#2           ;158
000062  f821cc06          STRH     r12,[r1,#-6]          ;158
000066  3908              SUBS     r1,r1,#8              ;158
000068  1e52              SUBS     r2,r2,#1              ;158
                  |L1.106|
00006a  2a00              CMP      r2,#0                 ;152
00006c  d1ec              BNE      |L1.72|
00006e  f0040203          AND      r2,r4,#3              ;166
000072  9203              STR      r2,[sp,#0xc]          ;168
000074  e005              B        |L1.130|
000076  bf00              NOP                            ;171
                  |L1.120|
000078  f8303b02          LDRH     r3,[r0],#2            ;171
00007c  f8213902          STRH     r3,[r1],#-2           ;171
000080  1e52              SUBS     r2,r2,#1              ;171
                  |L1.130|
000082  2a00              CMP      r2,#0                 ;168
000084  d1f8              BNE      |L1.120|
000086  1e62              SUBS     r2,r4,#1              ;182
000088  4641              MOV      r1,r8                 ;182
00008a  2000              MOVS     r0,#0                 ;182
00008c  f7fffffe          BL       arm_fill_q15
000090  eb080044          ADD      r0,r8,r4,LSL #1       ;185
000094  1e80              SUBS     r0,r0,#2              ;185
000096  4681              MOV      r9,r0                 ;185
000098  4601              MOV      r1,r0                 ;190
00009a  463a              MOV      r2,r7                 ;190
00009c  4628              MOV      r0,r5                 ;190
00009e  f7fffffe          BL       arm_copy_q15
0000a2  eb090147          ADD      r1,r9,r7,LSL #1       ;193
0000a6  1e62              SUBS     r2,r4,#1              ;196
0000a8  2000              MOVS     r0,#0                 ;196
0000aa  f7fffffe          BL       arm_fill_q15
0000ae  eb0a0046          ADD      r0,r10,r6,LSL #1      ;206
0000b2  9000              STR      r0,[sp,#0]            ;212
0000b4  9812              LDR      r0,[sp,#0x48]         ;212
0000b6  eb080e46          ADD      lr,r8,r6,LSL #1       ;204
0000ba  0880              LSRS     r0,r0,#2              ;212
0000bc  9901              LDR      r1,[sp,#4]            ;206
0000be  9002              STR      r0,[sp,#8]            ;214
0000c0  e05f              B        |L1.386|
                  |L1.194|
0000c2  2500              MOVS     r5,#0                 ;220
0000c4  f10e0004          ADD      r0,lr,#4              ;226
0000c8  46ac              MOV      r12,r5                ;221
0000ca  46a9              MOV      r9,r5                 ;222
0000cc  46aa              MOV      r10,r5                ;223
0000ce  f8de3000          LDR      r3,[lr,#0]            ;226
0000d2  f8502b04          LDR      r2,[r0],#4            ;229
0000d6  9e04              LDR      r6,[sp,#0x10]         ;233
0000d8  e022              B        |L1.288|
0000da  bf00              NOP                            ;237
                  |L1.220|
0000dc  f8517b04          LDR      r7,[r1],#4            ;237
0000e0  f8516b04          LDR      r6,[r1],#4            ;238
0000e4  fb235807          SMLAD    r8,r3,r7,r5           ;241
0000e8  fb229907          SMLAD    r9,r2,r7,r9           ;242
0000ec  eac20303          PKHBT    r3,r2,r3              ;246
0000f0  fb23cc17          SMLADX   r12,r3,r7,r12         ;252
0000f4  f8cdc014          STR      r12,[sp,#0x14]        ;255
0000f8  f8503b04          LDR      r3,[r0],#4            ;255
0000fc  fb228506          SMLAD    r5,r2,r6,r8           ;258
000100  fb239906          SMLAD    r9,r3,r6,r9           ;260
000104  eac30202          PKHBT    r2,r3,r2              ;264
000108  fb22a717          SMLADX   r7,r2,r7,r10          ;269
00010c  fb22cc16          SMLADX   r12,r2,r6,r12         ;270
000110  f8502b04          LDR      r2,[r0],#4            ;272
000114  eac20803          PKHBT    r8,r2,r3              ;275
000118  fb287a16          SMLADX   r10,r8,r6,r7          ;280
00011c  f1ab0601          SUB      r6,r11,#1             ;288
                  |L1.288|
000120  ea5f0b06          MOVS     r11,r6                ;231
000124  d1da              BNE      |L1.220|
000126  3808              SUBS     r0,r0,#8              ;231
000128  9a03              LDR      r2,[sp,#0xc]          ;297
00012a  e00f              B        |L1.332|
                  |L1.300|
00012c  f8306b02          LDRH     r6,[r0],#2            ;301
000130  f8313b02          LDRH     r3,[r1],#2            ;301
000134  fb165503          SMLABB   r5,r6,r3,r5           ;301
000138  8806              LDRH     r6,[r0,#0]            ;302
00013a  fb16cc03          SMLABB   r12,r6,r3,r12         ;302
00013e  8847              LDRH     r7,[r0,#2]            ;303
000140  fb179903          SMLABB   r9,r7,r3,r9           ;303
000144  8887              LDRH     r7,[r0,#4]            ;304
000146  fb17aa03          SMLABB   r10,r7,r3,r10         ;304
00014a  1e52              SUBS     r2,r2,#1              ;304
                  |L1.332|
00014c  2a00              CMP      r2,#0                 ;297
00014e  d1ed              BNE      |L1.300|
000150  9802              LDR      r0,[sp,#8]            ;312
000152  f32c31cf          SSAT     r1,#16,r12,ASR #15    ;319
000156  1e40              SUBS     r0,r0,#1              ;312
000158  9002              STR      r0,[sp,#8]            ;319
00015a  f32530cf          SSAT     r0,#16,r5,ASR #15     ;319
00015e  eac04101          PKHBT    r1,r0,r1,LSL #16      ;319
000162  9800              LDR      r0,[sp,#0]            ;319
000164  f32932cf          SSAT     r2,#16,r9,ASR #15     ;321
000168  6001              STR      r1,[r0,#0]            ;319
00016a  f32a31cf          SSAT     r1,#16,r10,ASR #15    ;321
00016e  eac24101          PKHBT    r1,r2,r1,LSL #16      ;321
000172  9800              LDR      r0,[sp,#0]            ;321
000174  f10e0e08          ADD      lr,lr,#8              ;336
000178  6041              STR      r1,[r0,#4]            ;321
00017a  3008              ADDS     r0,r0,#8              ;321
00017c  9000              STR      r0,[sp,#0]            ;336
00017e  e9dd1001          LDRD     r1,r0,[sp,#4]         ;336
                  |L1.386|
000182  2800              CMP      r0,#0                 ;214
000184  d19d              BNE      |L1.194|
000186  9812              LDR      r0,[sp,#0x48]         ;341
000188  f0000303          AND      r3,r0,#3              ;341
00018c  e024              B        |L1.472|
                  |L1.398|
00018e  2200              MOVS     r2,#0                 ;350
000190  4670              MOV      r0,lr                 ;347
000192  0865              LSRS     r5,r4,#1              ;352
000194  e007              B        |L1.422|
000196  bf00              NOP                            ;358
                  |L1.408|
000198  f8506b04          LDR      r6,[r0],#4            ;358
00019c  f8517b04          LDR      r7,[r1],#4            ;361
0001a0  fb262207          SMLAD    r2,r6,r7,r2           ;363
0001a4  1e6d              SUBS     r5,r5,#1              ;363
                  |L1.422|
0001a6  2d00              CMP      r5,#0                 ;354
0001a8  d1f6              BNE      |L1.408|
0001aa  f0040501          AND      r5,r4,#1              ;369
0001ae  e006              B        |L1.446|
                  |L1.432|
0001b0  f8307b02          LDRH     r7,[r0],#2            ;376
0001b4  f8316b02          LDRH     r6,[r1],#2            ;376
0001b8  fb172206          SMLABB   r2,r7,r6,r2           ;376
0001bc  1e6d              SUBS     r5,r5,#1              ;376
                  |L1.446|
0001be  2d00              CMP      r5,#0                 ;372
0001c0  d1f6              BNE      |L1.432|
0001c2  9800              LDR      r0,[sp,#0]            ;386
0001c4  f32231cf          SSAT     r1,#16,r2,ASR #15     ;386
0001c8  f10e0e02          ADD      lr,lr,#2              ;391
0001cc  8001              STRH     r1,[r0,#0]            ;386
0001ce  9800              LDR      r0,[sp,#0]            ;386
0001d0  9901              LDR      r1,[sp,#4]            ;391
0001d2  1c80              ADDS     r0,r0,#2              ;386
0001d4  9000              STR      r0,[sp,#0]            ;389
0001d6  1e5b              SUBS     r3,r3,#1              ;391
                  |L1.472|
0001d8  2b00              CMP      r3,#0                 ;344
0001da  d1d8              BNE      |L1.398|
0001dc  2000              MOVS     r0,#0                 ;395
0001de  e720              B        |L1.34|
;;;400    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_partial_fast_opt_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___31_arm_conv_partial_fast_opt_q15_c_47452bd7____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___31_arm_conv_partial_fast_opt_q15_c_47452bd7____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___31_arm_conv_partial_fast_opt_q15_c_47452bd7____REVSH|
#line 144
|__asm___31_arm_conv_partial_fast_opt_q15_c_47452bd7____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___31_arm_conv_partial_fast_opt_q15_c_47452bd7____RRX|
#line 300
|__asm___31_arm_conv_partial_fast_opt_q15_c_47452bd7____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
