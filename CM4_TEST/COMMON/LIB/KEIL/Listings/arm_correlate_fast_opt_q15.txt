; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_correlate_fast_opt_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_correlate_fast_opt_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_correlate_fast_opt_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_correlate_fast_opt_q15.c]
                          THUMB

                          AREA ||i.arm_correlate_fast_opt_q15||, CODE, READONLY, ALIGN=1

                  arm_correlate_fast_opt_q15 PROC
;;;83     
;;;84     void arm_correlate_fast_opt_q15(
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;85       q15_t * pSrcA,
;;;86       uint32_t srcALen,
;;;87       q15_t * pSrcB,
;;;88       uint32_t srcBLen,
;;;89       q15_t * pDst,
;;;90       q15_t * pScratch)
;;;91     {
000004  460e              MOV      r6,r1
000006  e9dd1b0e          LDRD     r1,r11,[sp,#0x38]
00000a  461d              MOV      r5,r3
;;;92       q15_t *pIn1;                                   /* inputA pointer               */
;;;93       q15_t *pIn2;                                   /* inputB pointer               */
;;;94       q31_t acc0, acc1, acc2, acc3;                  /* Accumulators                  */
;;;95       q15_t *py;                                     /* Intermediate inputB pointer  */
;;;96       q31_t x1, x2, x3;                              /* temporary variables for holding input and coefficient values */
;;;97       uint32_t j, blkCnt, outBlockSize;              /* loop counter                 */
;;;98       int32_t inc = 1;                               /* Destination address modifier */
00000c  2301              MOVS     r3,#1
00000e  9300              STR      r3,[sp,#0]
;;;99       uint32_t tapCnt;
;;;100      q31_t y1, y2;
;;;101      q15_t *pScr;                                   /* Intermediate pointers        */
;;;102      q15_t *pOut = pDst;                            /* output pointer               */
;;;103    #ifdef UNALIGNED_SUPPORT_DISABLE
;;;104    
;;;105      q15_t a, b;
;;;106    
;;;107    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;108    
;;;109      /* The algorithm implementation is based on the lengths of the inputs. */
;;;110      /* srcB is always made to slide across srcA. */
;;;111      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;112      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;113      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;114      /* and the destination pointer modifier, inc is set to -1 */
;;;115      /* If srcALen > srcBLen, zero pad has to be done to srcB to make the two inputs of same length */
;;;116      /* But to improve the performance,        
;;;117       * we include zeroes in the output instead of zero padding either of the the inputs*/
;;;118      /* If srcALen > srcBLen,        
;;;119       * (srcALen - srcBLen) zeroes has to included in the starting of the output buffer */
;;;120      /* If srcALen < srcBLen,        
;;;121       * (srcALen - srcBLen) zeroes has to included in the ending of the output buffer */
;;;122      if(srcALen >= srcBLen)
;;;123      {
;;;124        /* Initialization of inputA pointer */
;;;125        pIn1 = (pSrcA);
;;;126    
;;;127        /* Initialization of inputB pointer */
;;;128        pIn2 = (pSrcB);
;;;129    
;;;130        /* Number of output samples is calculated */
;;;131        outBlockSize = (2u * srcALen) - 1u;
000010  1e9b              SUBS     r3,r3,#2
000012  42ae              CMP      r6,r5                 ;122
000014  d309              BCC      |L1.42|
000016  4680              MOV      r8,r0                 ;125
000018  4614              MOV      r4,r2                 ;128
00001a  eb030046          ADD      r0,r3,r6,LSL #1
;;;132    
;;;133        /* When srcALen > srcBLen, zero padding is done to srcB        
;;;134         * to make their lengths equal.        
;;;135         * Instead, (outBlockSize - (srcALen + srcBLen - 1))        
;;;136         * number of output samples are made zero */
;;;137        j = outBlockSize - (srcALen + (srcBLen - 1u));
00001e  1972              ADDS     r2,r6,r5
000020  1a80              SUBS     r0,r0,r2
000022  1c40              ADDS     r0,r0,#1
;;;138    
;;;139        /* Updating the pointer position to non zero value */
;;;140        pOut += j;
000024  eb010740          ADD      r7,r1,r0,LSL #1
000028  e009              B        |L1.62|
                  |L1.42|
;;;141    
;;;142      }
;;;143      else
;;;144      {
;;;145        /* Initialization of inputA pointer */
;;;146        pIn1 = (pSrcB);
00002a  4690              MOV      r8,r2
;;;147    
;;;148        /* Initialization of inputB pointer */
;;;149        pIn2 = (pSrcA);
00002c  4604              MOV      r4,r0
;;;150    
;;;151        /* srcBLen is always considered as shorter or equal to srcALen */
;;;152        j = srcBLen;
00002e  4628              MOV      r0,r5
;;;153        srcBLen = srcALen;
000030  4635              MOV      r5,r6
;;;154        srcALen = j;
000032  4606              MOV      r6,r0
;;;155    
;;;156        /* CORR(x, y) = Reverse order(CORR(y, x)) */
;;;157        /* Hence set the destination pointer to point to the last output sample */
;;;158        pOut = pDst + ((srcALen + srcBLen) - 2u);
000034  1970              ADDS     r0,r6,r5
000036  1e80              SUBS     r0,r0,#2
000038  eb010740          ADD      r7,r1,r0,LSL #1
;;;159    
;;;160        /* Destination address modifier is set to -1 */
;;;161        inc = -1;
00003c  9300              STR      r3,[sp,#0]
                  |L1.62|
;;;162    
;;;163      }
;;;164    
;;;165      pScr = pScratch;
;;;166    
;;;167      /* Fill (srcBLen - 1u) zeros in scratch buffer */
;;;168      arm_fill_q15(0, pScr, (srcBLen - 1u));
00003e  1e6a              SUBS     r2,r5,#1
000040  4659              MOV      r1,r11
000042  2000              MOVS     r0,#0
000044  f7fffffe          BL       arm_fill_q15
;;;169    
;;;170      /* Update temporary scratch pointer */
;;;171      pScr += (srcBLen - 1u);
000048  1e68              SUBS     r0,r5,#1
00004a  eb0b0940          ADD      r9,r11,r0,LSL #1
;;;172    
;;;173    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;174    
;;;175      /* Copy (srcALen) samples in scratch buffer */
;;;176      arm_copy_q15(pIn1, pScr, srcALen);
00004e  4632              MOV      r2,r6
000050  4649              MOV      r1,r9
000052  4640              MOV      r0,r8
000054  f7fffffe          BL       arm_copy_q15
;;;177    
;;;178      /* Update pointers */
;;;179      pScr += srcALen;
000058  eb090146          ADD      r1,r9,r6,LSL #1
;;;180    
;;;181    #else
;;;182    
;;;183      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;184      j = srcALen >> 2u;
;;;185    
;;;186      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;187       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;188      while(j > 0u)
;;;189      {
;;;190        /* copy second buffer in reversal manner */
;;;191        *pScr++ = *pIn1++;
;;;192        *pScr++ = *pIn1++;
;;;193        *pScr++ = *pIn1++;
;;;194        *pScr++ = *pIn1++;
;;;195    
;;;196        /* Decrement the loop counter */
;;;197        j--;
;;;198      }
;;;199    
;;;200      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;201       ** No loop unrolling is used. */
;;;202      j = srcALen % 0x4u;
;;;203    
;;;204      while(j > 0u)
;;;205      {
;;;206        /* copy second buffer in reversal manner for remaining samples */
;;;207        *pScr++ = *pIn1++;
;;;208    
;;;209        /* Decrement the loop counter */
;;;210        j--;
;;;211      }
;;;212    
;;;213    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;214    
;;;215    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;216    
;;;217      /* Fill (srcBLen - 1u) zeros at end of scratch buffer */
;;;218      arm_fill_q15(0, pScr, (srcBLen - 1u));
00005c  1e6a              SUBS     r2,r5,#1
00005e  2000              MOVS     r0,#0
000060  f7fffffe          BL       arm_fill_q15
;;;219    
;;;220      /* Update pointer */
;;;221      pScr += (srcBLen - 1u);
;;;222    
;;;223    #else
;;;224    
;;;225    /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;226      j = (srcBLen - 1u) >> 2u;
;;;227    
;;;228      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;229       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;230      while(j > 0u)
;;;231      {
;;;232        /* copy second buffer in reversal manner */
;;;233        *pScr++ = 0;
;;;234        *pScr++ = 0;
;;;235        *pScr++ = 0;
;;;236        *pScr++ = 0;
;;;237    
;;;238        /* Decrement the loop counter */
;;;239        j--;
;;;240      }
;;;241    
;;;242      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;243       ** No loop unrolling is used. */
;;;244      j = (srcBLen - 1u) % 0x4u;
;;;245    
;;;246      while(j > 0u)
;;;247      {
;;;248        /* copy second buffer in reversal manner for remaining samples */
;;;249        *pScr++ = 0;
;;;250    
;;;251        /* Decrement the loop counter */
;;;252        j--;
;;;253      }
;;;254    
;;;255    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;256    
;;;257      /* Temporary pointer for scratch2 */
;;;258      py = pIn2;
000064  9402              STR      r4,[sp,#8]
;;;259    
;;;260    
;;;261      /* Actual correlation process starts here */
;;;262      blkCnt = (srcALen + srcBLen - 1u) >> 2;
000066  1970              ADDS     r0,r6,r5
000068  1e40              SUBS     r0,r0,#1
00006a  9003              STR      r0,[sp,#0xc]
00006c  0880              LSRS     r0,r0,#2
00006e  9001              STR      r0,[sp,#4]
;;;263    
;;;264      while(blkCnt > 0)
000070  e065              B        |L1.318|
                  |L1.114|
;;;265      {
;;;266        /* Initialze temporary scratch pointer as scratch1 */
;;;267        pScr = pScratch;
000072  465e              MOV      r6,r11
;;;268    
;;;269        /* Clear Accumlators */
;;;270        acc0 = 0;
000074  2200              MOVS     r2,#0
;;;271        acc1 = 0;
000076  2300              MOVS     r3,#0
;;;272        acc2 = 0;
000078  4694              MOV      r12,r2
;;;273        acc3 = 0;
00007a  4690              MOV      r8,r2
;;;274    
;;;275        /* Read four samples from scratch1 buffer */
;;;276        x1 = *__SIMD32(pScr)++;
00007c  6830              LDR      r0,[r6,#0]
;;;277    
;;;278        /* Read next four samples from scratch1 buffer */
;;;279        x2 = *__SIMD32(pScr)++;
00007e  6871              LDR      r1,[r6,#4]
000080  3608              ADDS     r6,r6,#8
;;;280    
;;;281        tapCnt = (srcBLen) >> 2u;
000082  ea4f0e95          LSR      lr,r5,#2
;;;282    
;;;283        while(tapCnt > 0u)
000086  e01f              B        |L1.200|
                  |L1.136|
;;;284        {
;;;285    
;;;286    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;287    
;;;288          /* Read four samples from smaller buffer */
;;;289          y1 = _SIMD32_OFFSET(pIn2);
000088  f8d4a000          LDR      r10,[r4,#0]
;;;290          y2 = _SIMD32_OFFSET(pIn2 + 2u);
00008c  f8d49004          LDR      r9,[r4,#4]
;;;291    
;;;292          acc0 = __SMLAD(x1, y1, acc0);
000090  fb20220a          SMLAD    r2,r0,r10,r2
;;;293    
;;;294          acc2 = __SMLAD(x2, y1, acc2);
000094  fb21cc0a          SMLAD    r12,r1,r10,r12
;;;295    
;;;296    #ifndef ARM_MATH_BIG_ENDIAN
;;;297          x3 = __PKHBT(x2, x1, 0);
000098  eac10000          PKHBT    r0,r1,r0
;;;298    #else
;;;299          x3 = __PKHBT(x1, x2, 0);
;;;300    #endif
;;;301    
;;;302          acc1 = __SMLADX(x3, y1, acc1);
00009c  fb20331a          SMLADX   r3,r0,r10,r3
;;;303    
;;;304          x1 = _SIMD32_OFFSET(pScr);
0000a0  6830              LDR      r0,[r6,#0]
;;;305    
;;;306          acc0 = __SMLAD(x2, y2, acc0);
0000a2  fb212209          SMLAD    r2,r1,r9,r2
;;;307    
;;;308          acc2 = __SMLAD(x1, y2, acc2);
0000a6  fb20cc09          SMLAD    r12,r0,r9,r12
;;;309    
;;;310    #ifndef ARM_MATH_BIG_ENDIAN
;;;311          x3 = __PKHBT(x1, x2, 0);
0000aa  eac00101          PKHBT    r1,r0,r1
;;;312    #else
;;;313          x3 = __PKHBT(x2, x1, 0);
;;;314    #endif
;;;315    
;;;316          acc3 = __SMLADX(x3, y1, acc3);
0000ae  fb21881a          SMLADX   r8,r1,r10,r8
;;;317    
;;;318          acc1 = __SMLADX(x3, y2, acc1);
0000b2  fb213319          SMLADX   r3,r1,r9,r3
;;;319    
;;;320          x2 = _SIMD32_OFFSET(pScr + 2u);
0000b6  6871              LDR      r1,[r6,#4]
;;;321    
;;;322    #ifndef ARM_MATH_BIG_ENDIAN
;;;323          x3 = __PKHBT(x2, x1, 0);
0000b8  eac10a00          PKHBT    r10,r1,r0
;;;324    #else
;;;325          x3 = __PKHBT(x1, x2, 0);
;;;326    #endif
;;;327    
;;;328          acc3 = __SMLADX(x3, y2, acc3);
0000bc  fb2a8819          SMLADX   r8,r10,r9,r8
;;;329    #else	 
;;;330    
;;;331          /* Read four samples from smaller buffer */
;;;332    	  a = *pIn2;
;;;333    	  b = *(pIn2 + 1);
;;;334    
;;;335    #ifndef ARM_MATH_BIG_ENDIAN
;;;336          y1 = __PKHBT(a, b, 16);
;;;337    #else
;;;338          y1 = __PKHBT(b, a, 16);
;;;339    #endif
;;;340    	  
;;;341    	  a = *(pIn2 + 2);
;;;342    	  b = *(pIn2 + 3);
;;;343    #ifndef ARM_MATH_BIG_ENDIAN
;;;344          y2 = __PKHBT(a, b, 16);
;;;345    #else
;;;346          y2 = __PKHBT(b, a, 16);
;;;347    #endif				
;;;348    
;;;349          acc0 = __SMLAD(x1, y1, acc0);
;;;350    
;;;351          acc2 = __SMLAD(x2, y1, acc2);
;;;352    
;;;353    #ifndef ARM_MATH_BIG_ENDIAN
;;;354          x3 = __PKHBT(x2, x1, 0);
;;;355    #else
;;;356          x3 = __PKHBT(x1, x2, 0);
;;;357    #endif
;;;358    
;;;359          acc1 = __SMLADX(x3, y1, acc1);
;;;360    
;;;361    	  a = *pScr;
;;;362    	  b = *(pScr + 1);
;;;363    
;;;364    #ifndef ARM_MATH_BIG_ENDIAN
;;;365          x1 = __PKHBT(a, b, 16);
;;;366    #else
;;;367          x1 = __PKHBT(b, a, 16);
;;;368    #endif
;;;369    
;;;370          acc0 = __SMLAD(x2, y2, acc0);
;;;371    
;;;372          acc2 = __SMLAD(x1, y2, acc2);
;;;373    
;;;374    #ifndef ARM_MATH_BIG_ENDIAN
;;;375          x3 = __PKHBT(x1, x2, 0);
;;;376    #else
;;;377          x3 = __PKHBT(x2, x1, 0);
;;;378    #endif
;;;379    
;;;380          acc3 = __SMLADX(x3, y1, acc3);
;;;381    
;;;382          acc1 = __SMLADX(x3, y2, acc1);
;;;383    
;;;384    	  a = *(pScr + 2);
;;;385    	  b = *(pScr + 3);
;;;386    
;;;387    #ifndef ARM_MATH_BIG_ENDIAN
;;;388          x2 = __PKHBT(a, b, 16);
;;;389    #else
;;;390          x2 = __PKHBT(b, a, 16);
;;;391    #endif
;;;392    
;;;393    #ifndef ARM_MATH_BIG_ENDIAN
;;;394          x3 = __PKHBT(x2, x1, 0);
;;;395    #else
;;;396          x3 = __PKHBT(x1, x2, 0);
;;;397    #endif
;;;398    
;;;399          acc3 = __SMLADX(x3, y2, acc3);
;;;400    
;;;401    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;402    
;;;403          pIn2 += 4u;
0000c0  3408              ADDS     r4,r4,#8
;;;404    
;;;405          pScr += 4u;
0000c2  3608              ADDS     r6,r6,#8
;;;406    
;;;407    
;;;408          /* Decrement the loop counter */
;;;409          tapCnt--;
0000c4  f1ae0e01          SUB      lr,lr,#1
                  |L1.200|
0000c8  f1be0f00          CMP      lr,#0                 ;283
0000cc  d1dc              BNE      |L1.136|
;;;410        }
;;;411    
;;;412    
;;;413    
;;;414        /* Update scratch pointer for remaining samples of smaller length sequence */
;;;415        pScr -= 4u;
0000ce  3e08              SUBS     r6,r6,#8
;;;416    
;;;417    
;;;418        /* apply same above for remaining samples of smaller length sequence */
;;;419        tapCnt = (srcBLen) & 3u;
0000d0  f0050103          AND      r1,r5,#3
;;;420    
;;;421        while(tapCnt > 0u)
0000d4  e013              B        |L1.254|
                  |L1.214|
;;;422        {
;;;423    
;;;424          /* accumlate the results */
;;;425          acc0 += (*pScr++ * *pIn2);
0000d6  f8369b02          LDRH     r9,[r6],#2
0000da  f8340b02          LDRH     r0,[r4],#2
0000de  fb192200          SMLABB   r2,r9,r0,r2
;;;426          acc1 += (*pScr++ * *pIn2);
0000e2  f8369b02          LDRH     r9,[r6],#2
0000e6  fb193300          SMLABB   r3,r9,r0,r3
;;;427          acc2 += (*pScr++ * *pIn2);
0000ea  f8369b02          LDRH     r9,[r6],#2
0000ee  fb19cc00          SMLABB   r12,r9,r0,r12
;;;428          acc3 += (*pScr++ * *pIn2++);
0000f2  f8b69000          LDRH     r9,[r6,#0]
0000f6  fb198800          SMLABB   r8,r9,r0,r8
;;;429    
;;;430          pScr -= 3u;
0000fa  1f36              SUBS     r6,r6,#4
;;;431    
;;;432          /* Decrement the loop counter */
;;;433          tapCnt--;
0000fc  1e49              SUBS     r1,r1,#1
                  |L1.254|
0000fe  2900              CMP      r1,#0                 ;421
000100  d1e9              BNE      |L1.214|
;;;434        }
;;;435    
;;;436        blkCnt--;
000102  9801              LDR      r0,[sp,#4]
000104  1e40              SUBS     r0,r0,#1
000106  9001              STR      r0,[sp,#4]
;;;437    
;;;438    
;;;439        /* Store the results in the accumulators in the destination buffer. */
;;;440        *pOut = (__SSAT(acc0 >> 15u, 16));
000108  f32230cf          SSAT     r0,#16,r2,ASR #15
00010c  8038              STRH     r0,[r7,#0]
;;;441        pOut += inc;
00010e  9800              LDR      r0,[sp,#0]
000110  eb070040          ADD      r0,r7,r0,LSL #1
;;;442        *pOut = (__SSAT(acc1 >> 15u, 16));
000114  f32331cf          SSAT     r1,#16,r3,ASR #15
000118  8001              STRH     r1,[r0,#0]
;;;443        pOut += inc;
00011a  9900              LDR      r1,[sp,#0]
00011c  eb000041          ADD      r0,r0,r1,LSL #1
;;;444        *pOut = (__SSAT(acc2 >> 15u, 16));
000120  f32c31cf          SSAT     r1,#16,r12,ASR #15
000124  8001              STRH     r1,[r0,#0]
;;;445        pOut += inc;
000126  9900              LDR      r1,[sp,#0]
000128  eb000041          ADD      r0,r0,r1,LSL #1
;;;446        *pOut = (__SSAT(acc3 >> 15u, 16));
00012c  f32831cf          SSAT     r1,#16,r8,ASR #15
000130  8001              STRH     r1,[r0,#0]
;;;447        pOut += inc;
000132  9900              LDR      r1,[sp,#0]
000134  eb000741          ADD      r7,r0,r1,LSL #1
;;;448    
;;;449    
;;;450        /* Initialization of inputB pointer */
;;;451        pIn2 = py;
000138  9c02              LDR      r4,[sp,#8]
;;;452    
;;;453        pScratch += 4u;
00013a  f10b0b08          ADD      r11,r11,#8
                  |L1.318|
00013e  9801              LDR      r0,[sp,#4]            ;264
000140  2800              CMP      r0,#0                 ;264
000142  d196              BNE      |L1.114|
;;;454    
;;;455      }
;;;456    
;;;457    
;;;458      blkCnt = (srcALen + srcBLen - 1u) & 0x3;
000144  9803              LDR      r0,[sp,#0xc]
000146  f0000303          AND      r3,r0,#3
;;;459    
;;;460      /* Calculate correlation for remaining samples of Bigger length sequence */
;;;461      while(blkCnt > 0)
00014a  e027              B        |L1.412|
                  |L1.332|
;;;462      {
;;;463        /* Initialze temporary scratch pointer as scratch1 */
;;;464        pScr = pScratch;
00014c  4658              MOV      r0,r11
;;;465    
;;;466        /* Clear Accumlators */
;;;467        acc0 = 0;
00014e  2100              MOVS     r1,#0
;;;468    
;;;469        tapCnt = (srcBLen) >> 1u;
000150  086a              LSRS     r2,r5,#1
;;;470    
;;;471        while(tapCnt > 0u)
000152  e00b              B        |L1.364|
                  |L1.340|
;;;472        {
;;;473    
;;;474          acc0 += (*pScr++ * *pIn2++);
000154  8806              LDRH     r6,[r0,#0]
000156  f834cb02          LDRH     r12,[r4],#2
00015a  fb16110c          SMLABB   r1,r6,r12,r1
;;;475          acc0 += (*pScr++ * *pIn2++);
00015e  8846              LDRH     r6,[r0,#2]
000160  f834cb02          LDRH     r12,[r4],#2
000164  1d00              ADDS     r0,r0,#4
000166  fb16110c          SMLABB   r1,r6,r12,r1
;;;476    
;;;477          /* Decrement the loop counter */
;;;478          tapCnt--;
00016a  1e52              SUBS     r2,r2,#1
                  |L1.364|
00016c  2a00              CMP      r2,#0                 ;471
00016e  d1f1              BNE      |L1.340|
;;;479        }
;;;480    
;;;481        tapCnt = (srcBLen) & 1u;
000170  f0050201          AND      r2,r5,#1
;;;482    
;;;483        /* apply same above for remaining samples of smaller length sequence */
;;;484        while(tapCnt > 0u)
000174  e006              B        |L1.388|
                  |L1.374|
;;;485        {
;;;486    
;;;487          /* accumlate the results */
;;;488          acc0 += (*pScr++ * *pIn2++);
000176  f8306b02          LDRH     r6,[r0],#2
00017a  f834cb02          LDRH     r12,[r4],#2
00017e  fb16110c          SMLABB   r1,r6,r12,r1
;;;489    
;;;490          /* Decrement the loop counter */
;;;491          tapCnt--;
000182  1e52              SUBS     r2,r2,#1
                  |L1.388|
000184  2a00              CMP      r2,#0                 ;484
000186  d1f6              BNE      |L1.374|
;;;492        }
;;;493    
;;;494        blkCnt--;
000188  1e5b              SUBS     r3,r3,#1
;;;495    
;;;496        /* Store the result in the accumulator in the destination buffer. */
;;;497    
;;;498        *pOut = (q15_t) (__SSAT((acc0 >> 15), 16));
00018a  f32130cf          SSAT     r0,#16,r1,ASR #15
00018e  8038              STRH     r0,[r7,#0]
;;;499    
;;;500        pOut += inc;
000190  9800              LDR      r0,[sp,#0]
000192  eb070740          ADD      r7,r7,r0,LSL #1
;;;501    
;;;502        /* Initialization of inputB pointer */
;;;503        pIn2 = py;
000196  9c02              LDR      r4,[sp,#8]
;;;504    
;;;505        pScratch += 1u;
000198  f10b0b02          ADD      r11,r11,#2
                  |L1.412|
00019c  2b00              CMP      r3,#0                 ;461
00019e  d1d5              BNE      |L1.332|
;;;506    
;;;507      }
;;;508    }
0001a0  e8bd9fff          POP      {r0-r12,pc}
;;;509    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_correlate_fast_opt_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___28_arm_correlate_fast_opt_q15_c_938dbf25____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___28_arm_correlate_fast_opt_q15_c_938dbf25____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___28_arm_correlate_fast_opt_q15_c_938dbf25____REVSH|
#line 144
|__asm___28_arm_correlate_fast_opt_q15_c_938dbf25____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___28_arm_correlate_fast_opt_q15_c_938dbf25____RRX|
#line 300
|__asm___28_arm_correlate_fast_opt_q15_c_938dbf25____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
