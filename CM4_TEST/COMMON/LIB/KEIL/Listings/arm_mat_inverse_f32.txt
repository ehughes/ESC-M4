; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_inverse_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_inverse_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_mat_inverse_f32.crf ..\..\SRC\CMSIS_DSP_4_5\src\MatrixFunctions\arm_mat_inverse_f32.c]
                          THUMB

                          AREA ||i.arm_mat_inverse_f32||, CODE, READONLY, ALIGN=2

                  arm_mat_inverse_f32 PROC
;;;84     
;;;85     arm_status arm_mat_inverse_f32(
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;86       const arm_matrix_instance_f32 * pSrc,
;;;87       arm_matrix_instance_f32 * pDst)
;;;88     {
000004  b083              SUB      sp,sp,#0xc
;;;89       float32_t *pIn = pSrc->pData;                  /* input data matrix pointer */
000006  9803              LDR      r0,[sp,#0xc]
000008  f8d09004          LDR      r9,[r0,#4]
;;;90       float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
00000c  684a              LDR      r2,[r1,#4]
00000e  9202              STR      r2,[sp,#8]
;;;91       float32_t *pInT1, *pInT2;                      /* Temporary input data matrix pointer */
;;;92       float32_t *pOutT1, *pOutT2;                    /* Temporary output data matrix pointer */
;;;93       float32_t *pPivotRowIn, *pPRT_in, *pPivotRowDst, *pPRT_pDst;  /* Temporary input and output data matrix pointer */
;;;94       uint32_t numRows = pSrc->numRows;              /* Number of rows in the matrix  */
000010  9803              LDR      r0,[sp,#0xc]
000012  f8b08000          LDRH     r8,[r0,#0]
;;;95       uint32_t numCols = pSrc->numCols;              /* Number of Cols in the matrix  */
000016  9803              LDR      r0,[sp,#0xc]
000018  8841              LDRH     r1,[r0,#2]
;;;96     
;;;97     #ifndef ARM_MATH_CM0_FAMILY
;;;98       float32_t maxC;                                /* maximum value in the column */
;;;99     
;;;100      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;101    
;;;102      float32_t Xchg, in = 0.0f, in1;                /* Temporary input values  */
00001a  eddf1a97          VLDR     s3,|L1.632|
00001e  eeb00a61          VMOV.F32 s0,s3
;;;103      uint32_t i, rowCnt, flag = 0u, j, loopCnt, k, l;      /* loop counters */
000022  2000              MOVS     r0,#0
000024  9001              STR      r0,[sp,#4]
;;;104      arm_status status;                             /* status of matrix inverse */
;;;105    
;;;106    #ifdef ARM_MATH_MATRIX_CHECK
;;;107    
;;;108    
;;;109      /* Check for matrix mismatch condition */
;;;110      if((pSrc->numRows != pSrc->numCols) || (pDst->numRows != pDst->numCols)
;;;111         || (pSrc->numRows != pDst->numRows))
;;;112      {
;;;113        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;114        status = ARM_MATH_SIZE_MISMATCH;
;;;115      }
;;;116      else
;;;117    #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;118    
;;;119      {
;;;120    
;;;121        /*--------------------------------------------------------------------------------------------------------------    
;;;122    	 * Matrix Inverse can be solved using elementary row operations.    
;;;123    	 *    
;;;124    	 *	Gauss-Jordan Method:    
;;;125    	 *    
;;;126    	 *	   1. First combine the identity matrix and the input matrix separated by a bar to form an    
;;;127    	 *        augmented matrix as follows:    
;;;128    	 *				        _ 	      	       _         _	       _    
;;;129    	 *					   |  a11  a12 | 1   0  |       |  X11 X12  |    
;;;130    	 *					   |           |        |   =   |           |    
;;;131    	 *					   |_ a21  a22 | 0   1 _|       |_ X21 X21 _|    
;;;132    	 *    
;;;133    	 *		2. In our implementation, pDst Matrix is used as identity matrix.    
;;;134    	 *    
;;;135    	 *		3. Begin with the first row. Let i = 1.    
;;;136    	 *    
;;;137    	 *	    4. Check to see if the pivot for column i is the greatest of the column.    
;;;138    	 *		   The pivot is the element of the main diagonal that is on the current row.    
;;;139    	 *		   For instance, if working with row i, then the pivot element is aii.    
;;;140    	 *		   If the pivot is not the most significant of the columns, exchange that row with a row
;;;141    	 *		   below it that does contain the most significant value in column i. If the most
;;;142    	 *         significant value of the column is zero, then an inverse to that matrix does not exist.
;;;143    	 *		   The most significant value of the column is the absolute maximum.
;;;144    	 *    
;;;145    	 *	    5. Divide every element of row i by the pivot.    
;;;146    	 *    
;;;147    	 *	    6. For every row below and  row i, replace that row with the sum of that row and    
;;;148    	 *		   a multiple of row i so that each new element in column i below row i is zero.    
;;;149    	 *    
;;;150    	 *	    7. Move to the next row and column and repeat steps 2 through 5 until you have zeros    
;;;151    	 *		   for every element below and above the main diagonal.    
;;;152    	 *    
;;;153    	 *		8. Now an identical matrix is formed to the left of the bar(input matrix, pSrc).    
;;;154    	 *		   Therefore, the matrix to the right of the bar is our solution(pDst matrix, pDst).    
;;;155    	 *----------------------------------------------------------------------------------------------------------------*/
;;;156    
;;;157        /* Working pointer for destination matrix */
;;;158        pOutT1 = pOut;
000026  9a02              LDR      r2,[sp,#8]
;;;159    
;;;160        /* Loop over the number of rows */
;;;161        rowCnt = numRows;
000028  4640              MOV      r0,r8
00002a  e013              B        |L1.84|
                  |L1.44|
;;;162    
;;;163        /* Making the destination matrix as identity matrix */
;;;164        while(rowCnt > 0u)
;;;165        {
;;;166          /* Writing all zeroes in lower triangle of the destination matrix */
;;;167          j = numRows - rowCnt;
00002c  eba80300          SUB      r3,r8,r0
;;;168          while(j > 0u)
000030  e002              B        |L1.56|
                  |L1.50|
;;;169          {
;;;170            *pOutT1++ = 0.0f;
000032  ece21a01          VSTM     r2!,{s3}
;;;171            j--;
000036  1e5b              SUBS     r3,r3,#1
                  |L1.56|
000038  2b00              CMP      r3,#0                 ;168
00003a  d1fa              BNE      |L1.50|
;;;172          }
;;;173    
;;;174          /* Writing all ones in the diagonal of the destination matrix */
;;;175          *pOutT1++ = 1.0f;
00003c  eef70a00          VMOV.F32 s1,#1.00000000
000040  ece20a01          VSTM     r2!,{s1}
;;;176    
;;;177          /* Writing all zeroes in upper triangle of the destination matrix */
;;;178          j = rowCnt - 1u;
000044  1e43              SUBS     r3,r0,#1
;;;179          while(j > 0u)
000046  e002              B        |L1.78|
                  |L1.72|
;;;180          {
;;;181            *pOutT1++ = 0.0f;
000048  ece21a01          VSTM     r2!,{s3}
;;;182            j--;
00004c  1e5b              SUBS     r3,r3,#1
                  |L1.78|
00004e  2b00              CMP      r3,#0                 ;179
000050  d1fa              BNE      |L1.72|
;;;183          }
;;;184    
;;;185          /* Decrement the loop counter */
;;;186          rowCnt--;
000052  1e40              SUBS     r0,r0,#1
                  |L1.84|
000054  2800              CMP      r0,#0                 ;164
000056  d1e9              BNE      |L1.44|
;;;187        }
;;;188    
;;;189        /* Loop over the number of columns of the input matrix.    
;;;190           All the elements in each column are processed by the row operations */
;;;191        loopCnt = numCols;
000058  9100              STR      r1,[sp,#0]
;;;192    
;;;193        /* Index modifier to navigate through the columns */
;;;194        l = 0u;
00005a  2300              MOVS     r3,#0
;;;195    
;;;196        while(loopCnt > 0u)
00005c  e0e9              B        |L1.562|
                  |L1.94|
;;;197        {
;;;198          /* Check if the pivot element is zero..    
;;;199           * If it is zero then interchange the row with non zero row below.    
;;;200           * If there is no non zero element to replace in the rows below,    
;;;201           * then the matrix is Singular. */
;;;202    
;;;203          /* Working pointer for the input matrix that points    
;;;204           * to the pivot element of the particular row  */
;;;205          pInT1 = pIn + (l * numCols);
00005e  fb03f001          MUL      r0,r3,r1
000062  eb090c80          ADD      r12,r9,r0,LSL #2
;;;206    
;;;207          /* Working pointer for the destination matrix that points    
;;;208           * to the pivot element of the particular row  */
;;;209          pOutT1 = pOut + (l * numCols);
000066  9a02              LDR      r2,[sp,#8]
000068  eb020480          ADD      r4,r2,r0,LSL #2
00006c  4627              MOV      r7,r4
;;;210    
;;;211          /* Temporary variable to hold the pivot value */
;;;212          in = *pInT1;
00006e  ed9c1a00          VLDR     s2,[r12,#0]
000072  4666              MOV      r6,r12
;;;213    
;;;214          /* Grab the most significant value from column l */
;;;215          maxC = 0;
000074  eeb00a61          VMOV.F32 s0,s3
;;;216          for (i = l; i < numRows; i++)
000078  4618              MOV      r0,r3
00007a  e01a              B        |L1.178|
                  |L1.124|
;;;217          {
;;;218            maxC = *pInT1 > 0 ? (*pInT1 > maxC ? *pInT1 : maxC) : (-*pInT1 > maxC ? -*pInT1 : maxC);
00007c  eddc0a00          VLDR     s1,[r12,#0]
000080  eef50ac0          VCMPE.F32 s1,#0.0
000084  eef1fa10          VMRS     APSR_nzcv,FPSCR
000088  dd07              BLE      |L1.154|
00008a  eef40ac0          VCMPE.F32 s1,s0
00008e  eef1fa10          VMRS     APSR_nzcv,FPSCR
000092  dd0b              BLE      |L1.172|
000094  eeb00a60          VMOV.F32 s0,s1
000098  e008              B        |L1.172|
                  |L1.154|
00009a  eef10a60          VNEG.F32 s1,s1
00009e  eef40ac0          VCMPE.F32 s1,s0
0000a2  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000a6  dd01              BLE      |L1.172|
0000a8  eeb00a60          VMOV.F32 s0,s1
                  |L1.172|
;;;219            pInT1 += numCols;
0000ac  eb0c0c81          ADD      r12,r12,r1,LSL #2
0000b0  1c40              ADDS     r0,r0,#1              ;216
                  |L1.178|
0000b2  4540              CMP      r0,r8                 ;216
0000b4  d3e2              BCC      |L1.124|
;;;220          }
;;;221    
;;;222          /* Update the status if the matrix is singular */
;;;223          if(maxC == 0.0f)
0000b6  eeb50ac0          VCMPE.F32 s0,#0.0
0000ba  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000be  d104              BNE      |L1.202|
;;;224          {
;;;225            return ARM_MATH_SINGULAR;
0000c0  f06f0004          MVN      r0,#4
                  |L1.196|
;;;226          }
;;;227    
;;;228          /* Restore pInT1  */
;;;229          pInT1 = pIn;
;;;230    
;;;231          /* Destination pointer modifier */
;;;232          k = 1u;
;;;233          
;;;234          /* Check if the pivot element is the most significant of the column */
;;;235          if( (in > 0.0f ? in : -in) != maxC)
;;;236          {
;;;237            /* Loop over the number rows present below */
;;;238            i = numRows - (l + 1u);
;;;239    
;;;240            while(i > 0u)
;;;241            {
;;;242              /* Update the input and destination pointers */
;;;243              pInT2 = pInT1 + (numCols * l);
;;;244              pOutT2 = pOutT1 + (numCols * k);
;;;245    
;;;246              /* Look for the most significant element to    
;;;247               * replace in the rows below */
;;;248              if((*pInT2 > 0.0f ? *pInT2: -*pInT2) == maxC)
;;;249              {
;;;250                /* Loop over number of columns    
;;;251                 * to the right of the pilot element */
;;;252                j = numCols - l;
;;;253    
;;;254                while(j > 0u)
;;;255                {
;;;256                  /* Exchange the row elements of the input matrix */
;;;257                  Xchg = *pInT2;
;;;258                  *pInT2++ = *pInT1;
;;;259                  *pInT1++ = Xchg;
;;;260    
;;;261                  /* Decrement the loop counter */
;;;262                  j--;
;;;263                }
;;;264    
;;;265                /* Loop over number of columns of the destination matrix */
;;;266                j = numCols;
;;;267    
;;;268                while(j > 0u)
;;;269                {
;;;270                  /* Exchange the row elements of the destination matrix */
;;;271                  Xchg = *pOutT2;
;;;272                  *pOutT2++ = *pOutT1;
;;;273                  *pOutT1++ = Xchg;
;;;274    
;;;275                  /* Decrement the loop counter */
;;;276                  j--;
;;;277                }
;;;278    
;;;279                /* Flag to indicate whether exchange is done or not */
;;;280                flag = 1u;
;;;281    
;;;282                /* Break after exchange is done */
;;;283                break;
;;;284              }
;;;285    
;;;286              /* Update the destination pointer modifier */
;;;287              k++;
;;;288    
;;;289              /* Decrement the loop counter */
;;;290              i--;
;;;291            }
;;;292          }
;;;293    
;;;294          /* Update the status if the matrix is singular */
;;;295          if((flag != 1u) && (in == 0.0f))
;;;296          {
;;;297            return ARM_MATH_SINGULAR;
;;;298          }
;;;299    
;;;300          /* Points to the pivot row of input and destination matrices */
;;;301          pPivotRowIn = pIn + (l * numCols);
;;;302          pPivotRowDst = pOut + (l * numCols);
;;;303    
;;;304          /* Temporary pointers to the pivot row pointers */
;;;305          pInT1 = pPivotRowIn;
;;;306          pInT2 = pPivotRowDst;
;;;307    
;;;308          /* Pivot element of the row */
;;;309          in = *pPivotRowIn;
;;;310    
;;;311          /* Loop over number of columns    
;;;312           * to the right of the pilot element */
;;;313          j = (numCols - l);
;;;314    
;;;315          while(j > 0u)
;;;316          {
;;;317            /* Divide each element of the row of the input matrix    
;;;318             * by the pivot element */
;;;319            in1 = *pInT1;
;;;320            *pInT1++ = in1 / in;
;;;321    
;;;322            /* Decrement the loop counter */
;;;323            j--;
;;;324          }
;;;325    
;;;326          /* Loop over number of columns of the destination matrix */
;;;327          j = numCols;
;;;328    
;;;329          while(j > 0u)
;;;330          {
;;;331            /* Divide each element of the row of the destination matrix    
;;;332             * by the pivot element */
;;;333            in1 = *pInT2;
;;;334            *pInT2++ = in1 / in;
;;;335    
;;;336            /* Decrement the loop counter */
;;;337            j--;
;;;338          }
;;;339    
;;;340          /* Replace the rows with the sum of that row and a multiple of row i    
;;;341           * so that each new element in column i above row i is zero.*/
;;;342    
;;;343          /* Temporary pointers for input and destination matrices */
;;;344          pInT1 = pIn;
;;;345          pInT2 = pOut;
;;;346    
;;;347          /* index used to check for pivot element */
;;;348          i = 0u;
;;;349    
;;;350          /* Loop over number of rows */
;;;351          /*  to be replaced by the sum of that row and a multiple of row i */
;;;352          k = numRows;
;;;353    
;;;354          while(k > 0u)
;;;355          {
;;;356            /* Check for the pivot element */
;;;357            if(i == l)
;;;358            {
;;;359              /* If the processing element is the pivot element,    
;;;360                 only the columns to the right are to be processed */
;;;361              pInT1 += numCols - l;
;;;362    
;;;363              pInT2 += numCols;
;;;364            }
;;;365            else
;;;366            {
;;;367              /* Element of the reference row */
;;;368              in = *pInT1;
;;;369    
;;;370              /* Working pointers for input and destination pivot rows */
;;;371              pPRT_in = pPivotRowIn;
;;;372              pPRT_pDst = pPivotRowDst;
;;;373    
;;;374              /* Loop over the number of columns to the right of the pivot element,    
;;;375                 to replace the elements in the input matrix */
;;;376              j = (numCols - l);
;;;377    
;;;378              while(j > 0u)
;;;379              {
;;;380                /* Replace the element by the sum of that row    
;;;381                   and a multiple of the reference row  */
;;;382                in1 = *pInT1;
;;;383                *pInT1++ = in1 - (in * *pPRT_in++);
;;;384    
;;;385                /* Decrement the loop counter */
;;;386                j--;
;;;387              }
;;;388    
;;;389              /* Loop over the number of columns to    
;;;390                 replace the elements in the destination matrix */
;;;391              j = numCols;
;;;392    
;;;393              while(j > 0u)
;;;394              {
;;;395                /* Replace the element by the sum of that row    
;;;396                   and a multiple of the reference row  */
;;;397                in1 = *pInT2;
;;;398                *pInT2++ = in1 - (in * *pPRT_pDst++);
;;;399    
;;;400                /* Decrement the loop counter */
;;;401                j--;
;;;402              }
;;;403    
;;;404            }
;;;405    
;;;406            /* Increment the temporary input pointer */
;;;407            pInT1 = pInT1 + l;
;;;408    
;;;409            /* Decrement the loop counter */
;;;410            k--;
;;;411    
;;;412            /* Increment the pivot index */
;;;413            i++;
;;;414          }
;;;415    
;;;416          /* Increment the input pointer */
;;;417          pIn++;
;;;418    
;;;419          /* Decrement the loop counter */
;;;420          loopCnt--;
;;;421    
;;;422          /* Increment the index modifier */
;;;423          l++;
;;;424        }
;;;425    
;;;426    
;;;427    #else
;;;428    
;;;429      /* Run the below code for Cortex-M0 */
;;;430    
;;;431      float32_t Xchg, in = 0.0f;                     /* Temporary input values  */
;;;432      uint32_t i, rowCnt, flag = 0u, j, loopCnt, k, l;      /* loop counters */
;;;433      arm_status status;                             /* status of matrix inverse */
;;;434    
;;;435    #ifdef ARM_MATH_MATRIX_CHECK
;;;436    
;;;437      /* Check for matrix mismatch condition */
;;;438      if((pSrc->numRows != pSrc->numCols) || (pDst->numRows != pDst->numCols)
;;;439         || (pSrc->numRows != pDst->numRows))
;;;440      {
;;;441        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;442        status = ARM_MATH_SIZE_MISMATCH;
;;;443      }
;;;444      else
;;;445    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;446      {
;;;447    
;;;448        /*--------------------------------------------------------------------------------------------------------------       
;;;449    	 * Matrix Inverse can be solved using elementary row operations.        
;;;450    	 *        
;;;451    	 *	Gauss-Jordan Method:       
;;;452    	 *	 	       
;;;453    	 *	   1. First combine the identity matrix and the input matrix separated by a bar to form an        
;;;454    	 *        augmented matrix as follows:        
;;;455    	 *				        _  _	      _	    _	   _   _         _	       _       
;;;456    	 *					   |  |  a11  a12  | | | 1   0  |   |       |  X11 X12  |         
;;;457    	 *					   |  |            | | |        |   |   =   |           |        
;;;458    	 *					   |_ |_ a21  a22 _| | |_0   1 _|  _|       |_ X21 X21 _|       
;;;459    	 *					          
;;;460    	 *		2. In our implementation, pDst Matrix is used as identity matrix.    
;;;461    	 *       
;;;462    	 *		3. Begin with the first row. Let i = 1.       
;;;463    	 *       
;;;464    	 *	    4. Check to see if the pivot for row i is zero.       
;;;465    	 *		   The pivot is the element of the main diagonal that is on the current row.       
;;;466    	 *		   For instance, if working with row i, then the pivot element is aii.       
;;;467    	 *		   If the pivot is zero, exchange that row with a row below it that does not        
;;;468    	 *		   contain a zero in column i. If this is not possible, then an inverse        
;;;469    	 *		   to that matrix does not exist.       
;;;470    	 *	       
;;;471    	 *	    5. Divide every element of row i by the pivot.       
;;;472    	 *	       
;;;473    	 *	    6. For every row below and  row i, replace that row with the sum of that row and        
;;;474    	 *		   a multiple of row i so that each new element in column i below row i is zero.       
;;;475    	 *	       
;;;476    	 *	    7. Move to the next row and column and repeat steps 2 through 5 until you have zeros       
;;;477    	 *		   for every element below and above the main diagonal.        
;;;478    	 *		   		          
;;;479    	 *		8. Now an identical matrix is formed to the left of the bar(input matrix, src).       
;;;480    	 *		   Therefore, the matrix to the right of the bar is our solution(dst matrix, dst).         
;;;481    	 *----------------------------------------------------------------------------------------------------------------*/
;;;482    
;;;483        /* Working pointer for destination matrix */
;;;484        pOutT1 = pOut;
;;;485    
;;;486        /* Loop over the number of rows */
;;;487        rowCnt = numRows;
;;;488    
;;;489        /* Making the destination matrix as identity matrix */
;;;490        while(rowCnt > 0u)
;;;491        {
;;;492          /* Writing all zeroes in lower triangle of the destination matrix */
;;;493          j = numRows - rowCnt;
;;;494          while(j > 0u)
;;;495          {
;;;496            *pOutT1++ = 0.0f;
;;;497            j--;
;;;498          }
;;;499    
;;;500          /* Writing all ones in the diagonal of the destination matrix */
;;;501          *pOutT1++ = 1.0f;
;;;502    
;;;503          /* Writing all zeroes in upper triangle of the destination matrix */
;;;504          j = rowCnt - 1u;
;;;505          while(j > 0u)
;;;506          {
;;;507            *pOutT1++ = 0.0f;
;;;508            j--;
;;;509          }
;;;510    
;;;511          /* Decrement the loop counter */
;;;512          rowCnt--;
;;;513        }
;;;514    
;;;515        /* Loop over the number of columns of the input matrix.     
;;;516           All the elements in each column are processed by the row operations */
;;;517        loopCnt = numCols;
;;;518    
;;;519        /* Index modifier to navigate through the columns */
;;;520        l = 0u;
;;;521        //for(loopCnt = 0u; loopCnt < numCols; loopCnt++)   
;;;522        while(loopCnt > 0u)
;;;523        {
;;;524          /* Check if the pivot element is zero..    
;;;525           * If it is zero then interchange the row with non zero row below.   
;;;526           * If there is no non zero element to replace in the rows below,   
;;;527           * then the matrix is Singular. */
;;;528    
;;;529          /* Working pointer for the input matrix that points     
;;;530           * to the pivot element of the particular row  */
;;;531          pInT1 = pIn + (l * numCols);
;;;532    
;;;533          /* Working pointer for the destination matrix that points     
;;;534           * to the pivot element of the particular row  */
;;;535          pOutT1 = pOut + (l * numCols);
;;;536    
;;;537          /* Temporary variable to hold the pivot value */
;;;538          in = *pInT1;
;;;539    
;;;540          /* Destination pointer modifier */
;;;541          k = 1u;
;;;542    
;;;543          /* Check if the pivot element is zero */
;;;544          if(*pInT1 == 0.0f)
;;;545          {
;;;546            /* Loop over the number rows present below */
;;;547            for (i = (l + 1u); i < numRows; i++)
;;;548            {
;;;549              /* Update the input and destination pointers */
;;;550              pInT2 = pInT1 + (numCols * l);
;;;551              pOutT2 = pOutT1 + (numCols * k);
;;;552    
;;;553              /* Check if there is a non zero pivot element to     
;;;554               * replace in the rows below */
;;;555              if(*pInT2 != 0.0f)
;;;556              {
;;;557                /* Loop over number of columns     
;;;558                 * to the right of the pilot element */
;;;559                for (j = 0u; j < (numCols - l); j++)
;;;560                {
;;;561                  /* Exchange the row elements of the input matrix */
;;;562                  Xchg = *pInT2;
;;;563                  *pInT2++ = *pInT1;
;;;564                  *pInT1++ = Xchg;
;;;565                }
;;;566    
;;;567                for (j = 0u; j < numCols; j++)
;;;568                {
;;;569                  Xchg = *pOutT2;
;;;570                  *pOutT2++ = *pOutT1;
;;;571                  *pOutT1++ = Xchg;
;;;572                }
;;;573    
;;;574                /* Flag to indicate whether exchange is done or not */
;;;575                flag = 1u;
;;;576    
;;;577                /* Break after exchange is done */
;;;578                break;
;;;579              }
;;;580    
;;;581              /* Update the destination pointer modifier */
;;;582              k++;
;;;583            }
;;;584          }
;;;585    
;;;586          /* Update the status if the matrix is singular */
;;;587          if((flag != 1u) && (in == 0.0f))
;;;588          {
;;;589            return ARM_MATH_SINGULAR;
;;;590          }
;;;591    
;;;592          /* Points to the pivot row of input and destination matrices */
;;;593          pPivotRowIn = pIn + (l * numCols);
;;;594          pPivotRowDst = pOut + (l * numCols);
;;;595    
;;;596          /* Temporary pointers to the pivot row pointers */
;;;597          pInT1 = pPivotRowIn;
;;;598          pOutT1 = pPivotRowDst;
;;;599    
;;;600          /* Pivot element of the row */
;;;601          in = *(pIn + (l * numCols));
;;;602    
;;;603          /* Loop over number of columns     
;;;604           * to the right of the pilot element */
;;;605          for (j = 0u; j < (numCols - l); j++)
;;;606          {
;;;607            /* Divide each element of the row of the input matrix     
;;;608             * by the pivot element */
;;;609            *pInT1 = *pInT1 / in;
;;;610            pInT1++;
;;;611          }
;;;612          for (j = 0u; j < numCols; j++)
;;;613          {
;;;614            /* Divide each element of the row of the destination matrix     
;;;615             * by the pivot element */
;;;616            *pOutT1 = *pOutT1 / in;
;;;617            pOutT1++;
;;;618          }
;;;619    
;;;620          /* Replace the rows with the sum of that row and a multiple of row i     
;;;621           * so that each new element in column i above row i is zero.*/
;;;622    
;;;623          /* Temporary pointers for input and destination matrices */
;;;624          pInT1 = pIn;
;;;625          pOutT1 = pOut;
;;;626    
;;;627          for (i = 0u; i < numRows; i++)
;;;628          {
;;;629            /* Check for the pivot element */
;;;630            if(i == l)
;;;631            {
;;;632              /* If the processing element is the pivot element,     
;;;633                 only the columns to the right are to be processed */
;;;634              pInT1 += numCols - l;
;;;635              pOutT1 += numCols;
;;;636            }
;;;637            else
;;;638            {
;;;639              /* Element of the reference row */
;;;640              in = *pInT1;
;;;641    
;;;642              /* Working pointers for input and destination pivot rows */
;;;643              pPRT_in = pPivotRowIn;
;;;644              pPRT_pDst = pPivotRowDst;
;;;645    
;;;646              /* Loop over the number of columns to the right of the pivot element,     
;;;647                 to replace the elements in the input matrix */
;;;648              for (j = 0u; j < (numCols - l); j++)
;;;649              {
;;;650                /* Replace the element by the sum of that row     
;;;651                   and a multiple of the reference row  */
;;;652                *pInT1 = *pInT1 - (in * *pPRT_in++);
;;;653                pInT1++;
;;;654              }
;;;655              /* Loop over the number of columns to     
;;;656                 replace the elements in the destination matrix */
;;;657              for (j = 0u; j < numCols; j++)
;;;658              {
;;;659                /* Replace the element by the sum of that row     
;;;660                   and a multiple of the reference row  */
;;;661                *pOutT1 = *pOutT1 - (in * *pPRT_pDst++);
;;;662                pOutT1++;
;;;663              }
;;;664    
;;;665            }
;;;666            /* Increment the temporary input pointer */
;;;667            pInT1 = pInT1 + l;
;;;668          }
;;;669          /* Increment the input pointer */
;;;670          pIn++;
;;;671    
;;;672          /* Decrement the loop counter */
;;;673          loopCnt--;
;;;674          /* Increment the index modifier */
;;;675          l++;
;;;676        }
;;;677    
;;;678    
;;;679    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;680    
;;;681        /* Set status as ARM_MATH_SUCCESS */
;;;682        status = ARM_MATH_SUCCESS;
;;;683    
;;;684        if((flag != 1u) && (in == 0.0f))
;;;685        {
;;;686          pIn = pSrc->pData;
;;;687          for (i = 0; i < numRows * numCols; i++)
;;;688          {
;;;689            if (pIn[i] != 0.0f)
;;;690                break;
;;;691          }
;;;692          
;;;693          if (i == numRows * numCols)
;;;694            status = ARM_MATH_SINGULAR;
;;;695        }
;;;696      }
;;;697      /* Return to application */
;;;698      return (status);
;;;699    }
0000c4  b005              ADD      sp,sp,#0x14
0000c6  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.202|
0000ca  464d              MOV      r5,r9                 ;229
0000cc  f04f0c01          MOV      r12,#1                ;232
0000d0  eeb51ac0          VCMPE.F32 s2,#0.0               ;235
0000d4  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;235
0000d8  dd02              BLE      |L1.224|
0000da  eef00a41          VMOV.F32 s1,s2                 ;235
0000de  e001              B        |L1.228|
                  |L1.224|
0000e0  eef10a41          VNEG.F32 s1,s2                 ;235
                  |L1.228|
0000e4  eef40a40          VCMP.F32 s1,s0                 ;235
0000e8  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;235
0000ec  d041              BEQ      |L1.370|
0000ee  eba80e03          SUB      lr,r8,r3              ;238
0000f2  f1ae0e01          SUB      lr,lr,#1              ;238
0000f6  fb01f003          MUL      r0,r1,r3              ;243
0000fa  eb050280          ADD      r2,r5,r0,LSL #2       ;243
0000fe  e035              B        |L1.364|
                  |L1.256|
000100  fb01f00c          MUL      r0,r1,r12             ;244
000104  eb040080          ADD      r0,r4,r0,LSL #2       ;244
000108  edd20a00          VLDR     s1,[r2,#0]            ;248
00010c  eef50ac0          VCMPE.F32 s1,#0.0               ;248
000110  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;248
000114  dc01              BGT      |L1.282|
000116  eef10a60          VNEG.F32 s1,s1                 ;248
                  |L1.282|
00011a  eef40a40          VCMP.F32 s1,s0                 ;248
00011e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;248
000122  d11f              BNE      |L1.356|
000124  eba10c03          SUB      r12,r1,r3             ;252
000128  e009              B        |L1.318|
                  |L1.298|
00012a  ed920a00          VLDR     s0,[r2,#0]            ;257
00012e  edd50a00          VLDR     s1,[r5,#0]            ;258
000132  ece20a01          VSTM     r2!,{s1}              ;258
000136  eca50a01          VSTM     r5!,{s0}              ;259
00013a  f1ac0c01          SUB      r12,r12,#1            ;262
                  |L1.318|
00013e  f1bc0f00          CMP      r12,#0                ;254
000142  d1f2              BNE      |L1.298|
000144  460a              MOV      r2,r1                 ;266
000146  e008              B        |L1.346|
                  |L1.328|
000148  ed900a00          VLDR     s0,[r0,#0]            ;271
00014c  edd40a00          VLDR     s1,[r4,#0]            ;272
000150  ece00a01          VSTM     r0!,{s1}              ;272
000154  eca40a01          VSTM     r4!,{s0}              ;273
000158  1e52              SUBS     r2,r2,#1              ;276
                  |L1.346|
00015a  2a00              CMP      r2,#0                 ;268
00015c  d1f4              BNE      |L1.328|
00015e  2001              MOVS     r0,#1                 ;280
000160  9001              STR      r0,[sp,#4]            ;280
000162  e006              B        |L1.370|
                  |L1.356|
000164  f10c0c01          ADD      r12,r12,#1            ;287
000168  f1ae0e01          SUB      lr,lr,#1              ;290
                  |L1.364|
00016c  f1be0f00          CMP      lr,#0                 ;240
000170  d1c6              BNE      |L1.256|
                  |L1.370|
000172  9801              LDR      r0,[sp,#4]            ;295
000174  2801              CMP      r0,#1                 ;295
000176  d007              BEQ      |L1.392|
000178  eeb51ac0          VCMPE.F32 s2,#0.0               ;295
00017c  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;295
000180  d102              BNE      |L1.392|
000182  f06f0004          MVN      r0,#4                 ;297
                  |L1.390|
000186  e79d              B        |L1.196|
                  |L1.392|
000188  46b2              MOV      r10,r6                ;301
00018a  46bb              MOV      r11,r7                ;302
00018c  465f              MOV      r7,r11                ;306
00018e  ed9a0a00          VLDR     s0,[r10,#0]           ;309
000192  4656              MOV      r6,r10                ;309
000194  1ac8              SUBS     r0,r1,r3              ;313
000196  4686              MOV      lr,r0                 ;313
000198  e006              B        |L1.424|
                  |L1.410|
00019a  edd60a00          VLDR     s1,[r6,#0]            ;319
00019e  ee801a80          VDIV.F32 s2,s1,s0              ;320
0001a2  eca61a01          VSTM     r6!,{s2}              ;320
0001a6  1e40              SUBS     r0,r0,#1              ;323
                  |L1.424|
0001a8  2800              CMP      r0,#0                 ;315
0001aa  d1f6              BNE      |L1.410|
0001ac  4608              MOV      r0,r1                 ;327
0001ae  e006              B        |L1.446|
                  |L1.432|
0001b0  edd70a00          VLDR     s1,[r7,#0]            ;333
0001b4  ee801a80          VDIV.F32 s2,s1,s0              ;334
0001b8  eca71a01          VSTM     r7!,{s2}              ;334
0001bc  1e40              SUBS     r0,r0,#1              ;337
                  |L1.446|
0001be  2800              CMP      r0,#0                 ;329
0001c0  d1f6              BNE      |L1.432|
0001c2  4648              MOV      r0,r9                 ;344
0001c4  9a02              LDR      r2,[sp,#8]            ;345
0001c6  2500              MOVS     r5,#0                 ;348
0001c8  4644              MOV      r4,r8                 ;352
0001ca  e02a              B        |L1.546|
                  |L1.460|
0001cc  429d              CMP      r5,r3                 ;357
0001ce  d104              BNE      |L1.474|
0001d0  eb00008e          ADD      r0,r0,lr,LSL #2       ;361
0001d4  eb020281          ADD      r2,r2,r1,LSL #2       ;363
0001d8  e01f              B        |L1.538|
                  |L1.474|
0001da  ed900a00          VLDR     s0,[r0,#0]            ;368
0001de  4656              MOV      r6,r10                ;371
0001e0  465f              MOV      r7,r11                ;372
0001e2  46f4              MOV      r12,lr                ;376
0001e4  e009              B        |L1.506|
                  |L1.486|
0001e6  edd00a00          VLDR     s1,[r0,#0]            ;382
0001ea  ecb61a01          VLDM     r6!,{s2}              ;383
0001ee  ee400a41          VMLS.F32 s1,s0,s2              ;383
0001f2  ece00a01          VSTM     r0!,{s1}              ;383
0001f6  f1ac0c01          SUB      r12,r12,#1            ;386
                  |L1.506|
0001fa  f1bc0f00          CMP      r12,#0                ;378
0001fe  d1f2              BNE      |L1.486|
000200  460e              MOV      r6,r1                 ;391
000202  e008              B        |L1.534|
                  |L1.516|
000204  edd20a00          VLDR     s1,[r2,#0]            ;397
000208  ecb71a01          VLDM     r7!,{s2}              ;398
00020c  ee400a41          VMLS.F32 s1,s0,s2              ;398
000210  ece20a01          VSTM     r2!,{s1}              ;398
000214  1e76              SUBS     r6,r6,#1              ;401
                  |L1.534|
000216  2e00              CMP      r6,#0                 ;393
000218  d1f4              BNE      |L1.516|
                  |L1.538|
00021a  eb000083          ADD      r0,r0,r3,LSL #2       ;407
00021e  1e64              SUBS     r4,r4,#1              ;410
000220  1c6d              ADDS     r5,r5,#1              ;413
                  |L1.546|
000222  2c00              CMP      r4,#0                 ;354
000224  d1d2              BNE      |L1.460|
000226  f1090904          ADD      r9,r9,#4              ;417
00022a  9800              LDR      r0,[sp,#0]            ;420
00022c  1e40              SUBS     r0,r0,#1              ;420
00022e  9000              STR      r0,[sp,#0]            ;420
000230  1c5b              ADDS     r3,r3,#1              ;423
                  |L1.562|
000232  9800              LDR      r0,[sp,#0]            ;196
000234  2800              CMP      r0,#0                 ;196
000236  f47faf12          BNE      |L1.94|
00023a  9a01              LDR      r2,[sp,#4]            ;684
00023c  2a01              CMP      r2,#1                 ;684
00023e  d0a2              BEQ      |L1.390|
000240  eeb50ac0          VCMPE.F32 s0,#0.0               ;684
000244  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;684
000248  d19d              BNE      |L1.390|
00024a  9a03              LDR      r2,[sp,#0xc]          ;686
00024c  6853              LDR      r3,[r2,#4]            ;686
00024e  2200              MOVS     r2,#0                 ;687
000250  fb08f801          MUL      r8,r8,r1              ;687
000254  e009              B        |L1.618|
                  |L1.598|
000256  eb030182          ADD      r1,r3,r2,LSL #2       ;689
00025a  ed910a00          VLDR     s0,[r1,#0]            ;689
00025e  eeb50ac0          VCMPE.F32 s0,#0.0               ;689
000262  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;689
000266  d102              BNE      |L1.622|
000268  1c52              ADDS     r2,r2,#1              ;687
                  |L1.618|
00026a  4590              CMP      r8,r2                 ;687
00026c  d8f3              BHI      |L1.598|
                  |L1.622|
00026e  4590              CMP      r8,r2                 ;693
000270  d189              BNE      |L1.390|
000272  f06f0004          MVN      r0,#4                 ;694
000276  e725              B        |L1.196|
;;;700    
                          ENDP

                  |L1.632|
000278  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\MatrixFunctions\\arm_mat_inverse_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_mat_inverse_f32_c_ad6caf25____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___21_arm_mat_inverse_f32_c_ad6caf25____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_mat_inverse_f32_c_ad6caf25____REVSH|
#line 144
|__asm___21_arm_mat_inverse_f32_c_ad6caf25____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_mat_inverse_f32_c_ad6caf25____RRX|
#line 300
|__asm___21_arm_mat_inverse_f32_c_ad6caf25____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
