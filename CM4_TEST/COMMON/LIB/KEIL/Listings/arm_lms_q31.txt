; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_lms_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_lms_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_lms_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_lms_q31.c]
                          THUMB

                          AREA ||i.arm_lms_q31||, CODE, READONLY, ALIGN=1

                  arm_lms_q31 PROC
;;;76     
;;;77     void arm_lms_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;78       const arm_lms_instance_q31 * S,
;;;79       q31_t * pSrc,
;;;80       q31_t * pRef,
;;;81       q31_t * pOut,
;;;82       q31_t * pErr,
;;;83       uint32_t blockSize)
;;;84     {
000004  b087              SUB      sp,sp,#0x1c
000006  f8dd9054          LDR      r9,[sp,#0x54]
;;;85       q31_t *pState = S->pState;                     /* State pointer */
00000a  9807              LDR      r0,[sp,#0x1c]
00000c  6845              LDR      r5,[r0,#4]
;;;86       uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
00000e  9807              LDR      r0,[sp,#0x1c]
000010  8800              LDRH     r0,[r0,#0]
000012  9005              STR      r0,[sp,#0x14]
;;;87       q31_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
000014  9807              LDR      r0,[sp,#0x1c]
000016  6880              LDR      r0,[r0,#8]
000018  9004              STR      r0,[sp,#0x10]
;;;88       q31_t *pStateCurnt;                            /* Points to the current sample of the state */
;;;89       q31_t mu = S->mu;                              /* Adaptive factor */
00001a  9807              LDR      r0,[sp,#0x1c]
00001c  68c0              LDR      r0,[r0,#0xc]
00001e  9003              STR      r0,[sp,#0xc]
;;;90       q31_t *px;                                     /* Temporary pointer for state */
;;;91       q31_t *pb;                                     /* Temporary pointer for coefficient buffer */
;;;92       uint32_t tapCnt, blkCnt;                       /* Loop counters */
;;;93       q63_t acc;                                     /* Accumulator */
;;;94       q31_t e = 0;                                   /* error of data sample */
;;;95       q31_t alpha;                                   /* Intermediate constant for taps update */
;;;96       q31_t coef;                                    /* Temporary variable for coef */
;;;97       q31_t acc_l, acc_h;                            /*  temporary input */
;;;98       uint32_t uShift = ((uint32_t) S->postShift + 1u);
000020  9807              LDR      r0,[sp,#0x1c]
000022  6900              LDR      r0,[r0,#0x10]
000024  1c40              ADDS     r0,r0,#1
000026  9002              STR      r0,[sp,#8]
;;;99       uint32_t lShift = 32u - uShift;                /*  Shift to be applied to the output */
000028  9802              LDR      r0,[sp,#8]
00002a  f1c00020          RSB      r0,r0,#0x20
00002e  9001              STR      r0,[sp,#4]
;;;100    
;;;101      /* S->pState points to buffer which contains previous frame (numTaps - 1) samples */
;;;102      /* pStateCurnt points to the location where the new input data should be written */
;;;103      pStateCurnt = &(S->pState[(numTaps - 1u)]);
000030  9805              LDR      r0,[sp,#0x14]
000032  1e40              SUBS     r0,r0,#1
000034  eb050b80          ADD      r11,r5,r0,LSL #2
000038  9006              STR      r0,[sp,#0x18]
00003a  e0a7              B        |L1.396|
                  |L1.60|
;;;104    
;;;105      /* Initializing blkCnt with blockSize */
;;;106      blkCnt = blockSize;
;;;107    
;;;108    
;;;109    #ifndef ARM_MATH_CM0_FAMILY
;;;110    
;;;111      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;112    
;;;113      while(blkCnt > 0u)
;;;114      {
;;;115        /* Copy the new input sample into the state buffer */
;;;116        *pStateCurnt++ = *pSrc++;
00003c  9808              LDR      r0,[sp,#0x20]
00003e  6800              LDR      r0,[r0,#0]
000040  f84b0b04          STR      r0,[r11],#4
000044  9808              LDR      r0,[sp,#0x20]
000046  1d00              ADDS     r0,r0,#4
000048  9008              STR      r0,[sp,#0x20]
;;;117    
;;;118        /* Initialize state pointer */
;;;119        px = pState;
00004a  462a              MOV      r2,r5
;;;120    
;;;121        /* Initialize coefficient pointer */
;;;122        pb = pCoeffs;
00004c  9b04              LDR      r3,[sp,#0x10]
;;;123    
;;;124        /* Set the accumulator to zero */
;;;125        acc = 0;
00004e  2000              MOVS     r0,#0
000050  4601              MOV      r1,r0
;;;126    
;;;127        /* Loop unrolling.  Process 4 taps at a time. */
;;;128        tapCnt = numTaps >> 2;
000052  9c05              LDR      r4,[sp,#0x14]
000054  08a7              LSRS     r7,r4,#2
000056  46bc              MOV      r12,r7
;;;129    
;;;130        while(tapCnt > 0u)
000058  e01b              B        |L1.146|
                  |L1.90|
;;;131        {
;;;132          /* Perform the multiply-accumulate */
;;;133          /* acc +=  b[N] * x[n-N] */
;;;134          acc += ((q63_t) (*px++)) * (*pb++);
00005a  6814              LDR      r4,[r2,#0]
00005c  681e              LDR      r6,[r3,#0]
00005e  fb846406          SMULL    r6,r4,r4,r6
000062  1830              ADDS     r0,r6,r0
000064  4161              ADCS     r1,r1,r4
;;;135    
;;;136          /* acc +=  b[N-1] * x[n-N-1] */
;;;137          acc += ((q63_t) (*px++)) * (*pb++);
000066  6854              LDR      r4,[r2,#4]
000068  685e              LDR      r6,[r3,#4]
00006a  fb846406          SMULL    r6,r4,r4,r6
00006e  1830              ADDS     r0,r6,r0
000070  4161              ADCS     r1,r1,r4
;;;138    
;;;139          /* acc +=  b[N-2] * x[n-N-2] */
;;;140          acc += ((q63_t) (*px++)) * (*pb++);
000072  6894              LDR      r4,[r2,#8]
000074  689e              LDR      r6,[r3,#8]
000076  fb846406          SMULL    r6,r4,r4,r6
00007a  1830              ADDS     r0,r6,r0
00007c  4161              ADCS     r1,r1,r4
;;;141    
;;;142          /* acc +=  b[N-3] * x[n-N-3] */
;;;143          acc += ((q63_t) (*px++)) * (*pb++);
00007e  68d4              LDR      r4,[r2,#0xc]
000080  68de              LDR      r6,[r3,#0xc]
000082  3210              ADDS     r2,r2,#0x10
000084  fb846406          SMULL    r6,r4,r4,r6
000088  3310              ADDS     r3,r3,#0x10
00008a  1830              ADDS     r0,r6,r0
00008c  4161              ADCS     r1,r1,r4
;;;144    
;;;145          /* Decrement the loop counter */
;;;146          tapCnt--;
00008e  f1ac0c01          SUB      r12,r12,#1
                  |L1.146|
000092  f1bc0f00          CMP      r12,#0                ;130
000096  d1e0              BNE      |L1.90|
;;;147        }
;;;148    
;;;149        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;150        tapCnt = numTaps % 0x4u;
000098  9c05              LDR      r4,[sp,#0x14]
00009a  f0040403          AND      r4,r4,#3
00009e  46a2              MOV      r10,r4
;;;151    
;;;152        while(tapCnt > 0u)
0000a0  e008              B        |L1.180|
                  |L1.162|
;;;153        {
;;;154          /* Perform the multiply-accumulate */
;;;155          acc += ((q63_t) (*px++)) * (*pb++);
0000a2  ca40              LDM      r2!,{r6}
0000a4  f853cb04          LDR      r12,[r3],#4
0000a8  fb86c60c          SMULL    r12,r6,r6,r12
0000ac  eb1c0000          ADDS     r0,r12,r0
0000b0  4171              ADCS     r1,r1,r6
;;;156    
;;;157          /* Decrement the loop counter */
;;;158          tapCnt--;
0000b2  1e64              SUBS     r4,r4,#1
                  |L1.180|
0000b4  2c00              CMP      r4,#0                 ;152
0000b6  d1f4              BNE      |L1.162|
;;;159        }
;;;160    
;;;161        /* Converting the result to 1.31 format */
;;;162        /* Calc lower part of acc */
;;;163        acc_l = acc & 0xffffffff;
;;;164    
;;;165        /* Calc upper part of acc */
;;;166        acc_h = (acc >> 32) & 0xffffffff;
;;;167    
;;;168        acc = (uint32_t) acc_l >> lShift | acc_h << uShift;
0000b8  9a01              LDR      r2,[sp,#4]
0000ba  40d0              LSRS     r0,r0,r2
0000bc  9a02              LDR      r2,[sp,#8]
0000be  4091              LSLS     r1,r1,r2
0000c0  4308              ORRS     r0,r0,r1
;;;169    
;;;170        /* Store the result from accumulator into the destination buffer. */
;;;171        *pOut++ = (q31_t) acc;
0000c2  990a              LDR      r1,[sp,#0x28]
0000c4  6008              STR      r0,[r1,#0]
0000c6  990a              LDR      r1,[sp,#0x28]
0000c8  1d09              ADDS     r1,r1,#4
0000ca  910a              STR      r1,[sp,#0x28]
;;;172    
;;;173        /* Compute and store error */
;;;174        e = *pRef++ - (q31_t) acc;
0000cc  9909              LDR      r1,[sp,#0x24]
0000ce  c904              LDM      r1!,{r2}
0000d0  9109              STR      r1,[sp,#0x24]
0000d2  1a10              SUBS     r0,r2,r0
;;;175    
;;;176        *pErr++ = (q31_t) e;
0000d4  9914              LDR      r1,[sp,#0x50]
0000d6  6008              STR      r0,[r1,#0]
0000d8  9914              LDR      r1,[sp,#0x50]
0000da  1d09              ADDS     r1,r1,#4
0000dc  9114              STR      r1,[sp,#0x50]
;;;177    
;;;178        /* Compute alpha i.e. intermediate constant for taps update */
;;;179        alpha = (q31_t) (((q63_t) e * mu) >> 31);
0000de  9903              LDR      r1,[sp,#0xc]
0000e0  fb800101          SMULL    r0,r1,r0,r1
0000e4  0fc6              LSRS     r6,r0,#31
0000e6  ea460641          ORR      r6,r6,r1,LSL #1
;;;180    
;;;181        /* Initialize state pointer */
;;;182        /* Advance state pointer by 1 for the next sample */
;;;183        px = pState++;
0000ea  46a8              MOV      r8,r5
0000ec  1d2d              ADDS     r5,r5,#4
;;;184    
;;;185        /* Initialize coefficient pointer */
;;;186        pb = pCoeffs;
0000ee  9c04              LDR      r4,[sp,#0x10]
;;;187    
;;;188        /* Loop unrolling.  Process 4 taps at a time. */
;;;189        tapCnt = numTaps >> 2;
;;;190    
;;;191        /* Update filter coefficients */
;;;192        while(tapCnt > 0u)
0000f0  e035              B        |L1.350|
                  |L1.242|
;;;193        {
;;;194          /* coef is in 2.30 format */
;;;195          coef = (q31_t) (((q63_t) alpha * (*px++)) >> (32));
0000f2  f8580b04          LDR      r0,[r8],#4
0000f6  fb56f100          SMMUL    r1,r6,r0
;;;196          /* get coef in 1.31 format by left shifting */
;;;197          *pb = clip_q63_to_q31((q63_t) * pb + (coef << 1u));
0000fa  6820              LDR      r0,[r4,#0]
0000fc  0049              LSLS     r1,r1,#1
0000fe  17c2              ASRS     r2,r0,#31
000100  1840              ADDS     r0,r0,r1
000102  eb4271e1          ADC      r1,r2,r1,ASR #31
000106  f7fffffe          BL       clip_q63_to_q31
00010a  6020              STR      r0,[r4,#0]
;;;198          /* update coefficient buffer to next coefficient */
;;;199          pb++;
;;;200    
;;;201          coef = (q31_t) (((q63_t) alpha * (*px++)) >> (32));
00010c  f8580b04          LDR      r0,[r8],#4
000110  fb56f100          SMMUL    r1,r6,r0
;;;202          *pb = clip_q63_to_q31((q63_t) * pb + (coef << 1u));
000114  6860              LDR      r0,[r4,#4]
000116  0049              LSLS     r1,r1,#1
000118  17c2              ASRS     r2,r0,#31
00011a  1840              ADDS     r0,r0,r1
00011c  eb4271e1          ADC      r1,r2,r1,ASR #31
000120  f7fffffe          BL       clip_q63_to_q31
000124  6060              STR      r0,[r4,#4]
;;;203          pb++;
;;;204    
;;;205          coef = (q31_t) (((q63_t) alpha * (*px++)) >> (32));
000126  f8580b04          LDR      r0,[r8],#4
00012a  fb56f100          SMMUL    r1,r6,r0
;;;206          *pb = clip_q63_to_q31((q63_t) * pb + (coef << 1u));
00012e  68a0              LDR      r0,[r4,#8]
000130  0049              LSLS     r1,r1,#1
000132  17c2              ASRS     r2,r0,#31
000134  1840              ADDS     r0,r0,r1
000136  eb4271e1          ADC      r1,r2,r1,ASR #31
00013a  f7fffffe          BL       clip_q63_to_q31
00013e  60a0              STR      r0,[r4,#8]
;;;207          pb++;
;;;208    
;;;209          coef = (q31_t) (((q63_t) alpha * (*px++)) >> (32));
000140  f8580b04          LDR      r0,[r8],#4
000144  fb56f100          SMMUL    r1,r6,r0
;;;210          *pb = clip_q63_to_q31((q63_t) * pb + (coef << 1u));
000148  68e0              LDR      r0,[r4,#0xc]
00014a  0049              LSLS     r1,r1,#1
00014c  17c2              ASRS     r2,r0,#31
00014e  1840              ADDS     r0,r0,r1
000150  eb4271e1          ADC      r1,r2,r1,ASR #31
000154  f7fffffe          BL       clip_q63_to_q31
000158  60e0              STR      r0,[r4,#0xc]
00015a  3410              ADDS     r4,r4,#0x10
;;;211          pb++;
;;;212    
;;;213          /* Decrement the loop counter */
;;;214          tapCnt--;
00015c  1e7f              SUBS     r7,r7,#1
                  |L1.350|
00015e  2f00              CMP      r7,#0                 ;192
000160  d1c7              BNE      |L1.242|
000162  e00e              B        |L1.386|
                  |L1.356|
;;;215        }
;;;216    
;;;217        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;218        tapCnt = numTaps % 0x4u;
;;;219    
;;;220        while(tapCnt > 0u)
;;;221        {
;;;222          /* Perform the multiply-accumulate */
;;;223          coef = (q31_t) (((q63_t) alpha * (*px++)) >> (32));
000164  f8580b04          LDR      r0,[r8],#4
000168  fb56f100          SMMUL    r1,r6,r0
;;;224          *pb = clip_q63_to_q31((q63_t) * pb + (coef << 1u));
00016c  6820              LDR      r0,[r4,#0]
00016e  0049              LSLS     r1,r1,#1
000170  17c2              ASRS     r2,r0,#31
000172  1840              ADDS     r0,r0,r1
000174  eb4271e1          ADC      r1,r2,r1,ASR #31
000178  f7fffffe          BL       clip_q63_to_q31
00017c  c401              STM      r4!,{r0}
;;;225          pb++;
;;;226    
;;;227          /* Decrement the loop counter */
;;;228          tapCnt--;
00017e  f1aa0a01          SUB      r10,r10,#1
                  |L1.386|
000182  f1ba0f00          CMP      r10,#0                ;220
000186  d1ed              BNE      |L1.356|
;;;229        }
;;;230    
;;;231        /* Decrement the loop counter */
;;;232        blkCnt--;
000188  f1a90901          SUB      r9,r9,#1
                  |L1.396|
00018c  f1b90f00          CMP      r9,#0                 ;113
000190  f47faf54          BNE      |L1.60|
;;;233      }
;;;234    
;;;235      /* Processing is complete. Now copy the last numTaps - 1 samples to the    
;;;236         satrt of the state buffer. This prepares the state buffer for the    
;;;237         next function call. */
;;;238    
;;;239      /* Points to the start of the pState buffer */
;;;240      pStateCurnt = S->pState;
000194  9807              LDR      r0,[sp,#0x1c]
000196  6840              LDR      r0,[r0,#4]
;;;241    
;;;242      /* Loop unrolling for (numTaps - 1u) samples copy */
;;;243      tapCnt = (numTaps - 1u) >> 2u;
000198  9906              LDR      r1,[sp,#0x18]
00019a  0889              LSRS     r1,r1,#2
;;;244    
;;;245      /* copy data */
;;;246      while(tapCnt > 0u)
00019c  e00a              B        |L1.436|
                  |L1.414|
;;;247      {
;;;248        *pStateCurnt++ = *pState++;
00019e  682a              LDR      r2,[r5,#0]
0001a0  6002              STR      r2,[r0,#0]
;;;249        *pStateCurnt++ = *pState++;
0001a2  686a              LDR      r2,[r5,#4]
0001a4  6042              STR      r2,[r0,#4]
;;;250        *pStateCurnt++ = *pState++;
0001a6  68aa              LDR      r2,[r5,#8]
0001a8  6082              STR      r2,[r0,#8]
;;;251        *pStateCurnt++ = *pState++;
0001aa  68ea              LDR      r2,[r5,#0xc]
0001ac  3510              ADDS     r5,r5,#0x10
0001ae  60c2              STR      r2,[r0,#0xc]
0001b0  3010              ADDS     r0,r0,#0x10
;;;252    
;;;253        /* Decrement the loop counter */
;;;254        tapCnt--;
0001b2  1e49              SUBS     r1,r1,#1
                  |L1.436|
0001b4  2900              CMP      r1,#0                 ;246
0001b6  d1f2              BNE      |L1.414|
;;;255      }
;;;256    
;;;257      /* Calculate remaining number of copies */
;;;258      tapCnt = (numTaps - 1u) % 0x4u;
0001b8  9906              LDR      r1,[sp,#0x18]
0001ba  f0010103          AND      r1,r1,#3
;;;259    
;;;260      /* Copy the remaining q31_t data */
;;;261      while(tapCnt > 0u)
0001be  e002              B        |L1.454|
                  |L1.448|
;;;262      {
;;;263        *pStateCurnt++ = *pState++;
0001c0  cd04              LDM      r5!,{r2}
0001c2  c004              STM      r0!,{r2}
;;;264    
;;;265        /* Decrement the loop counter */
;;;266        tapCnt--;
0001c4  1e49              SUBS     r1,r1,#1
                  |L1.454|
0001c6  2900              CMP      r1,#0                 ;261
0001c8  d1fa              BNE      |L1.448|
;;;267      }
;;;268    
;;;269    #else
;;;270    
;;;271      /* Run the below code for Cortex-M0 */
;;;272    
;;;273      while(blkCnt > 0u)
;;;274      {
;;;275        /* Copy the new input sample into the state buffer */
;;;276        *pStateCurnt++ = *pSrc++;
;;;277    
;;;278        /* Initialize pState pointer */
;;;279        px = pState;
;;;280    
;;;281        /* Initialize pCoeffs pointer */
;;;282        pb = pCoeffs;
;;;283    
;;;284        /* Set the accumulator to zero */
;;;285        acc = 0;
;;;286    
;;;287        /* Loop over numTaps number of values */
;;;288        tapCnt = numTaps;
;;;289    
;;;290        while(tapCnt > 0u)
;;;291        {
;;;292          /* Perform the multiply-accumulate */
;;;293          acc += ((q63_t) (*px++)) * (*pb++);
;;;294    
;;;295          /* Decrement the loop counter */
;;;296          tapCnt--;
;;;297        }
;;;298    
;;;299        /* Converting the result to 1.31 format */
;;;300        /* Store the result from accumulator into the destination buffer. */
;;;301        /* Calc lower part of acc */
;;;302        acc_l = acc & 0xffffffff;
;;;303    
;;;304        /* Calc upper part of acc */
;;;305        acc_h = (acc >> 32) & 0xffffffff;
;;;306    
;;;307        acc = (uint32_t) acc_l >> lShift | acc_h << uShift;
;;;308    
;;;309        *pOut++ = (q31_t) acc;
;;;310    
;;;311        /* Compute and store error */
;;;312        e = *pRef++ - (q31_t) acc;
;;;313    
;;;314        *pErr++ = (q31_t) e;
;;;315    
;;;316        /* Weighting factor for the LMS version */
;;;317        alpha = (q31_t) (((q63_t) e * mu) >> 31);
;;;318    
;;;319        /* Initialize pState pointer */
;;;320        /* Advance state pointer by 1 for the next sample */
;;;321        px = pState++;
;;;322    
;;;323        /* Initialize pCoeffs pointer */
;;;324        pb = pCoeffs;
;;;325    
;;;326        /* Loop over numTaps number of values */
;;;327        tapCnt = numTaps;
;;;328    
;;;329        while(tapCnt > 0u)
;;;330        {
;;;331          /* Perform the multiply-accumulate */
;;;332          coef = (q31_t) (((q63_t) alpha * (*px++)) >> (32));
;;;333          *pb = clip_q63_to_q31((q63_t) * pb + (coef << 1u));
;;;334          pb++;
;;;335    
;;;336          /* Decrement the loop counter */
;;;337          tapCnt--;
;;;338        }
;;;339    
;;;340        /* Decrement the loop counter */
;;;341        blkCnt--;
;;;342      }
;;;343    
;;;344      /* Processing is complete. Now copy the last numTaps - 1 samples to the     
;;;345         start of the state buffer. This prepares the state buffer for the   
;;;346         next function call. */
;;;347    
;;;348      /* Points to the start of the pState buffer */
;;;349      pStateCurnt = S->pState;
;;;350    
;;;351      /*  Copy (numTaps - 1u) samples  */
;;;352      tapCnt = (numTaps - 1u);
;;;353    
;;;354      /* Copy the data */
;;;355      while(tapCnt > 0u)
;;;356      {
;;;357        *pStateCurnt++ = *pState++;
;;;358    
;;;359        /* Decrement the loop counter */
;;;360        tapCnt--;
;;;361      }
;;;362    
;;;363    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;364    
;;;365    }
0001ca  b00b              ADD      sp,sp,#0x2c
0001cc  e8bd8ff0          POP      {r4-r11,pc}
;;;366    
                          ENDP


                          AREA ||i.clip_q63_to_q31||, CODE, READONLY, ALIGN=1

                  clip_q63_to_q31 PROC
;;;458       */
;;;459      static __INLINE q31_t clip_q63_to_q31(
000000  17ca              ASRS     r2,r1,#31
;;;460      q63_t x)
;;;461      {
;;;462        return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
000002  ebb17fe0          CMP      r1,r0,ASR #31
000006  d002              BEQ      |L2.14|
;;;463          ((0x7FFFFFFF ^ ((q31_t) (x >> 63)))) : (q31_t) x;
000008  f06f4000          MVN      r0,#0x80000000
00000c  4050              EORS     r0,r0,r2
                  |L2.14|
;;;464      }
00000e  4770              BX       lr
;;;465    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_lms_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_lms_q31_c_0cadf2bb____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___13_arm_lms_q31_c_0cadf2bb____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_lms_q31_c_0cadf2bb____REVSH|
#line 144
|__asm___13_arm_lms_q31_c_0cadf2bb____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_lms_q31_c_0cadf2bb____RRX|
#line 300
|__asm___13_arm_lms_q31_c_0cadf2bb____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
