; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_sparse_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_sparse_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_fir_sparse_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_fir_sparse_q15.c]
                          THUMB

                          AREA ||i.arm_circularRead_q15||, CODE, READONLY, ALIGN=1

                  arm_circularRead_q15 PROC
;;;6293      */
;;;6294     static __INLINE void arm_circularRead_q15(
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;6295     q15_t * circBuffer,
;;;6296     int32_t L,
;;;6297     int32_t * readOffset,
;;;6298     int32_t bufferInc,
;;;6299     q15_t * dst,
;;;6300     q15_t * dst_base,
;;;6301     int32_t dst_length,
;;;6302     int32_t dstInc,
;;;6303     uint32_t blockSize)
;;;6304     {
000004  e9dd7c09          LDRD     r7,r12,[sp,#0x24]
000008  e9dd5807          LDRD     r5,r8,[sp,#0x1c]
00000c  9e0b              LDR      r6,[sp,#0x2c]
;;;6305       uint32_t i = 0;
;;;6306       int32_t rOffset, dst_end;
;;;6307   
;;;6308       /* Copy the value of Index pointer that points
;;;6309        * to the current location from where the input samples to be read */
;;;6310       rOffset = *readOffset;
00000e  6814              LDR      r4,[r2,#0]
;;;6311   
;;;6312       dst_end = (int32_t) (dst_base + dst_length);
000010  eb080747          ADD      r7,r8,r7,LSL #1
000014  e00d              B        |L1.50|
                  |L1.22|
;;;6313   
;;;6314       /* Loop over the blockSize */
;;;6315       i = blockSize;
;;;6316   
;;;6317       while(i > 0u)
;;;6318       {
;;;6319         /* copy the sample from the circular buffer to the destination buffer */
;;;6320         *dst = circBuffer[rOffset];
000016  f8309014          LDRH     r9,[r0,r4,LSL #1]
00001a  f8a59000          STRH     r9,[r5,#0]
;;;6321   
;;;6322         /* Update the input pointer */
;;;6323         dst += dstInc;
00001e  eb05054c          ADD      r5,r5,r12,LSL #1
;;;6324   
;;;6325         if(dst == (q15_t *) dst_end)
000022  42bd              CMP      r5,r7
000024  d100              BNE      |L1.40|
;;;6326         {
;;;6327           dst = dst_base;
000026  4645              MOV      r5,r8
                  |L1.40|
;;;6328         }
;;;6329   
;;;6330         /* Circularly update wOffset.  Watch out for positive and negative value */
;;;6331         rOffset += bufferInc;
000028  441c              ADD      r4,r4,r3
;;;6332   
;;;6333         if(rOffset >= L)
00002a  428c              CMP      r4,r1
00002c  db00              BLT      |L1.48|
;;;6334         {
;;;6335           rOffset -= L;
00002e  1a64              SUBS     r4,r4,r1
                  |L1.48|
;;;6336         }
;;;6337   
;;;6338         /* Decrement the loop counter */
;;;6339         i--;
000030  1e76              SUBS     r6,r6,#1
                  |L1.50|
000032  2e00              CMP      r6,#0                 ;6317
000034  d1ef              BNE      |L1.22|
;;;6340       }
;;;6341   
;;;6342       /* Update the index pointer */
;;;6343       *readOffset = rOffset;
000036  6014              STR      r4,[r2,#0]
;;;6344     }
000038  e8bd83f0          POP      {r4-r9,pc}
;;;6345   
                          ENDP


                          AREA ||i.arm_fir_sparse_q15||, CODE, READONLY, ALIGN=1

                  arm_fir_sparse_q15 PROC
;;;67     
;;;68     void arm_fir_sparse_q15(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;69       arm_fir_sparse_instance_q15 * S,
;;;70       q15_t * pSrc,
;;;71       q15_t * pDst,
;;;72       q15_t * pScratchIn,
;;;73       q31_t * pScratchOut,
;;;74       uint32_t blockSize)
;;;75     {
000004  b08d              SUB      sp,sp,#0x34
000006  4682              MOV      r10,r0
000008  e9dd4516          LDRD     r4,r5,[sp,#0x58]
00000c  4690              MOV      r8,r2
;;;76     
;;;77       q15_t *pState = S->pState;                     /* State pointer */
00000e  f8dac004          LDR      r12,[r10,#4]
000012  f8cdc028          STR      r12,[sp,#0x28]
;;;78       q15_t *pIn = pSrc;                             /* Working pointer for input */
;;;79       q15_t *pOut = pDst;                            /* Working pointer for output */
;;;80       q15_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
000016  f8dab008          LDR      r11,[r10,#8]
;;;81       q15_t *px;                                     /* Temporary pointers for scratch buffer */
;;;82       q15_t *pb = pScratchIn;                        /* Temporary pointers for scratch buffer */
00001a  461f              MOV      r7,r3
;;;83       q15_t *py = pState;                            /* Temporary pointers for state buffer */
00001c  f8ddc028          LDR      r12,[sp,#0x28]
;;;84       int32_t *pTapDelay = S->pTapDelay;             /* Pointer to the array containing offset of the non-zero tap values. */
000020  f8dae010          LDR      lr,[r10,#0x10]
;;;85       uint32_t delaySize = S->maxDelay + blockSize;  /* state length */
000024  f8ba000c          LDRH     r0,[r10,#0xc]
000028  1942              ADDS     r2,r0,r5
00002a  9209              STR      r2,[sp,#0x24]
;;;86       uint16_t numTaps = S->numTaps;                 /* Filter order */
00002c  f8ba0000          LDRH     r0,[r10,#0]
000030  9008              STR      r0,[sp,#0x20]
;;;87       int32_t readIndex;                             /* Read index of the state buffer */
;;;88       uint32_t tapCnt, blkCnt;                       /* loop counters */
;;;89       q15_t coeff = *pCoeffs++;                      /* Read the first coefficient value */
000032  f93b9b02          LDRSH    r9,[r11],#2
;;;90       q31_t *pScr2 = pScratchOut;                    /* Working pointer for pScratchOut */
;;;91     
;;;92     
;;;93     #ifndef ARM_MATH_CM0_FAMILY
;;;94     
;;;95       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;96     
;;;97       q31_t in1, in2;                                /* Temporary variables */
;;;98     
;;;99     
;;;100      /* BlockSize of Input samples are copied into the state buffer */
;;;101      /* StateIndex points to the starting position to write in the state buffer */
;;;102      arm_circularWrite_q15(py, delaySize, &S->stateIndex, 1, pIn, 1, blockSize);
000036  f10a0002          ADD      r0,r10,#2
00003a  9003              STR      r0,[sp,#0xc]
00003c  2001              MOVS     r0,#1
00003e  9a09              LDR      r2,[sp,#0x24]
000040  9004              STR      r0,[sp,#0x10]
000042  9005              STR      r0,[sp,#0x14]
000044  4628              MOV      r0,r5
000046  9b03              LDR      r3,[sp,#0xc]
000048  881e              LDRH     r6,[r3,#0]
00004a  e00b              B        |L2.100|
                  |L2.76|
00004c  880b              LDRH     r3,[r1,#0]            ;75
00004e  f82c3016          STRH     r3,[r12,r6,LSL #1]    ;75
000052  9b05              LDR      r3,[sp,#0x14]         ;75
000054  eb010143          ADD      r1,r1,r3,LSL #1       ;75
000058  9b04              LDR      r3,[sp,#0x10]         ;75
00005a  441e              ADD      r6,r6,r3              ;75
00005c  4296              CMP      r6,r2                 ;75
00005e  db00              BLT      |L2.98|
000060  1ab6              SUBS     r6,r6,r2              ;75
                  |L2.98|
000062  1e40              SUBS     r0,r0,#1              ;75
                  |L2.100|
000064  2800              CMP      r0,#0                 ;75
000066  d1f1              BNE      |L2.76|
000068  9803              LDR      r0,[sp,#0xc]          ;75
00006a  8006              STRH     r6,[r0,#0]            ;75
;;;103    
;;;104      /* Loop over the number of taps. */
;;;105      tapCnt = numTaps;
;;;106    
;;;107      /* Read Index, from where the state buffer should be read, is calculated. */
;;;108      readIndex = (S->stateIndex - blockSize) - *pTapDelay++;
00006c  f8ba1002          LDRH     r1,[r10,#2]
000070  f8de0000          LDR      r0,[lr,#0]
000074  1b49              SUBS     r1,r1,r5
000076  1a08              SUBS     r0,r1,r0
000078  f10e0604          ADD      r6,lr,#4
00007c  9007              STR      r0,[sp,#0x1c]
;;;109    
;;;110      /* Wraparound of readIndex */
;;;111      if(readIndex < 0)
00007e  2800              CMP      r0,#0
000080  da02              BGE      |L2.136|
;;;112      {
;;;113        readIndex += (int32_t) delaySize;
000082  9909              LDR      r1,[sp,#0x24]
000084  4408              ADD      r0,r0,r1
000086  9007              STR      r0,[sp,#0x1c]
                  |L2.136|
;;;114      }
;;;115    
;;;116      /* Working pointer for state buffer is updated */
;;;117      py = pState;
000088  980a              LDR      r0,[sp,#0x28]
;;;118    
;;;119      /* blockSize samples are read from the state buffer */
;;;120      arm_circularRead_q15(py, delaySize, &readIndex, 1,
00008a  e9cd7501          STRD     r7,r5,[sp,#4]
00008e  2101              MOVS     r1,#1
000090  9700              STR      r7,[sp,#0]
000092  e9cd1503          STRD     r1,r5,[sp,#0xc]
000096  460b              MOV      r3,r1
000098  aa07              ADD      r2,sp,#0x1c
00009a  9909              LDR      r1,[sp,#0x24]
00009c  f7fffffe          BL       arm_circularRead_q15
;;;121                           pb, pb, blockSize, 1, blockSize);
;;;122    
;;;123      /* Working pointer for the scratch buffer of state values */
;;;124      px = pb;
0000a0  463a              MOV      r2,r7
;;;125    
;;;126      /* Working pointer for scratch buffer of output values */
;;;127      pScratchOut = pScr2;
0000a2  4621              MOV      r1,r4
;;;128    
;;;129      /* Loop over the blockSize. Unroll by a factor of 4.    
;;;130       * Compute 4 multiplications at a time. */
;;;131      blkCnt = blockSize >> 2;
0000a4  08a8              LSRS     r0,r5,#2
0000a6  900c              STR      r0,[sp,#0x30]
;;;132    
;;;133      while(blkCnt > 0u)
0000a8  e016              B        |L2.216|
                  |L2.170|
;;;134      {
;;;135        /* Perform multiplication and store in the scratch buffer */
;;;136        *pScratchOut++ = ((q31_t) * px++ * coeff);
0000aa  f9b23000          LDRSH    r3,[r2,#0]
0000ae  fb03f309          MUL      r3,r3,r9
0000b2  600b              STR      r3,[r1,#0]
;;;137        *pScratchOut++ = ((q31_t) * px++ * coeff);
0000b4  f9b23002          LDRSH    r3,[r2,#2]
0000b8  fb03f309          MUL      r3,r3,r9
0000bc  604b              STR      r3,[r1,#4]
;;;138        *pScratchOut++ = ((q31_t) * px++ * coeff);
0000be  f9b23004          LDRSH    r3,[r2,#4]
0000c2  fb03f309          MUL      r3,r3,r9
0000c6  608b              STR      r3,[r1,#8]
;;;139        *pScratchOut++ = ((q31_t) * px++ * coeff);
0000c8  f9b23006          LDRSH    r3,[r2,#6]
0000cc  3208              ADDS     r2,r2,#8
0000ce  fb03f309          MUL      r3,r3,r9
0000d2  60cb              STR      r3,[r1,#0xc]
0000d4  3110              ADDS     r1,r1,#0x10
;;;140    
;;;141        /* Decrement the loop counter */
;;;142        blkCnt--;
0000d6  1e40              SUBS     r0,r0,#1
                  |L2.216|
0000d8  2800              CMP      r0,#0                 ;133
0000da  d1e6              BNE      |L2.170|
;;;143      }
;;;144    
;;;145      /* If the blockSize is not a multiple of 4,    
;;;146       * compute the remaining samples */
;;;147      blkCnt = blockSize % 0x4u;
0000dc  f0050003          AND      r0,r5,#3
0000e0  900b              STR      r0,[sp,#0x2c]
;;;148    
;;;149      while(blkCnt > 0u)
0000e2  e005              B        |L2.240|
                  |L2.228|
;;;150      {
;;;151        /* Perform multiplication and store in the scratch buffer */
;;;152        *pScratchOut++ = ((q31_t) * px++ * coeff);
0000e4  f9323b02          LDRSH    r3,[r2],#2
0000e8  fb03f309          MUL      r3,r3,r9
0000ec  c108              STM      r1!,{r3}
;;;153    
;;;154        /* Decrement the loop counter */
;;;155        blkCnt--;
0000ee  1e40              SUBS     r0,r0,#1
                  |L2.240|
0000f0  2800              CMP      r0,#0                 ;149
0000f2  d1f7              BNE      |L2.228|
;;;156      }
;;;157    
;;;158      /* Load the coefficient value and    
;;;159       * increment the coefficient buffer for the next set of state values */
;;;160      coeff = *pCoeffs++;
0000f4  f93b9b02          LDRSH    r9,[r11],#2
;;;161    
;;;162      /* Read Index, from where the state buffer should be read, is calculated. */
;;;163      readIndex = (S->stateIndex - blockSize) - *pTapDelay++;
0000f8  ce01              LDM      r6!,{r0}
0000fa  f8ba1002          LDRH     r1,[r10,#2]
0000fe  1b49              SUBS     r1,r1,r5
000100  1a08              SUBS     r0,r1,r0
000102  9007              STR      r0,[sp,#0x1c]
;;;164    
;;;165      /* Wraparound of readIndex */
;;;166      if(readIndex < 0)
000104  2800              CMP      r0,#0
000106  da02              BGE      |L2.270|
;;;167      {
;;;168        readIndex += (int32_t) delaySize;
000108  9909              LDR      r1,[sp,#0x24]
00010a  4408              ADD      r0,r0,r1
00010c  9007              STR      r0,[sp,#0x1c]
                  |L2.270|
;;;169      }
;;;170    
;;;171      /* Loop over the number of taps. */
;;;172      tapCnt = (uint32_t) numTaps - 2u;
00010e  9808              LDR      r0,[sp,#0x20]
000110  1e80              SUBS     r0,r0,#2
000112  9006              STR      r0,[sp,#0x18]
;;;173    
;;;174      while(tapCnt > 0u)
000114  e04c              B        |L2.432|
                  |L2.278|
;;;175      {
;;;176        /* Working pointer for state buffer is updated */
;;;177        py = pState;
000116  980a              LDR      r0,[sp,#0x28]
;;;178    
;;;179        /* blockSize samples are read from the state buffer */
;;;180        arm_circularRead_q15(py, delaySize, &readIndex, 1,
000118  e9cd7501          STRD     r7,r5,[sp,#4]
00011c  2101              MOVS     r1,#1
00011e  9700              STR      r7,[sp,#0]
000120  e9cd1503          STRD     r1,r5,[sp,#0xc]
000124  460b              MOV      r3,r1
000126  aa07              ADD      r2,sp,#0x1c
000128  9909              LDR      r1,[sp,#0x24]
00012a  f7fffffe          BL       arm_circularRead_q15
;;;181                             pb, pb, blockSize, 1, blockSize);
;;;182    
;;;183        /* Working pointer for the scratch buffer of state values */
;;;184        px = pb;
00012e  463a              MOV      r2,r7
;;;185    
;;;186        /* Working pointer for scratch buffer of output values */
;;;187        pScratchOut = pScr2;
000130  4620              MOV      r0,r4
;;;188    
;;;189        /* Loop over the blockSize. Unroll by a factor of 4.    
;;;190         * Compute 4 MACS at a time. */
;;;191        blkCnt = blockSize >> 2;
000132  990c              LDR      r1,[sp,#0x30]
;;;192    
;;;193        while(blkCnt > 0u)
000134  e01e              B        |L2.372|
                  |L2.310|
;;;194        {
;;;195          /* Perform Multiply-Accumulate */
;;;196          *pScratchOut++ += (q31_t) * px++ * coeff;
000136  f9b23000          LDRSH    r3,[r2,#0]
00013a  f8d0c000          LDR      r12,[r0,#0]
00013e  fb03c309          MLA      r3,r3,r9,r12
000142  6003              STR      r3,[r0,#0]
;;;197          *pScratchOut++ += (q31_t) * px++ * coeff;
000144  f9b23002          LDRSH    r3,[r2,#2]
000148  f8d0c004          LDR      r12,[r0,#4]
00014c  fb03c309          MLA      r3,r3,r9,r12
000150  6043              STR      r3,[r0,#4]
;;;198          *pScratchOut++ += (q31_t) * px++ * coeff;
000152  f9b23004          LDRSH    r3,[r2,#4]
000156  f8d0c008          LDR      r12,[r0,#8]
00015a  fb03c309          MLA      r3,r3,r9,r12
00015e  6083              STR      r3,[r0,#8]
;;;199          *pScratchOut++ += (q31_t) * px++ * coeff;
000160  f9b23006          LDRSH    r3,[r2,#6]
000164  f8d0c00c          LDR      r12,[r0,#0xc]
000168  3208              ADDS     r2,r2,#8
00016a  fb03c309          MLA      r3,r3,r9,r12
00016e  60c3              STR      r3,[r0,#0xc]
000170  3010              ADDS     r0,r0,#0x10
;;;200    
;;;201          /* Decrement the loop counter */
;;;202          blkCnt--;
000172  1e49              SUBS     r1,r1,#1
                  |L2.372|
000174  2900              CMP      r1,#0                 ;193
000176  d1de              BNE      |L2.310|
;;;203        }
;;;204    
;;;205        /* If the blockSize is not a multiple of 4,    
;;;206         * compute the remaining samples */
;;;207        blkCnt = blockSize % 0x4u;
000178  990b              LDR      r1,[sp,#0x2c]
;;;208    
;;;209        while(blkCnt > 0u)
00017a  e007              B        |L2.396|
                  |L2.380|
;;;210        {
;;;211          /* Perform Multiply-Accumulate */
;;;212          *pScratchOut++ += (q31_t) * px++ * coeff;
00017c  f9323b02          LDRSH    r3,[r2],#2
000180  f8d0c000          LDR      r12,[r0,#0]
000184  fb03c309          MLA      r3,r3,r9,r12
000188  c008              STM      r0!,{r3}
;;;213    
;;;214          /* Decrement the loop counter */
;;;215          blkCnt--;
00018a  1e49              SUBS     r1,r1,#1
                  |L2.396|
00018c  2900              CMP      r1,#0                 ;209
00018e  d1f5              BNE      |L2.380|
;;;216        }
;;;217    
;;;218        /* Load the coefficient value and    
;;;219         * increment the coefficient buffer for the next set of state values */
;;;220        coeff = *pCoeffs++;
000190  f93b9b02          LDRSH    r9,[r11],#2
;;;221    
;;;222        /* Read Index, from where the state buffer should be read, is calculated. */
;;;223        readIndex = (S->stateIndex - blockSize) - *pTapDelay++;
000194  ce01              LDM      r6!,{r0}
000196  f8ba1002          LDRH     r1,[r10,#2]
00019a  1b49              SUBS     r1,r1,r5
00019c  1a08              SUBS     r0,r1,r0
00019e  9007              STR      r0,[sp,#0x1c]
;;;224    
;;;225        /* Wraparound of readIndex */
;;;226        if(readIndex < 0)
0001a0  2800              CMP      r0,#0
0001a2  da02              BGE      |L2.426|
;;;227        {
;;;228          readIndex += (int32_t) delaySize;
0001a4  9909              LDR      r1,[sp,#0x24]
0001a6  4408              ADD      r0,r0,r1
0001a8  9007              STR      r0,[sp,#0x1c]
                  |L2.426|
;;;229        }
;;;230    
;;;231        /* Decrement the tap loop counter */
;;;232        tapCnt--;
0001aa  9806              LDR      r0,[sp,#0x18]
0001ac  1e40              SUBS     r0,r0,#1
0001ae  9006              STR      r0,[sp,#0x18]
                  |L2.432|
0001b0  9806              LDR      r0,[sp,#0x18]         ;174
0001b2  2800              CMP      r0,#0                 ;174
0001b4  d1af              BNE      |L2.278|
;;;233      }
;;;234    	
;;;235    	/* Compute last tap without the final read of pTapDelay */		
;;;236    
;;;237    	/* Working pointer for state buffer is updated */
;;;238    	py = pState;
0001b6  980a              LDR      r0,[sp,#0x28]
;;;239    
;;;240    	/* blockSize samples are read from the state buffer */
;;;241    	arm_circularRead_q15(py, delaySize, &readIndex, 1,
0001b8  e9cd7501          STRD     r7,r5,[sp,#4]
0001bc  2101              MOVS     r1,#1
0001be  9700              STR      r7,[sp,#0]
0001c0  e9cd1503          STRD     r1,r5,[sp,#0xc]
0001c4  460b              MOV      r3,r1
0001c6  aa07              ADD      r2,sp,#0x1c
0001c8  9909              LDR      r1,[sp,#0x24]
0001ca  f7fffffe          BL       arm_circularRead_q15
;;;242    											 pb, pb, blockSize, 1, blockSize);
;;;243    
;;;244    	/* Working pointer for the scratch buffer of state values */
;;;245    	px = pb;
;;;246    
;;;247    	/* Working pointer for scratch buffer of output values */
;;;248    	pScratchOut = pScr2;
0001ce  4620              MOV      r0,r4
;;;249    
;;;250    	/* Loop over the blockSize. Unroll by a factor of 4.    
;;;251    	 * Compute 4 MACS at a time. */
;;;252    	blkCnt = blockSize >> 2;
0001d0  990c              LDR      r1,[sp,#0x30]
;;;253    
;;;254    	while(blkCnt > 0u)
0001d2  e01a              B        |L2.522|
                  |L2.468|
;;;255    	{
;;;256    		/* Perform Multiply-Accumulate */
;;;257    		*pScratchOut++ += (q31_t) * px++ * coeff;
0001d4  f9b72000          LDRSH    r2,[r7,#0]
0001d8  6803              LDR      r3,[r0,#0]
0001da  fb023209          MLA      r2,r2,r9,r3
0001de  6002              STR      r2,[r0,#0]
;;;258    		*pScratchOut++ += (q31_t) * px++ * coeff;
0001e0  f9b72002          LDRSH    r2,[r7,#2]
0001e4  6843              LDR      r3,[r0,#4]
0001e6  fb023209          MLA      r2,r2,r9,r3
0001ea  6042              STR      r2,[r0,#4]
;;;259    		*pScratchOut++ += (q31_t) * px++ * coeff;
0001ec  f9b72004          LDRSH    r2,[r7,#4]
0001f0  6883              LDR      r3,[r0,#8]
0001f2  fb023209          MLA      r2,r2,r9,r3
0001f6  6082              STR      r2,[r0,#8]
;;;260    		*pScratchOut++ += (q31_t) * px++ * coeff;
0001f8  f9b72006          LDRSH    r2,[r7,#6]
0001fc  68c3              LDR      r3,[r0,#0xc]
0001fe  3708              ADDS     r7,r7,#8
000200  fb023209          MLA      r2,r2,r9,r3
000204  60c2              STR      r2,[r0,#0xc]
000206  3010              ADDS     r0,r0,#0x10
;;;261    
;;;262    		/* Decrement the loop counter */
;;;263    		blkCnt--;
000208  1e49              SUBS     r1,r1,#1
                  |L2.522|
00020a  2900              CMP      r1,#0                 ;254
00020c  d1e2              BNE      |L2.468|
;;;264    	}
;;;265    
;;;266    	/* If the blockSize is not a multiple of 4,    
;;;267    	 * compute the remaining samples */
;;;268    	blkCnt = blockSize % 0x4u;
00020e  990b              LDR      r1,[sp,#0x2c]
;;;269    
;;;270    	while(blkCnt > 0u)
000210  e006              B        |L2.544|
                  |L2.530|
;;;271    	{
;;;272    		/* Perform Multiply-Accumulate */
;;;273    		*pScratchOut++ += (q31_t) * px++ * coeff;
000212  f9372b02          LDRSH    r2,[r7],#2
000216  6803              LDR      r3,[r0,#0]
000218  fb023209          MLA      r2,r2,r9,r3
00021c  c004              STM      r0!,{r2}
;;;274    
;;;275    		/* Decrement the loop counter */
;;;276    		blkCnt--;
00021e  1e49              SUBS     r1,r1,#1
                  |L2.544|
000220  2900              CMP      r1,#0                 ;270
000222  d1f6              BNE      |L2.530|
;;;277    	}
;;;278    
;;;279      /* All the output values are in pScratchOut buffer.    
;;;280         Convert them into 1.15 format, saturate and store in the destination buffer. */
;;;281      /* Loop over the blockSize. */
;;;282      blkCnt = blockSize >> 2;
000224  980c              LDR      r0,[sp,#0x30]
;;;283    
;;;284      while(blkCnt > 0u)
000226  e015              B        |L2.596|
                  |L2.552|
;;;285      {
;;;286        in1 = *pScr2++;
000228  6821              LDR      r1,[r4,#0]
;;;287        in2 = *pScr2++;
00022a  6862              LDR      r2,[r4,#4]
;;;288    
;;;289    #ifndef  ARM_MATH_BIG_ENDIAN
;;;290    
;;;291        *__SIMD32(pOut)++ =
00022c  f32131cf          SSAT     r1,#16,r1,ASR #15
000230  f32232cf          SSAT     r2,#16,r2,ASR #15
000234  eac14102          PKHBT    r1,r1,r2,LSL #16
000238  f8481b04          STR      r1,[r8],#4
;;;292          __PKHBT((q15_t) __SSAT(in1 >> 15, 16), (q15_t) __SSAT(in2 >> 15, 16),
;;;293                  16);
;;;294    
;;;295    #else
;;;296        *__SIMD32(pOut)++ =
;;;297          __PKHBT((q15_t) __SSAT(in2 >> 15, 16), (q15_t) __SSAT(in1 >> 15, 16),
;;;298                  16);
;;;299    
;;;300    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;301    
;;;302        in1 = *pScr2++;
00023c  68a1              LDR      r1,[r4,#8]
;;;303    
;;;304        in2 = *pScr2++;
00023e  68e2              LDR      r2,[r4,#0xc]
000240  3410              ADDS     r4,r4,#0x10
;;;305    
;;;306    #ifndef  ARM_MATH_BIG_ENDIAN
;;;307    
;;;308        *__SIMD32(pOut)++ =
000242  f32131cf          SSAT     r1,#16,r1,ASR #15
000246  f32232cf          SSAT     r2,#16,r2,ASR #15
00024a  eac14102          PKHBT    r1,r1,r2,LSL #16
00024e  f8481b04          STR      r1,[r8],#4
;;;309          __PKHBT((q15_t) __SSAT(in1 >> 15, 16), (q15_t) __SSAT(in2 >> 15, 16),
;;;310                  16);
;;;311    
;;;312    #else
;;;313    
;;;314        *__SIMD32(pOut)++ =
;;;315          __PKHBT((q15_t) __SSAT(in2 >> 15, 16), (q15_t) __SSAT(in1 >> 15, 16),
;;;316                  16);
;;;317    
;;;318    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;319    
;;;320    
;;;321        blkCnt--;
000252  1e40              SUBS     r0,r0,#1
                  |L2.596|
000254  2800              CMP      r0,#0                 ;284
000256  d1e7              BNE      |L2.552|
;;;322    
;;;323      }
;;;324    
;;;325      /* If the blockSize is not a multiple of 4,    
;;;326         remaining samples are processed in the below loop */
;;;327      blkCnt = blockSize % 0x4u;
000258  980b              LDR      r0,[sp,#0x2c]
;;;328    
;;;329      while(blkCnt > 0u)
00025a  e005              B        |L2.616|
                  |L2.604|
;;;330      {
;;;331        *pOut++ = (q15_t) __SSAT(*pScr2++ >> 15, 16);
00025c  cc02              LDM      r4!,{r1}
00025e  f32131cf          SSAT     r1,#16,r1,ASR #15
000262  f8281b02          STRH     r1,[r8],#2
;;;332        blkCnt--;
000266  1e40              SUBS     r0,r0,#1
                  |L2.616|
000268  2800              CMP      r0,#0                 ;329
00026a  d1f7              BNE      |L2.604|
;;;333      }
;;;334    
;;;335    #else
;;;336    
;;;337      /* Run the below code for Cortex-M0 */
;;;338    
;;;339      /* BlockSize of Input samples are copied into the state buffer */
;;;340      /* StateIndex points to the starting position to write in the state buffer */
;;;341      arm_circularWrite_q15(py, delaySize, &S->stateIndex, 1, pIn, 1, blockSize);
;;;342    
;;;343      /* Loop over the number of taps. */
;;;344      tapCnt = numTaps;
;;;345    
;;;346      /* Read Index, from where the state buffer should be read, is calculated. */
;;;347      readIndex = (S->stateIndex - blockSize) - *pTapDelay++;
;;;348    
;;;349      /* Wraparound of readIndex */
;;;350      if(readIndex < 0)
;;;351      {
;;;352        readIndex += (int32_t) delaySize;
;;;353      }
;;;354    
;;;355      /* Working pointer for state buffer is updated */
;;;356      py = pState;
;;;357    
;;;358      /* blockSize samples are read from the state buffer */
;;;359      arm_circularRead_q15(py, delaySize, &readIndex, 1,
;;;360                           pb, pb, blockSize, 1, blockSize);
;;;361    
;;;362      /* Working pointer for the scratch buffer of state values */
;;;363      px = pb;
;;;364    
;;;365      /* Working pointer for scratch buffer of output values */
;;;366      pScratchOut = pScr2;
;;;367    
;;;368      blkCnt = blockSize;
;;;369    
;;;370      while(blkCnt > 0u)
;;;371      {
;;;372        /* Perform multiplication and store in the scratch buffer */
;;;373        *pScratchOut++ = ((q31_t) * px++ * coeff);
;;;374    
;;;375        /* Decrement the loop counter */
;;;376        blkCnt--;
;;;377      }
;;;378    
;;;379      /* Load the coefficient value and           
;;;380       * increment the coefficient buffer for the next set of state values */
;;;381      coeff = *pCoeffs++;
;;;382    
;;;383      /* Read Index, from where the state buffer should be read, is calculated. */
;;;384      readIndex = (S->stateIndex - blockSize) - *pTapDelay++;
;;;385    
;;;386      /* Wraparound of readIndex */
;;;387      if(readIndex < 0)
;;;388      {
;;;389        readIndex += (int32_t) delaySize;
;;;390      }
;;;391    
;;;392      /* Loop over the number of taps. */
;;;393      tapCnt = (uint32_t) numTaps - 2u;
;;;394    
;;;395      while(tapCnt > 0u)
;;;396      {
;;;397        /* Working pointer for state buffer is updated */
;;;398        py = pState;
;;;399    
;;;400        /* blockSize samples are read from the state buffer */
;;;401        arm_circularRead_q15(py, delaySize, &readIndex, 1,
;;;402                             pb, pb, blockSize, 1, blockSize);
;;;403    
;;;404        /* Working pointer for the scratch buffer of state values */
;;;405        px = pb;
;;;406    
;;;407        /* Working pointer for scratch buffer of output values */
;;;408        pScratchOut = pScr2;
;;;409    
;;;410        blkCnt = blockSize;
;;;411    
;;;412        while(blkCnt > 0u)
;;;413        {
;;;414          /* Perform Multiply-Accumulate */
;;;415          *pScratchOut++ += (q31_t) * px++ * coeff;
;;;416    
;;;417          /* Decrement the loop counter */
;;;418          blkCnt--;
;;;419        }
;;;420    
;;;421        /* Load the coefficient value and           
;;;422         * increment the coefficient buffer for the next set of state values */
;;;423        coeff = *pCoeffs++;
;;;424    
;;;425        /* Read Index, from where the state buffer should be read, is calculated. */
;;;426        readIndex = (S->stateIndex - blockSize) - *pTapDelay++;
;;;427    
;;;428        /* Wraparound of readIndex */
;;;429        if(readIndex < 0)
;;;430        {
;;;431          readIndex += (int32_t) delaySize;
;;;432        }
;;;433    
;;;434        /* Decrement the tap loop counter */
;;;435        tapCnt--;
;;;436      }
;;;437    	
;;;438    	/* Compute last tap without the final read of pTapDelay */	
;;;439    	
;;;440    	/* Working pointer for state buffer is updated */
;;;441    	py = pState;
;;;442    
;;;443    	/* blockSize samples are read from the state buffer */
;;;444    	arm_circularRead_q15(py, delaySize, &readIndex, 1,
;;;445    											 pb, pb, blockSize, 1, blockSize);
;;;446    
;;;447    	/* Working pointer for the scratch buffer of state values */
;;;448    	px = pb;
;;;449    
;;;450    	/* Working pointer for scratch buffer of output values */
;;;451    	pScratchOut = pScr2;
;;;452    
;;;453    	blkCnt = blockSize;
;;;454    
;;;455    	while(blkCnt > 0u)
;;;456    	{
;;;457    		/* Perform Multiply-Accumulate */
;;;458    		*pScratchOut++ += (q31_t) * px++ * coeff;
;;;459    
;;;460    		/* Decrement the loop counter */
;;;461    		blkCnt--;
;;;462    	}
;;;463    
;;;464      /* All the output values are in pScratchOut buffer.       
;;;465         Convert them into 1.15 format, saturate and store in the destination buffer. */
;;;466      /* Loop over the blockSize. */
;;;467      blkCnt = blockSize;
;;;468    
;;;469      while(blkCnt > 0u)
;;;470      {
;;;471        *pOut++ = (q15_t) __SSAT(*pScr2++ >> 15, 16);
;;;472        blkCnt--;
;;;473      }
;;;474    
;;;475    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;476    
;;;477    }
00026c  b00d              ADD      sp,sp,#0x34
00026e  e8bd8ff0          POP      {r4-r11,pc}
;;;478    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_fir_sparse_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_arm_fir_sparse_q15_c_ebe2e0a0____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___20_arm_fir_sparse_q15_c_ebe2e0a0____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_arm_fir_sparse_q15_c_ebe2e0a0____REVSH|
#line 144
|__asm___20_arm_fir_sparse_q15_c_ebe2e0a0____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_arm_fir_sparse_q15_c_ebe2e0a0____RRX|
#line 300
|__asm___20_arm_fir_sparse_q15_c_ebe2e0a0____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
