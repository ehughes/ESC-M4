; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_sparse_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_sparse_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE\_CMSIS_DSP_4_5_O3 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_fir_sparse_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_fir_sparse_q15.c]
                          THUMB

                          AREA ||i.arm_circularRead_q15||, CODE, READONLY, ALIGN=2

                  arm_circularRead_q15 PROC
;;;6293      */
;;;6294     static __INLINE void arm_circularRead_q15(
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;6295     q15_t * circBuffer,
;;;6296     int32_t L,
;;;6297     int32_t * readOffset,
;;;6298     int32_t bufferInc,
;;;6299     q15_t * dst,
;;;6300     q15_t * dst_base,
;;;6301     int32_t dst_length,
;;;6302     int32_t dstInc,
;;;6303     uint32_t blockSize)
;;;6304     {
000004  ac07              ADD      r4,sp,#0x1c
000006  e9dd960a          LDRD     r9,r6,[sp,#0x28]
00000a  e89410a0          LDM      r4,{r5,r7,r12}
00000e  6814              LDR      r4,[r2,#0]
;;;6305       uint32_t i = 0;
;;;6306       int32_t rOffset, dst_end;
;;;6307   
;;;6308       /* Copy the value of Index pointer that points
;;;6309        * to the current location from where the input samples to be read */
;;;6310       rOffset = *readOffset;
;;;6311   
;;;6312       dst_end = (int32_t) (dst_base + dst_length);
000010  eb070c4c          ADD      r12,r7,r12,LSL #1
000014  e00e              B        |L1.52|
;;;6313   
;;;6314       /* Loop over the blockSize */
;;;6315       i = blockSize;
;;;6316   
;;;6317       while(i > 0u)
;;;6318       {
;;;6319         /* copy the sample from the circular buffer to the destination buffer */
;;;6320         *dst = circBuffer[rOffset];
000016  bf00              NOP      
                  |L1.24|
000018  f8308014          LDRH     r8,[r0,r4,LSL #1]
00001c  f8a58000          STRH     r8,[r5,#0]
;;;6321   
;;;6322         /* Update the input pointer */
;;;6323         dst += dstInc;
000020  eb050549          ADD      r5,r5,r9,LSL #1
;;;6324   
;;;6325         if(dst == (q15_t *) dst_end)
000024  4565              CMP      r5,r12
000026  d100              BNE      |L1.42|
;;;6326         {
;;;6327           dst = dst_base;
000028  463d              MOV      r5,r7
                  |L1.42|
;;;6328         }
;;;6329   
;;;6330         /* Circularly update wOffset.  Watch out for positive and negative value */
;;;6331         rOffset += bufferInc;
00002a  441c              ADD      r4,r4,r3
;;;6332   
;;;6333         if(rOffset >= L)
00002c  428c              CMP      r4,r1
00002e  db00              BLT      |L1.50|
;;;6334         {
;;;6335           rOffset -= L;
000030  1a64              SUBS     r4,r4,r1
                  |L1.50|
000032  1e76              SUBS     r6,r6,#1
                  |L1.52|
000034  2e00              CMP      r6,#0                 ;6317
000036  d1ef              BNE      |L1.24|
;;;6336         }
;;;6337   
;;;6338         /* Decrement the loop counter */
;;;6339         i--;
;;;6340       }
;;;6341   
;;;6342       /* Update the index pointer */
;;;6343       *readOffset = rOffset;
000038  6014              STR      r4,[r2,#0]
;;;6344     }
00003a  e8bd83f0          POP      {r4-r9,pc}
;;;6345   
                          ENDP


                          AREA ||i.arm_fir_sparse_q15||, CODE, READONLY, ALIGN=2

                  arm_fir_sparse_q15 PROC
;;;67     
;;;68     void arm_fir_sparse_q15(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;69       arm_fir_sparse_instance_q15 * S,
;;;70       q15_t * pSrc,
;;;71       q15_t * pDst,
;;;72       q15_t * pScratchIn,
;;;73       q31_t * pScratchOut,
;;;74       uint32_t blockSize)
;;;75     {
000004  b08b              SUB      sp,sp,#0x2c
000006  4680              MOV      r8,r0
000008  e9dd4614          LDRD     r4,r6,[sp,#0x50]
;;;76     
;;;77       q15_t *pState = S->pState;                     /* State pointer */
;;;78       q15_t *pIn = pSrc;                             /* Working pointer for input */
;;;79       q15_t *pOut = pDst;                            /* Working pointer for output */
00000c  4691              MOV      r9,r2
;;;80       q15_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
;;;81       q15_t *px;                                     /* Temporary pointers for scratch buffer */
;;;82       q15_t *pb = pScratchIn;                        /* Temporary pointers for scratch buffer */
00000e  461d              MOV      r5,r3
;;;83       q15_t *py = pState;                            /* Temporary pointers for state buffer */
000010  e9d0a201          LDRD     r10,r2,[r0,#4]
;;;84       int32_t *pTapDelay = S->pTapDelay;             /* Pointer to the array containing offset of the non-zero tap values. */
;;;85       uint32_t delaySize = S->maxDelay + blockSize;  /* state length */
000014  f8b8300c          LDRH     r3,[r8,#0xc]
;;;86       uint16_t numTaps = S->numTaps;                 /* Filter order */
000018  f8d8e010          LDR      lr,[r8,#0x10]
00001c  eb030b06          ADD      r11,r3,r6             ;85
000020  f8b83000          LDRH     r3,[r8,#0]
;;;87       int32_t readIndex;                             /* Read index of the state buffer */
;;;88       uint32_t tapCnt, blkCnt;                       /* loop counters */
;;;89       q15_t coeff = *pCoeffs++;                      /* Read the first coefficient value */
000024  9309              STR      r3,[sp,#0x24]
000026  f9327b02          LDRSH    r7,[r2],#2
;;;90       q31_t *pScr2 = pScratchOut;                    /* Working pointer for pScratchOut */
;;;91     
;;;92     
;;;93     #ifndef ARM_MATH_CM0_FAMILY
;;;94     
;;;95       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;96     
;;;97       q31_t in1, in2;                                /* Temporary variables */
;;;98     
;;;99     
;;;100      /* BlockSize of Input samples are copied into the state buffer */
;;;101      /* StateIndex points to the starting position to write in the state buffer */
;;;102      arm_circularWrite_q15(py, delaySize, &S->stateIndex, 1, pIn, 1, blockSize);
00002a  9208              STR      r2,[sp,#0x20]
00002c  2201              MOVS     r2,#1
00002e  f1080302          ADD      r3,r8,#2
000032  e9cd3200          STRD     r3,r2,[sp,#0]
000036  9202              STR      r2,[sp,#8]
000038  4650              MOV      r0,r10                ;83
00003a  4632              MOV      r2,r6
00003c  f8b83002          LDRH     r3,[r8,#2]
000040  e010              B        |L2.100|
000042  bf00              NOP                            ;75
                  |L2.68|
000044  f8b1c000          LDRH     r12,[r1,#0]           ;75
000048  f820c013          STRH     r12,[r0,r3,LSL #1]    ;75
00004c  f8ddc004          LDR      r12,[sp,#4]           ;75
000050  eb01014c          ADD      r1,r1,r12,LSL #1      ;75
000054  f8ddc008          LDR      r12,[sp,#8]           ;75
000058  4463              ADD      r3,r3,r12             ;75
00005a  455b              CMP      r3,r11                ;75
00005c  db01              BLT      |L2.98|
00005e  eba3030b          SUB      r3,r3,r11             ;75
                  |L2.98|
000062  1e52              SUBS     r2,r2,#1              ;75
                  |L2.100|
000064  2a00              CMP      r2,#0                 ;75
000066  d1ed              BNE      |L2.68|
000068  9800              LDR      r0,[sp,#0]            ;75
00006a  8003              STRH     r3,[r0,#0]            ;75
;;;103    
;;;104      /* Loop over the number of taps. */
;;;105      tapCnt = numTaps;
;;;106    
;;;107      /* Read Index, from where the state buffer should be read, is calculated. */
;;;108      readIndex = (S->stateIndex - blockSize) - *pTapDelay++;
00006c  f8b80002          LDRH     r0,[r8,#2]
000070  1b81              SUBS     r1,r0,r6
000072  f8de0000          LDR      r0,[lr,#0]
000076  1a08              SUBS     r0,r1,r0
000078  f10e0104          ADD      r1,lr,#4
;;;109    
;;;110      /* Wraparound of readIndex */
;;;111      if(readIndex < 0)
00007c  910a              STR      r1,[sp,#0x28]
00007e  9005              STR      r0,[sp,#0x14]
000080  d501              BPL      |L2.134|
;;;112      {
;;;113        readIndex += (int32_t) delaySize;
000082  4458              ADD      r0,r0,r11
000084  9005              STR      r0,[sp,#0x14]
                  |L2.134|
;;;114      }
;;;115    
;;;116      /* Working pointer for state buffer is updated */
;;;117      py = pState;
;;;118    
;;;119      /* blockSize samples are read from the state buffer */
;;;120      arm_circularRead_q15(py, delaySize, &readIndex, 1,
000086  2101              MOVS     r1,#1
000088  e9cd6102          STRD     r6,r1,[sp,#8]
00008c  460b              MOV      r3,r1
00008e  4650              MOV      r0,r10                ;117
000090  9501              STR      r5,[sp,#4]
000092  aa05              ADD      r2,sp,#0x14
000094  4659              MOV      r1,r11
000096  9604              STR      r6,[sp,#0x10]
000098  9500              STR      r5,[sp,#0]
00009a  f7fffffe          BL       arm_circularRead_q15
;;;121                           pb, pb, blockSize, 1, blockSize);
;;;122    
;;;123      /* Working pointer for the scratch buffer of state values */
;;;124      px = pb;
;;;125    
;;;126      /* Working pointer for scratch buffer of output values */
;;;127      pScratchOut = pScr2;
;;;128    
;;;129      /* Loop over the blockSize. Unroll by a factor of 4.    
;;;130       * Compute 4 multiplications at a time. */
;;;131      blkCnt = blockSize >> 2;
00009e  08b2              LSRS     r2,r6,#2
0000a0  4629              MOV      r1,r5                 ;124
0000a2  4620              MOV      r0,r4                 ;127
;;;132    
;;;133      while(blkCnt > 0u)
0000a4  9207              STR      r2,[sp,#0x1c]
0000a6  e016              B        |L2.214|
                  |L2.168|
;;;134      {
;;;135        /* Perform multiplication and store in the scratch buffer */
;;;136        *pScratchOut++ = ((q31_t) * px++ * coeff);
0000a8  f8313b02          LDRH     r3,[r1],#2
0000ac  fb13f307          SMULBB   r3,r3,r7
0000b0  c008              STM      r0!,{r3}
;;;137        *pScratchOut++ = ((q31_t) * px++ * coeff);
0000b2  f8313b02          LDRH     r3,[r1],#2
0000b6  fb13f307          SMULBB   r3,r3,r7
0000ba  c008              STM      r0!,{r3}
;;;138        *pScratchOut++ = ((q31_t) * px++ * coeff);
0000bc  f8313b04          LDRH     r3,[r1],#4
0000c0  fb13f307          SMULBB   r3,r3,r7
0000c4  f8403b08          STR      r3,[r0],#8
;;;139        *pScratchOut++ = ((q31_t) * px++ * coeff);
0000c8  f8313c02          LDRH     r3,[r1,#-2]
0000cc  fb13f307          SMULBB   r3,r3,r7
0000d0  f8403c04          STR      r3,[r0,#-4]
0000d4  1e52              SUBS     r2,r2,#1
                  |L2.214|
0000d6  2a00              CMP      r2,#0                 ;133
0000d8  d1e6              BNE      |L2.168|
;;;140    
;;;141        /* Decrement the loop counter */
;;;142        blkCnt--;
;;;143      }
;;;144    
;;;145      /* If the blockSize is not a multiple of 4,    
;;;146       * compute the remaining samples */
;;;147      blkCnt = blockSize % 0x4u;
0000da  f0060203          AND      r2,r6,#3
;;;148    
;;;149      while(blkCnt > 0u)
0000de  9206              STR      r2,[sp,#0x18]
0000e0  e006              B        |L2.240|
;;;150      {
;;;151        /* Perform multiplication and store in the scratch buffer */
;;;152        *pScratchOut++ = ((q31_t) * px++ * coeff);
0000e2  bf00              NOP      
                  |L2.228|
0000e4  f8313b02          LDRH     r3,[r1],#2
0000e8  fb13f307          SMULBB   r3,r3,r7
0000ec  c008              STM      r0!,{r3}
0000ee  1e52              SUBS     r2,r2,#1
                  |L2.240|
0000f0  2a00              CMP      r2,#0                 ;149
0000f2  d1f7              BNE      |L2.228|
;;;153    
;;;154        /* Decrement the loop counter */
;;;155        blkCnt--;
;;;156      }
;;;157    
;;;158      /* Load the coefficient value and    
;;;159       * increment the coefficient buffer for the next set of state values */
;;;160      coeff = *pCoeffs++;
0000f4  9808              LDR      r0,[sp,#0x20]
0000f6  f9307b02          LDRSH    r7,[r0],#2
;;;161    
;;;162      /* Read Index, from where the state buffer should be read, is calculated. */
;;;163      readIndex = (S->stateIndex - blockSize) - *pTapDelay++;
0000fa  9008              STR      r0,[sp,#0x20]
0000fc  f8b80002          LDRH     r0,[r8,#2]
000100  1b81              SUBS     r1,r0,r6
000102  980a              LDR      r0,[sp,#0x28]
000104  6800              LDR      r0,[r0,#0]
000106  1a08              SUBS     r0,r1,r0
000108  9005              STR      r0,[sp,#0x14]
00010a  990a              LDR      r1,[sp,#0x28]
00010c  f1010104          ADD      r1,r1,#4
;;;164    
;;;165      /* Wraparound of readIndex */
;;;166      if(readIndex < 0)
000110  910a              STR      r1,[sp,#0x28]
000112  d501              BPL      |L2.280|
;;;167      {
;;;168        readIndex += (int32_t) delaySize;
000114  4458              ADD      r0,r0,r11
000116  9005              STR      r0,[sp,#0x14]
                  |L2.280|
;;;169      }
;;;170    
;;;171      /* Loop over the number of taps. */
;;;172      tapCnt = (uint32_t) numTaps - 2u;
000118  9809              LDR      r0,[sp,#0x24]
00011a  1e80              SUBS     r0,r0,#2
;;;173    
;;;174      while(tapCnt > 0u)
00011c  e045              B        |L2.426|
;;;175      {
;;;176        /* Working pointer for state buffer is updated */
;;;177        py = pState;
;;;178    
;;;179        /* blockSize samples are read from the state buffer */
;;;180        arm_circularRead_q15(py, delaySize, &readIndex, 1,
00011e  bf00              NOP      
                  |L2.288|
000120  f7fffffe          BL       arm_circularRead_q15
;;;181                             pb, pb, blockSize, 1, blockSize);
;;;182    
;;;183        /* Working pointer for the scratch buffer of state values */
;;;184        px = pb;
000124  4629              MOV      r1,r5
;;;185    
;;;186        /* Working pointer for scratch buffer of output values */
;;;187        pScratchOut = pScr2;
000126  4620              MOV      r0,r4
;;;188    
;;;189        /* Loop over the blockSize. Unroll by a factor of 4.    
;;;190         * Compute 4 MACS at a time. */
;;;191        blkCnt = blockSize >> 2;
;;;192    
;;;193        while(blkCnt > 0u)
000128  9a07              LDR      r2,[sp,#0x1c]
00012a  e01d              B        |L2.360|
                  |L2.300|
;;;194        {
;;;195          /* Perform Multiply-Accumulate */
;;;196          *pScratchOut++ += (q31_t) * px++ * coeff;
00012c  6803              LDR      r3,[r0,#0]
00012e  f831cb02          LDRH     r12,[r1],#2
000132  fb1c3307          SMLABB   r3,r12,r7,r3
000136  c008              STM      r0!,{r3}
;;;197          *pScratchOut++ += (q31_t) * px++ * coeff;
000138  f831cb02          LDRH     r12,[r1],#2
00013c  c808              LDM      r0!,{r3}
00013e  fb1c3307          SMLABB   r3,r12,r7,r3
000142  f8403c04          STR      r3,[r0,#-4]
;;;198          *pScratchOut++ += (q31_t) * px++ * coeff;
000146  f8503b08          LDR      r3,[r0],#8
00014a  f831cb02          LDRH     r12,[r1],#2
00014e  fb1c3307          SMLABB   r3,r12,r7,r3
000152  f8403c08          STR      r3,[r0,#-8]
;;;199          *pScratchOut++ += (q31_t) * px++ * coeff;
000156  f8503c04          LDR      r3,[r0,#-4]
00015a  f831cb02          LDRH     r12,[r1],#2
00015e  fb1c3307          SMLABB   r3,r12,r7,r3
000162  f8403c04          STR      r3,[r0,#-4]
000166  1e52              SUBS     r2,r2,#1
                  |L2.360|
000168  2a00              CMP      r2,#0                 ;193
00016a  d1df              BNE      |L2.300|
;;;200    
;;;201          /* Decrement the loop counter */
;;;202          blkCnt--;
;;;203        }
;;;204    
;;;205        /* If the blockSize is not a multiple of 4,    
;;;206         * compute the remaining samples */
;;;207        blkCnt = blockSize % 0x4u;
;;;208    
;;;209        while(blkCnt > 0u)
00016c  9a06              LDR      r2,[sp,#0x18]
00016e  e006              B        |L2.382|
                  |L2.368|
;;;210        {
;;;211          /* Perform Multiply-Accumulate */
;;;212          *pScratchOut++ += (q31_t) * px++ * coeff;
000170  6803              LDR      r3,[r0,#0]
000172  f831cb02          LDRH     r12,[r1],#2
000176  fb1c3307          SMLABB   r3,r12,r7,r3
00017a  c008              STM      r0!,{r3}
00017c  1e52              SUBS     r2,r2,#1
                  |L2.382|
00017e  2a00              CMP      r2,#0                 ;209
000180  d1f6              BNE      |L2.368|
;;;213    
;;;214          /* Decrement the loop counter */
;;;215          blkCnt--;
;;;216        }
;;;217    
;;;218        /* Load the coefficient value and    
;;;219         * increment the coefficient buffer for the next set of state values */
;;;220        coeff = *pCoeffs++;
000182  9808              LDR      r0,[sp,#0x20]
000184  f9307b02          LDRSH    r7,[r0],#2
;;;221    
;;;222        /* Read Index, from where the state buffer should be read, is calculated. */
;;;223        readIndex = (S->stateIndex - blockSize) - *pTapDelay++;
000188  9008              STR      r0,[sp,#0x20]
00018a  f8b80002          LDRH     r0,[r8,#2]
00018e  1b81              SUBS     r1,r0,r6
000190  980a              LDR      r0,[sp,#0x28]
000192  6800              LDR      r0,[r0,#0]
000194  1a08              SUBS     r0,r1,r0
000196  9005              STR      r0,[sp,#0x14]
000198  990a              LDR      r1,[sp,#0x28]
00019a  f1010104          ADD      r1,r1,#4
;;;224    
;;;225        /* Wraparound of readIndex */
;;;226        if(readIndex < 0)
00019e  910a              STR      r1,[sp,#0x28]
0001a0  d501              BPL      |L2.422|
;;;227        {
;;;228          readIndex += (int32_t) delaySize;
0001a2  4458              ADD      r0,r0,r11
0001a4  9005              STR      r0,[sp,#0x14]
                  |L2.422|
;;;229        }
;;;230    
;;;231        /* Decrement the tap loop counter */
;;;232        tapCnt--;
0001a6  9809              LDR      r0,[sp,#0x24]
0001a8  1e40              SUBS     r0,r0,#1
                  |L2.426|
;;;233      }
;;;234    	
;;;235    	/* Compute last tap without the final read of pTapDelay */		
;;;236    
;;;237    	/* Working pointer for state buffer is updated */
;;;238    	py = pState;
;;;239    
;;;240    	/* blockSize samples are read from the state buffer */
;;;241    	arm_circularRead_q15(py, delaySize, &readIndex, 1,
0001aa  f04f0101          MOV      r1,#1
0001ae  e9cd6102          STRD     r6,r1,[sp,#8]
0001b2  9009              STR      r0,[sp,#0x24]         ;174
0001b4  2800              CMP      r0,#0                 ;174
0001b6  460b              MOV      r3,r1
0001b8  4650              MOV      r0,r10                ;238
0001ba  9501              STR      r5,[sp,#4]
0001bc  aa05              ADD      r2,sp,#0x14
0001be  4659              MOV      r1,r11
0001c0  9604              STR      r6,[sp,#0x10]
0001c2  9500              STR      r5,[sp,#0]
0001c4  d1ac              BNE      |L2.288|
0001c6  f7fffffe          BL       arm_circularRead_q15
;;;242    											 pb, pb, blockSize, 1, blockSize);
;;;243    
;;;244    	/* Working pointer for the scratch buffer of state values */
;;;245    	px = pb;
;;;246    
;;;247    	/* Working pointer for scratch buffer of output values */
;;;248    	pScratchOut = pScr2;
0001ca  4620              MOV      r0,r4
;;;249    
;;;250    	/* Loop over the blockSize. Unroll by a factor of 4.    
;;;251    	 * Compute 4 MACS at a time. */
;;;252    	blkCnt = blockSize >> 2;
;;;253    
;;;254    	while(blkCnt > 0u)
0001cc  9907              LDR      r1,[sp,#0x1c]
0001ce  e01d              B        |L2.524|
                  |L2.464|
;;;255    	{
;;;256    		/* Perform Multiply-Accumulate */
;;;257    		*pScratchOut++ += (q31_t) * px++ * coeff;
0001d0  6802              LDR      r2,[r0,#0]
0001d2  f8353b02          LDRH     r3,[r5],#2
0001d6  fb132207          SMLABB   r2,r3,r7,r2
0001da  c004              STM      r0!,{r2}
;;;258    		*pScratchOut++ += (q31_t) * px++ * coeff;
0001dc  f8353b02          LDRH     r3,[r5],#2
0001e0  c804              LDM      r0!,{r2}
0001e2  fb132207          SMLABB   r2,r3,r7,r2
0001e6  f8402c04          STR      r2,[r0,#-4]
;;;259    		*pScratchOut++ += (q31_t) * px++ * coeff;
0001ea  f8502b08          LDR      r2,[r0],#8
0001ee  f8353b04          LDRH     r3,[r5],#4
0001f2  fb132207          SMLABB   r2,r3,r7,r2
0001f6  f8402c08          STR      r2,[r0,#-8]
;;;260    		*pScratchOut++ += (q31_t) * px++ * coeff;
0001fa  f8502c04          LDR      r2,[r0,#-4]
0001fe  f8353c02          LDRH     r3,[r5,#-2]
000202  fb132207          SMLABB   r2,r3,r7,r2
000206  f8402c04          STR      r2,[r0,#-4]
00020a  1e49              SUBS     r1,r1,#1
                  |L2.524|
00020c  2900              CMP      r1,#0                 ;254
00020e  d1df              BNE      |L2.464|
;;;261    
;;;262    		/* Decrement the loop counter */
;;;263    		blkCnt--;
;;;264    	}
;;;265    
;;;266    	/* If the blockSize is not a multiple of 4,    
;;;267    	 * compute the remaining samples */
;;;268    	blkCnt = blockSize % 0x4u;
;;;269    
;;;270    	while(blkCnt > 0u)
000210  9906              LDR      r1,[sp,#0x18]
000212  e006              B        |L2.546|
                  |L2.532|
;;;271    	{
;;;272    		/* Perform Multiply-Accumulate */
;;;273    		*pScratchOut++ += (q31_t) * px++ * coeff;
000214  6802              LDR      r2,[r0,#0]
000216  f8353b02          LDRH     r3,[r5],#2
00021a  fb132207          SMLABB   r2,r3,r7,r2
00021e  c004              STM      r0!,{r2}
000220  1e49              SUBS     r1,r1,#1
                  |L2.546|
000222  2900              CMP      r1,#0                 ;270
000224  d1f6              BNE      |L2.532|
;;;274    
;;;275    		/* Decrement the loop counter */
;;;276    		blkCnt--;
;;;277    	}
;;;278    
;;;279      /* All the output values are in pScratchOut buffer.    
;;;280         Convert them into 1.15 format, saturate and store in the destination buffer. */
;;;281      /* Loop over the blockSize. */
;;;282      blkCnt = blockSize >> 2;
;;;283    
;;;284      while(blkCnt > 0u)
000226  9807              LDR      r0,[sp,#0x1c]
000228  e018              B        |L2.604|
00022a  bf00              NOP      
                  |L2.556|
00022c  e8f42102          LDRD     r2,r1,[r4],#8
;;;285      {
;;;286        in1 = *pScr2++;
;;;287        in2 = *pScr2++;
;;;288    
;;;289    #ifndef  ARM_MATH_BIG_ENDIAN
;;;290    
;;;291        *__SIMD32(pOut)++ =
000230  f32232cf          SSAT     r2,#16,r2,ASR #15
000234  f32131cf          SSAT     r1,#16,r1,ASR #15
000238  eac24101          PKHBT    r1,r2,r1,LSL #16
00023c  f8c91000          STR      r1,[r9,#0]
000240  e8f42302          LDRD     r2,r3,[r4],#8
000244  f1090104          ADD      r1,r9,#4
;;;292          __PKHBT((q15_t) __SSAT(in1 >> 15, 16), (q15_t) __SSAT(in2 >> 15, 16),
;;;293                  16);
;;;294    
;;;295    #else
;;;296        *__SIMD32(pOut)++ =
;;;297          __PKHBT((q15_t) __SSAT(in2 >> 15, 16), (q15_t) __SSAT(in1 >> 15, 16),
;;;298                  16);
;;;299    
;;;300    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;301    
;;;302        in1 = *pScr2++;
;;;303    
;;;304        in2 = *pScr2++;
;;;305    
;;;306    #ifndef  ARM_MATH_BIG_ENDIAN
;;;307    
;;;308        *__SIMD32(pOut)++ =
000248  f32232cf          SSAT     r2,#16,r2,ASR #15
00024c  f32333cf          SSAT     r3,#16,r3,ASR #15
000250  eac24203          PKHBT    r2,r2,r3,LSL #16
000254  f8412b04          STR      r2,[r1],#4
000258  4689              MOV      r9,r1
00025a  1e40              SUBS     r0,r0,#1
                  |L2.604|
00025c  2800              CMP      r0,#0                 ;284
00025e  d1e5              BNE      |L2.556|
;;;309          __PKHBT((q15_t) __SSAT(in1 >> 15, 16), (q15_t) __SSAT(in2 >> 15, 16),
;;;310                  16);
;;;311    
;;;312    #else
;;;313    
;;;314        *__SIMD32(pOut)++ =
;;;315          __PKHBT((q15_t) __SSAT(in2 >> 15, 16), (q15_t) __SSAT(in1 >> 15, 16),
;;;316                  16);
;;;317    
;;;318    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;319    
;;;320    
;;;321        blkCnt--;
;;;322    
;;;323      }
;;;324    
;;;325      /* If the blockSize is not a multiple of 4,    
;;;326         remaining samples are processed in the below loop */
;;;327      blkCnt = blockSize % 0x4u;
;;;328    
;;;329      while(blkCnt > 0u)
000260  9806              LDR      r0,[sp,#0x18]
000262  e005              B        |L2.624|
                  |L2.612|
;;;330      {
;;;331        *pOut++ = (q15_t) __SSAT(*pScr2++ >> 15, 16);
000264  cc02              LDM      r4!,{r1}
000266  1e40              SUBS     r0,r0,#1
000268  f32132cf          SSAT     r2,#16,r1,ASR #15
00026c  f8292b02          STRH     r2,[r9],#2
                  |L2.624|
000270  2800              CMP      r0,#0                 ;329
000272  d1f7              BNE      |L2.612|
;;;332        blkCnt--;
;;;333      }
;;;334    
;;;335    #else
;;;336    
;;;337      /* Run the below code for Cortex-M0 */
;;;338    
;;;339      /* BlockSize of Input samples are copied into the state buffer */
;;;340      /* StateIndex points to the starting position to write in the state buffer */
;;;341      arm_circularWrite_q15(py, delaySize, &S->stateIndex, 1, pIn, 1, blockSize);
;;;342    
;;;343      /* Loop over the number of taps. */
;;;344      tapCnt = numTaps;
;;;345    
;;;346      /* Read Index, from where the state buffer should be read, is calculated. */
;;;347      readIndex = (S->stateIndex - blockSize) - *pTapDelay++;
;;;348    
;;;349      /* Wraparound of readIndex */
;;;350      if(readIndex < 0)
;;;351      {
;;;352        readIndex += (int32_t) delaySize;
;;;353      }
;;;354    
;;;355      /* Working pointer for state buffer is updated */
;;;356      py = pState;
;;;357    
;;;358      /* blockSize samples are read from the state buffer */
;;;359      arm_circularRead_q15(py, delaySize, &readIndex, 1,
;;;360                           pb, pb, blockSize, 1, blockSize);
;;;361    
;;;362      /* Working pointer for the scratch buffer of state values */
;;;363      px = pb;
;;;364    
;;;365      /* Working pointer for scratch buffer of output values */
;;;366      pScratchOut = pScr2;
;;;367    
;;;368      blkCnt = blockSize;
;;;369    
;;;370      while(blkCnt > 0u)
;;;371      {
;;;372        /* Perform multiplication and store in the scratch buffer */
;;;373        *pScratchOut++ = ((q31_t) * px++ * coeff);
;;;374    
;;;375        /* Decrement the loop counter */
;;;376        blkCnt--;
;;;377      }
;;;378    
;;;379      /* Load the coefficient value and           
;;;380       * increment the coefficient buffer for the next set of state values */
;;;381      coeff = *pCoeffs++;
;;;382    
;;;383      /* Read Index, from where the state buffer should be read, is calculated. */
;;;384      readIndex = (S->stateIndex - blockSize) - *pTapDelay++;
;;;385    
;;;386      /* Wraparound of readIndex */
;;;387      if(readIndex < 0)
;;;388      {
;;;389        readIndex += (int32_t) delaySize;
;;;390      }
;;;391    
;;;392      /* Loop over the number of taps. */
;;;393      tapCnt = (uint32_t) numTaps - 2u;
;;;394    
;;;395      while(tapCnt > 0u)
;;;396      {
;;;397        /* Working pointer for state buffer is updated */
;;;398        py = pState;
;;;399    
;;;400        /* blockSize samples are read from the state buffer */
;;;401        arm_circularRead_q15(py, delaySize, &readIndex, 1,
;;;402                             pb, pb, blockSize, 1, blockSize);
;;;403    
;;;404        /* Working pointer for the scratch buffer of state values */
;;;405        px = pb;
;;;406    
;;;407        /* Working pointer for scratch buffer of output values */
;;;408        pScratchOut = pScr2;
;;;409    
;;;410        blkCnt = blockSize;
;;;411    
;;;412        while(blkCnt > 0u)
;;;413        {
;;;414          /* Perform Multiply-Accumulate */
;;;415          *pScratchOut++ += (q31_t) * px++ * coeff;
;;;416    
;;;417          /* Decrement the loop counter */
;;;418          blkCnt--;
;;;419        }
;;;420    
;;;421        /* Load the coefficient value and           
;;;422         * increment the coefficient buffer for the next set of state values */
;;;423        coeff = *pCoeffs++;
;;;424    
;;;425        /* Read Index, from where the state buffer should be read, is calculated. */
;;;426        readIndex = (S->stateIndex - blockSize) - *pTapDelay++;
;;;427    
;;;428        /* Wraparound of readIndex */
;;;429        if(readIndex < 0)
;;;430        {
;;;431          readIndex += (int32_t) delaySize;
;;;432        }
;;;433    
;;;434        /* Decrement the tap loop counter */
;;;435        tapCnt--;
;;;436      }
;;;437    	
;;;438    	/* Compute last tap without the final read of pTapDelay */	
;;;439    	
;;;440    	/* Working pointer for state buffer is updated */
;;;441    	py = pState;
;;;442    
;;;443    	/* blockSize samples are read from the state buffer */
;;;444    	arm_circularRead_q15(py, delaySize, &readIndex, 1,
;;;445    											 pb, pb, blockSize, 1, blockSize);
;;;446    
;;;447    	/* Working pointer for the scratch buffer of state values */
;;;448    	px = pb;
;;;449    
;;;450    	/* Working pointer for scratch buffer of output values */
;;;451    	pScratchOut = pScr2;
;;;452    
;;;453    	blkCnt = blockSize;
;;;454    
;;;455    	while(blkCnt > 0u)
;;;456    	{
;;;457    		/* Perform Multiply-Accumulate */
;;;458    		*pScratchOut++ += (q31_t) * px++ * coeff;
;;;459    
;;;460    		/* Decrement the loop counter */
;;;461    		blkCnt--;
;;;462    	}
;;;463    
;;;464      /* All the output values are in pScratchOut buffer.       
;;;465         Convert them into 1.15 format, saturate and store in the destination buffer. */
;;;466      /* Loop over the blockSize. */
;;;467      blkCnt = blockSize;
;;;468    
;;;469      while(blkCnt > 0u)
;;;470      {
;;;471        *pOut++ = (q15_t) __SSAT(*pScr2++ >> 15, 16);
;;;472        blkCnt--;
;;;473      }
;;;474    
;;;475    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;476    
;;;477    }
000274  b00b              ADD      sp,sp,#0x2c
000276  e8bd8ff0          POP      {r4-r11,pc}
;;;478    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_fir_sparse_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_arm_fir_sparse_q15_c_ebe2e0a0____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___20_arm_fir_sparse_q15_c_ebe2e0a0____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_arm_fir_sparse_q15_c_ebe2e0a0____REVSH|
#line 144
|__asm___20_arm_fir_sparse_q15_c_ebe2e0a0____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_arm_fir_sparse_q15_c_ebe2e0a0____RRX|
#line 300
|__asm___20_arm_fir_sparse_q15_c_ebe2e0a0____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
