; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_conv_f32.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_f32.c]
                          THUMB

                          AREA ||i.arm_conv_f32||, CODE, READONLY, ALIGN=2

                  arm_conv_f32 PROC
;;;123    
;;;124    void arm_conv_f32(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;125      float32_t * pSrcA,
;;;126      uint32_t srcALen,
;;;127      float32_t * pSrcB,
;;;128      uint32_t srcBLen,
;;;129      float32_t * pDst)
;;;130    {
000004  9d09              LDR      r5,[sp,#0x24]
;;;131    
;;;132    
;;;133    #ifndef ARM_MATH_CM0_FAMILY
;;;134    
;;;135      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;136    
;;;137      float32_t *pIn1;                               /* inputA pointer */
;;;138      float32_t *pIn2;                               /* inputB pointer */
;;;139      float32_t *pOut = pDst;                        /* output pointer */
;;;140      float32_t *px;                                 /* Intermediate inputA pointer */
;;;141      float32_t *py;                                 /* Intermediate inputB pointer */
;;;142      float32_t *pSrc1, *pSrc2;                      /* Intermediate pointers */
;;;143      float32_t sum, acc0, acc1, acc2, acc3;         /* Accumulator */
;;;144      float32_t x0, x1, x2, x3, c0;                  /* Temporary variables to hold state and coefficient values */
;;;145      uint32_t j, k, count, blkCnt, blockSize1, blockSize2, blockSize3;     /* loop counters */
;;;146    
;;;147      /* The algorithm implementation is based on the lengths of the inputs. */
;;;148      /* srcB is always made to slide across srcA. */
;;;149      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;150      if(srcALen >= srcBLen)
000006  4299              CMP      r1,r3
000008  d302              BCC      |L1.16|
;;;151      {
;;;152        /* Initialization of inputA pointer */
;;;153        pIn1 = pSrcA;
00000a  4606              MOV      r6,r0
;;;154    
;;;155        /* Initialization of inputB pointer */
;;;156        pIn2 = pSrcB;
00000c  4691              MOV      r9,r2
00000e  e004              B        |L1.26|
                  |L1.16|
;;;157      }
;;;158      else
;;;159      {
;;;160        /* Initialization of inputA pointer */
;;;161        pIn1 = pSrcB;
000010  4616              MOV      r6,r2
;;;162    
;;;163        /* Initialization of inputB pointer */
;;;164        pIn2 = pSrcA;
000012  4681              MOV      r9,r0
;;;165    
;;;166        /* srcBLen is always considered as shorter or equal to srcALen */
;;;167        j = srcBLen;
000014  4618              MOV      r0,r3
;;;168        srcBLen = srcALen;
000016  460b              MOV      r3,r1
;;;169        srcALen = j;
000018  4601              MOV      r1,r0
                  |L1.26|
;;;170      }
;;;171    
;;;172      /* conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1] */
;;;173      /* The function is internally    
;;;174       * divided into three stages according to the number of multiplications that has to be    
;;;175       * taken place between inputA samples and inputB samples. In the first stage of the    
;;;176       * algorithm, the multiplications increase by one for every iteration.    
;;;177       * In the second stage of the algorithm, srcBLen number of multiplications are done.    
;;;178       * In the third stage of the algorithm, the multiplications decrease by one    
;;;179       * for every iteration. */
;;;180    
;;;181      /* The algorithm is implemented in three stages.    
;;;182         The loop counters of each stage is initiated here. */
;;;183      blockSize1 = srcBLen - 1u;
00001a  f1a30a01          SUB      r10,r3,#1
;;;184      blockSize2 = srcALen - (srcBLen - 1u);
00001e  eba10c03          SUB      r12,r1,r3
000022  f10c0c01          ADD      r12,r12,#1
;;;185      blockSize3 = blockSize1;
000026  4657              MOV      r7,r10
;;;186    
;;;187      /* --------------------------    
;;;188       * initializations of stage1    
;;;189       * -------------------------*/
;;;190    
;;;191      /* sum = x[0] * y[0]    
;;;192       * sum = x[0] * y[1] + x[1] * y[0]    
;;;193       * ....    
;;;194       * sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]    
;;;195       */
;;;196    
;;;197      /* In this stage the MAC operations are increased by 1 for every iteration.    
;;;198         The count variable holds the number of MAC operations performed */
;;;199      count = 1u;
000028  2201              MOVS     r2,#1
;;;200    
;;;201      /* Working pointer of inputA */
;;;202      px = pIn1;
00002a  4634              MOV      r4,r6
;;;203    
;;;204      /* Working pointer of inputB */
;;;205      py = pIn2;
00002c  4648              MOV      r0,r9
;;;206    
;;;207    
;;;208      /* ------------------------    
;;;209       * Stage1 process    
;;;210       * ----------------------*/
;;;211    
;;;212      /* The first stage starts here */
;;;213      while(blockSize1 > 0u)
;;;214      {
;;;215        /* Accumulator is made zero for every iteration */
;;;216        sum = 0.0f;
00002e  eddf6abb          VLDR     s13,|L1.796|
000032  e03c              B        |L1.174|
                  |L1.52|
000034  eef01a66          VMOV.F32 s3,s13
;;;217    
;;;218        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;219        k = count >> 2u;
000038  ea4f0892          LSR      r8,r2,#2
;;;220    
;;;221        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;222         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;223        while(k > 0u)
00003c  e01d              B        |L1.122|
                  |L1.62|
;;;224        {
;;;225          /* x[0] * y[srcBLen - 1] */
;;;226          sum += *px++ * *py--;
00003e  ecb40a01          VLDM     r4!,{s0}
000042  edd00a00          VLDR     s1,[r0,#0]
000046  1f00              SUBS     r0,r0,#4
000048  ee401a20          VMLA.F32 s3,s0,s1
;;;227    
;;;228          /* x[1] * y[srcBLen - 2] */
;;;229          sum += *px++ * *py--;
00004c  ecb40a01          VLDM     r4!,{s0}
000050  edd00a00          VLDR     s1,[r0,#0]
000054  1f00              SUBS     r0,r0,#4
000056  ee401a20          VMLA.F32 s3,s0,s1
;;;230    
;;;231          /* x[2] * y[srcBLen - 3] */
;;;232          sum += *px++ * *py--;
00005a  ecb40a01          VLDM     r4!,{s0}
00005e  edd00a00          VLDR     s1,[r0,#0]
000062  1f00              SUBS     r0,r0,#4
000064  ee401a20          VMLA.F32 s3,s0,s1
;;;233    
;;;234          /* x[3] * y[srcBLen - 4] */
;;;235          sum += *px++ * *py--;
000068  ecb40a01          VLDM     r4!,{s0}
00006c  edd00a00          VLDR     s1,[r0,#0]
000070  1f00              SUBS     r0,r0,#4
000072  ee401a20          VMLA.F32 s3,s0,s1
;;;236    
;;;237          /* Decrement the loop counter */
;;;238          k--;
000076  f1a80801          SUB      r8,r8,#1
                  |L1.122|
00007a  f1b80f00          CMP      r8,#0                 ;223
00007e  d1de              BNE      |L1.62|
;;;239        }
;;;240    
;;;241        /* If the count is not a multiple of 4, compute any remaining MACs here.    
;;;242         ** No loop unrolling is used. */
;;;243        k = count % 0x4u;
000080  f0020803          AND      r8,r2,#3
;;;244    
;;;245        while(k > 0u)
000084  e008              B        |L1.152|
                  |L1.134|
;;;246        {
;;;247          /* Perform the multiply-accumulate */
;;;248          sum += *px++ * *py--;
000086  ecb40a01          VLDM     r4!,{s0}
00008a  edd00a00          VLDR     s1,[r0,#0]
00008e  1f00              SUBS     r0,r0,#4
000090  ee401a20          VMLA.F32 s3,s0,s1
;;;249    
;;;250          /* Decrement the loop counter */
;;;251          k--;
000094  f1a80801          SUB      r8,r8,#1
                  |L1.152|
000098  f1b80f00          CMP      r8,#0                 ;245
00009c  d1f3              BNE      |L1.134|
;;;252        }
;;;253    
;;;254        /* Store the result in the accumulator in the destination buffer. */
;;;255        *pOut++ = sum;
00009e  ece51a01          VSTM     r5!,{s3}
;;;256    
;;;257        /* Update the inputA and inputB pointers for next MAC calculation */
;;;258        py = pIn2 + count;
0000a2  eb090082          ADD      r0,r9,r2,LSL #2
;;;259        px = pIn1;
0000a6  4634              MOV      r4,r6
;;;260    
;;;261        /* Increment the MAC count */
;;;262        count++;
0000a8  1c52              ADDS     r2,r2,#1
;;;263    
;;;264        /* Decrement the loop counter */
;;;265        blockSize1--;
0000aa  f1aa0a01          SUB      r10,r10,#1
                  |L1.174|
0000ae  f1ba0f00          CMP      r10,#0                ;213
0000b2  d1bf              BNE      |L1.52|
;;;266      }
;;;267    
;;;268      /* --------------------------    
;;;269       * Initializations of stage2    
;;;270       * ------------------------*/
;;;271    
;;;272      /* sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0]    
;;;273       * sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0]    
;;;274       * ....    
;;;275       * sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]    
;;;276       */
;;;277    
;;;278      /* Working pointer of inputA */
;;;279      px = pIn1;
;;;280    
;;;281      /* Working pointer of inputB */
;;;282      pSrc2 = pIn2 + (srcBLen - 1u);
0000b4  f1a30a01          SUB      r10,r3,#1
0000b8  eb09088a          ADD      r8,r9,r10,LSL #2
;;;283      py = pSrc2;
0000bc  4640              MOV      r0,r8
;;;284    
;;;285      /* count is index by which the pointer pIn1 to be incremented */
;;;286      count = 0u;
0000be  2200              MOVS     r2,#0
;;;287    
;;;288      /* -------------------    
;;;289       * Stage2 process    
;;;290       * ------------------*/
;;;291    
;;;292      /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.    
;;;293       * So, to loop unroll over blockSize2,    
;;;294       * srcBLen should be greater than or equal to 4 */
;;;295      if(srcBLen >= 4u)
0000c0  2b04              CMP      r3,#4
0000c2  d37d              BCC      |L1.448|
;;;296      {
;;;297        /* Loop unroll over blockSize2, by 4 */
;;;298        blkCnt = blockSize2 >> 2u;
0000c4  ea4f099c          LSR      r9,r12,#2
;;;299    
;;;300        while(blkCnt > 0u)
0000c8  e07e              B        |L1.456|
                  |L1.202|
;;;301        {
;;;302          /* Set all accumulators to zero */
;;;303          acc0 = 0.0f;
;;;304          acc1 = 0.0f;
0000ca  eef01a66          VMOV.F32 s3,s13
0000ce  eeb02a61          VMOV.F32 s4,s3
;;;305          acc2 = 0.0f;
0000d2  eef01a66          VMOV.F32 s3,s13
0000d6  eeb03a61          VMOV.F32 s6,s3
;;;306          acc3 = 0.0f;
0000da  eef01a66          VMOV.F32 s3,s13
0000de  eef03a61          VMOV.F32 s7,s3
;;;307    
;;;308          /* read x[0], x[1], x[2] samples */
;;;309          x0 = *(px++);
0000e2  ecb41a01          VLDM     r4!,{s2}
;;;310          x1 = *(px++);
0000e6  ecf40a01          VLDM     r4!,{s1}
;;;311          x2 = *(px++);
0000ea  ecb40a01          VLDM     r4!,{s0}
;;;312    
;;;313          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;314          k = srcBLen >> 2u;
0000ee  ea4f0b93          LSR      r11,r3,#2
                  |L1.242|
;;;315    
;;;316          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;317           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;318          do
;;;319          {
;;;320            /* Read y[srcBLen - 1] sample */
;;;321            c0 = *(py--);
0000f2  edd04a00          VLDR     s9,[r0,#0]
0000f6  1f00              SUBS     r0,r0,#4
;;;322    
;;;323            /* Read x[3] sample */
;;;324            x3 = *(px);
0000f8  ed944a00          VLDR     s8,[r4,#0]
;;;325    
;;;326            /* Perform the multiply-accumulate */
;;;327            /* acc0 +=  x[0] * y[srcBLen - 1] */
;;;328            acc0 += x0 * c0;
0000fc  eef05a61          VMOV.F32 s11,s3
000100  ee415a24          VMLA.F32 s11,s2,s9
;;;329    
;;;330            /* acc1 +=  x[1] * y[srcBLen - 1] */
;;;331            acc1 += x1 * c0;
000104  ee002aa4          VMLA.F32 s4,s1,s9
;;;332    
;;;333            /* acc2 +=  x[2] * y[srcBLen - 1] */
;;;334            acc2 += x2 * c0;
000108  ee003a24          VMLA.F32 s6,s0,s9
;;;335    
;;;336            /* acc3 +=  x[3] * y[srcBLen - 1] */
;;;337            acc3 += x3 * c0;
00010c  eeb06a63          VMOV.F32 s12,s7
000110  ee046a24          VMLA.F32 s12,s8,s9
;;;338    
;;;339            /* Read y[srcBLen - 2] sample */
;;;340            c0 = *(py--);
000114  edd01a00          VLDR     s3,[r0,#0]
000118  1f00              SUBS     r0,r0,#4
;;;341    
;;;342            /* Read x[4] sample */
;;;343            x0 = *(px + 1u);
00011a  ed941a01          VLDR     s2,[r4,#4]
;;;344    
;;;345            /* Perform the multiply-accumulate */
;;;346            /* acc0 +=  x[1] * y[srcBLen - 2] */
;;;347            acc0 += x1 * c0;
00011e  ee405aa1          VMLA.F32 s11,s1,s3
;;;348            /* acc1 +=  x[2] * y[srcBLen - 2] */
;;;349            acc1 += x2 * c0;
000122  ee002a21          VMLA.F32 s4,s0,s3
;;;350            /* acc2 +=  x[3] * y[srcBLen - 2] */
;;;351            acc2 += x3 * c0;
000126  ee043a21          VMLA.F32 s6,s8,s3
;;;352            /* acc3 +=  x[4] * y[srcBLen - 2] */
;;;353            acc3 += x0 * c0;
00012a  ee016a21          VMLA.F32 s12,s2,s3
;;;354    
;;;355            /* Read y[srcBLen - 3] sample */
;;;356            c0 = *(py--);
00012e  edd01a00          VLDR     s3,[r0,#0]
000132  1f00              SUBS     r0,r0,#4
;;;357    
;;;358            /* Read x[5] sample */
;;;359            x1 = *(px + 2u);
000134  edd40a02          VLDR     s1,[r4,#8]
;;;360    
;;;361            /* Perform the multiply-accumulates */
;;;362            /* acc0 +=  x[2] * y[srcBLen - 3] */
;;;363            acc0 += x2 * c0;
000138  ee405a21          VMLA.F32 s11,s0,s3
;;;364            /* acc1 +=  x[3] * y[srcBLen - 2] */
;;;365            acc1 += x3 * c0;
00013c  ee042a21          VMLA.F32 s4,s8,s3
;;;366            /* acc2 +=  x[4] * y[srcBLen - 2] */
;;;367            acc2 += x0 * c0;
000140  ee013a21          VMLA.F32 s6,s2,s3
;;;368            /* acc3 +=  x[5] * y[srcBLen - 2] */
;;;369            acc3 += x1 * c0;
000144  ee006aa1          VMLA.F32 s12,s1,s3
;;;370    
;;;371            /* Read y[srcBLen - 4] sample */
;;;372            c0 = *(py--);
000148  edd03a00          VLDR     s7,[r0,#0]
00014c  1f00              SUBS     r0,r0,#4
;;;373    
;;;374            /* Read x[6] sample */
;;;375            x2 = *(px + 3u);
00014e  ed940a03          VLDR     s0,[r4,#0xc]
;;;376            px += 4u;
000152  3410              ADDS     r4,r4,#0x10
;;;377    
;;;378            /* Perform the multiply-accumulates */
;;;379            /* acc0 +=  x[3] * y[srcBLen - 4] */
;;;380            acc0 += x3 * c0;
000154  eef01a65          VMOV.F32 s3,s11
000158  ee441a23          VMLA.F32 s3,s8,s7
;;;381            /* acc1 +=  x[4] * y[srcBLen - 4] */
;;;382            acc1 += x0 * c0;
00015c  ee012a23          VMLA.F32 s4,s2,s7
;;;383            /* acc2 +=  x[5] * y[srcBLen - 4] */
;;;384            acc2 += x1 * c0;
000160  ee003aa3          VMLA.F32 s6,s1,s7
;;;385            /* acc3 +=  x[6] * y[srcBLen - 4] */
;;;386            acc3 += x2 * c0;
000164  ee006a23          VMLA.F32 s12,s0,s7
000168  eef03a46          VMOV.F32 s7,s12
;;;387    
;;;388    
;;;389          } while(--k);
00016c  f1bb0b01          SUBS     r11,r11,#1
000170  d1bf              BNE      |L1.242|
;;;390    
;;;391          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.    
;;;392           ** No loop unrolling is used. */
;;;393          k = srcBLen % 0x4u;
000172  f0030b03          AND      r11,r3,#3
;;;394    
;;;395          while(k > 0u)
000176  e014              B        |L1.418|
                  |L1.376|
;;;396          {
;;;397            /* Read y[srcBLen - 5] sample */
;;;398            c0 = *(py--);
000178  ed904a00          VLDR     s8,[r0,#0]
00017c  1f00              SUBS     r0,r0,#4
;;;399    
;;;400            /* Read x[7] sample */
;;;401            x3 = *(px++);
00017e  ecf44a01          VLDM     r4!,{s9}
;;;402    
;;;403            /* Perform the multiply-accumulates */
;;;404            /* acc0 +=  x[4] * y[srcBLen - 5] */
;;;405            acc0 += x0 * c0;
000182  ee411a04          VMLA.F32 s3,s2,s8
;;;406            /* acc1 +=  x[5] * y[srcBLen - 5] */
;;;407            acc1 += x1 * c0;
000186  ee002a84          VMLA.F32 s4,s1,s8
;;;408            /* acc2 +=  x[6] * y[srcBLen - 5] */
;;;409            acc2 += x2 * c0;
00018a  ee003a04          VMLA.F32 s6,s0,s8
;;;410            /* acc3 +=  x[7] * y[srcBLen - 5] */
;;;411            acc3 += x3 * c0;
00018e  ee443a84          VMLA.F32 s7,s9,s8
;;;412    
;;;413            /* Reuse the present samples for the next MAC */
;;;414            x0 = x1;
000192  eeb01a60          VMOV.F32 s2,s1
;;;415            x1 = x2;
000196  eef00a40          VMOV.F32 s1,s0
;;;416            x2 = x3;
00019a  eeb00a64          VMOV.F32 s0,s9
;;;417    
;;;418            /* Decrement the loop counter */
;;;419            k--;
00019e  f1ab0b01          SUB      r11,r11,#1
                  |L1.418|
0001a2  f1bb0f00          CMP      r11,#0                ;395
0001a6  d1e7              BNE      |L1.376|
;;;420          }
;;;421    
;;;422          /* Store the result in the accumulator in the destination buffer. */
;;;423          *pOut++ = acc0;
0001a8  ece51a01          VSTM     r5!,{s3}
;;;424          *pOut++ = acc1;
0001ac  eca52a01          VSTM     r5!,{s4}
;;;425          *pOut++ = acc2;
0001b0  eca53a01          VSTM     r5!,{s6}
;;;426          *pOut++ = acc3;
0001b4  ece53a01          VSTM     r5!,{s7}
;;;427    
;;;428          /* Increment the pointer pIn1 index, count by 4 */
;;;429          count += 4u;
0001b8  1d12              ADDS     r2,r2,#4
;;;430    
;;;431          /* Update the inputA and inputB pointers for next MAC calculation */
;;;432          px = pIn1 + count;
0001ba  eb060482          ADD      r4,r6,r2,LSL #2
;;;433          py = pSrc2;
0001be  e000              B        |L1.450|
                  |L1.448|
0001c0  e062              B        |L1.648|
                  |L1.450|
0001c2  4640              MOV      r0,r8
;;;434    
;;;435    
;;;436          /* Decrement the loop counter */
;;;437          blkCnt--;
0001c4  f1a90901          SUB      r9,r9,#1
                  |L1.456|
0001c8  f1b90f00          CMP      r9,#0                 ;300
0001cc  f47faf7d          BNE      |L1.202|
;;;438        }
;;;439    
;;;440    
;;;441        /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.    
;;;442         ** No loop unrolling is used. */
;;;443        blkCnt = blockSize2 % 0x4u;
0001d0  f00c0903          AND      r9,r12,#3
;;;444    
;;;445        while(blkCnt > 0u)
0001d4  e03c              B        |L1.592|
                  |L1.470|
;;;446        {
;;;447          /* Accumulator is made zero for every iteration */
;;;448          sum = 0.0f;
0001d6  eef02a66          VMOV.F32 s5,s13
;;;449    
;;;450          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;451          k = srcBLen >> 2u;
0001da  ea4f0c93          LSR      r12,r3,#2
;;;452    
;;;453          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;454           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;455          while(k > 0u)
0001de  e01d              B        |L1.540|
                  |L1.480|
;;;456          {
;;;457            /* Perform the multiply-accumulates */
;;;458            sum += *px++ * *py--;
0001e0  ecb40a01          VLDM     r4!,{s0}
0001e4  edd00a00          VLDR     s1,[r0,#0]
0001e8  1f00              SUBS     r0,r0,#4
0001ea  ee402a20          VMLA.F32 s5,s0,s1
;;;459            sum += *px++ * *py--;
0001ee  ecb40a01          VLDM     r4!,{s0}
0001f2  edd00a00          VLDR     s1,[r0,#0]
0001f6  1f00              SUBS     r0,r0,#4
0001f8  ee402a20          VMLA.F32 s5,s0,s1
;;;460            sum += *px++ * *py--;
0001fc  ecb40a01          VLDM     r4!,{s0}
000200  edd00a00          VLDR     s1,[r0,#0]
000204  1f00              SUBS     r0,r0,#4
000206  ee402a20          VMLA.F32 s5,s0,s1
;;;461            sum += *px++ * *py--;
00020a  ecb40a01          VLDM     r4!,{s0}
00020e  edd00a00          VLDR     s1,[r0,#0]
000212  1f00              SUBS     r0,r0,#4
000214  ee402a20          VMLA.F32 s5,s0,s1
;;;462    
;;;463            /* Decrement the loop counter */
;;;464            k--;
000218  f1ac0c01          SUB      r12,r12,#1
                  |L1.540|
00021c  f1bc0f00          CMP      r12,#0                ;455
000220  d1de              BNE      |L1.480|
;;;465          }
;;;466    
;;;467          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.    
;;;468           ** No loop unrolling is used. */
;;;469          k = srcBLen % 0x4u;
000222  f0030c03          AND      r12,r3,#3
;;;470    
;;;471          while(k > 0u)
000226  e008              B        |L1.570|
                  |L1.552|
;;;472          {
;;;473            /* Perform the multiply-accumulate */
;;;474            sum += *px++ * *py--;
000228  ecb40a01          VLDM     r4!,{s0}
00022c  edd00a00          VLDR     s1,[r0,#0]
000230  1f00              SUBS     r0,r0,#4
000232  ee402a20          VMLA.F32 s5,s0,s1
;;;475    
;;;476            /* Decrement the loop counter */
;;;477            k--;
000236  f1ac0c01          SUB      r12,r12,#1
                  |L1.570|
00023a  f1bc0f00          CMP      r12,#0                ;471
00023e  d1f3              BNE      |L1.552|
;;;478          }
;;;479    
;;;480          /* Store the result in the accumulator in the destination buffer. */
;;;481          *pOut++ = sum;
000240  ece52a01          VSTM     r5!,{s5}
;;;482    
;;;483          /* Increment the MAC count */
;;;484          count++;
000244  1c52              ADDS     r2,r2,#1
;;;485    
;;;486          /* Update the inputA and inputB pointers for next MAC calculation */
;;;487          px = pIn1 + count;
000246  eb060482          ADD      r4,r6,r2,LSL #2
;;;488          py = pSrc2;
00024a  4640              MOV      r0,r8
;;;489    
;;;490          /* Decrement the loop counter */
;;;491          blkCnt--;
00024c  f1a90901          SUB      r9,r9,#1
                  |L1.592|
000250  f1b90f00          CMP      r9,#0                 ;445
000254  d1bf              BNE      |L1.470|
000256  e01a              B        |L1.654|
                  |L1.600|
;;;492        }
;;;493      }
;;;494      else
;;;495      {
;;;496        /* If the srcBLen is not a multiple of 4,    
;;;497         * the blockSize2 loop cannot be unrolled by 4 */
;;;498        blkCnt = blockSize2;
;;;499    
;;;500        while(blkCnt > 0u)
;;;501        {
;;;502          /* Accumulator is made zero for every iteration */
;;;503          sum = 0.0f;
000258  eeb05a66          VMOV.F32 s10,s13
;;;504    
;;;505          /* srcBLen number of MACS should be performed */
;;;506          k = srcBLen;
00025c  4699              MOV      r9,r3
;;;507    
;;;508          while(k > 0u)
00025e  e008              B        |L1.626|
                  |L1.608|
;;;509          {
;;;510            /* Perform the multiply-accumulate */
;;;511            sum += *px++ * *py--;
000260  ecb40a01          VLDM     r4!,{s0}
000264  edd00a00          VLDR     s1,[r0,#0]
000268  1f00              SUBS     r0,r0,#4
00026a  ee005a20          VMLA.F32 s10,s0,s1
;;;512    
;;;513            /* Decrement the loop counter */
;;;514            k--;
00026e  f1a90901          SUB      r9,r9,#1
                  |L1.626|
000272  f1b90f00          CMP      r9,#0                 ;508
000276  d1f3              BNE      |L1.608|
;;;515          }
;;;516    
;;;517          /* Store the result in the accumulator in the destination buffer. */
;;;518          *pOut++ = sum;
000278  eca55a01          VSTM     r5!,{s10}
;;;519    
;;;520          /* Increment the MAC count */
;;;521          count++;
00027c  1c52              ADDS     r2,r2,#1
;;;522    
;;;523          /* Update the inputA and inputB pointers for next MAC calculation */
;;;524          px = pIn1 + count;
00027e  eb060482          ADD      r4,r6,r2,LSL #2
;;;525          py = pSrc2;
000282  4640              MOV      r0,r8
;;;526    
;;;527          /* Decrement the loop counter */
;;;528          blkCnt--;
000284  f1ac0c01          SUB      r12,r12,#1
                  |L1.648|
000288  f1bc0f00          CMP      r12,#0                ;500
00028c  d1e4              BNE      |L1.600|
                  |L1.654|
;;;529        }
;;;530      }
;;;531    
;;;532    
;;;533      /* --------------------------    
;;;534       * Initializations of stage3    
;;;535       * -------------------------*/
;;;536    
;;;537      /* sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1]    
;;;538       * sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2]    
;;;539       * ....    
;;;540       * sum +=  x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2]    
;;;541       * sum +=  x[srcALen-1] * y[srcBLen-1]    
;;;542       */
;;;543    
;;;544      /* In this stage the MAC operations are decreased by 1 for every iteration.    
;;;545         The blockSize3 variable holds the number of MAC operations performed */
;;;546    
;;;547      /* Working pointer of inputA */
;;;548      pSrc1 = (pIn1 + srcALen) - (srcBLen - 1u);
00028e  eb060081          ADD      r0,r6,r1,LSL #2
000292  eba0028a          SUB      r2,r0,r10,LSL #2
;;;549      px = pSrc1;
000296  4610              MOV      r0,r2
;;;550    
;;;551      /* Working pointer of inputB */
;;;552      pSrc2 = pIn2 + (srcBLen - 1u);
000298  4643              MOV      r3,r8
;;;553      py = pSrc2;
00029a  4698              MOV      r8,r3
;;;554    
;;;555      /* -------------------    
;;;556       * Stage3 process    
;;;557       * ------------------*/
;;;558    
;;;559      while(blockSize3 > 0u)
00029c  e03a              B        |L1.788|
                  |L1.670|
;;;560      {
;;;561        /* Accumulator is made zero for every iteration */
;;;562        sum = 0.0f;
00029e  eef01a66          VMOV.F32 s3,s13
;;;563    
;;;564        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;565        k = blockSize3 >> 2u;
0002a2  08b9              LSRS     r1,r7,#2
;;;566    
;;;567        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;568         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;569        while(k > 0u)
0002a4  e020              B        |L1.744|
                  |L1.678|
;;;570        {
;;;571          /* sum += x[srcALen - srcBLen + 1] * y[srcBLen - 1] */
;;;572          sum += *px++ * *py--;
0002a6  ecb00a01          VLDM     r0!,{s0}
0002aa  edd80a00          VLDR     s1,[r8,#0]
0002ae  f1a80804          SUB      r8,r8,#4
0002b2  ee401a20          VMLA.F32 s3,s0,s1
;;;573    
;;;574          /* sum += x[srcALen - srcBLen + 2] * y[srcBLen - 2] */
;;;575          sum += *px++ * *py--;
0002b6  ecb00a01          VLDM     r0!,{s0}
0002ba  edd80a00          VLDR     s1,[r8,#0]
0002be  f1a80804          SUB      r8,r8,#4
0002c2  ee401a20          VMLA.F32 s3,s0,s1
;;;576    
;;;577          /* sum += x[srcALen - srcBLen + 3] * y[srcBLen - 3] */
;;;578          sum += *px++ * *py--;
0002c6  ecb00a01          VLDM     r0!,{s0}
0002ca  edd80a00          VLDR     s1,[r8,#0]
0002ce  f1a80804          SUB      r8,r8,#4
0002d2  ee401a20          VMLA.F32 s3,s0,s1
;;;579    
;;;580          /* sum += x[srcALen - srcBLen + 4] * y[srcBLen - 4] */
;;;581          sum += *px++ * *py--;
0002d6  ecb00a01          VLDM     r0!,{s0}
0002da  edd80a00          VLDR     s1,[r8,#0]
0002de  f1a80804          SUB      r8,r8,#4
0002e2  ee401a20          VMLA.F32 s3,s0,s1
;;;582    
;;;583          /* Decrement the loop counter */
;;;584          k--;
0002e6  1e49              SUBS     r1,r1,#1
                  |L1.744|
0002e8  2900              CMP      r1,#0                 ;569
0002ea  d1dc              BNE      |L1.678|
;;;585        }
;;;586    
;;;587        /* If the blockSize3 is not a multiple of 4, compute any remaining MACs here.    
;;;588         ** No loop unrolling is used. */
;;;589        k = blockSize3 % 0x4u;
0002ec  f0070103          AND      r1,r7,#3
;;;590    
;;;591        while(k > 0u)
0002f0  e008              B        |L1.772|
                  |L1.754|
;;;592        {
;;;593          /* Perform the multiply-accumulates */
;;;594          /* sum +=  x[srcALen-1] * y[srcBLen-1] */
;;;595          sum += *px++ * *py--;
0002f2  ecb00a01          VLDM     r0!,{s0}
0002f6  edd80a00          VLDR     s1,[r8,#0]
0002fa  f1a80804          SUB      r8,r8,#4
0002fe  ee401a20          VMLA.F32 s3,s0,s1
;;;596    
;;;597          /* Decrement the loop counter */
;;;598          k--;
000302  1e49              SUBS     r1,r1,#1
                  |L1.772|
000304  2900              CMP      r1,#0                 ;591
000306  d1f4              BNE      |L1.754|
;;;599        }
;;;600    
;;;601        /* Store the result in the accumulator in the destination buffer. */
;;;602        *pOut++ = sum;
000308  ece51a01          VSTM     r5!,{s3}
;;;603    
;;;604        /* Update the inputA and inputB pointers for next MAC calculation */
;;;605        px = ++pSrc1;
00030c  1d10              ADDS     r0,r2,#4
00030e  4602              MOV      r2,r0
;;;606        py = pSrc2;
000310  4698              MOV      r8,r3
;;;607    
;;;608        /* Decrement the loop counter */
;;;609        blockSize3--;
000312  1e7f              SUBS     r7,r7,#1
                  |L1.788|
000314  2f00              CMP      r7,#0                 ;559
000316  d1c2              BNE      |L1.670|
;;;610      }
;;;611    
;;;612    #else
;;;613    
;;;614      /* Run the below code for Cortex-M0 */
;;;615    
;;;616      float32_t *pIn1 = pSrcA;                       /* inputA pointer */
;;;617      float32_t *pIn2 = pSrcB;                       /* inputB pointer */
;;;618      float32_t sum;                                 /* Accumulator */
;;;619      uint32_t i, j;                                 /* loop counters */
;;;620    
;;;621      /* Loop to calculate convolution for output length number of times */
;;;622      for (i = 0u; i < ((srcALen + srcBLen) - 1u); i++)
;;;623      {
;;;624        /* Initialize sum with zero to carry out MAC operations */
;;;625        sum = 0.0f;
;;;626    
;;;627        /* Loop to perform MAC operations according to convolution equation */
;;;628        for (j = 0u; j <= i; j++)
;;;629        {
;;;630          /* Check the array limitations */
;;;631          if((((i - j) < srcBLen) && (j < srcALen)))
;;;632          {
;;;633            /* z[i] += x[i-j] * y[j] */
;;;634            sum += pIn1[j] * pIn2[i - j];
;;;635          }
;;;636        }
;;;637        /* Store the output in the destination buffer */
;;;638        pDst[i] = sum;
;;;639      }
;;;640    
;;;641    #endif /*   #ifndef ARM_MATH_CM0_FAMILY        */
;;;642    
;;;643    }
000318  e8bd8ff0          POP      {r4-r11,pc}
;;;644    
                          ENDP

                  |L1.796|
00031c  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_conv_f32_c_63e0709a____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___14_arm_conv_f32_c_63e0709a____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_conv_f32_c_63e0709a____REVSH|
#line 144
|__asm___14_arm_conv_f32_c_63e0709a____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_conv_f32_c_63e0709a____RRX|
#line 300
|__asm___14_arm_conv_f32_c_63e0709a____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
