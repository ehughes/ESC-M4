; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_fast_opt_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_fast_opt_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_conv_fast_opt_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_fast_opt_q15.c]
                          THUMB

                          AREA ||i.arm_conv_fast_opt_q15||, CODE, READONLY, ALIGN=1

                  arm_conv_fast_opt_q15 PROC
;;;82     
;;;83     void arm_conv_fast_opt_q15(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;84       q15_t * pSrcA,
;;;85       uint32_t srcALen,
;;;86       q15_t * pSrcB,
;;;87       uint32_t srcBLen,
;;;88       q15_t * pDst,
;;;89       q15_t * pScratch1,
;;;90       q15_t * pScratch2)
;;;91     {
000004  b085              SUB      sp,sp,#0x14
000006  460d              MOV      r5,r1
000008  e9ddb80e          LDRD     r11,r8,[sp,#0x38]
00000c  9c10              LDR      r4,[sp,#0x40]
00000e  461f              MOV      r7,r3
;;;92       q31_t acc0, acc1, acc2, acc3;                  /* Accumulators */
;;;93       q31_t x1, x2, x3;                              /* Temporary variables to hold state and coefficient values */
;;;94       q31_t y1, y2;                                  /* State variables */
;;;95       q15_t *pOut = pDst;                            /* output pointer */
;;;96       q15_t *pScr1 = pScratch1;                      /* Temporary pointer for scratch1 */
;;;97       q15_t *pScr2 = pScratch2;                      /* Temporary pointer for scratch1 */
;;;98       q15_t *pIn1;                                   /* inputA pointer */
;;;99       q15_t *pIn2;                                   /* inputB pointer */
;;;100      q15_t *px;                                     /* Intermediate inputA pointer  */
;;;101      q15_t *py;                                     /* Intermediate inputB pointer  */
;;;102      uint32_t j, k, blkCnt;                         /* loop counter */
;;;103      uint32_t tapCnt;                               /* loop count */
;;;104    #ifdef UNALIGNED_SUPPORT_DISABLE
;;;105    
;;;106      q15_t a, b;
;;;107    
;;;108    #endif	/*	#ifdef UNALIGNED_SUPPORT_DISABLE	*/
;;;109    
;;;110      /* The algorithm implementation is based on the lengths of the inputs. */
;;;111      /* srcB is always made to slide across srcA. */
;;;112      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;113      if(srcALen >= srcBLen)
000010  42bd              CMP      r5,r7
000012  d302              BCC      |L1.26|
;;;114      {
;;;115        /* Initialization of inputA pointer */
;;;116        pIn1 = pSrcA;
000014  4606              MOV      r6,r0
;;;117    
;;;118        /* Initialization of inputB pointer */
;;;119        pIn2 = pSrcB;
000016  4610              MOV      r0,r2
000018  e003              B        |L1.34|
                  |L1.26|
;;;120      }
;;;121      else
;;;122      {
;;;123        /* Initialization of inputA pointer */
;;;124        pIn1 = pSrcB;
00001a  4616              MOV      r6,r2
;;;125    
;;;126        /* Initialization of inputB pointer */
;;;127        pIn2 = pSrcA;
;;;128    
;;;129        /* srcBLen is always considered as shorter or equal to srcALen */
;;;130        j = srcBLen;
00001c  4639              MOV      r1,r7
;;;131        srcBLen = srcALen;
00001e  462f              MOV      r7,r5
;;;132        srcALen = j;
000020  460d              MOV      r5,r1
                  |L1.34|
;;;133      }
;;;134    
;;;135      /* Pointer to take end of scratch2 buffer */
;;;136      pScr2 = pScratch2 + srcBLen - 1;
000022  eb040147          ADD      r1,r4,r7,LSL #1
000026  1e89              SUBS     r1,r1,#2
;;;137    
;;;138      /* points to smaller length sequence */
;;;139      px = pIn2;
;;;140    
;;;141      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;142      k = srcBLen >> 2u;
000028  08ba              LSRS     r2,r7,#2
00002a  9204              STR      r2,[sp,#0x10]
;;;143    
;;;144      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;145       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;146    
;;;147      /* Copy smaller length input sequence in reverse order into second scratch buffer */
;;;148      while(k > 0u)
00002c  e00b              B        |L1.70|
                  |L1.46|
;;;149      {
;;;150        /* copy second buffer in reversal manner */
;;;151        *pScr2-- = *px++;
00002e  1f89              SUBS     r1,r1,#6
000030  8803              LDRH     r3,[r0,#0]
000032  80cb              STRH     r3,[r1,#6]
;;;152        *pScr2-- = *px++;
000034  8843              LDRH     r3,[r0,#2]
000036  808b              STRH     r3,[r1,#4]
;;;153        *pScr2-- = *px++;
000038  8883              LDRH     r3,[r0,#4]
00003a  804b              STRH     r3,[r1,#2]
;;;154        *pScr2-- = *px++;
00003c  88c3              LDRH     r3,[r0,#6]
00003e  3008              ADDS     r0,r0,#8
000040  f8213902          STRH     r3,[r1],#-2
;;;155    
;;;156        /* Decrement the loop counter */
;;;157        k--;
000044  1e52              SUBS     r2,r2,#1
                  |L1.70|
000046  2a00              CMP      r2,#0                 ;148
000048  d1f1              BNE      |L1.46|
;;;158      }
;;;159    
;;;160      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;161       ** No loop unrolling is used. */
;;;162      k = srcBLen % 0x4u;
00004a  f0070203          AND      r2,r7,#3
00004e  9203              STR      r2,[sp,#0xc]
;;;163    
;;;164      while(k > 0u)
000050  e004              B        |L1.92|
                  |L1.82|
;;;165      {
;;;166        /* copy second buffer in reversal manner for remaining samples */
;;;167        *pScr2-- = *px++;
000052  f8303b02          LDRH     r3,[r0],#2
000056  f8213902          STRH     r3,[r1],#-2
;;;168    
;;;169        /* Decrement the loop counter */
;;;170        k--;
00005a  1e52              SUBS     r2,r2,#1
                  |L1.92|
00005c  2a00              CMP      r2,#0                 ;164
00005e  d1f8              BNE      |L1.82|
;;;171      }
;;;172    
;;;173      /* Initialze temporary scratch pointer */
;;;174      pScr1 = pScratch1;
;;;175    
;;;176      /* Assuming scratch1 buffer is aligned by 32-bit */
;;;177      /* Fill (srcBLen - 1u) zeros in scratch1 buffer */
;;;178      arm_fill_q15(0, pScr1, (srcBLen - 1u));
000060  1e7a              SUBS     r2,r7,#1
000062  4641              MOV      r1,r8
000064  2000              MOVS     r0,#0
000066  f7fffffe          BL       arm_fill_q15
;;;179    
;;;180      /* Update temporary scratch pointer */
;;;181      pScr1 += (srcBLen - 1u);
00006a  1e78              SUBS     r0,r7,#1
00006c  eb080940          ADD      r9,r8,r0,LSL #1
;;;182    
;;;183      /* Copy bigger length sequence(srcALen) samples in scratch1 buffer */
;;;184    
;;;185    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;186    
;;;187      /* Copy (srcALen) samples in scratch buffer */
;;;188      arm_copy_q15(pIn1, pScr1, srcALen);
000070  462a              MOV      r2,r5
000072  4649              MOV      r1,r9
000074  4630              MOV      r0,r6
000076  f7fffffe          BL       arm_copy_q15
;;;189    
;;;190      /* Update pointers */
;;;191      pScr1 += srcALen;
00007a  eb090145          ADD      r1,r9,r5,LSL #1
;;;192    
;;;193    #else
;;;194    
;;;195      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;196      k = srcALen >> 2u;
;;;197    
;;;198      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;199       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;200      while(k > 0u)
;;;201      {
;;;202        /* copy second buffer in reversal manner */
;;;203        *pScr1++ = *pIn1++;
;;;204        *pScr1++ = *pIn1++;
;;;205        *pScr1++ = *pIn1++;
;;;206        *pScr1++ = *pIn1++;
;;;207    
;;;208        /* Decrement the loop counter */
;;;209        k--;
;;;210      }
;;;211    
;;;212      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;213       ** No loop unrolling is used. */
;;;214      k = srcALen % 0x4u;
;;;215    
;;;216      while(k > 0u)
;;;217      {
;;;218        /* copy second buffer in reversal manner for remaining samples */
;;;219        *pScr1++ = *pIn1++;
;;;220    
;;;221        /* Decrement the loop counter */
;;;222        k--;
;;;223      }
;;;224    
;;;225    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;226    
;;;227    
;;;228    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;229    
;;;230      /* Fill (srcBLen - 1u) zeros at end of scratch buffer */
;;;231      arm_fill_q15(0, pScr1, (srcBLen - 1u));
00007e  1e7a              SUBS     r2,r7,#1
000080  2000              MOVS     r0,#0
000082  f7fffffe          BL       arm_fill_q15
;;;232    
;;;233      /* Update pointer */
;;;234      pScr1 += (srcBLen - 1u);
;;;235    
;;;236    #else
;;;237    
;;;238      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;239      k = (srcBLen - 1u) >> 2u;
;;;240    
;;;241      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;242       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;243      while(k > 0u)
;;;244      {
;;;245        /* copy second buffer in reversal manner */
;;;246        *pScr1++ = 0;
;;;247        *pScr1++ = 0;
;;;248        *pScr1++ = 0;
;;;249        *pScr1++ = 0;
;;;250    
;;;251        /* Decrement the loop counter */
;;;252        k--;
;;;253      }
;;;254    
;;;255      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;256       ** No loop unrolling is used. */
;;;257      k = (srcBLen - 1u) % 0x4u;
;;;258    
;;;259      while(k > 0u)
;;;260      {
;;;261        /* copy second buffer in reversal manner for remaining samples */
;;;262        *pScr1++ = 0;
;;;263    
;;;264        /* Decrement the loop counter */
;;;265        k--;
;;;266      }
;;;267    
;;;268    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;269    
;;;270      /* Temporary pointer for scratch2 */
;;;271      py = pScratch2;
000086  9401              STR      r4,[sp,#4]
;;;272    
;;;273    
;;;274      /* Initialization of pIn2 pointer */
;;;275      pIn2 = py;
000088  9c01              LDR      r4,[sp,#4]
;;;276    
;;;277      /* First part of the processing with loop unrolling process 4 data points at a time.       
;;;278       ** a second loop below process for the remaining 1 to 3 samples. */
;;;279    
;;;280      /* Actual convolution process starts here */
;;;281      blkCnt = (srcALen + srcBLen - 1u) >> 2;
00008a  19e8              ADDS     r0,r5,r7
00008c  1e40              SUBS     r0,r0,#1
00008e  9002              STR      r0,[sp,#8]
000090  0880              LSRS     r0,r0,#2
000092  9000              STR      r0,[sp,#0]
;;;282    
;;;283      while(blkCnt > 0)
000094  e05c              B        |L1.336|
                  |L1.150|
;;;284      {
;;;285        /* Initialze temporary scratch pointer as scratch1 */
;;;286        pScr1 = pScratch1;
000096  4645              MOV      r5,r8
;;;287    
;;;288        /* Clear Accumlators */
;;;289        acc0 = 0;
000098  2200              MOVS     r2,#0
;;;290        acc1 = 0;
00009a  2600              MOVS     r6,#0
;;;291        acc2 = 0;
00009c  2300              MOVS     r3,#0
;;;292        acc3 = 0;
00009e  4694              MOV      r12,r2
;;;293    
;;;294        /* Read two samples from scratch1 buffer */
;;;295        x1 = *__SIMD32(pScr1)++;
0000a0  6828              LDR      r0,[r5,#0]
;;;296    
;;;297        /* Read next two samples from scratch1 buffer */
;;;298        x2 = *__SIMD32(pScr1)++;
0000a2  6869              LDR      r1,[r5,#4]
0000a4  3508              ADDS     r5,r5,#8
;;;299    
;;;300        tapCnt = (srcBLen) >> 2u;
0000a6  f8dde010          LDR      lr,[sp,#0x10]
;;;301    
;;;302        while(tapCnt > 0u)
0000aa  e01f              B        |L1.236|
                  |L1.172|
;;;303        {
;;;304    
;;;305    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;306    
;;;307          /* Read four samples from smaller buffer */
;;;308          y1 = _SIMD32_OFFSET(pIn2);
0000ac  f8d4a000          LDR      r10,[r4,#0]
;;;309          y2 = _SIMD32_OFFSET(pIn2 + 2u);
0000b0  f8d49004          LDR      r9,[r4,#4]
;;;310    
;;;311          /* multiply and accumlate */
;;;312          acc0 = __SMLAD(x1, y1, acc0);
0000b4  fb20220a          SMLAD    r2,r0,r10,r2
;;;313          acc2 = __SMLAD(x2, y1, acc2);
0000b8  fb21330a          SMLAD    r3,r1,r10,r3
;;;314    
;;;315          /* pack input data */
;;;316    #ifndef ARM_MATH_BIG_ENDIAN
;;;317          x3 = __PKHBT(x2, x1, 0);
0000bc  eac10000          PKHBT    r0,r1,r0
;;;318    #else
;;;319          x3 = __PKHBT(x1, x2, 0);
;;;320    #endif
;;;321    
;;;322          /* multiply and accumlate */
;;;323          acc1 = __SMLADX(x3, y1, acc1);
0000c0  fb20661a          SMLADX   r6,r0,r10,r6
;;;324    
;;;325          /* Read next two samples from scratch1 buffer */
;;;326          x1 = _SIMD32_OFFSET(pScr1);
0000c4  6828              LDR      r0,[r5,#0]
;;;327    
;;;328          /* multiply and accumlate */
;;;329          acc0 = __SMLAD(x2, y2, acc0);
0000c6  fb212209          SMLAD    r2,r1,r9,r2
;;;330          acc2 = __SMLAD(x1, y2, acc2);
0000ca  fb203309          SMLAD    r3,r0,r9,r3
;;;331    
;;;332          /* pack input data */
;;;333    #ifndef ARM_MATH_BIG_ENDIAN
;;;334          x3 = __PKHBT(x1, x2, 0);
0000ce  eac00101          PKHBT    r1,r0,r1
;;;335    #else
;;;336          x3 = __PKHBT(x2, x1, 0);
;;;337    #endif
;;;338    
;;;339          acc3 = __SMLADX(x3, y1, acc3);
0000d2  fb21cc1a          SMLADX   r12,r1,r10,r12
;;;340          acc1 = __SMLADX(x3, y2, acc1);
0000d6  fb216619          SMLADX   r6,r1,r9,r6
;;;341    
;;;342          x2 = _SIMD32_OFFSET(pScr1 + 2u);
0000da  6869              LDR      r1,[r5,#4]
;;;343    
;;;344    #ifndef ARM_MATH_BIG_ENDIAN
;;;345          x3 = __PKHBT(x2, x1, 0);
0000dc  eac10a00          PKHBT    r10,r1,r0
;;;346    #else
;;;347          x3 = __PKHBT(x1, x2, 0);
;;;348    #endif
;;;349    
;;;350          acc3 = __SMLADX(x3, y2, acc3);
0000e0  fb2acc19          SMLADX   r12,r10,r9,r12
;;;351    
;;;352    #else	 
;;;353    
;;;354          /* Read four samples from smaller buffer */
;;;355    	  a = *pIn2;
;;;356    	  b = *(pIn2 + 1);
;;;357    
;;;358    #ifndef ARM_MATH_BIG_ENDIAN
;;;359          y1 = __PKHBT(a, b, 16);
;;;360    #else
;;;361          y1 = __PKHBT(b, a, 16);
;;;362    #endif
;;;363    	  
;;;364    	  a = *(pIn2 + 2);
;;;365    	  b = *(pIn2 + 3);
;;;366    #ifndef ARM_MATH_BIG_ENDIAN
;;;367          y2 = __PKHBT(a, b, 16);
;;;368    #else
;;;369          y2 = __PKHBT(b, a, 16);
;;;370    #endif				
;;;371    
;;;372          acc0 = __SMLAD(x1, y1, acc0);
;;;373    
;;;374          acc2 = __SMLAD(x2, y1, acc2);
;;;375    
;;;376    #ifndef ARM_MATH_BIG_ENDIAN
;;;377          x3 = __PKHBT(x2, x1, 0);
;;;378    #else
;;;379          x3 = __PKHBT(x1, x2, 0);
;;;380    #endif
;;;381    
;;;382          acc1 = __SMLADX(x3, y1, acc1);
;;;383    
;;;384    	  a = *pScr1;
;;;385    	  b = *(pScr1 + 1);
;;;386    
;;;387    #ifndef ARM_MATH_BIG_ENDIAN
;;;388          x1 = __PKHBT(a, b, 16);
;;;389    #else
;;;390          x1 = __PKHBT(b, a, 16);
;;;391    #endif
;;;392    
;;;393          acc0 = __SMLAD(x2, y2, acc0);
;;;394    
;;;395          acc2 = __SMLAD(x1, y2, acc2);
;;;396    
;;;397    #ifndef ARM_MATH_BIG_ENDIAN
;;;398          x3 = __PKHBT(x1, x2, 0);
;;;399    #else
;;;400          x3 = __PKHBT(x2, x1, 0);
;;;401    #endif
;;;402    
;;;403          acc3 = __SMLADX(x3, y1, acc3);
;;;404    
;;;405          acc1 = __SMLADX(x3, y2, acc1);
;;;406    
;;;407    	  a = *(pScr1 + 2);
;;;408    	  b = *(pScr1 + 3);
;;;409    
;;;410    #ifndef ARM_MATH_BIG_ENDIAN
;;;411          x2 = __PKHBT(a, b, 16);
;;;412    #else
;;;413          x2 = __PKHBT(b, a, 16);
;;;414    #endif
;;;415    
;;;416    #ifndef ARM_MATH_BIG_ENDIAN
;;;417          x3 = __PKHBT(x2, x1, 0);
;;;418    #else
;;;419          x3 = __PKHBT(x1, x2, 0);
;;;420    #endif
;;;421    
;;;422          acc3 = __SMLADX(x3, y2, acc3);
;;;423    
;;;424    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;425    
;;;426          /* update scratch pointers */
;;;427          pIn2 += 4u;
0000e4  3408              ADDS     r4,r4,#8
;;;428          pScr1 += 4u;
0000e6  3508              ADDS     r5,r5,#8
;;;429    
;;;430    
;;;431          /* Decrement the loop counter */
;;;432          tapCnt--;
0000e8  f1ae0e01          SUB      lr,lr,#1
                  |L1.236|
0000ec  f1be0f00          CMP      lr,#0                 ;302
0000f0  d1dc              BNE      |L1.172|
;;;433        }
;;;434    
;;;435        /* Update scratch pointer for remaining samples of smaller length sequence */
;;;436        pScr1 -= 4u;
0000f2  3d08              SUBS     r5,r5,#8
;;;437    
;;;438        /* apply same above for remaining samples of smaller length sequence */
;;;439        tapCnt = (srcBLen) & 3u;
0000f4  9903              LDR      r1,[sp,#0xc]
;;;440    
;;;441        while(tapCnt > 0u)
0000f6  e013              B        |L1.288|
                  |L1.248|
;;;442        {
;;;443    
;;;444          /* accumlate the results */
;;;445          acc0 += (*pScr1++ * *pIn2);
0000f8  f8359b02          LDRH     r9,[r5],#2
0000fc  f8340b02          LDRH     r0,[r4],#2
000100  fb192200          SMLABB   r2,r9,r0,r2
;;;446          acc1 += (*pScr1++ * *pIn2);
000104  f8359b02          LDRH     r9,[r5],#2
000108  fb196600          SMLABB   r6,r9,r0,r6
;;;447          acc2 += (*pScr1++ * *pIn2);
00010c  f8359b02          LDRH     r9,[r5],#2
000110  fb193300          SMLABB   r3,r9,r0,r3
;;;448          acc3 += (*pScr1++ * *pIn2++);
000114  f8b59000          LDRH     r9,[r5,#0]
000118  fb19cc00          SMLABB   r12,r9,r0,r12
;;;449    
;;;450          pScr1 -= 3u;
00011c  1f2d              SUBS     r5,r5,#4
;;;451    
;;;452          /* Decrement the loop counter */
;;;453          tapCnt--;
00011e  1e49              SUBS     r1,r1,#1
                  |L1.288|
000120  2900              CMP      r1,#0                 ;441
000122  d1e9              BNE      |L1.248|
;;;454        }
;;;455    
;;;456        blkCnt--;
000124  9800              LDR      r0,[sp,#0]
000126  1e40              SUBS     r0,r0,#1
000128  9000              STR      r0,[sp,#0]
;;;457    
;;;458    
;;;459        /* Store the results in the accumulators in the destination buffer. */
;;;460    
;;;461    #ifndef ARM_MATH_BIG_ENDIAN
;;;462    
;;;463        *__SIMD32(pOut)++ =
00012a  f32230cf          SSAT     r0,#16,r2,ASR #15
00012e  f32631cf          SSAT     r1,#16,r6,ASR #15
000132  eac04001          PKHBT    r0,r0,r1,LSL #16
000136  f84b0b04          STR      r0,[r11],#4
;;;464          __PKHBT(__SSAT((acc0 >> 15), 16), __SSAT((acc1 >> 15), 16), 16);
;;;465    
;;;466        *__SIMD32(pOut)++ =
00013a  f32330cf          SSAT     r0,#16,r3,ASR #15
00013e  f32c31cf          SSAT     r1,#16,r12,ASR #15
000142  eac04001          PKHBT    r0,r0,r1,LSL #16
000146  f84b0b04          STR      r0,[r11],#4
;;;467          __PKHBT(__SSAT((acc2 >> 15), 16), __SSAT((acc3 >> 15), 16), 16);
;;;468    
;;;469    
;;;470    #else
;;;471    
;;;472        *__SIMD32(pOut)++ =
;;;473          __PKHBT(__SSAT((acc1 >> 15), 16), __SSAT((acc0 >> 15), 16), 16);
;;;474    
;;;475        *__SIMD32(pOut)++ =
;;;476          __PKHBT(__SSAT((acc3 >> 15), 16), __SSAT((acc2 >> 15), 16), 16);
;;;477    
;;;478    
;;;479    
;;;480    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN       */
;;;481    
;;;482        /* Initialization of inputB pointer */
;;;483        pIn2 = py;
00014a  9c01              LDR      r4,[sp,#4]
;;;484    
;;;485        pScratch1 += 4u;
00014c  f1080808          ADD      r8,r8,#8
                  |L1.336|
000150  9800              LDR      r0,[sp,#0]            ;283
000152  2800              CMP      r0,#0                 ;283
000154  d19f              BNE      |L1.150|
;;;486    
;;;487      }
;;;488    
;;;489    
;;;490      blkCnt = (srcALen + srcBLen - 1u) & 0x3;
000156  9802              LDR      r0,[sp,#8]
000158  f0000303          AND      r3,r0,#3
;;;491    
;;;492      /* Calculate convolution for remaining samples of Bigger length sequence */
;;;493      while(blkCnt > 0)
00015c  e024              B        |L1.424|
                  |L1.350|
;;;494      {
;;;495        /* Initialze temporary scratch pointer as scratch1 */
;;;496        pScr1 = pScratch1;
00015e  4640              MOV      r0,r8
;;;497    
;;;498        /* Clear Accumlators */
;;;499        acc0 = 0;
000160  2100              MOVS     r1,#0
;;;500    
;;;501        tapCnt = (srcBLen) >> 1u;
000162  087a              LSRS     r2,r7,#1
;;;502    
;;;503        while(tapCnt > 0u)
000164  e00a              B        |L1.380|
                  |L1.358|
;;;504        {
;;;505    
;;;506          acc0 += (*pScr1++ * *pIn2++);
000166  8805              LDRH     r5,[r0,#0]
000168  8826              LDRH     r6,[r4,#0]
00016a  fb151106          SMLABB   r1,r5,r6,r1
;;;507          acc0 += (*pScr1++ * *pIn2++);
00016e  8845              LDRH     r5,[r0,#2]
000170  1d00              ADDS     r0,r0,#4
000172  8866              LDRH     r6,[r4,#2]
000174  1d24              ADDS     r4,r4,#4
000176  fb151106          SMLABB   r1,r5,r6,r1
;;;508    
;;;509          /* Decrement the loop counter */
;;;510          tapCnt--;
00017a  1e52              SUBS     r2,r2,#1
                  |L1.380|
00017c  2a00              CMP      r2,#0                 ;503
00017e  d1f2              BNE      |L1.358|
;;;511        }
;;;512    
;;;513        tapCnt = (srcBLen) & 1u;
000180  f0070201          AND      r2,r7,#1
;;;514    
;;;515        /* apply same above for remaining samples of smaller length sequence */
;;;516        while(tapCnt > 0u)
000184  e006              B        |L1.404|
                  |L1.390|
;;;517        {
;;;518    
;;;519          /* accumlate the results */
;;;520          acc0 += (*pScr1++ * *pIn2++);
000186  f8305b02          LDRH     r5,[r0],#2
00018a  f8346b02          LDRH     r6,[r4],#2
00018e  fb151106          SMLABB   r1,r5,r6,r1
;;;521    
;;;522          /* Decrement the loop counter */
;;;523          tapCnt--;
000192  1e52              SUBS     r2,r2,#1
                  |L1.404|
000194  2a00              CMP      r2,#0                 ;516
000196  d1f6              BNE      |L1.390|
;;;524        }
;;;525    
;;;526        blkCnt--;
000198  1e5b              SUBS     r3,r3,#1
;;;527    
;;;528        /* The result is in 2.30 format.  Convert to 1.15 with saturation.       
;;;529         ** Then store the output in the destination buffer. */
;;;530        *pOut++ = (q15_t) (__SSAT((acc0 >> 15), 16));
00019a  f32130cf          SSAT     r0,#16,r1,ASR #15
00019e  f82b0b02          STRH     r0,[r11],#2
;;;531    
;;;532        /* Initialization of inputB pointer */
;;;533        pIn2 = py;
0001a2  9c01              LDR      r4,[sp,#4]
;;;534    
;;;535        pScratch1 += 1u;
0001a4  f1080802          ADD      r8,r8,#2
                  |L1.424|
0001a8  2b00              CMP      r3,#0                 ;493
0001aa  d1d8              BNE      |L1.350|
;;;536    
;;;537      }
;;;538    
;;;539    }
0001ac  b005              ADD      sp,sp,#0x14
0001ae  e8bd8ff0          POP      {r4-r11,pc}
;;;540    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_fast_opt_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_conv_fast_opt_q15_c_c4fc4475____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___23_arm_conv_fast_opt_q15_c_c4fc4475____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_conv_fast_opt_q15_c_c4fc4475____REVSH|
#line 144
|__asm___23_arm_conv_fast_opt_q15_c_c4fc4475____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_conv_fast_opt_q15_c_c4fc4475____RRX|
#line 300
|__asm___23_arm_conv_fast_opt_q15_c_c4fc4475____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
