; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_biquad_cascade_df1_32x64_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_biquad_cascade_df1_32x64_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_biquad_cascade_df1_32x64_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_biquad_cascade_df1_32x64_q31.c]
                          THUMB

                          AREA ||i.arm_biquad_cas_df1_32x64_q31||, CODE, READONLY, ALIGN=1

                  arm_biquad_cas_df1_32x64_q31 PROC
;;;186    
;;;187    void arm_biquad_cas_df1_32x64_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;188      const arm_biquad_cas_df1_32x64_ins_q31 * S,
;;;189      q31_t * pSrc,
;;;190      q31_t * pDst,
;;;191      uint32_t blockSize)
;;;192    {
000004  b091              SUB      sp,sp,#0x44
;;;193      q31_t *pIn = pSrc;                             /*  input pointer initialization  */
000006  910f              STR      r1,[sp,#0x3c]
;;;194      q31_t *pOut = pDst;                            /*  output pointer initialization */
000008  f8dda04c          LDR      r10,[sp,#0x4c]
;;;195      q63_t *pState = S->pState;                     /*  state pointer initialization  */
00000c  6841              LDR      r1,[r0,#4]
00000e  910e              STR      r1,[sp,#0x38]
;;;196      q31_t *pCoeffs = S->pCoeffs;                   /*  coeff pointer initialization  */
000010  6881              LDR      r1,[r0,#8]
000012  910d              STR      r1,[sp,#0x34]
;;;197      q63_t acc;                                     /*  accumulator                   */
;;;198      q31_t Xn1, Xn2;                                /*  Input Filter state variables        */
;;;199      q63_t Yn1, Yn2;                                /*  Output Filter state variables        */
;;;200      q31_t b0, b1, b2, a1, a2;                      /*  Filter coefficients           */
;;;201      q31_t Xn;                                      /*  temporary input               */
;;;202      int32_t shift = (int32_t) S->postShift + 1;    /*  Shift to be applied to the output */
000014  7b01              LDRB     r1,[r0,#0xc]
000016  1c4a              ADDS     r2,r1,#1
000018  9204              STR      r2,[sp,#0x10]
;;;203      uint32_t sample, stage = S->numStages;         /*  loop counters                     */
00001a  7800              LDRB     r0,[r0,#0]
00001c  9002              STR      r0,[sp,#8]
;;;204      q31_t acc_l, acc_h;                            /*  temporary output               */
;;;205      uint32_t uShift = ((uint32_t) S->postShift + 1u);
00001e  1c49              ADDS     r1,r1,#1
000020  9101              STR      r1,[sp,#4]
;;;206      uint32_t lShift = 32u - uShift;                /*  Shift to be applied to the output */
000022  9901              LDR      r1,[sp,#4]
000024  f1c10020          RSB      r0,r1,#0x20
000028  9000              STR      r0,[sp,#0]
;;;207    
;;;208    
;;;209    #ifndef ARM_MATH_CM0_FAMILY
;;;210    
;;;211      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;212    
;;;213      do
;;;214      {
;;;215        /* Reading the coefficients */
;;;216        b0 = *pCoeffs++;
;;;217        b1 = *pCoeffs++;
;;;218        b2 = *pCoeffs++;
;;;219        a1 = *pCoeffs++;
;;;220        a2 = *pCoeffs++;
;;;221    
;;;222        /* Reading the state values */
;;;223        Xn1 = (q31_t) (pState[0]);
;;;224        Xn2 = (q31_t) (pState[1]);
;;;225        Yn1 = pState[2];
;;;226        Yn2 = pState[3];
;;;227    
;;;228        /* Apply loop unrolling and compute 4 output values simultaneously. */
;;;229        /* The variable acc hold output value that is being computed and    
;;;230         * stored in the destination buffer    
;;;231         * acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2]    
;;;232         */
;;;233    
;;;234        sample = blockSize >> 2u;
00002a  9814              LDR      r0,[sp,#0x50]
00002c  0880              LSRS     r0,r0,#2
00002e  9010              STR      r0,[sp,#0x40]
                  |L1.48|
000030  980d              LDR      r0,[sp,#0x34]         ;216
000032  6800              LDR      r0,[r0,#0]            ;216
000034  900a              STR      r0,[sp,#0x28]         ;216
000036  980d              LDR      r0,[sp,#0x34]         ;216
000038  6841              LDR      r1,[r0,#4]            ;217
00003a  9109              STR      r1,[sp,#0x24]         ;217
00003c  6881              LDR      r1,[r0,#8]            ;218
00003e  9108              STR      r1,[sp,#0x20]         ;218
000040  68c1              LDR      r1,[r0,#0xc]          ;219
000042  9107              STR      r1,[sp,#0x1c]         ;219
000044  6901              LDR      r1,[r0,#0x10]         ;220
000046  3014              ADDS     r0,r0,#0x14           ;220
000048  9106              STR      r1,[sp,#0x18]         ;220
00004a  900d              STR      r0,[sp,#0x34]         ;220
00004c  980e              LDR      r0,[sp,#0x38]         ;223
00004e  f8d0b000          LDR      r11,[r0,#0]           ;223
000052  980e              LDR      r0,[sp,#0x38]         ;224
000054  6880              LDR      r0,[r0,#8]            ;224
000056  900b              STR      r0,[sp,#0x2c]         ;224
000058  980e              LDR      r0,[sp,#0x38]         ;225
00005a  e9d06704          LDRD     r6,r7,[r0,#0x10]      ;225
00005e  980e              LDR      r0,[sp,#0x38]         ;226
000060  e9d08906          LDRD     r8,r9,[r0,#0x18]      ;226
000064  9810              LDR      r0,[sp,#0x40]
000066  9003              STR      r0,[sp,#0xc]
;;;235    
;;;236        /* First part of the processing with loop unrolling. Compute 4 outputs at a time.    
;;;237         ** a second loop below computes the remaining 1 to 3 samples. */
;;;238        while(sample > 0u)
000068  e0b9              B        |L1.478|
                  |L1.106|
;;;239        {
;;;240          /* Read the input */
;;;241          Xn = *pIn++;
00006a  980f              LDR      r0,[sp,#0x3c]
00006c  6800              LDR      r0,[r0,#0]
00006e  9005              STR      r0,[sp,#0x14]
000070  980f              LDR      r0,[sp,#0x3c]
000072  1d00              ADDS     r0,r0,#4
000074  900f              STR      r0,[sp,#0x3c]
;;;242    
;;;243          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;244    
;;;245          /* acc =  b0 * x[n] */
;;;246          acc = (q63_t) Xn *b0;
000076  990a              LDR      r1,[sp,#0x28]
000078  9805              LDR      r0,[sp,#0x14]
00007a  fb804501          SMULL    r4,r5,r0,r1
;;;247    
;;;248          /* acc +=  b1 * x[n-1] */
;;;249          acc += (q63_t) Xn1 *b1;
00007e  9809              LDR      r0,[sp,#0x24]
000080  fbcb4500          SMLAL    r4,r5,r11,r0
;;;250    
;;;251          /* acc +=  b[2] * x[n-2] */
;;;252          acc += (q63_t) Xn2 *b2;
000084  9908              LDR      r1,[sp,#0x20]
000086  980b              LDR      r0,[sp,#0x2c]
000088  fbc04501          SMLAL    r4,r5,r0,r1
;;;253    
;;;254          /* acc +=  a1 * y[n-1] */
;;;255          acc += mult32x64(Yn1, a1);
00008c  4630              MOV      r0,r6
00008e  4639              MOV      r1,r7
000090  9a07              LDR      r2,[sp,#0x1c]
000092  f7fffffe          BL       mult32x64
000096  1904              ADDS     r4,r0,r4
000098  414d              ADCS     r5,r5,r1
;;;256    
;;;257          /* acc +=  a2 * y[n-2] */
;;;258          acc += mult32x64(Yn2, a2);
00009a  4640              MOV      r0,r8
00009c  4649              MOV      r1,r9
00009e  9a06              LDR      r2,[sp,#0x18]
0000a0  f7fffffe          BL       mult32x64
0000a4  1904              ADDS     r4,r0,r4
0000a6  414d              ADCS     r5,r5,r1
;;;259    
;;;260          /* The result is converted to 1.63 , Yn2 variable is reused */
;;;261          Yn2 = acc << shift;
0000a8  4620              MOV      r0,r4
0000aa  4629              MOV      r1,r5
0000ac  9a04              LDR      r2,[sp,#0x10]
0000ae  f7fffffe          BL       __aeabi_llsl
0000b2  4680              MOV      r8,r0
0000b4  4689              MOV      r9,r1
;;;262    
;;;263          /* Calc lower part of acc */
;;;264          acc_l = acc & 0xffffffff;
;;;265    
;;;266          /* Calc upper part of acc */
;;;267          acc_h = (acc >> 32) & 0xffffffff;
;;;268    
;;;269          /* Apply shift for lower part of acc and upper part of acc */
;;;270          acc_h = (uint32_t) acc_l >> lShift | acc_h << uShift;
0000b6  9800              LDR      r0,[sp,#0]
0000b8  40c4              LSRS     r4,r4,r0
0000ba  9801              LDR      r0,[sp,#4]
0000bc  4085              LSLS     r5,r5,r0
0000be  432c              ORRS     r4,r4,r5
;;;271    
;;;272          /* Store the output in the destination buffer in 1.31 format. */
;;;273          *pOut = acc_h;
0000c0  f8ca4000          STR      r4,[r10,#0]
;;;274    
;;;275          /* Read the second input into Xn2, to reuse the value */
;;;276          Xn2 = *pIn++;
0000c4  980f              LDR      r0,[sp,#0x3c]
0000c6  6800              LDR      r0,[r0,#0]
0000c8  900b              STR      r0,[sp,#0x2c]
0000ca  980f              LDR      r0,[sp,#0x3c]
0000cc  1d00              ADDS     r0,r0,#4
0000ce  900f              STR      r0,[sp,#0x3c]
;;;277    
;;;278          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;279    
;;;280          /* acc +=  b1 * x[n-1] */
;;;281          acc = (q63_t) Xn *b1;
0000d0  9909              LDR      r1,[sp,#0x24]
0000d2  9805              LDR      r0,[sp,#0x14]
0000d4  fb804501          SMULL    r4,r5,r0,r1
;;;282    
;;;283          /* acc =  b0 * x[n] */
;;;284          acc += (q63_t) Xn2 *b0;
0000d8  e9dd100a          LDRD     r1,r0,[sp,#0x28]
0000dc  fbc04501          SMLAL    r4,r5,r0,r1
;;;285    
;;;286          /* acc +=  b[2] * x[n-2] */
;;;287          acc += (q63_t) Xn1 *b2;
0000e0  9808              LDR      r0,[sp,#0x20]
0000e2  fbcb4500          SMLAL    r4,r5,r11,r0
;;;288    
;;;289          /* acc +=  a1 * y[n-1] */
;;;290          acc += mult32x64(Yn2, a1);
0000e6  4640              MOV      r0,r8
0000e8  4649              MOV      r1,r9
0000ea  9a07              LDR      r2,[sp,#0x1c]
0000ec  f7fffffe          BL       mult32x64
0000f0  1904              ADDS     r4,r0,r4
0000f2  414d              ADCS     r5,r5,r1
;;;291    
;;;292          /* acc +=  a2 * y[n-2] */
;;;293          acc += mult32x64(Yn1, a2);
0000f4  4630              MOV      r0,r6
0000f6  4639              MOV      r1,r7
0000f8  9a06              LDR      r2,[sp,#0x18]
0000fa  f7fffffe          BL       mult32x64
0000fe  1904              ADDS     r4,r0,r4
000100  414d              ADCS     r5,r5,r1
;;;294    
;;;295          /* The result is converted to 1.63, Yn1 variable is reused */
;;;296          Yn1 = acc << shift;
000102  4620              MOV      r0,r4
000104  4629              MOV      r1,r5
000106  9a04              LDR      r2,[sp,#0x10]
000108  f7fffffe          BL       __aeabi_llsl
00010c  4606              MOV      r6,r0
00010e  460f              MOV      r7,r1
;;;297    
;;;298          /* Calc lower part of acc */
;;;299          acc_l = acc & 0xffffffff;
;;;300    
;;;301          /* Calc upper part of acc */
;;;302          acc_h = (acc >> 32) & 0xffffffff;
;;;303    
;;;304          /* Apply shift for lower part of acc and upper part of acc */
;;;305          acc_h = (uint32_t) acc_l >> lShift | acc_h << uShift;
000110  9800              LDR      r0,[sp,#0]
000112  40c4              LSRS     r4,r4,r0
000114  9801              LDR      r0,[sp,#4]
000116  4085              LSLS     r5,r5,r0
000118  432c              ORRS     r4,r4,r5
;;;306    
;;;307          /* Read the third input into Xn1, to reuse the value */
;;;308          Xn1 = *pIn++;
00011a  980f              LDR      r0,[sp,#0x3c]
00011c  6800              LDR      r0,[r0,#0]
00011e  900c              STR      r0,[sp,#0x30]
000120  980f              LDR      r0,[sp,#0x3c]
000122  1d00              ADDS     r0,r0,#4
000124  900f              STR      r0,[sp,#0x3c]
;;;309    
;;;310          /* The result is converted to 1.31 */
;;;311          /* Store the output in the destination buffer. */
;;;312          *(pOut + 1u) = acc_h;
000126  f8ca4004          STR      r4,[r10,#4]
;;;313    
;;;314          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;315    
;;;316          /* acc =  b0 * x[n] */
;;;317          acc = (q63_t) Xn1 *b0;
00012a  990a              LDR      r1,[sp,#0x28]
00012c  980c              LDR      r0,[sp,#0x30]
00012e  fb804501          SMULL    r4,r5,r0,r1
;;;318    
;;;319          /* acc +=  b1 * x[n-1] */
;;;320          acc += (q63_t) Xn2 *b1;
000132  9909              LDR      r1,[sp,#0x24]
000134  980b              LDR      r0,[sp,#0x2c]
000136  fbc04501          SMLAL    r4,r5,r0,r1
;;;321    
;;;322          /* acc +=  b[2] * x[n-2] */
;;;323          acc += (q63_t) Xn *b2;
00013a  9908              LDR      r1,[sp,#0x20]
00013c  9805              LDR      r0,[sp,#0x14]
00013e  fbc04501          SMLAL    r4,r5,r0,r1
;;;324    
;;;325          /* acc +=  a1 * y[n-1] */
;;;326          acc += mult32x64(Yn1, a1);
000142  4630              MOV      r0,r6
000144  4639              MOV      r1,r7
000146  9a07              LDR      r2,[sp,#0x1c]
000148  f7fffffe          BL       mult32x64
00014c  1904              ADDS     r4,r0,r4
00014e  414d              ADCS     r5,r5,r1
;;;327    
;;;328          /* acc +=  a2 * y[n-2] */
;;;329          acc += mult32x64(Yn2, a2);
000150  4640              MOV      r0,r8
000152  4649              MOV      r1,r9
000154  9a06              LDR      r2,[sp,#0x18]
000156  f7fffffe          BL       mult32x64
00015a  1904              ADDS     r4,r0,r4
00015c  414d              ADCS     r5,r5,r1
;;;330    
;;;331          /* The result is converted to 1.63, Yn2 variable is reused  */
;;;332          Yn2 = acc << shift;
00015e  4620              MOV      r0,r4
000160  4629              MOV      r1,r5
000162  9a04              LDR      r2,[sp,#0x10]
000164  f7fffffe          BL       __aeabi_llsl
000168  4680              MOV      r8,r0
00016a  4689              MOV      r9,r1
;;;333    
;;;334          /* Calc lower part of acc */
;;;335          acc_l = acc & 0xffffffff;
;;;336    
;;;337          /* Calc upper part of acc */
;;;338          acc_h = (acc >> 32) & 0xffffffff;
;;;339    
;;;340          /* Apply shift for lower part of acc and upper part of acc */
;;;341          acc_h = (uint32_t) acc_l >> lShift | acc_h << uShift;
00016c  9800              LDR      r0,[sp,#0]
00016e  40c4              LSRS     r4,r4,r0
000170  9801              LDR      r0,[sp,#4]
000172  4085              LSLS     r5,r5,r0
000174  432c              ORRS     r4,r4,r5
;;;342    
;;;343          /* Store the output in the destination buffer in 1.31 format. */
;;;344          *(pOut + 2u) = acc_h;
000176  f8ca4008          STR      r4,[r10,#8]
;;;345    
;;;346          /* Read the fourth input into Xn, to reuse the value */
;;;347          Xn = *pIn++;
00017a  980f              LDR      r0,[sp,#0x3c]
00017c  f850bb04          LDR      r11,[r0],#4
000180  900f              STR      r0,[sp,#0x3c]
;;;348    
;;;349          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;350          /* acc =  b0 * x[n] */
;;;351          acc = (q63_t) Xn *b0;
000182  980a              LDR      r0,[sp,#0x28]
000184  fb8b4500          SMULL    r4,r5,r11,r0
;;;352    
;;;353          /* acc +=  b1 * x[n-1] */
;;;354          acc += (q63_t) Xn1 *b1;
000188  9909              LDR      r1,[sp,#0x24]
00018a  980c              LDR      r0,[sp,#0x30]
00018c  fbc04501          SMLAL    r4,r5,r0,r1
;;;355    
;;;356          /* acc +=  b[2] * x[n-2] */
;;;357          acc += (q63_t) Xn2 *b2;
000190  9908              LDR      r1,[sp,#0x20]
000192  980b              LDR      r0,[sp,#0x2c]
000194  fbc04501          SMLAL    r4,r5,r0,r1
;;;358    
;;;359          /* acc +=  a1 * y[n-1] */
;;;360          acc += mult32x64(Yn2, a1);
000198  4640              MOV      r0,r8
00019a  4649              MOV      r1,r9
00019c  9a07              LDR      r2,[sp,#0x1c]
00019e  f7fffffe          BL       mult32x64
0001a2  1904              ADDS     r4,r0,r4
0001a4  414d              ADCS     r5,r5,r1
;;;361    
;;;362          /* acc +=  a2 * y[n-2] */
;;;363          acc += mult32x64(Yn1, a2);
0001a6  4630              MOV      r0,r6
0001a8  4639              MOV      r1,r7
0001aa  9a06              LDR      r2,[sp,#0x18]
0001ac  f7fffffe          BL       mult32x64
0001b0  1904              ADDS     r4,r0,r4
0001b2  414d              ADCS     r5,r5,r1
;;;364    
;;;365          /* The result is converted to 1.63, Yn1 variable is reused  */
;;;366          Yn1 = acc << shift;
0001b4  4620              MOV      r0,r4
0001b6  4629              MOV      r1,r5
0001b8  9a04              LDR      r2,[sp,#0x10]
0001ba  f7fffffe          BL       __aeabi_llsl
0001be  4606              MOV      r6,r0
0001c0  460f              MOV      r7,r1
;;;367    
;;;368          /* Calc lower part of acc */
;;;369          acc_l = acc & 0xffffffff;
;;;370    
;;;371          /* Calc upper part of acc */
;;;372          acc_h = (acc >> 32) & 0xffffffff;
;;;373    
;;;374          /* Apply shift for lower part of acc and upper part of acc */
;;;375          acc_h = (uint32_t) acc_l >> lShift | acc_h << uShift;
0001c2  9800              LDR      r0,[sp,#0]
0001c4  40c4              LSRS     r4,r4,r0
0001c6  9801              LDR      r0,[sp,#4]
0001c8  4085              LSLS     r5,r5,r0
0001ca  432c              ORRS     r4,r4,r5
;;;376    
;;;377          /* Store the output in the destination buffer in 1.31 format. */
;;;378          *(pOut + 3u) = acc_h;
0001cc  f8ca400c          STR      r4,[r10,#0xc]
;;;379    
;;;380          /* Every time after the output is computed state should be updated. */
;;;381          /* The states should be updated as:  */
;;;382          /* Xn2 = Xn1    */
;;;383          /* Xn1 = Xn     */
;;;384          /* Yn2 = Yn1    */
;;;385          /* Yn1 = acc    */
;;;386          Xn2 = Xn1;
0001d0  980c              LDR      r0,[sp,#0x30]
0001d2  900b              STR      r0,[sp,#0x2c]
;;;387          Xn1 = Xn;
;;;388    
;;;389          /* update output pointer */
;;;390          pOut += 4u;
0001d4  f10a0a10          ADD      r10,r10,#0x10
;;;391    
;;;392          /* decrement the loop counter */
;;;393          sample--;
0001d8  9803              LDR      r0,[sp,#0xc]
0001da  1e40              SUBS     r0,r0,#1
0001dc  9003              STR      r0,[sp,#0xc]
                  |L1.478|
0001de  9803              LDR      r0,[sp,#0xc]          ;238
0001e0  2800              CMP      r0,#0                 ;238
0001e2  f47faf42          BNE      |L1.106|
;;;394        }
;;;395    
;;;396        /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;397         ** No loop unrolling is used. */
;;;398        sample = (blockSize & 0x3u);
0001e6  9814              LDR      r0,[sp,#0x50]
0001e8  f0000003          AND      r0,r0,#3
0001ec  9003              STR      r0,[sp,#0xc]
;;;399    
;;;400        while(sample > 0u)
0001ee  e035              B        |L1.604|
                  |L1.496|
;;;401        {
;;;402          /* Read the input */
;;;403          Xn = *pIn++;
0001f0  980f              LDR      r0,[sp,#0x3c]
0001f2  6800              LDR      r0,[r0,#0]
0001f4  9005              STR      r0,[sp,#0x14]
0001f6  980f              LDR      r0,[sp,#0x3c]
0001f8  1d00              ADDS     r0,r0,#4
0001fa  900f              STR      r0,[sp,#0x3c]
;;;404    
;;;405          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;406    
;;;407          /* acc =  b0 * x[n] */
;;;408          acc = (q63_t) Xn *b0;
0001fc  990a              LDR      r1,[sp,#0x28]
0001fe  9805              LDR      r0,[sp,#0x14]
000200  fb804501          SMULL    r4,r5,r0,r1
;;;409          /* acc +=  b1 * x[n-1] */
;;;410          acc += (q63_t) Xn1 *b1;
000204  9809              LDR      r0,[sp,#0x24]
000206  fbcb4500          SMLAL    r4,r5,r11,r0
;;;411          /* acc +=  b[2] * x[n-2] */
;;;412          acc += (q63_t) Xn2 *b2;
00020a  9908              LDR      r1,[sp,#0x20]
00020c  980b              LDR      r0,[sp,#0x2c]
00020e  fbc04501          SMLAL    r4,r5,r0,r1
;;;413          /* acc +=  a1 * y[n-1] */
;;;414          acc += mult32x64(Yn1, a1);
000212  4630              MOV      r0,r6
000214  4639              MOV      r1,r7
000216  9a07              LDR      r2,[sp,#0x1c]
000218  f7fffffe          BL       mult32x64
00021c  1904              ADDS     r4,r0,r4
00021e  414d              ADCS     r5,r5,r1
;;;415          /* acc +=  a2 * y[n-2] */
;;;416          acc += mult32x64(Yn2, a2);
000220  4640              MOV      r0,r8
000222  4649              MOV      r1,r9
000224  9a06              LDR      r2,[sp,#0x18]
000226  f7fffffe          BL       mult32x64
00022a  1904              ADDS     r4,r0,r4
00022c  414d              ADCS     r5,r5,r1
;;;417    
;;;418          /* Every time after the output is computed state should be updated. */
;;;419          /* The states should be updated as:  */
;;;420          /* Xn2 = Xn1    */
;;;421          /* Xn1 = Xn     */
;;;422          /* Yn2 = Yn1    */
;;;423          /* Yn1 = acc    */
;;;424          Xn2 = Xn1;
00022e  f8cdb02c          STR      r11,[sp,#0x2c]
;;;425          Xn1 = Xn;
000232  f8ddb014          LDR      r11,[sp,#0x14]
;;;426          Yn2 = Yn1;
000236  46b9              MOV      r9,r7
000238  46b0              MOV      r8,r6
;;;427          /* The result is converted to 1.63, Yn1 variable is reused  */
;;;428          Yn1 = acc << shift;
00023a  4620              MOV      r0,r4
00023c  4629              MOV      r1,r5
00023e  9a04              LDR      r2,[sp,#0x10]
000240  f7fffffe          BL       __aeabi_llsl
000244  4606              MOV      r6,r0
000246  460f              MOV      r7,r1
;;;429    
;;;430          /* Calc lower part of acc */
;;;431          acc_l = acc & 0xffffffff;
;;;432    
;;;433          /* Calc upper part of acc */
;;;434          acc_h = (acc >> 32) & 0xffffffff;
;;;435    
;;;436          /* Apply shift for lower part of acc and upper part of acc */
;;;437          acc_h = (uint32_t) acc_l >> lShift | acc_h << uShift;
000248  9800              LDR      r0,[sp,#0]
00024a  40c4              LSRS     r4,r4,r0
00024c  9801              LDR      r0,[sp,#4]
00024e  4085              LSLS     r5,r5,r0
000250  432c              ORRS     r4,r4,r5
;;;438    
;;;439          /* Store the output in the destination buffer in 1.31 format. */
;;;440          *pOut++ = acc_h;
000252  f84a4b04          STR      r4,[r10],#4
;;;441          /* Yn1 = acc << shift; */
;;;442    
;;;443          /* Store the output in the destination buffer in 1.31 format. */
;;;444    /*      *pOut++ = (q31_t) (acc >> (32 - shift));  */
;;;445    
;;;446          /* decrement the loop counter */
;;;447          sample--;
000256  9803              LDR      r0,[sp,#0xc]
000258  1e40              SUBS     r0,r0,#1
00025a  9003              STR      r0,[sp,#0xc]
                  |L1.604|
00025c  9803              LDR      r0,[sp,#0xc]          ;400
00025e  2800              CMP      r0,#0                 ;400
000260  d1c6              BNE      |L1.496|
;;;448        }
;;;449    
;;;450        /*  The first stage output is given as input to the second stage. */
;;;451        pIn = pDst;
000262  f8dda04c          LDR      r10,[sp,#0x4c]
000266  f8cda03c          STR      r10,[sp,#0x3c]
;;;452    
;;;453        /* Reset to destination buffer working pointer */
;;;454        pOut = pDst;
00026a  f8dda04c          LDR      r10,[sp,#0x4c]
;;;455    
;;;456        /*  Store the updated state variables back into the pState array */
;;;457        /*  Store the updated state variables back into the pState array */
;;;458        *pState++ = (q63_t) Xn1;
00026e  980e              LDR      r0,[sp,#0x38]
000270  ea4f71eb          ASR      r1,r11,#31
000274  e9c0b100          STRD     r11,r1,[r0,#0]
000278  980e              LDR      r0,[sp,#0x38]
00027a  3008              ADDS     r0,r0,#8
;;;459        *pState++ = (q63_t) Xn2;
00027c  990b              LDR      r1,[sp,#0x2c]
00027e  17ca              ASRS     r2,r1,#31
000280  e9c01200          STRD     r1,r2,[r0,#0]
000284  3008              ADDS     r0,r0,#8
;;;460        *pState++ = Yn1;
000286  e9c06700          STRD     r6,r7,[r0,#0]
00028a  3008              ADDS     r0,r0,#8
;;;461        *pState++ = Yn2;
00028c  e9c08900          STRD     r8,r9,[r0,#0]
000290  3008              ADDS     r0,r0,#8
000292  900e              STR      r0,[sp,#0x38]
;;;462    
;;;463      } while(--stage);
000294  9802              LDR      r0,[sp,#8]
000296  1e40              SUBS     r0,r0,#1
000298  9002              STR      r0,[sp,#8]
00029a  f47faec9          BNE      |L1.48|
;;;464    
;;;465    #else
;;;466    
;;;467      /* Run the below code for Cortex-M0 */
;;;468    
;;;469      do
;;;470      {
;;;471        /* Reading the coefficients */
;;;472        b0 = *pCoeffs++;
;;;473        b1 = *pCoeffs++;
;;;474        b2 = *pCoeffs++;
;;;475        a1 = *pCoeffs++;
;;;476        a2 = *pCoeffs++;
;;;477    
;;;478        /* Reading the state values */
;;;479        Xn1 = pState[0];
;;;480        Xn2 = pState[1];
;;;481        Yn1 = pState[2];
;;;482        Yn2 = pState[3];
;;;483    
;;;484        /* The variable acc hold output value that is being computed and        
;;;485         * stored in the destination buffer            
;;;486         * acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2]            
;;;487         */
;;;488    
;;;489        sample = blockSize;
;;;490    
;;;491        while(sample > 0u)
;;;492        {
;;;493          /* Read the input */
;;;494          Xn = *pIn++;
;;;495    
;;;496          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;497          /* acc =  b0 * x[n] */
;;;498          acc = (q63_t) Xn *b0;
;;;499          /* acc +=  b1 * x[n-1] */
;;;500          acc += (q63_t) Xn1 *b1;
;;;501          /* acc +=  b[2] * x[n-2] */
;;;502          acc += (q63_t) Xn2 *b2;
;;;503          /* acc +=  a1 * y[n-1] */
;;;504          acc += mult32x64(Yn1, a1);
;;;505          /* acc +=  a2 * y[n-2] */
;;;506          acc += mult32x64(Yn2, a2);
;;;507    
;;;508          /* Every time after the output is computed state should be updated. */
;;;509          /* The states should be updated as:  */
;;;510          /* Xn2 = Xn1    */
;;;511          /* Xn1 = Xn     */
;;;512          /* Yn2 = Yn1    */
;;;513          /* Yn1 = acc    */
;;;514          Xn2 = Xn1;
;;;515          Xn1 = Xn;
;;;516          Yn2 = Yn1;
;;;517    
;;;518          /* The result is converted to 1.63, Yn1 variable is reused  */
;;;519          Yn1 = acc << shift;
;;;520    
;;;521          /* Calc lower part of acc */
;;;522          acc_l = acc & 0xffffffff;
;;;523    
;;;524          /* Calc upper part of acc */
;;;525          acc_h = (acc >> 32) & 0xffffffff;
;;;526    
;;;527          /* Apply shift for lower part of acc and upper part of acc */
;;;528          acc_h = (uint32_t) acc_l >> lShift | acc_h << uShift;
;;;529    
;;;530          /* Store the output in the destination buffer in 1.31 format. */
;;;531          *pOut++ = acc_h;
;;;532    
;;;533          /* Yn1 = acc << shift; */
;;;534    
;;;535          /* Store the output in the destination buffer in 1.31 format. */
;;;536          /* *pOut++ = (q31_t) (acc >> (32 - shift)); */
;;;537    
;;;538          /* decrement the loop counter */
;;;539          sample--;
;;;540        }
;;;541    
;;;542        /*  The first stage output is given as input to the second stage. */
;;;543        pIn = pDst;
;;;544    
;;;545        /* Reset to destination buffer working pointer */
;;;546        pOut = pDst;
;;;547    
;;;548        /*  Store the updated state variables back into the pState array */
;;;549        *pState++ = (q63_t) Xn1;
;;;550        *pState++ = (q63_t) Xn2;
;;;551        *pState++ = Yn1;
;;;552        *pState++ = Yn2;
;;;553    
;;;554      } while(--stage);
;;;555    
;;;556    #endif /*    #ifndef ARM_MATH_CM0_FAMILY     */
;;;557    }
00029e  b015              ADD      sp,sp,#0x54
0002a0  e8bd8ff0          POP      {r4-r11,pc}
;;;558    
                          ENDP


                          AREA ||i.mult32x64||, CODE, READONLY, ALIGN=1

                  mult32x64 PROC
;;;499    
;;;500      static __INLINE q63_t mult32x64(
000000  b5f0              PUSH     {r4-r7,lr}
;;;501      q63_t x,
;;;502      q31_t y)
;;;503      {
;;;504        return ((((q63_t) (x & 0x00000000FFFFFFFF) * y) >> 32) +
000002  4603              MOV      r3,r0
000004  fba36502          UMULL    r6,r5,r3,r2
000008  fba16702          UMULL    r6,r7,r1,r2
00000c  2400              MOVS     r4,#0
00000e  fb045402          MLA      r4,r4,r2,r5
000012  17d0              ASRS     r0,r2,#31
000014  17cd              ASRS     r5,r1,#31
000016  fb057202          MLA      r2,r5,r2,r7
00001a  fb034300          MLA      r3,r3,r0,r4
00001e  fb012100          MLA      r1,r1,r0,r2
000022  1998              ADDS     r0,r3,r6
000024  eb4171e3          ADC      r1,r1,r3,ASR #31
;;;505                (((q63_t) (x >> 32) * y)));
;;;506      }
000028  bdf0              POP      {r4-r7,pc}
;;;507    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_biquad_cascade_df1_32x64_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___34_arm_biquad_cascade_df1_32x64_q31_c_68808ed6____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___34_arm_biquad_cascade_df1_32x64_q31_c_68808ed6____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___34_arm_biquad_cascade_df1_32x64_q31_c_68808ed6____REVSH|
#line 144
|__asm___34_arm_biquad_cascade_df1_32x64_q31_c_68808ed6____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___34_arm_biquad_cascade_df1_32x64_q31_c_68808ed6____RRX|
#line 300
|__asm___34_arm_biquad_cascade_df1_32x64_q31_c_68808ed6____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
