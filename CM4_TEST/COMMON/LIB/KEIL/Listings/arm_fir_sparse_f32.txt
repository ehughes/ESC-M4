; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_sparse_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_sparse_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_fir_sparse_f32.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_fir_sparse_f32.c]
                          THUMB

                          AREA ||i.arm_circularRead_f32||, CODE, READONLY, ALIGN=1

                  arm_circularRead_f32 PROC
;;;6193      */
;;;6194     static __INLINE void arm_circularRead_f32(
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;6195     int32_t * circBuffer,
;;;6196     int32_t L,
;;;6197     int32_t * readOffset,
;;;6198     int32_t bufferInc,
;;;6199     int32_t * dst,
;;;6200     int32_t * dst_base,
;;;6201     int32_t dst_length,
;;;6202     int32_t dstInc,
;;;6203     uint32_t blockSize)
;;;6204     {
000004  e9dd7c09          LDRD     r7,r12,[sp,#0x24]
000008  e9dd5807          LDRD     r5,r8,[sp,#0x1c]
00000c  9e0b              LDR      r6,[sp,#0x2c]
;;;6205       uint32_t i = 0u;
;;;6206       int32_t rOffset, dst_end;
;;;6207   
;;;6208       /* Copy the value of Index pointer that points
;;;6209        * to the current location from where the input samples to be read */
;;;6210       rOffset = *readOffset;
00000e  6814              LDR      r4,[r2,#0]
;;;6211       dst_end = (int32_t) (dst_base + dst_length);
000010  eb080787          ADD      r7,r8,r7,LSL #2
000014  e00d              B        |L1.50|
                  |L1.22|
;;;6212   
;;;6213       /* Loop over the blockSize */
;;;6214       i = blockSize;
;;;6215   
;;;6216       while(i > 0u)
;;;6217       {
;;;6218         /* copy the sample from the circular buffer to the destination buffer */
;;;6219         *dst = circBuffer[rOffset];
000016  f8509024          LDR      r9,[r0,r4,LSL #2]
00001a  f8c59000          STR      r9,[r5,#0]
;;;6220   
;;;6221         /* Update the input pointer */
;;;6222         dst += dstInc;
00001e  eb05058c          ADD      r5,r5,r12,LSL #2
;;;6223   
;;;6224         if(dst == (int32_t *) dst_end)
000022  42bd              CMP      r5,r7
000024  d100              BNE      |L1.40|
;;;6225         {
;;;6226           dst = dst_base;
000026  4645              MOV      r5,r8
                  |L1.40|
;;;6227         }
;;;6228   
;;;6229         /* Circularly update rOffset.  Watch out for positive and negative value  */
;;;6230         rOffset += bufferInc;
000028  441c              ADD      r4,r4,r3
;;;6231   
;;;6232         if(rOffset >= L)
00002a  428c              CMP      r4,r1
00002c  db00              BLT      |L1.48|
;;;6233         {
;;;6234           rOffset -= L;
00002e  1a64              SUBS     r4,r4,r1
                  |L1.48|
;;;6235         }
;;;6236   
;;;6237         /* Decrement the loop counter */
;;;6238         i--;
000030  1e76              SUBS     r6,r6,#1
                  |L1.50|
000032  2e00              CMP      r6,#0                 ;6216
000034  d1ef              BNE      |L1.22|
;;;6239       }
;;;6240   
;;;6241       /* Update the index pointer */
;;;6242       *readOffset = rOffset;
000036  6014              STR      r4,[r2,#0]
;;;6243     }
000038  e8bd83f0          POP      {r4-r9,pc}
;;;6244   
                          ENDP


                          AREA ||i.arm_fir_sparse_f32||, CODE, READONLY, ALIGN=1

                  arm_fir_sparse_f32 PROC
;;;122    
;;;123    void arm_fir_sparse_f32(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;124      arm_fir_sparse_instance_f32 * S,
;;;125      float32_t * pSrc,
;;;126      float32_t * pDst,
;;;127      float32_t * pScratchIn,
;;;128      uint32_t blockSize)
;;;129    {
000004  4606              MOV      r6,r0
000006  ed2d8b02          VPUSH    {d8}
00000a  b089              SUB      sp,sp,#0x24
00000c  461d              MOV      r5,r3
00000e  9c18              LDR      r4,[sp,#0x60]
;;;130    
;;;131      float32_t *pState = S->pState;                 /* State pointer */
000010  6877              LDR      r7,[r6,#4]
;;;132      float32_t *pCoeffs = S->pCoeffs;               /* Coefficient pointer */
000012  f8d69008          LDR      r9,[r6,#8]
;;;133      float32_t *px;                                 /* Scratch buffer pointer */
;;;134      float32_t *py = pState;                        /* Temporary pointers for state buffer */
;;;135      float32_t *pb = pScratchIn;                    /* Temporary pointers for scratch buffer */
;;;136      float32_t *pOut;                               /* Destination pointer */
;;;137      int32_t *pTapDelay = S->pTapDelay;             /* Pointer to the array containing offset of the non-zero tap values. */
000016  f8d6a010          LDR      r10,[r6,#0x10]
;;;138      uint32_t delaySize = S->maxDelay + blockSize;  /* state length */
00001a  89b0              LDRH     r0,[r6,#0xc]
00001c  eb000804          ADD      r8,r0,r4
;;;139      uint16_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter  */
000020  8830              LDRH     r0,[r6,#0]
000022  9006              STR      r0,[sp,#0x18]
;;;140      int32_t readIndex;                             /* Read index of the state buffer */
;;;141      uint32_t tapCnt, blkCnt;                       /* loop counters */
;;;142      float32_t coeff = *pCoeffs++;                  /* Read the first coefficient value */
000024  ecb98a01          VLDM     r9!,{s16}
;;;143    
;;;144    
;;;145    
;;;146      /* BlockSize of Input samples are copied into the state buffer */
;;;147      /* StateIndex points to the starting position to write in the state buffer */
;;;148      arm_circularWrite_f32((int32_t *) py, delaySize, &S->stateIndex, 1,
000028  2001              MOVS     r0,#1
00002a  4683              MOV      r11,r0
00002c  9004              STR      r0,[sp,#0x10]
00002e  46bc              MOV      r12,r7
000030  f1060e02          ADD      lr,r6,#2
000034  4620              MOV      r0,r4
000036  f8be2000          LDRH     r2,[lr,#0]
00003a  e00b              B        |L2.84|
                  |L2.60|
00003c  680b              LDR      r3,[r1,#0]            ;129
00003e  f84c3022          STR      r3,[r12,r2,LSL #2]    ;129
000042  eb01018b          ADD      r1,r1,r11,LSL #2      ;129
000046  9b04              LDR      r3,[sp,#0x10]         ;129
000048  441a              ADD      r2,r2,r3              ;129
00004a  4542              CMP      r2,r8                 ;129
00004c  db01              BLT      |L2.82|
00004e  eba20208          SUB      r2,r2,r8              ;129
                  |L2.82|
000052  1e40              SUBS     r0,r0,#1              ;129
                  |L2.84|
000054  2800              CMP      r0,#0                 ;129
000056  d1f1              BNE      |L2.60|
000058  f8ae2000          STRH     r2,[lr,#0]            ;129
;;;149                            (int32_t *) pSrc, 1, blockSize);
;;;150    
;;;151    
;;;152      /* Read Index, from where the state buffer should be read, is calculated. */
;;;153      readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
00005c  8871              LDRH     r1,[r6,#2]
00005e  f85a0b04          LDR      r0,[r10],#4
000062  1b09              SUBS     r1,r1,r4
000064  1a08              SUBS     r0,r1,r0
000066  9005              STR      r0,[sp,#0x14]
;;;154    
;;;155      /* Wraparound of readIndex */
;;;156      if(readIndex < 0)
000068  2800              CMP      r0,#0
00006a  da01              BGE      |L2.112|
;;;157      {
;;;158        readIndex += (int32_t) delaySize;
00006c  4440              ADD      r0,r0,r8
00006e  9005              STR      r0,[sp,#0x14]
                  |L2.112|
;;;159      }
;;;160    
;;;161      /* Working pointer for state buffer is updated */
;;;162      py = pState;
000070  4638              MOV      r0,r7
;;;163    
;;;164      /* blockSize samples are read from the state buffer */
;;;165      arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
000072  e9cd5401          STRD     r5,r4,[sp,#4]
000076  2101              MOVS     r1,#1
000078  9500              STR      r5,[sp,#0]
00007a  e9cd1403          STRD     r1,r4,[sp,#0xc]
00007e  460b              MOV      r3,r1
000080  aa05              ADD      r2,sp,#0x14
000082  4641              MOV      r1,r8
000084  f7fffffe          BL       arm_circularRead_f32
;;;166                           (int32_t *) pb, (int32_t *) pb, blockSize, 1,
;;;167                           blockSize);
;;;168    
;;;169      /* Working pointer for the scratch buffer */
;;;170      px = pb;
000088  4628              MOV      r0,r5
;;;171    
;;;172      /* Working pointer for destination buffer */
;;;173      pOut = pDst;
00008a  990d              LDR      r1,[sp,#0x34]
;;;174    
;;;175    
;;;176    #ifndef ARM_MATH_CM0_FAMILY
;;;177    
;;;178      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;179    
;;;180      /* Loop over the blockSize. Unroll by a factor of 4.    
;;;181       * Compute 4 Multiplications at a time. */
;;;182      blkCnt = blockSize >> 2u;
00008c  08a2              LSRS     r2,r4,#2
00008e  9208              STR      r2,[sp,#0x20]
;;;183    
;;;184      while(blkCnt > 0u)
000090  e018              B        |L2.196|
                  |L2.146|
;;;185      {
;;;186        /* Perform Multiplications and store in destination buffer */
;;;187        *pOut++ = *px++ * coeff;
000092  ecb00a01          VLDM     r0!,{s0}
000096  ee200a08          VMUL.F32 s0,s0,s16
00009a  eca10a01          VSTM     r1!,{s0}
;;;188        *pOut++ = *px++ * coeff;
00009e  ecb00a01          VLDM     r0!,{s0}
0000a2  ee200a08          VMUL.F32 s0,s0,s16
0000a6  eca10a01          VSTM     r1!,{s0}
;;;189        *pOut++ = *px++ * coeff;
0000aa  ecb00a01          VLDM     r0!,{s0}
0000ae  ee200a08          VMUL.F32 s0,s0,s16
0000b2  eca10a01          VSTM     r1!,{s0}
;;;190        *pOut++ = *px++ * coeff;
0000b6  ecb00a01          VLDM     r0!,{s0}
0000ba  ee200a08          VMUL.F32 s0,s0,s16
0000be  eca10a01          VSTM     r1!,{s0}
;;;191    
;;;192        /* Decrement the loop counter */
;;;193        blkCnt--;
0000c2  1e52              SUBS     r2,r2,#1
                  |L2.196|
0000c4  2a00              CMP      r2,#0                 ;184
0000c6  d1e4              BNE      |L2.146|
;;;194      }
;;;195    
;;;196      /* If the blockSize is not a multiple of 4,    
;;;197       * compute the remaining samples */
;;;198      blkCnt = blockSize % 0x4u;
0000c8  f0040203          AND      r2,r4,#3
0000cc  9207              STR      r2,[sp,#0x1c]
;;;199    
;;;200      while(blkCnt > 0u)
0000ce  e006              B        |L2.222|
                  |L2.208|
;;;201      {
;;;202        /* Perform Multiplications and store in destination buffer */
;;;203        *pOut++ = *px++ * coeff;
0000d0  ecb00a01          VLDM     r0!,{s0}
0000d4  ee200a08          VMUL.F32 s0,s0,s16
0000d8  eca10a01          VSTM     r1!,{s0}
;;;204    
;;;205        /* Decrement the loop counter */
;;;206        blkCnt--;
0000dc  1e52              SUBS     r2,r2,#1
                  |L2.222|
0000de  2a00              CMP      r2,#0                 ;200
0000e0  d1f6              BNE      |L2.208|
;;;207      }
;;;208    
;;;209      /* Load the coefficient value and    
;;;210       * increment the coefficient buffer for the next set of state values */
;;;211      coeff = *pCoeffs++;
0000e2  ecb98a01          VLDM     r9!,{s16}
;;;212    
;;;213      /* Read Index, from where the state buffer should be read, is calculated. */
;;;214      readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
0000e6  8871              LDRH     r1,[r6,#2]
0000e8  f85a0b04          LDR      r0,[r10],#4
0000ec  1b09              SUBS     r1,r1,r4
0000ee  1a08              SUBS     r0,r1,r0
0000f0  9005              STR      r0,[sp,#0x14]
;;;215    
;;;216      /* Wraparound of readIndex */
;;;217      if(readIndex < 0)
0000f2  2800              CMP      r0,#0
0000f4  da01              BGE      |L2.250|
;;;218      {
;;;219        readIndex += (int32_t) delaySize;
0000f6  4440              ADD      r0,r0,r8
0000f8  9005              STR      r0,[sp,#0x14]
                  |L2.250|
;;;220      }
;;;221    
;;;222      /* Loop over the number of taps. */
;;;223      tapCnt = (uint32_t) numTaps - 2u;
0000fa  f8ddb018          LDR      r11,[sp,#0x18]
0000fe  f1ab0b02          SUB      r11,r11,#2
;;;224    
;;;225      while(tapCnt > 0u)
000102  e04d              B        |L2.416|
                  |L2.260|
;;;226      {
;;;227    
;;;228        /* Working pointer for state buffer is updated */
;;;229        py = pState;
000104  4638              MOV      r0,r7
;;;230    
;;;231        /* blockSize samples are read from the state buffer */
;;;232        arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
000106  e9cd5401          STRD     r5,r4,[sp,#4]
00010a  2101              MOVS     r1,#1
00010c  9500              STR      r5,[sp,#0]
00010e  e9cd1403          STRD     r1,r4,[sp,#0xc]
000112  460b              MOV      r3,r1
000114  aa05              ADD      r2,sp,#0x14
000116  4641              MOV      r1,r8
000118  f7fffffe          BL       arm_circularRead_f32
;;;233                             (int32_t *) pb, (int32_t *) pb, blockSize, 1,
;;;234                             blockSize);
;;;235    
;;;236        /* Working pointer for the scratch buffer */
;;;237        px = pb;
00011c  4629              MOV      r1,r5
;;;238    
;;;239        /* Working pointer for destination buffer */
;;;240        pOut = pDst;
00011e  980d              LDR      r0,[sp,#0x34]
;;;241    
;;;242        /* Loop over the blockSize. Unroll by a factor of 4.    
;;;243         * Compute 4 MACS at a time. */
;;;244        blkCnt = blockSize >> 2u;
000120  9a08              LDR      r2,[sp,#0x20]
;;;245    
;;;246        while(blkCnt > 0u)
000122  e020              B        |L2.358|
                  |L2.292|
;;;247        {
;;;248          /* Perform Multiply-Accumulate */
;;;249          *pOut++ += *px++ * coeff;
000124  ecf10a01          VLDM     r1!,{s1}
000128  ed900a00          VLDR     s0,[r0,#0]
00012c  ee000a88          VMLA.F32 s0,s1,s16
000130  eca00a01          VSTM     r0!,{s0}
;;;250          *pOut++ += *px++ * coeff;
000134  ecf10a01          VLDM     r1!,{s1}
000138  ed900a00          VLDR     s0,[r0,#0]
00013c  ee000a88          VMLA.F32 s0,s1,s16
000140  eca00a01          VSTM     r0!,{s0}
;;;251          *pOut++ += *px++ * coeff;
000144  ecf10a01          VLDM     r1!,{s1}
000148  ed900a00          VLDR     s0,[r0,#0]
00014c  ee000a88          VMLA.F32 s0,s1,s16
000150  eca00a01          VSTM     r0!,{s0}
;;;252          *pOut++ += *px++ * coeff;
000154  ecf10a01          VLDM     r1!,{s1}
000158  ed900a00          VLDR     s0,[r0,#0]
00015c  ee000a88          VMLA.F32 s0,s1,s16
000160  eca00a01          VSTM     r0!,{s0}
;;;253    
;;;254          /* Decrement the loop counter */
;;;255          blkCnt--;
000164  1e52              SUBS     r2,r2,#1
                  |L2.358|
000166  2a00              CMP      r2,#0                 ;246
000168  d1dc              BNE      |L2.292|
;;;256        }
;;;257    
;;;258        /* If the blockSize is not a multiple of 4,    
;;;259         * compute the remaining samples */
;;;260        blkCnt = blockSize % 0x4u;
00016a  9a07              LDR      r2,[sp,#0x1c]
;;;261    
;;;262        while(blkCnt > 0u)
00016c  e008              B        |L2.384|
                  |L2.366|
;;;263        {
;;;264          /* Perform Multiply-Accumulate */
;;;265          *pOut++ += *px++ * coeff;
00016e  ecf10a01          VLDM     r1!,{s1}
000172  ed900a00          VLDR     s0,[r0,#0]
000176  ee000a88          VMLA.F32 s0,s1,s16
00017a  eca00a01          VSTM     r0!,{s0}
;;;266    
;;;267          /* Decrement the loop counter */
;;;268          blkCnt--;
00017e  1e52              SUBS     r2,r2,#1
                  |L2.384|
000180  2a00              CMP      r2,#0                 ;262
000182  d1f4              BNE      |L2.366|
;;;269        }
;;;270    
;;;271        /* Load the coefficient value and    
;;;272         * increment the coefficient buffer for the next set of state values */
;;;273        coeff = *pCoeffs++;
000184  ecb98a01          VLDM     r9!,{s16}
;;;274    
;;;275        /* Read Index, from where the state buffer should be read, is calculated. */
;;;276        readIndex = ((int32_t) S->stateIndex -
000188  8871              LDRH     r1,[r6,#2]
00018a  f85a0b04          LDR      r0,[r10],#4
00018e  1b09              SUBS     r1,r1,r4
000190  1a08              SUBS     r0,r1,r0
000192  9005              STR      r0,[sp,#0x14]
;;;277                     (int32_t) blockSize) - *pTapDelay++;
;;;278    
;;;279        /* Wraparound of readIndex */
;;;280        if(readIndex < 0)
000194  2800              CMP      r0,#0
000196  da01              BGE      |L2.412|
;;;281        {
;;;282          readIndex += (int32_t) delaySize;
000198  4440              ADD      r0,r0,r8
00019a  9005              STR      r0,[sp,#0x14]
                  |L2.412|
;;;283        }
;;;284    
;;;285        /* Decrement the tap loop counter */
;;;286        tapCnt--;
00019c  f1ab0b01          SUB      r11,r11,#1
                  |L2.416|
0001a0  f1bb0f00          CMP      r11,#0                ;225
0001a4  d1ae              BNE      |L2.260|
;;;287      }
;;;288    	
;;;289    	/* Compute last tap without the final read of pTapDelay */
;;;290    
;;;291    	/* Working pointer for state buffer is updated */
;;;292    	py = pState;
0001a6  4638              MOV      r0,r7
;;;293    
;;;294    	/* blockSize samples are read from the state buffer */
;;;295    	arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
0001a8  e9cd5401          STRD     r5,r4,[sp,#4]
0001ac  2101              MOVS     r1,#1
0001ae  9500              STR      r5,[sp,#0]
0001b0  e9cd1403          STRD     r1,r4,[sp,#0xc]
0001b4  460b              MOV      r3,r1
0001b6  aa05              ADD      r2,sp,#0x14
0001b8  4641              MOV      r1,r8
0001ba  f7fffffe          BL       arm_circularRead_f32
;;;296    											 (int32_t *) pb, (int32_t *) pb, blockSize, 1,
;;;297    											 blockSize);
;;;298    
;;;299    	/* Working pointer for the scratch buffer */
;;;300    	px = pb;
;;;301    
;;;302    	/* Working pointer for destination buffer */
;;;303    	pOut = pDst;
0001be  980d              LDR      r0,[sp,#0x34]
;;;304    
;;;305    	/* Loop over the blockSize. Unroll by a factor of 4.    
;;;306    	 * Compute 4 MACS at a time. */
;;;307    	blkCnt = blockSize >> 2u;
0001c0  9908              LDR      r1,[sp,#0x20]
;;;308    
;;;309    	while(blkCnt > 0u)
0001c2  e020              B        |L2.518|
                  |L2.452|
;;;310    	{
;;;311    		/* Perform Multiply-Accumulate */
;;;312    		*pOut++ += *px++ * coeff;
0001c4  ecf50a01          VLDM     r5!,{s1}
0001c8  ed900a00          VLDR     s0,[r0,#0]
0001cc  ee000a88          VMLA.F32 s0,s1,s16
0001d0  eca00a01          VSTM     r0!,{s0}
;;;313    		*pOut++ += *px++ * coeff;
0001d4  ecf50a01          VLDM     r5!,{s1}
0001d8  ed900a00          VLDR     s0,[r0,#0]
0001dc  ee000a88          VMLA.F32 s0,s1,s16
0001e0  eca00a01          VSTM     r0!,{s0}
;;;314    		*pOut++ += *px++ * coeff;
0001e4  ecf50a01          VLDM     r5!,{s1}
0001e8  ed900a00          VLDR     s0,[r0,#0]
0001ec  ee000a88          VMLA.F32 s0,s1,s16
0001f0  eca00a01          VSTM     r0!,{s0}
;;;315    		*pOut++ += *px++ * coeff;
0001f4  ecf50a01          VLDM     r5!,{s1}
0001f8  ed900a00          VLDR     s0,[r0,#0]
0001fc  ee000a88          VMLA.F32 s0,s1,s16
000200  eca00a01          VSTM     r0!,{s0}
;;;316    
;;;317    		/* Decrement the loop counter */
;;;318    		blkCnt--;
000204  1e49              SUBS     r1,r1,#1
                  |L2.518|
000206  2900              CMP      r1,#0                 ;309
000208  d1dc              BNE      |L2.452|
;;;319    	}
;;;320    
;;;321    	/* If the blockSize is not a multiple of 4,    
;;;322    	 * compute the remaining samples */
;;;323    	blkCnt = blockSize % 0x4u;
00020a  9907              LDR      r1,[sp,#0x1c]
;;;324    
;;;325    	while(blkCnt > 0u)
00020c  e008              B        |L2.544|
                  |L2.526|
;;;326    	{
;;;327    		/* Perform Multiply-Accumulate */
;;;328    		*pOut++ += *px++ * coeff;
00020e  ecf50a01          VLDM     r5!,{s1}
000212  ed900a00          VLDR     s0,[r0,#0]
000216  ee000a88          VMLA.F32 s0,s1,s16
00021a  eca00a01          VSTM     r0!,{s0}
;;;329    
;;;330    		/* Decrement the loop counter */
;;;331    		blkCnt--;
00021e  1e49              SUBS     r1,r1,#1
                  |L2.544|
000220  2900              CMP      r1,#0                 ;325
000222  d1f4              BNE      |L2.526|
;;;332    	}
;;;333    
;;;334    #else
;;;335    
;;;336    /* Run the below code for Cortex-M0 */
;;;337    
;;;338      blkCnt = blockSize;
;;;339    
;;;340      while(blkCnt > 0u)
;;;341      {
;;;342        /* Perform Multiplications and store in destination buffer */
;;;343        *pOut++ = *px++ * coeff;
;;;344    
;;;345        /* Decrement the loop counter */
;;;346        blkCnt--;
;;;347      }
;;;348    
;;;349      /* Load the coefficient value and           
;;;350       * increment the coefficient buffer for the next set of state values */
;;;351      coeff = *pCoeffs++;
;;;352    
;;;353      /* Read Index, from where the state buffer should be read, is calculated. */
;;;354      readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
;;;355    
;;;356      /* Wraparound of readIndex */
;;;357      if(readIndex < 0)
;;;358      {
;;;359        readIndex += (int32_t) delaySize;
;;;360      }
;;;361    
;;;362      /* Loop over the number of taps. */
;;;363      tapCnt = (uint32_t) numTaps - 2u;
;;;364    
;;;365      while(tapCnt > 0u)
;;;366      {
;;;367    
;;;368        /* Working pointer for state buffer is updated */
;;;369        py = pState;
;;;370    
;;;371        /* blockSize samples are read from the state buffer */
;;;372        arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
;;;373                             (int32_t *) pb, (int32_t *) pb, blockSize, 1,
;;;374                             blockSize);
;;;375    
;;;376        /* Working pointer for the scratch buffer */
;;;377        px = pb;
;;;378    
;;;379        /* Working pointer for destination buffer */
;;;380        pOut = pDst;
;;;381    
;;;382        blkCnt = blockSize;
;;;383    
;;;384        while(blkCnt > 0u)
;;;385        {
;;;386          /* Perform Multiply-Accumulate */
;;;387          *pOut++ += *px++ * coeff;
;;;388    
;;;389          /* Decrement the loop counter */
;;;390          blkCnt--;
;;;391        }
;;;392    
;;;393        /* Load the coefficient value and           
;;;394         * increment the coefficient buffer for the next set of state values */
;;;395        coeff = *pCoeffs++;
;;;396    
;;;397        /* Read Index, from where the state buffer should be read, is calculated. */
;;;398        readIndex =
;;;399          ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
;;;400    
;;;401        /* Wraparound of readIndex */
;;;402        if(readIndex < 0)
;;;403        {
;;;404          readIndex += (int32_t) delaySize;
;;;405        }
;;;406    
;;;407        /* Decrement the tap loop counter */
;;;408        tapCnt--;
;;;409      }
;;;410    	
;;;411    	/* Compute last tap without the final read of pTapDelay */	
;;;412    	
;;;413    	/* Working pointer for state buffer is updated */
;;;414    	py = pState;
;;;415    
;;;416    	/* blockSize samples are read from the state buffer */
;;;417    	arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
;;;418    											 (int32_t *) pb, (int32_t *) pb, blockSize, 1,
;;;419    											 blockSize);
;;;420    
;;;421    	/* Working pointer for the scratch buffer */
;;;422    	px = pb;
;;;423    
;;;424    	/* Working pointer for destination buffer */
;;;425    	pOut = pDst;
;;;426    
;;;427    	blkCnt = blockSize;
;;;428    
;;;429    	while(blkCnt > 0u)
;;;430    	{
;;;431    		/* Perform Multiply-Accumulate */
;;;432    		*pOut++ += *px++ * coeff;
;;;433    
;;;434    		/* Decrement the loop counter */
;;;435    		blkCnt--;
;;;436    	}
;;;437    
;;;438    #endif /*   #ifndef ARM_MATH_CM0_FAMILY        */
;;;439    
;;;440    }
000224  b009              ADD      sp,sp,#0x24
000226  ecbd8b02          VPOP     {d8}
00022a  e8bd8fff          POP      {r0-r11,pc}
;;;441    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_fir_sparse_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_arm_fir_sparse_f32_c_5ed9a274____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___20_arm_fir_sparse_f32_c_5ed9a274____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_arm_fir_sparse_f32_c_5ed9a274____REVSH|
#line 144
|__asm___20_arm_fir_sparse_f32_c_5ed9a274____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_arm_fir_sparse_f32_c_5ed9a274____RRX|
#line 300
|__asm___20_arm_fir_sparse_f32_c_5ed9a274____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
