; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_partial_fast_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_partial_fast_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_conv_partial_fast_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_partial_fast_q15.c]
                          THUMB

                          AREA ||i.arm_conv_partial_fast_q15||, CODE, READONLY, ALIGN=1

                  arm_conv_partial_fast_q15 PROC
;;;66     
;;;67     arm_status arm_conv_partial_fast_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;68       q15_t * pSrcA,
;;;69       uint32_t srcALen,
;;;70       q15_t * pSrcB,
;;;71       uint32_t srcBLen,
;;;72       q15_t * pDst,
;;;73       uint32_t firstIndex,
;;;74       uint32_t numPoints)
;;;75     {
000004  b089              SUB      sp,sp,#0x24
000006  e9dd8517          LDRD     r8,r5,[sp,#0x5c]
00000a  9c16              LDR      r4,[sp,#0x58]
;;;76     #ifndef UNALIGNED_SUPPORT_DISABLE
;;;77     
;;;78       q15_t *pIn1;                                   /* inputA pointer               */
;;;79       q15_t *pIn2;                                   /* inputB pointer               */
;;;80       q15_t *pOut = pDst;                            /* output pointer               */
;;;81       q31_t sum, acc0, acc1, acc2, acc3;             /* Accumulator                  */
;;;82       q15_t *px;                                     /* Intermediate inputA pointer  */
;;;83       q15_t *py;                                     /* Intermediate inputB pointer  */
;;;84       q15_t *pSrc1, *pSrc2;                          /* Intermediate pointers        */
;;;85       q31_t x0, x1, x2, x3, c0;
;;;86       uint32_t j, k, count, check, blkCnt;
;;;87       int32_t blockSize1, blockSize2, blockSize3;    /* loop counters                 */
;;;88       arm_status status;                             /* status of Partial convolution */
;;;89     
;;;90       /* Check for range of output samples to be calculated */
;;;91       if((firstIndex + numPoints) > ((srcALen + (srcBLen - 1u))))
00000c  9e0a              LDR      r6,[sp,#0x28]
00000e  eb080105          ADD      r1,r8,r5
000012  441e              ADD      r6,r6,r3
000014  1e76              SUBS     r6,r6,#1
000016  42b1              CMP      r1,r6
000018  d904              BLS      |L1.36|
;;;92       {
;;;93         /* Set status as ARM_MATH_ARGUMENT_ERROR */
;;;94         status = ARM_MATH_ARGUMENT_ERROR;
00001a  f04f30ff          MOV      r0,#0xffffffff
                  |L1.30|
;;;95       }
;;;96       else
;;;97       {
;;;98     
;;;99         /* The algorithm implementation is based on the lengths of the inputs. */
;;;100        /* srcB is always made to slide across srcA. */
;;;101        /* So srcBLen is always considered as shorter or equal to srcALen */
;;;102        if(srcALen >=srcBLen)
;;;103        {
;;;104          /* Initialization of inputA pointer */
;;;105          pIn1 = pSrcA;
;;;106    
;;;107          /* Initialization of inputB pointer */
;;;108          pIn2 = pSrcB;
;;;109        }
;;;110        else
;;;111        {
;;;112          /* Initialization of inputA pointer */
;;;113          pIn1 = pSrcB;
;;;114    
;;;115          /* Initialization of inputB pointer */
;;;116          pIn2 = pSrcA;
;;;117    
;;;118          /* srcBLen is always considered as shorter or equal to srcALen */
;;;119          j = srcBLen;
;;;120          srcBLen = srcALen;
;;;121          srcALen = j;
;;;122        }
;;;123    
;;;124        /* Conditions to check which loopCounter holds   
;;;125         * the first and last indices of the output samples to be calculated. */
;;;126        check = firstIndex + numPoints;
;;;127        blockSize3 = ((int32_t)check > (int32_t)srcALen) ? (int32_t)check - (int32_t)srcALen : 0;
;;;128        blockSize3 = ((int32_t)firstIndex > (int32_t)srcALen - 1) ? blockSize3 - (int32_t)firstIndex + (int32_t)srcALen : blockSize3;
;;;129        blockSize1 = (((int32_t) srcBLen - 1) - (int32_t) firstIndex);
;;;130        blockSize1 = (blockSize1 > 0) ? ((check > (srcBLen - 1u)) ? blockSize1 :
;;;131                                         (int32_t) numPoints) : 0;
;;;132        blockSize2 = (int32_t) check - ((blockSize3 + blockSize1) +
;;;133                                        (int32_t) firstIndex);
;;;134        blockSize2 = (blockSize2 > 0) ? blockSize2 : 0;
;;;135    
;;;136        /* conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1] */
;;;137        /* The function is internally   
;;;138         * divided into three stages according to the number of multiplications that has to be   
;;;139         * taken place between inputA samples and inputB samples. In the first stage of the   
;;;140         * algorithm, the multiplications increase by one for every iteration.   
;;;141         * In the second stage of the algorithm, srcBLen number of multiplications are done.   
;;;142         * In the third stage of the algorithm, the multiplications decrease by one   
;;;143         * for every iteration. */
;;;144    
;;;145        /* Set the output pointer to point to the firstIndex   
;;;146         * of the output sample to be calculated. */
;;;147        pOut = pDst + firstIndex;
;;;148    
;;;149        /* --------------------------   
;;;150         * Initializations of stage1   
;;;151         * -------------------------*/
;;;152    
;;;153        /* sum = x[0] * y[0]   
;;;154         * sum = x[0] * y[1] + x[1] * y[0]   
;;;155         * ....   
;;;156         * sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]   
;;;157         */
;;;158    
;;;159        /* In this stage the MAC operations are increased by 1 for every iteration.   
;;;160           The count variable holds the number of MAC operations performed.   
;;;161           Since the partial convolution starts from firstIndex   
;;;162           Number of Macs to be performed is firstIndex + 1 */
;;;163        count = 1u + firstIndex;
;;;164    
;;;165        /* Working pointer of inputA */
;;;166        px = pIn1;
;;;167    
;;;168        /* Working pointer of inputB */
;;;169        pSrc2 = pIn2 + firstIndex;
;;;170        py = pSrc2;
;;;171    
;;;172        /* ------------------------   
;;;173         * Stage1 process   
;;;174         * ----------------------*/
;;;175    
;;;176        /* For loop unrolling by 4, this stage is divided into two. */
;;;177        /* First part of this stage computes the MAC operations less than 4 */
;;;178        /* Second part of this stage computes the MAC operations greater than or equal to 4 */
;;;179    
;;;180        /* The first part of the stage starts here */
;;;181        while((count < 4u) && (blockSize1 > 0))
;;;182        {
;;;183          /* Accumulator is made zero for every iteration */
;;;184          sum = 0;
;;;185    
;;;186          /* Loop over number of MAC operations between   
;;;187           * inputA samples and inputB samples */
;;;188          k = count;
;;;189    
;;;190          while(k > 0u)
;;;191          {
;;;192            /* Perform the multiply-accumulates */
;;;193            sum = __SMLAD(*px++, *py--, sum);
;;;194    
;;;195            /* Decrement the loop counter */
;;;196            k--;
;;;197          }
;;;198    
;;;199          /* Store the result in the accumulator in the destination buffer. */
;;;200          *pOut++ = (q15_t) (sum >> 15);
;;;201    
;;;202          /* Update the inputA and inputB pointers for next MAC calculation */
;;;203          py = ++pSrc2;
;;;204          px = pIn1;
;;;205    
;;;206          /* Increment the MAC count */
;;;207          count++;
;;;208    
;;;209          /* Decrement the loop counter */
;;;210          blockSize1--;
;;;211        }
;;;212    
;;;213        /* The second part of the stage starts here */
;;;214        /* The internal loop, over count, is unrolled by 4 */
;;;215        /* To, read the last two inputB samples using SIMD:   
;;;216         * y[srcBLen] and y[srcBLen-1] coefficients, py is decremented by 1 */
;;;217        py = py - 1;
;;;218    
;;;219        while(blockSize1 > 0)
;;;220        {
;;;221          /* Accumulator is made zero for every iteration */
;;;222          sum = 0;
;;;223    
;;;224          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;225          k = count >> 2u;
;;;226    
;;;227          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;228           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;229          while(k > 0u)
;;;230          {
;;;231            /* Perform the multiply-accumulates */
;;;232            /* x[0], x[1] are multiplied with y[srcBLen - 1], y[srcBLen - 2] respectively */
;;;233            sum = __SMLADX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
;;;234            /* x[2], x[3] are multiplied with y[srcBLen - 3], y[srcBLen - 4] respectively */
;;;235            sum = __SMLADX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
;;;236    
;;;237            /* Decrement the loop counter */
;;;238            k--;
;;;239          }
;;;240    
;;;241          /* For the next MAC operations, the pointer py is used without SIMD   
;;;242           * So, py is incremented by 1 */
;;;243          py = py + 1u;
;;;244    
;;;245          /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;246           ** No loop unrolling is used. */
;;;247          k = count % 0x4u;
;;;248    
;;;249          while(k > 0u)
;;;250          {
;;;251            /* Perform the multiply-accumulates */
;;;252            sum = __SMLAD(*px++, *py--, sum);
;;;253    
;;;254            /* Decrement the loop counter */
;;;255            k--;
;;;256          }
;;;257    
;;;258          /* Store the result in the accumulator in the destination buffer. */
;;;259          *pOut++ = (q15_t) (sum >> 15);
;;;260    
;;;261          /* Update the inputA and inputB pointers for next MAC calculation */
;;;262          py = ++pSrc2 - 1u;
;;;263          px = pIn1;
;;;264    
;;;265          /* Increment the MAC count */
;;;266          count++;
;;;267    
;;;268          /* Decrement the loop counter */
;;;269          blockSize1--;
;;;270        }
;;;271    
;;;272        /* --------------------------   
;;;273         * Initializations of stage2   
;;;274         * ------------------------*/
;;;275    
;;;276        /* sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0]   
;;;277         * sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0]   
;;;278         * ....   
;;;279         * sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]   
;;;280         */
;;;281    
;;;282        /* Working pointer of inputA */
;;;283        if((int32_t)firstIndex - (int32_t)srcBLen + 1 > 0)
;;;284        {
;;;285          px = pIn1 + firstIndex - srcBLen + 1;
;;;286        }
;;;287        else
;;;288        {
;;;289          px = pIn1;
;;;290        }
;;;291    
;;;292        /* Working pointer of inputB */
;;;293        pSrc2 = pIn2 + (srcBLen - 1u);
;;;294        py = pSrc2;
;;;295    
;;;296        /* count is the index by which the pointer pIn1 to be incremented */
;;;297        count = 0u;
;;;298    
;;;299    
;;;300        /* --------------------   
;;;301         * Stage2 process   
;;;302         * -------------------*/
;;;303    
;;;304        /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.   
;;;305         * So, to loop unroll over blockSize2,   
;;;306         * srcBLen should be greater than or equal to 4 */
;;;307        if(srcBLen >= 4u)
;;;308        {
;;;309          /* Loop unroll over blockSize2, by 4 */
;;;310          blkCnt = ((uint32_t) blockSize2 >> 2u);
;;;311    
;;;312          while(blkCnt > 0u)
;;;313          {
;;;314          py = py - 1u;
;;;315    
;;;316            /* Set all accumulators to zero */
;;;317            acc0 = 0;
;;;318            acc1 = 0;
;;;319            acc2 = 0;
;;;320            acc3 = 0;
;;;321    
;;;322    
;;;323            /* read x[0], x[1] samples */
;;;324          x0 = *__SIMD32(px);
;;;325            /* read x[1], x[2] samples */
;;;326          x1 = _SIMD32_OFFSET(px+1);
;;;327    	  px+= 2u;
;;;328    
;;;329    
;;;330            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;331            k = srcBLen >> 2u;
;;;332    
;;;333            /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;334             ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;335            do
;;;336            {
;;;337              /* Read the last two inputB samples using SIMD:   
;;;338               * y[srcBLen - 1] and y[srcBLen - 2] */
;;;339            c0 = *__SIMD32(py)--;
;;;340    
;;;341              /* acc0 +=  x[0] * y[srcBLen - 1] + x[1] * y[srcBLen - 2] */
;;;342              acc0 = __SMLADX(x0, c0, acc0);
;;;343    
;;;344              /* acc1 +=  x[1] * y[srcBLen - 1] + x[2] * y[srcBLen - 2] */
;;;345              acc1 = __SMLADX(x1, c0, acc1);
;;;346    
;;;347              /* Read x[2], x[3] */
;;;348            x2 = *__SIMD32(px);
;;;349    
;;;350              /* Read x[3], x[4] */
;;;351            x3 = _SIMD32_OFFSET(px+1);
;;;352    
;;;353              /* acc2 +=  x[2] * y[srcBLen - 1] + x[3] * y[srcBLen - 2] */
;;;354              acc2 = __SMLADX(x2, c0, acc2);
;;;355    
;;;356              /* acc3 +=  x[3] * y[srcBLen - 1] + x[4] * y[srcBLen - 2] */
;;;357              acc3 = __SMLADX(x3, c0, acc3);
;;;358    
;;;359              /* Read y[srcBLen - 3] and y[srcBLen - 4] */
;;;360            c0 = *__SIMD32(py)--;
;;;361    
;;;362              /* acc0 +=  x[2] * y[srcBLen - 3] + x[3] * y[srcBLen - 4] */
;;;363              acc0 = __SMLADX(x2, c0, acc0);
;;;364    
;;;365              /* acc1 +=  x[3] * y[srcBLen - 3] + x[4] * y[srcBLen - 4] */
;;;366              acc1 = __SMLADX(x3, c0, acc1);
;;;367    
;;;368              /* Read x[4], x[5] */
;;;369            x0 = _SIMD32_OFFSET(px+2);
;;;370    
;;;371              /* Read x[5], x[6] */
;;;372            x1 = _SIMD32_OFFSET(px+3);
;;;373    		px += 4u;
;;;374    
;;;375              /* acc2 +=  x[4] * y[srcBLen - 3] + x[5] * y[srcBLen - 4] */
;;;376              acc2 = __SMLADX(x0, c0, acc2);
;;;377    
;;;378              /* acc3 +=  x[5] * y[srcBLen - 3] + x[6] * y[srcBLen - 4] */
;;;379              acc3 = __SMLADX(x1, c0, acc3);
;;;380    
;;;381            } while(--k);
;;;382    
;;;383            /* For the next MAC operations, SIMD is not used   
;;;384             * So, the 16 bit pointer if inputB, py is updated */
;;;385    
;;;386            /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;387             ** No loop unrolling is used. */
;;;388            k = srcBLen % 0x4u;
;;;389    
;;;390            if(k == 1u)
;;;391            {
;;;392              /* Read y[srcBLen - 5] */
;;;393            c0 = *(py+1);
;;;394    #ifdef  ARM_MATH_BIG_ENDIAN
;;;395    
;;;396            c0 = c0 << 16u;
;;;397    
;;;398    #else
;;;399    
;;;400            c0 = c0 & 0x0000FFFF;
;;;401    
;;;402    #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;403    
;;;404              /* Read x[7] */
;;;405            x3 = *__SIMD32(px);
;;;406    		px++;
;;;407    
;;;408              /* Perform the multiply-accumulates */
;;;409              acc0 = __SMLAD(x0, c0, acc0);
;;;410              acc1 = __SMLAD(x1, c0, acc1);
;;;411              acc2 = __SMLADX(x1, c0, acc2);
;;;412              acc3 = __SMLADX(x3, c0, acc3);
;;;413            }
;;;414    
;;;415            if(k == 2u)
;;;416            {
;;;417              /* Read y[srcBLen - 5], y[srcBLen - 6] */
;;;418            c0 = _SIMD32_OFFSET(py);
;;;419    
;;;420              /* Read x[7], x[8] */
;;;421            x3 = *__SIMD32(px);
;;;422    
;;;423            /* Read x[9] */
;;;424            x2 = _SIMD32_OFFSET(px+1);
;;;425    		px += 2u;
;;;426    
;;;427              /* Perform the multiply-accumulates */
;;;428              acc0 = __SMLADX(x0, c0, acc0);
;;;429              acc1 = __SMLADX(x1, c0, acc1);
;;;430              acc2 = __SMLADX(x3, c0, acc2);
;;;431              acc3 = __SMLADX(x2, c0, acc3);
;;;432            }
;;;433    
;;;434            if(k == 3u)
;;;435            {
;;;436              /* Read y[srcBLen - 5], y[srcBLen - 6] */
;;;437            c0 = _SIMD32_OFFSET(py);
;;;438    
;;;439              /* Read x[7], x[8] */
;;;440            x3 = *__SIMD32(px);
;;;441    
;;;442              /* Read x[9] */
;;;443            x2 = _SIMD32_OFFSET(px+1);
;;;444    
;;;445              /* Perform the multiply-accumulates */
;;;446              acc0 = __SMLADX(x0, c0, acc0);
;;;447              acc1 = __SMLADX(x1, c0, acc1);
;;;448              acc2 = __SMLADX(x3, c0, acc2);
;;;449              acc3 = __SMLADX(x2, c0, acc3);
;;;450    
;;;451    		c0 = *(py-1);
;;;452    #ifdef  ARM_MATH_BIG_ENDIAN
;;;453    
;;;454            c0 = c0 << 16u;
;;;455    #else
;;;456    
;;;457            c0 = c0 & 0x0000FFFF;
;;;458    #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;459    
;;;460              /* Read x[10] */
;;;461            x3 =  _SIMD32_OFFSET(px+2);
;;;462    		px += 3u;
;;;463    
;;;464              /* Perform the multiply-accumulates */
;;;465              acc0 = __SMLADX(x1, c0, acc0);
;;;466              acc1 = __SMLAD(x2, c0, acc1);
;;;467              acc2 = __SMLADX(x2, c0, acc2);
;;;468              acc3 = __SMLADX(x3, c0, acc3);
;;;469            }
;;;470    
;;;471            /* Store the results in the accumulators in the destination buffer. */
;;;472    #ifndef ARM_MATH_BIG_ENDIAN
;;;473    
;;;474            *__SIMD32(pOut)++ = __PKHBT(acc0 >> 15, acc1 >> 15, 16);
;;;475            *__SIMD32(pOut)++ = __PKHBT(acc2 >> 15, acc3 >> 15, 16);
;;;476    
;;;477    #else
;;;478    
;;;479            *__SIMD32(pOut)++ = __PKHBT(acc1 >> 15, acc0 >> 15, 16);
;;;480            *__SIMD32(pOut)++ = __PKHBT(acc3 >> 15, acc2 >> 15, 16);
;;;481    
;;;482    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;483    
;;;484            /* Increment the pointer pIn1 index, count by 4 */
;;;485            count += 4u;
;;;486    
;;;487            /* Update the inputA and inputB pointers for next MAC calculation */
;;;488            px = pIn1 + count;
;;;489            py = pSrc2;
;;;490    
;;;491            /* Decrement the loop counter */
;;;492            blkCnt--;
;;;493          }
;;;494    
;;;495          /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.   
;;;496           ** No loop unrolling is used. */
;;;497          blkCnt = (uint32_t) blockSize2 % 0x4u;
;;;498    
;;;499          while(blkCnt > 0u)
;;;500          {
;;;501            /* Accumulator is made zero for every iteration */
;;;502            sum = 0;
;;;503    
;;;504            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;505            k = srcBLen >> 2u;
;;;506    
;;;507            /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;508             ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;509            while(k > 0u)
;;;510            {
;;;511              /* Perform the multiply-accumulates */
;;;512              sum += ((q31_t) * px++ * *py--);
;;;513              sum += ((q31_t) * px++ * *py--);
;;;514              sum += ((q31_t) * px++ * *py--);
;;;515              sum += ((q31_t) * px++ * *py--);
;;;516    
;;;517              /* Decrement the loop counter */
;;;518              k--;
;;;519            }
;;;520    
;;;521            /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;522             ** No loop unrolling is used. */
;;;523            k = srcBLen % 0x4u;
;;;524    
;;;525            while(k > 0u)
;;;526            {
;;;527              /* Perform the multiply-accumulates */
;;;528              sum += ((q31_t) * px++ * *py--);
;;;529    
;;;530              /* Decrement the loop counter */
;;;531              k--;
;;;532            }
;;;533    
;;;534            /* Store the result in the accumulator in the destination buffer. */
;;;535            *pOut++ = (q15_t) (sum >> 15);
;;;536    
;;;537            /* Increment the pointer pIn1 index, count by 1 */
;;;538            count++;
;;;539    
;;;540            /* Update the inputA and inputB pointers for next MAC calculation */
;;;541            px = pIn1 + count;
;;;542            py = pSrc2;
;;;543    
;;;544            /* Decrement the loop counter */
;;;545            blkCnt--;
;;;546          }
;;;547        }
;;;548        else
;;;549        {
;;;550          /* If the srcBLen is not a multiple of 4,   
;;;551           * the blockSize2 loop cannot be unrolled by 4 */
;;;552          blkCnt = (uint32_t) blockSize2;
;;;553    
;;;554          while(blkCnt > 0u)
;;;555          {
;;;556            /* Accumulator is made zero for every iteration */
;;;557            sum = 0;
;;;558    
;;;559            /* srcBLen number of MACS should be performed */
;;;560            k = srcBLen;
;;;561    
;;;562            while(k > 0u)
;;;563            {
;;;564              /* Perform the multiply-accumulate */
;;;565              sum += ((q31_t) * px++ * *py--);
;;;566    
;;;567              /* Decrement the loop counter */
;;;568              k--;
;;;569            }
;;;570    
;;;571            /* Store the result in the accumulator in the destination buffer. */
;;;572            *pOut++ = (q15_t) (sum >> 15);
;;;573    
;;;574            /* Increment the MAC count */
;;;575            count++;
;;;576    
;;;577            /* Update the inputA and inputB pointers for next MAC calculation */
;;;578            px = pIn1 + count;
;;;579            py = pSrc2;
;;;580    
;;;581            /* Decrement the loop counter */
;;;582            blkCnt--;
;;;583          }
;;;584        }
;;;585    
;;;586    
;;;587        /* --------------------------   
;;;588         * Initializations of stage3   
;;;589         * -------------------------*/
;;;590    
;;;591        /* sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1]   
;;;592         * sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2]   
;;;593         * ....   
;;;594         * sum +=  x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2]   
;;;595         * sum +=  x[srcALen-1] * y[srcBLen-1]   
;;;596         */
;;;597    
;;;598        /* In this stage the MAC operations are decreased by 1 for every iteration.   
;;;599           The count variable holds the number of MAC operations performed */
;;;600        count = srcBLen - 1u;
;;;601    
;;;602        /* Working pointer of inputA */
;;;603        pSrc1 = (pIn1 + srcALen) - (srcBLen - 1u);
;;;604        px = pSrc1;
;;;605    
;;;606        /* Working pointer of inputB */
;;;607        pSrc2 = pIn2 + (srcBLen - 1u);
;;;608        pIn2 = pSrc2 - 1u;
;;;609        py = pIn2;
;;;610    
;;;611        /* -------------------   
;;;612         * Stage3 process   
;;;613         * ------------------*/
;;;614    
;;;615        /* For loop unrolling by 4, this stage is divided into two. */
;;;616        /* First part of this stage computes the MAC operations greater than 4 */
;;;617        /* Second part of this stage computes the MAC operations less than or equal to 4 */
;;;618    
;;;619        /* The first part of the stage starts here */
;;;620        j = count >> 2u;
;;;621    
;;;622        while((j > 0u) && (blockSize3 > 0))
;;;623        {
;;;624          /* Accumulator is made zero for every iteration */
;;;625          sum = 0;
;;;626    
;;;627          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;628          k = count >> 2u;
;;;629    
;;;630          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;631           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;632          while(k > 0u)
;;;633          {
;;;634            /* x[srcALen - srcBLen + 1], x[srcALen - srcBLen + 2] are multiplied   
;;;635             * with y[srcBLen - 1], y[srcBLen - 2] respectively */
;;;636            sum = __SMLADX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
;;;637            /* x[srcALen - srcBLen + 3], x[srcALen - srcBLen + 4] are multiplied   
;;;638             * with y[srcBLen - 3], y[srcBLen - 4] respectively */
;;;639            sum = __SMLADX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
;;;640    
;;;641            /* Decrement the loop counter */
;;;642            k--;
;;;643          }
;;;644    
;;;645          /* For the next MAC operations, the pointer py is used without SIMD   
;;;646           * So, py is incremented by 1 */
;;;647          py = py + 1u;
;;;648    
;;;649          /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;650           ** No loop unrolling is used. */
;;;651          k = count % 0x4u;
;;;652    
;;;653          while(k > 0u)
;;;654          {
;;;655            /* sum += x[srcALen - srcBLen + 5] * y[srcBLen - 5] */
;;;656            sum = __SMLAD(*px++, *py--, sum);
;;;657    
;;;658            /* Decrement the loop counter */
;;;659            k--;
;;;660          }
;;;661    
;;;662          /* Store the result in the accumulator in the destination buffer. */
;;;663          *pOut++ = (q15_t) (sum >> 15);
;;;664    
;;;665          /* Update the inputA and inputB pointers for next MAC calculation */
;;;666          px = ++pSrc1;
;;;667          py = pIn2;
;;;668    
;;;669          /* Decrement the MAC count */
;;;670          count--;
;;;671    
;;;672          /* Decrement the loop counter */
;;;673          blockSize3--;
;;;674    
;;;675          j--;
;;;676        }
;;;677    
;;;678        /* The second part of the stage starts here */
;;;679        /* SIMD is not used for the next MAC operations,   
;;;680         * so pointer py is updated to read only one sample at a time */
;;;681        py = py + 1u;
;;;682    
;;;683        while(blockSize3 > 0)
;;;684        {
;;;685          /* Accumulator is made zero for every iteration */
;;;686          sum = 0;
;;;687    
;;;688          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;689          k = count;
;;;690    
;;;691          while(k > 0u)
;;;692          {
;;;693            /* Perform the multiply-accumulates */
;;;694            /* sum +=  x[srcALen-1] * y[srcBLen-1] */
;;;695            sum = __SMLAD(*px++, *py--, sum);
;;;696    
;;;697            /* Decrement the loop counter */
;;;698            k--;
;;;699          }
;;;700    
;;;701          /* Store the result in the accumulator in the destination buffer. */
;;;702          *pOut++ = (q15_t) (sum >> 15);
;;;703    
;;;704          /* Update the inputA and inputB pointers for next MAC calculation */
;;;705          px = ++pSrc1;
;;;706          py = pSrc2;
;;;707    
;;;708          /* Decrement the MAC count */
;;;709          count--;
;;;710    
;;;711          /* Decrement the loop counter */
;;;712          blockSize3--;
;;;713        }
;;;714    
;;;715        /* set status as ARM_MATH_SUCCESS */
;;;716        status = ARM_MATH_SUCCESS;
;;;717      }
;;;718    
;;;719      /* Return to application */
;;;720      return (status);
;;;721    
;;;722    #else
;;;723    
;;;724      q15_t *pIn1;                                   /* inputA pointer               */
;;;725      q15_t *pIn2;                                   /* inputB pointer               */
;;;726      q15_t *pOut = pDst;                            /* output pointer               */
;;;727      q31_t sum, acc0, acc1, acc2, acc3;             /* Accumulator                  */
;;;728      q15_t *px;                                     /* Intermediate inputA pointer  */
;;;729      q15_t *py;                                     /* Intermediate inputB pointer  */
;;;730      q15_t *pSrc1, *pSrc2;                          /* Intermediate pointers        */
;;;731      q31_t x0, x1, x2, x3, c0;
;;;732      uint32_t j, k, count, check, blkCnt;
;;;733      int32_t blockSize1, blockSize2, blockSize3;    /* loop counters                 */
;;;734      arm_status status;                             /* status of Partial convolution */
;;;735      q15_t a, b;
;;;736    
;;;737      /* Check for range of output samples to be calculated */
;;;738      if((firstIndex + numPoints) > ((srcALen + (srcBLen - 1u))))
;;;739      {
;;;740        /* Set status as ARM_MATH_ARGUMENT_ERROR */
;;;741        status = ARM_MATH_ARGUMENT_ERROR;
;;;742      }
;;;743      else
;;;744      {
;;;745    
;;;746        /* The algorithm implementation is based on the lengths of the inputs. */
;;;747        /* srcB is always made to slide across srcA. */
;;;748        /* So srcBLen is always considered as shorter or equal to srcALen */
;;;749        if(srcALen >=srcBLen)
;;;750        {
;;;751          /* Initialization of inputA pointer */
;;;752          pIn1 = pSrcA;
;;;753    
;;;754          /* Initialization of inputB pointer */
;;;755          pIn2 = pSrcB;
;;;756        }
;;;757        else
;;;758        {
;;;759          /* Initialization of inputA pointer */
;;;760          pIn1 = pSrcB;
;;;761    
;;;762          /* Initialization of inputB pointer */
;;;763          pIn2 = pSrcA;
;;;764    
;;;765          /* srcBLen is always considered as shorter or equal to srcALen */
;;;766          j = srcBLen;
;;;767          srcBLen = srcALen;
;;;768          srcALen = j;
;;;769        }
;;;770    
;;;771        /* Conditions to check which loopCounter holds   
;;;772         * the first and last indices of the output samples to be calculated. */
;;;773        check = firstIndex + numPoints;
;;;774        blockSize3 = ((int32_t)check > (int32_t)srcALen) ? (int32_t)check - (int32_t)srcALen : 0;
;;;775        blockSize3 = ((int32_t)firstIndex > (int32_t)srcALen - 1) ? blockSize3 - (int32_t)firstIndex + (int32_t)srcALen : blockSize3;
;;;776        blockSize1 = ((int32_t) srcBLen - 1) - (int32_t) firstIndex;
;;;777        blockSize1 = (blockSize1 > 0) ? ((check > (srcBLen - 1u)) ? blockSize1 :
;;;778                                         (int32_t) numPoints) : 0;
;;;779        blockSize2 = ((int32_t) check - blockSize3) -
;;;780          (blockSize1 + (int32_t) firstIndex);
;;;781        blockSize2 = (blockSize2 > 0) ? blockSize2 : 0;
;;;782    
;;;783        /* conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1] */
;;;784        /* The function is internally   
;;;785         * divided into three stages according to the number of multiplications that has to be   
;;;786         * taken place between inputA samples and inputB samples. In the first stage of the   
;;;787         * algorithm, the multiplications increase by one for every iteration.   
;;;788         * In the second stage of the algorithm, srcBLen number of multiplications are done.   
;;;789         * In the third stage of the algorithm, the multiplications decrease by one   
;;;790         * for every iteration. */
;;;791    
;;;792        /* Set the output pointer to point to the firstIndex   
;;;793         * of the output sample to be calculated. */
;;;794        pOut = pDst + firstIndex;
;;;795    
;;;796        /* --------------------------   
;;;797         * Initializations of stage1   
;;;798         * -------------------------*/
;;;799    
;;;800        /* sum = x[0] * y[0]   
;;;801         * sum = x[0] * y[1] + x[1] * y[0]   
;;;802         * ....   
;;;803         * sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]   
;;;804         */
;;;805    
;;;806        /* In this stage the MAC operations are increased by 1 for every iteration.   
;;;807           The count variable holds the number of MAC operations performed.   
;;;808           Since the partial convolution starts from firstIndex   
;;;809           Number of Macs to be performed is firstIndex + 1 */
;;;810        count = 1u + firstIndex;
;;;811    
;;;812        /* Working pointer of inputA */
;;;813        px = pIn1;
;;;814    
;;;815        /* Working pointer of inputB */
;;;816        pSrc2 = pIn2 + firstIndex;
;;;817        py = pSrc2;
;;;818    
;;;819        /* ------------------------   
;;;820         * Stage1 process   
;;;821         * ----------------------*/
;;;822    
;;;823        /* For loop unrolling by 4, this stage is divided into two. */
;;;824        /* First part of this stage computes the MAC operations less than 4 */
;;;825        /* Second part of this stage computes the MAC operations greater than or equal to 4 */
;;;826    
;;;827        /* The first part of the stage starts here */
;;;828      while((count < 4u) && (blockSize1 > 0))
;;;829        {
;;;830          /* Accumulator is made zero for every iteration */
;;;831          sum = 0;
;;;832    
;;;833          /* Loop over number of MAC operations between   
;;;834           * inputA samples and inputB samples */
;;;835          k = count;
;;;836    
;;;837          while(k > 0u)
;;;838          {
;;;839            /* Perform the multiply-accumulates */
;;;840          sum += ((q31_t) * px++ * *py--);
;;;841    
;;;842            /* Decrement the loop counter */
;;;843            k--;
;;;844          }
;;;845    
;;;846          /* Store the result in the accumulator in the destination buffer. */
;;;847          *pOut++ = (q15_t) (sum >> 15);
;;;848    
;;;849          /* Update the inputA and inputB pointers for next MAC calculation */
;;;850          py = ++pSrc2;
;;;851          px = pIn1;
;;;852    
;;;853          /* Increment the MAC count */
;;;854          count++;
;;;855    
;;;856          /* Decrement the loop counter */
;;;857          blockSize1--;
;;;858        }
;;;859    
;;;860        /* The second part of the stage starts here */
;;;861        /* The internal loop, over count, is unrolled by 4 */
;;;862        /* To, read the last two inputB samples using SIMD:   
;;;863         * y[srcBLen] and y[srcBLen-1] coefficients, py is decremented by 1 */
;;;864        py = py - 1;
;;;865    
;;;866      while(blockSize1 > 0)
;;;867        {
;;;868          /* Accumulator is made zero for every iteration */
;;;869          sum = 0;
;;;870    
;;;871          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;872          k = count >> 2u;
;;;873    
;;;874          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;875           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;876    	py++;
;;;877    
;;;878        while(k > 0u)
;;;879        {
;;;880          /* Perform the multiply-accumulates */
;;;881            sum += ((q31_t) * px++ * *py--);
;;;882            sum += ((q31_t) * px++ * *py--);
;;;883            sum += ((q31_t) * px++ * *py--);
;;;884            sum += ((q31_t) * px++ * *py--);
;;;885    
;;;886          /* Decrement the loop counter */
;;;887          k--;
;;;888        }
;;;889    
;;;890          /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;891           ** No loop unrolling is used. */
;;;892          k = count % 0x4u;
;;;893    
;;;894          while(k > 0u)
;;;895          {
;;;896            /* Perform the multiply-accumulates */
;;;897          sum += ((q31_t) * px++ * *py--);
;;;898    
;;;899            /* Decrement the loop counter */
;;;900            k--;
;;;901          }
;;;902    
;;;903          /* Store the result in the accumulator in the destination buffer. */
;;;904          *pOut++ = (q15_t) (sum >> 15);
;;;905    
;;;906          /* Update the inputA and inputB pointers for next MAC calculation */
;;;907          py = ++pSrc2 - 1u;
;;;908          px = pIn1;
;;;909    
;;;910          /* Increment the MAC count */
;;;911          count++;
;;;912    
;;;913          /* Decrement the loop counter */
;;;914          blockSize1--;
;;;915        }
;;;916    
;;;917        /* --------------------------   
;;;918         * Initializations of stage2   
;;;919         * ------------------------*/
;;;920    
;;;921        /* sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0]   
;;;922         * sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0]   
;;;923         * ....   
;;;924         * sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]   
;;;925         */
;;;926    
;;;927        /* Working pointer of inputA */
;;;928        if((int32_t)firstIndex - (int32_t)srcBLen + 1 > 0)
;;;929        {
;;;930          px = pIn1 + firstIndex - srcBLen + 1;
;;;931        }
;;;932        else
;;;933        {
;;;934          px = pIn1;
;;;935        }
;;;936    
;;;937        /* Working pointer of inputB */
;;;938        pSrc2 = pIn2 + (srcBLen - 1u);
;;;939        py = pSrc2;
;;;940    
;;;941        /* count is the index by which the pointer pIn1 to be incremented */
;;;942        count = 0u;
;;;943    
;;;944    
;;;945        /* --------------------   
;;;946         * Stage2 process   
;;;947         * -------------------*/
;;;948    
;;;949        /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.   
;;;950         * So, to loop unroll over blockSize2,   
;;;951         * srcBLen should be greater than or equal to 4 */
;;;952        if(srcBLen >= 4u)
;;;953        {
;;;954          /* Loop unroll over blockSize2, by 4 */
;;;955          blkCnt = ((uint32_t) blockSize2 >> 2u);
;;;956    
;;;957          while(blkCnt > 0u)
;;;958          {
;;;959          py = py - 1u;
;;;960    
;;;961            /* Set all accumulators to zero */
;;;962            acc0 = 0;
;;;963            acc1 = 0;
;;;964            acc2 = 0;
;;;965            acc3 = 0;
;;;966    
;;;967          /* read x[0], x[1] samples */
;;;968    	  a = *px++;
;;;969    	  b = *px++;
;;;970    
;;;971    #ifndef ARM_MATH_BIG_ENDIAN
;;;972    	
;;;973    	  x0 = __PKHBT(a, b, 16);
;;;974    	  a = *px;
;;;975    	  x1 = __PKHBT(b, a, 16);
;;;976    
;;;977    #else
;;;978    
;;;979    	  x0 = __PKHBT(b, a, 16);
;;;980    	  a = *px;
;;;981    	  x1 = __PKHBT(a, b, 16);
;;;982    
;;;983    #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	   */
;;;984    
;;;985          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;986          k = srcBLen >> 2u;
;;;987    
;;;988          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;989           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;990          do
;;;991          {
;;;992            /* Read the last two inputB samples using SIMD:   
;;;993             * y[srcBLen - 1] and y[srcBLen - 2] */
;;;994    		a = *py;
;;;995    		b = *(py+1);
;;;996    		py -= 2;
;;;997    
;;;998    #ifndef ARM_MATH_BIG_ENDIAN
;;;999    
;;;1000   		c0 = __PKHBT(a, b, 16);
;;;1001   
;;;1002   #else
;;;1003   
;;;1004    		c0 = __PKHBT(b, a, 16);;
;;;1005   
;;;1006   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;1007   
;;;1008           /* acc0 +=  x[0] * y[srcBLen - 1] + x[1] * y[srcBLen - 2] */
;;;1009           acc0 = __SMLADX(x0, c0, acc0);
;;;1010   
;;;1011           /* acc1 +=  x[1] * y[srcBLen - 1] + x[2] * y[srcBLen - 2] */
;;;1012           acc1 = __SMLADX(x1, c0, acc1);
;;;1013   
;;;1014   	  a = *px;
;;;1015   	  b = *(px + 1);
;;;1016   
;;;1017   #ifndef ARM_MATH_BIG_ENDIAN
;;;1018   	
;;;1019   	  x2 = __PKHBT(a, b, 16);
;;;1020   	  a = *(px + 2);
;;;1021   	  x3 = __PKHBT(b, a, 16);
;;;1022   
;;;1023   #else
;;;1024   
;;;1025   	  x2 = __PKHBT(b, a, 16);
;;;1026   	  a = *(px + 2);
;;;1027   	  x3 = __PKHBT(a, b, 16);
;;;1028   
;;;1029   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	   */
;;;1030   
;;;1031           /* acc2 +=  x[2] * y[srcBLen - 1] + x[3] * y[srcBLen - 2] */
;;;1032           acc2 = __SMLADX(x2, c0, acc2);
;;;1033   
;;;1034           /* acc3 +=  x[3] * y[srcBLen - 1] + x[4] * y[srcBLen - 2] */
;;;1035           acc3 = __SMLADX(x3, c0, acc3);
;;;1036   
;;;1037           /* Read y[srcBLen - 3] and y[srcBLen - 4] */
;;;1038   		a = *py;
;;;1039   		b = *(py+1);
;;;1040   		py -= 2;
;;;1041   
;;;1042   #ifndef ARM_MATH_BIG_ENDIAN
;;;1043   
;;;1044   		c0 = __PKHBT(a, b, 16);
;;;1045   
;;;1046   #else
;;;1047   
;;;1048    		c0 = __PKHBT(b, a, 16);;
;;;1049   
;;;1050   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;1051   
;;;1052           /* acc0 +=  x[2] * y[srcBLen - 3] + x[3] * y[srcBLen - 4] */
;;;1053           acc0 = __SMLADX(x2, c0, acc0);
;;;1054   
;;;1055           /* acc1 +=  x[3] * y[srcBLen - 3] + x[4] * y[srcBLen - 4] */
;;;1056           acc1 = __SMLADX(x3, c0, acc1);
;;;1057   
;;;1058           /* Read x[4], x[5], x[6] */
;;;1059   	  a = *(px + 2);
;;;1060   	  b = *(px + 3);
;;;1061   
;;;1062   #ifndef ARM_MATH_BIG_ENDIAN
;;;1063   	
;;;1064   	  x0 = __PKHBT(a, b, 16);
;;;1065   	  a = *(px + 4);
;;;1066   	  x1 = __PKHBT(b, a, 16);
;;;1067   
;;;1068   #else
;;;1069   
;;;1070   	  x0 = __PKHBT(b, a, 16);
;;;1071   	  a = *(px + 4);
;;;1072   	  x1 = __PKHBT(a, b, 16);
;;;1073   
;;;1074   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	   */
;;;1075   
;;;1076   		px += 4u;
;;;1077   
;;;1078           /* acc2 +=  x[4] * y[srcBLen - 3] + x[5] * y[srcBLen - 4] */
;;;1079           acc2 = __SMLADX(x0, c0, acc2);
;;;1080   
;;;1081           /* acc3 +=  x[5] * y[srcBLen - 3] + x[6] * y[srcBLen - 4] */
;;;1082           acc3 = __SMLADX(x1, c0, acc3);
;;;1083   
;;;1084         } while(--k);
;;;1085   
;;;1086         /* For the next MAC operations, SIMD is not used   
;;;1087          * So, the 16 bit pointer if inputB, py is updated */
;;;1088   
;;;1089         /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;1090          ** No loop unrolling is used. */
;;;1091         k = srcBLen % 0x4u;
;;;1092   
;;;1093         if(k == 1u)
;;;1094         {
;;;1095           /* Read y[srcBLen - 5] */
;;;1096           c0 = *(py+1);
;;;1097   
;;;1098   #ifdef  ARM_MATH_BIG_ENDIAN
;;;1099   
;;;1100           c0 = c0 << 16u;
;;;1101   
;;;1102   #else
;;;1103   
;;;1104           c0 = c0 & 0x0000FFFF;
;;;1105   
;;;1106   #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;1107   
;;;1108           /* Read x[7] */
;;;1109   		a = *px;
;;;1110   		b = *(px+1);
;;;1111   		px++;
;;;1112   
;;;1113   #ifndef ARM_MATH_BIG_ENDIAN
;;;1114   
;;;1115   		x3 = __PKHBT(a, b, 16);
;;;1116   
;;;1117   #else
;;;1118   
;;;1119    		x3 = __PKHBT(b, a, 16);;
;;;1120   
;;;1121   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;1122   
;;;1123   
;;;1124           /* Perform the multiply-accumulates */
;;;1125           acc0 = __SMLAD(x0, c0, acc0);
;;;1126           acc1 = __SMLAD(x1, c0, acc1);
;;;1127           acc2 = __SMLADX(x1, c0, acc2);
;;;1128           acc3 = __SMLADX(x3, c0, acc3);
;;;1129         }
;;;1130   
;;;1131         if(k == 2u)
;;;1132         {
;;;1133           /* Read y[srcBLen - 5], y[srcBLen - 6] */
;;;1134   		a = *py;
;;;1135   		b = *(py+1);
;;;1136   
;;;1137   #ifndef ARM_MATH_BIG_ENDIAN
;;;1138   
;;;1139   		c0 = __PKHBT(a, b, 16);
;;;1140   
;;;1141   #else
;;;1142   
;;;1143    		c0 = __PKHBT(b, a, 16);;
;;;1144   
;;;1145   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;1146   
;;;1147           /* Read x[7], x[8], x[9] */
;;;1148   	  a = *px;
;;;1149   	  b = *(px + 1);
;;;1150   
;;;1151   #ifndef ARM_MATH_BIG_ENDIAN
;;;1152   	
;;;1153   	  x3 = __PKHBT(a, b, 16);
;;;1154   	  a = *(px + 2);
;;;1155   	  x2 = __PKHBT(b, a, 16);
;;;1156   
;;;1157   #else
;;;1158   
;;;1159   	  x3 = __PKHBT(b, a, 16);
;;;1160   	  a = *(px + 2);
;;;1161   	  x2 = __PKHBT(a, b, 16);
;;;1162   
;;;1163   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	   */
;;;1164   		px += 2u;
;;;1165   
;;;1166           /* Perform the multiply-accumulates */
;;;1167           acc0 = __SMLADX(x0, c0, acc0);
;;;1168           acc1 = __SMLADX(x1, c0, acc1);
;;;1169           acc2 = __SMLADX(x3, c0, acc2);
;;;1170           acc3 = __SMLADX(x2, c0, acc3);
;;;1171         }
;;;1172   
;;;1173         if(k == 3u)
;;;1174         {
;;;1175           /* Read y[srcBLen - 5], y[srcBLen - 6] */
;;;1176   		a = *py;
;;;1177   		b = *(py+1);
;;;1178   
;;;1179   #ifndef ARM_MATH_BIG_ENDIAN
;;;1180   
;;;1181   		c0 = __PKHBT(a, b, 16);
;;;1182   
;;;1183   #else
;;;1184   
;;;1185    		c0 = __PKHBT(b, a, 16);;
;;;1186   
;;;1187   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;1188   
;;;1189           /* Read x[7], x[8], x[9] */
;;;1190   	  a = *px;
;;;1191   	  b = *(px + 1);
;;;1192   
;;;1193   #ifndef ARM_MATH_BIG_ENDIAN
;;;1194   	
;;;1195   	  x3 = __PKHBT(a, b, 16);
;;;1196   	  a = *(px + 2);
;;;1197   	  x2 = __PKHBT(b, a, 16);
;;;1198   
;;;1199   #else
;;;1200   
;;;1201   	  x3 = __PKHBT(b, a, 16);
;;;1202   	  a = *(px + 2);
;;;1203   	  x2 = __PKHBT(a, b, 16);
;;;1204   
;;;1205   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	   */
;;;1206   
;;;1207           /* Perform the multiply-accumulates */
;;;1208           acc0 = __SMLADX(x0, c0, acc0);
;;;1209           acc1 = __SMLADX(x1, c0, acc1);
;;;1210           acc2 = __SMLADX(x3, c0, acc2);
;;;1211           acc3 = __SMLADX(x2, c0, acc3);
;;;1212   
;;;1213           /* Read y[srcBLen - 7] */
;;;1214   		c0 = *(py-1);
;;;1215   #ifdef  ARM_MATH_BIG_ENDIAN
;;;1216   
;;;1217           c0 = c0 << 16u;
;;;1218   #else
;;;1219   
;;;1220           c0 = c0 & 0x0000FFFF;
;;;1221   #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;1222   
;;;1223           /* Read x[10] */
;;;1224   		a = *(px+2);
;;;1225   		b = *(px+3);
;;;1226   
;;;1227   #ifndef ARM_MATH_BIG_ENDIAN
;;;1228   
;;;1229   		x3 = __PKHBT(a, b, 16);
;;;1230   
;;;1231   #else
;;;1232   
;;;1233    		x3 = __PKHBT(b, a, 16);;
;;;1234   
;;;1235   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;1236   
;;;1237   		px += 3u;
;;;1238   
;;;1239           /* Perform the multiply-accumulates */
;;;1240           acc0 = __SMLADX(x1, c0, acc0);
;;;1241           acc1 = __SMLAD(x2, c0, acc1);
;;;1242           acc2 = __SMLADX(x2, c0, acc2);
;;;1243           acc3 = __SMLADX(x3, c0, acc3);
;;;1244         }
;;;1245   
;;;1246         /* Store the results in the accumulators in the destination buffer. */
;;;1247   	  *pOut++ = (q15_t)(acc0 >> 15);
;;;1248   	  *pOut++ = (q15_t)(acc1 >> 15);
;;;1249   	  *pOut++ = (q15_t)(acc2 >> 15);
;;;1250   	  *pOut++ = (q15_t)(acc3 >> 15);
;;;1251   
;;;1252           /* Increment the pointer pIn1 index, count by 4 */
;;;1253           count += 4u;
;;;1254   
;;;1255           /* Update the inputA and inputB pointers for next MAC calculation */
;;;1256           px = pIn1 + count;
;;;1257           py = pSrc2;
;;;1258   
;;;1259           /* Decrement the loop counter */
;;;1260           blkCnt--;
;;;1261         }
;;;1262   
;;;1263         /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.   
;;;1264          ** No loop unrolling is used. */
;;;1265         blkCnt = (uint32_t) blockSize2 % 0x4u;
;;;1266   
;;;1267         while(blkCnt > 0u)
;;;1268         {
;;;1269           /* Accumulator is made zero for every iteration */
;;;1270           sum = 0;
;;;1271   
;;;1272           /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;1273           k = srcBLen >> 2u;
;;;1274   
;;;1275           /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;1276            ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;1277           while(k > 0u)
;;;1278           {
;;;1279             /* Perform the multiply-accumulates */
;;;1280             sum += ((q31_t) * px++ * *py--);
;;;1281             sum += ((q31_t) * px++ * *py--);
;;;1282             sum += ((q31_t) * px++ * *py--);
;;;1283             sum += ((q31_t) * px++ * *py--);
;;;1284   
;;;1285             /* Decrement the loop counter */
;;;1286             k--;
;;;1287           }
;;;1288   
;;;1289           /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;1290            ** No loop unrolling is used. */
;;;1291           k = srcBLen % 0x4u;
;;;1292   
;;;1293           while(k > 0u)
;;;1294           {
;;;1295             /* Perform the multiply-accumulates */
;;;1296             sum += ((q31_t) * px++ * *py--);
;;;1297   
;;;1298             /* Decrement the loop counter */
;;;1299             k--;
;;;1300           }
;;;1301   
;;;1302           /* Store the result in the accumulator in the destination buffer. */
;;;1303           *pOut++ = (q15_t) (sum >> 15);
;;;1304   
;;;1305           /* Increment the pointer pIn1 index, count by 1 */
;;;1306           count++;
;;;1307   
;;;1308           /* Update the inputA and inputB pointers for next MAC calculation */
;;;1309           px = pIn1 + count;
;;;1310           py = pSrc2;
;;;1311   
;;;1312           /* Decrement the loop counter */
;;;1313           blkCnt--;
;;;1314         }
;;;1315       }
;;;1316       else
;;;1317       {
;;;1318         /* If the srcBLen is not a multiple of 4,   
;;;1319          * the blockSize2 loop cannot be unrolled by 4 */
;;;1320         blkCnt = (uint32_t) blockSize2;
;;;1321   
;;;1322         while(blkCnt > 0u)
;;;1323         {
;;;1324           /* Accumulator is made zero for every iteration */
;;;1325           sum = 0;
;;;1326   
;;;1327           /* srcBLen number of MACS should be performed */
;;;1328           k = srcBLen;
;;;1329   
;;;1330           while(k > 0u)
;;;1331           {
;;;1332             /* Perform the multiply-accumulate */
;;;1333             sum += ((q31_t) * px++ * *py--);
;;;1334   
;;;1335             /* Decrement the loop counter */
;;;1336             k--;
;;;1337           }
;;;1338   
;;;1339           /* Store the result in the accumulator in the destination buffer. */
;;;1340           *pOut++ = (q15_t) (sum >> 15);
;;;1341   
;;;1342           /* Increment the MAC count */
;;;1343           count++;
;;;1344   
;;;1345           /* Update the inputA and inputB pointers for next MAC calculation */
;;;1346           px = pIn1 + count;
;;;1347           py = pSrc2;
;;;1348   
;;;1349           /* Decrement the loop counter */
;;;1350           blkCnt--;
;;;1351         }
;;;1352       }
;;;1353   
;;;1354   
;;;1355       /* --------------------------   
;;;1356        * Initializations of stage3   
;;;1357        * -------------------------*/
;;;1358   
;;;1359       /* sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1]   
;;;1360        * sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2]   
;;;1361        * ....   
;;;1362        * sum +=  x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2]   
;;;1363        * sum +=  x[srcALen-1] * y[srcBLen-1]   
;;;1364        */
;;;1365   
;;;1366       /* In this stage the MAC operations are decreased by 1 for every iteration.   
;;;1367          The count variable holds the number of MAC operations performed */
;;;1368       count = srcBLen - 1u;
;;;1369   
;;;1370       /* Working pointer of inputA */
;;;1371       pSrc1 = (pIn1 + srcALen) - (srcBLen - 1u);
;;;1372       px = pSrc1;
;;;1373   
;;;1374       /* Working pointer of inputB */
;;;1375       pSrc2 = pIn2 + (srcBLen - 1u);
;;;1376       pIn2 = pSrc2 - 1u;
;;;1377       py = pIn2;
;;;1378   
;;;1379       /* -------------------   
;;;1380        * Stage3 process   
;;;1381        * ------------------*/
;;;1382   
;;;1383       /* For loop unrolling by 4, this stage is divided into two. */
;;;1384       /* First part of this stage computes the MAC operations greater than 4 */
;;;1385       /* Second part of this stage computes the MAC operations less than or equal to 4 */
;;;1386   
;;;1387       /* The first part of the stage starts here */
;;;1388       j = count >> 2u;
;;;1389   
;;;1390       while((j > 0u) && (blockSize3 > 0))
;;;1391       {
;;;1392         /* Accumulator is made zero for every iteration */
;;;1393         sum = 0;
;;;1394   
;;;1395         /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;1396         k = count >> 2u;
;;;1397   
;;;1398         /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;1399          ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;1400   	py++;
;;;1401   
;;;1402       while(k > 0u)
;;;1403       {	
;;;1404         /* Perform the multiply-accumulates */
;;;1405           sum += ((q31_t) * px++ * *py--);
;;;1406           sum += ((q31_t) * px++ * *py--);
;;;1407           sum += ((q31_t) * px++ * *py--);
;;;1408           sum += ((q31_t) * px++ * *py--);
;;;1409         /* Decrement the loop counter */
;;;1410         k--;
;;;1411       }
;;;1412   
;;;1413   
;;;1414         /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;1415          ** No loop unrolling is used. */
;;;1416         k = count % 0x4u;
;;;1417   
;;;1418         while(k > 0u)
;;;1419         {
;;;1420         /* Perform the multiply-accumulates */
;;;1421           sum += ((q31_t) * px++ * *py--);
;;;1422   
;;;1423           /* Decrement the loop counter */
;;;1424           k--;
;;;1425         }
;;;1426   
;;;1427         /* Store the result in the accumulator in the destination buffer. */
;;;1428         *pOut++ = (q15_t) (sum >> 15);
;;;1429   
;;;1430         /* Update the inputA and inputB pointers for next MAC calculation */
;;;1431         px = ++pSrc1;
;;;1432         py = pIn2;
;;;1433   
;;;1434         /* Decrement the MAC count */
;;;1435         count--;
;;;1436   
;;;1437         /* Decrement the loop counter */
;;;1438         blockSize3--;
;;;1439   
;;;1440         j--;
;;;1441       }
;;;1442   
;;;1443       /* The second part of the stage starts here */
;;;1444       /* SIMD is not used for the next MAC operations,   
;;;1445        * so pointer py is updated to read only one sample at a time */
;;;1446       py = py + 1u;
;;;1447   
;;;1448     while(blockSize3 > 0)
;;;1449       {
;;;1450         /* Accumulator is made zero for every iteration */
;;;1451         sum = 0;
;;;1452   
;;;1453         /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;1454         k = count;
;;;1455   
;;;1456         while(k > 0u)
;;;1457         {
;;;1458           /* Perform the multiply-accumulates */
;;;1459           /* sum +=  x[srcALen-1] * y[srcBLen-1] */
;;;1460           sum += ((q31_t) * px++ * *py--);
;;;1461   
;;;1462           /* Decrement the loop counter */
;;;1463           k--;
;;;1464         }
;;;1465   
;;;1466         /* Store the result in the accumulator in the destination buffer. */
;;;1467         *pOut++ = (q15_t) (sum >> 15);
;;;1468   
;;;1469         /* Update the inputA and inputB pointers for next MAC calculation */
;;;1470         px = ++pSrc1;
;;;1471         py = pSrc2;
;;;1472   
;;;1473         /* Decrement the MAC count */
;;;1474         count--;
;;;1475   
;;;1476         /* Decrement the loop counter */
;;;1477         blockSize3--;
;;;1478       }
;;;1479   
;;;1480       /* set status as ARM_MATH_SUCCESS */
;;;1481       status = ARM_MATH_SUCCESS;
;;;1482     }
;;;1483   
;;;1484     /* Return to application */
;;;1485     return (status);
;;;1486   
;;;1487   #endif /*     #ifndef UNALIGNED_SUPPORT_DISABLE      */
;;;1488   }
00001e  b00d              ADD      sp,sp,#0x34
000020  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.36|
000024  9e0a              LDR      r6,[sp,#0x28]         ;102
000026  429e              CMP      r6,r3                 ;102
000028  d302              BCC      |L1.48|
00002a  4682              MOV      r10,r0                ;105
00002c  4696              MOV      lr,r2                 ;108
00002e  e004              B        |L1.58|
                  |L1.48|
000030  4692              MOV      r10,r2                ;113
000032  4686              MOV      lr,r0                 ;116
000034  4618              MOV      r0,r3                 ;119
000036  9b0a              LDR      r3,[sp,#0x28]         ;120
000038  900a              STR      r0,[sp,#0x28]         ;121
                  |L1.58|
00003a  980a              LDR      r0,[sp,#0x28]         ;127
00003c  4281              CMP      r1,r0                 ;127
00003e  dd02              BLE      |L1.70|
000040  980a              LDR      r0,[sp,#0x28]         ;127
000042  1a08              SUBS     r0,r1,r0              ;127
000044  e000              B        |L1.72|
                  |L1.70|
000046  2000              MOVS     r0,#0                 ;127
                  |L1.72|
000048  9a0a              LDR      r2,[sp,#0x28]         ;128
00004a  1e52              SUBS     r2,r2,#1              ;128
00004c  4590              CMP      r8,r2                 ;128
00004e  dd03              BLE      |L1.88|
000050  eba00208          SUB      r2,r0,r8              ;128
000054  980a              LDR      r0,[sp,#0x28]         ;128
000056  4410              ADD      r0,r0,r2              ;128
                  |L1.88|
000058  9000              STR      r0,[sp,#0]            ;128
00005a  eba30608          SUB      r6,r3,r8              ;129
00005e  1e76              SUBS     r6,r6,#1              ;129
000060  2e00              CMP      r6,#0                 ;130
000062  dd04              BLE      |L1.110|
000064  1e58              SUBS     r0,r3,#1              ;130
000066  4281              CMP      r1,r0                 ;130
000068  d802              BHI      |L1.112|
00006a  462e              MOV      r6,r5                 ;131
00006c  e000              B        |L1.112|
                  |L1.110|
00006e  2600              MOVS     r6,#0                 ;131
                  |L1.112|
000070  9800              LDR      r0,[sp,#0]            ;132
000072  4430              ADD      r0,r0,r6              ;132
000074  4440              ADD      r0,r0,r8              ;132
000076  1a08              SUBS     r0,r1,r0              ;132
000078  2800              CMP      r0,#0                 ;134
00007a  dc00              BGT      |L1.126|
00007c  2000              MOVS     r0,#0                 ;134
                  |L1.126|
00007e  9001              STR      r0,[sp,#4]            ;134
000080  eb040048          ADD      r0,r4,r8,LSL #1       ;147
000084  f1080401          ADD      r4,r8,#1              ;163
000088  4651              MOV      r1,r10                ;166
00008a  eb0e0c48          ADD      r12,lr,r8,LSL #1      ;169
00008e  4665              MOV      r5,r12                ;170
000090  e014              B        |L1.188|
                  |L1.146|
000092  2700              MOVS     r7,#0                 ;184
000094  4622              MOV      r2,r4                 ;188
000096  e006              B        |L1.166|
                  |L1.152|
000098  f9319b02          LDRSH    r9,[r1],#2            ;193
00009c  f935b902          LDRSH    r11,[r5],#-2          ;193
0000a0  fb29770b          SMLAD    r7,r9,r11,r7          ;193
0000a4  1e52              SUBS     r2,r2,#1              ;196
                  |L1.166|
0000a6  2a00              CMP      r2,#0                 ;190
0000a8  d1f6              BNE      |L1.152|
0000aa  13f9              ASRS     r1,r7,#15             ;200
0000ac  f8201b02          STRH     r1,[r0],#2            ;200
0000b0  f10c0502          ADD      r5,r12,#2             ;203
0000b4  46ac              MOV      r12,r5                ;203
0000b6  4651              MOV      r1,r10                ;204
0000b8  1c64              ADDS     r4,r4,#1              ;207
0000ba  1e76              SUBS     r6,r6,#1              ;210
                  |L1.188|
0000bc  2c04              CMP      r4,#4                 ;181
0000be  d201              BCS      |L1.196|
0000c0  2e00              CMP      r6,#0                 ;181
0000c2  dce6              BGT      |L1.146|
                  |L1.196|
0000c4  1ead              SUBS     r5,r5,#2              ;217
0000c6  e028              B        |L1.282|
                  |L1.200|
0000c8  2200              MOVS     r2,#0                 ;222
0000ca  08a7              LSRS     r7,r4,#2              ;225
0000cc  e00c              B        |L1.232|
                  |L1.206|
0000ce  f8519b04          LDR      r9,[r1],#4            ;233
0000d2  f855b904          LDR      r11,[r5],#-4          ;233
0000d6  fb29221b          SMLADX   r2,r9,r11,r2          ;233
0000da  f8519b04          LDR      r9,[r1],#4            ;235
0000de  f855b904          LDR      r11,[r5],#-4          ;235
0000e2  fb29221b          SMLADX   r2,r9,r11,r2          ;235
0000e6  1e7f              SUBS     r7,r7,#1              ;238
                  |L1.232|
0000e8  2f00              CMP      r7,#0                 ;229
0000ea  d1f0              BNE      |L1.206|
0000ec  1cad              ADDS     r5,r5,#2              ;243
0000ee  f0040703          AND      r7,r4,#3              ;247
0000f2  e006              B        |L1.258|
                  |L1.244|
0000f4  f9319b02          LDRSH    r9,[r1],#2            ;252
0000f8  f935b902          LDRSH    r11,[r5],#-2          ;252
0000fc  fb29220b          SMLAD    r2,r9,r11,r2          ;252
000100  1e7f              SUBS     r7,r7,#1              ;255
                  |L1.258|
000102  2f00              CMP      r7,#0                 ;249
000104  d1f6              BNE      |L1.244|
000106  13d1              ASRS     r1,r2,#15             ;259
000108  f8201b02          STRH     r1,[r0],#2            ;259
00010c  f10c0c02          ADD      r12,r12,#2            ;262
000110  f1ac0502          SUB      r5,r12,#2             ;262
000114  4651              MOV      r1,r10                ;263
000116  1c64              ADDS     r4,r4,#1              ;266
000118  1e76              SUBS     r6,r6,#1              ;269
                  |L1.282|
00011a  2e00              CMP      r6,#0                 ;219
00011c  dcd4              BGT      |L1.200|
00011e  eba80203          SUB      r2,r8,r3              ;283
000122  1c52              ADDS     r2,r2,#1              ;283
000124  2a00              CMP      r2,#0                 ;283
000126  dd04              BLE      |L1.306|
000128  eb0a0148          ADD      r1,r10,r8,LSL #1      ;285
00012c  eba10143          SUB      r1,r1,r3,LSL #1       ;285
000130  1c89              ADDS     r1,r1,#2              ;285
                  |L1.306|
000132  1e5a              SUBS     r2,r3,#1              ;293
000134  eb0e0c42          ADD      r12,lr,r2,LSL #1      ;293
000138  e9cdc207          STRD     r12,r2,[sp,#0x1c]     ;293
00013c  f8cdc018          STR      r12,[sp,#0x18]        ;293
000140  f8ddc018          LDR      r12,[sp,#0x18]        ;294
000144  f04f0800          MOV      r8,#0                 ;297
000148  2b04              CMP      r3,#4                 ;307
00014a  d37d              BCC      |L1.584|
00014c  9a01              LDR      r2,[sp,#4]            ;310
00014e  0892              LSRS     r2,r2,#2              ;310
000150  9202              STR      r2,[sp,#8]            ;310
000152  e098              B        |L1.646|
                  |L1.340|
000154  f1ac0c02          SUB      r12,r12,#2            ;314
000158  2200              MOVS     r2,#0                 ;317
00015a  2400              MOVS     r4,#0                 ;318
00015c  2500              MOVS     r5,#0                 ;319
00015e  2600              MOVS     r6,#0                 ;320
000160  f8d19000          LDR      r9,[r1,#0]            ;324
000164  f8d17002          LDR      r7,[r1,#2]            ;326
000168  1d09              ADDS     r1,r1,#4              ;327
00016a  ea4f0e93          LSR      lr,r3,#2              ;331
                  |L1.366|
00016e  f85cb904          LDR      r11,[r12],#-4         ;339
000172  fb29291b          SMLADX   r9,r9,r11,r2          ;342
000176  fb27471b          SMLADX   r7,r7,r11,r4          ;345
00017a  680a              LDR      r2,[r1,#0]            ;348
00017c  f8d14002          LDR      r4,[r1,#2]            ;351
000180  fb22551b          SMLADX   r5,r2,r11,r5          ;354
000184  fb246b1b          SMLADX   r11,r4,r11,r6         ;357
000188  f85c6904          LDR      r6,[r12],#-4          ;360
00018c  fb229216          SMLADX   r2,r2,r6,r9           ;363
000190  fb247416          SMLADX   r4,r4,r6,r7           ;366
000194  f8d19004          LDR      r9,[r1,#4]            ;369
000198  f8d17006          LDR      r7,[r1,#6]            ;372
00019c  3108              ADDS     r1,r1,#8              ;373
00019e  fb295516          SMLADX   r5,r9,r6,r5           ;376
0001a2  fb27b616          SMLADX   r6,r7,r6,r11          ;379
0001a6  f1be0e01          SUBS     lr,lr,#1              ;381
0001aa  d1e0              BNE      |L1.366|
0001ac  f0030b03          AND      r11,r3,#3             ;388
0001b0  f8cdb00c          STR      r11,[sp,#0xc]         ;388
0001b4  f8ddb00c          LDR      r11,[sp,#0xc]         ;390
0001b8  f1bb0f01          CMP      r11,#1                ;390
0001bc  d10e              BNE      |L1.476|
0001be  f8bcb002          LDRH     r11,[r12,#2]          ;393
0001c2  fa1ffb8b          UXTH     r11,r11               ;400
0001c6  f8d1e000          LDR      lr,[r1,#0]            ;405
0001ca  1c89              ADDS     r1,r1,#2              ;406
0001cc  fb29220b          SMLAD    r2,r9,r11,r2          ;409
0001d0  fb27440b          SMLAD    r4,r7,r11,r4          ;410
0001d4  fb27551b          SMLADX   r5,r7,r11,r5          ;411
0001d8  fb2e661b          SMLADX   r6,lr,r11,r6          ;412
                  |L1.476|
0001dc  f8ddb00c          LDR      r11,[sp,#0xc]         ;415
0001e0  f1bb0f02          CMP      r11,#2                ;415
0001e4  d116              BNE      |L1.532|
0001e6  f8dcb000          LDR      r11,[r12,#0]          ;418
0001ea  f8d1e000          LDR      lr,[r1,#0]            ;421
0001ee  f8cde010          STR      lr,[sp,#0x10]         ;421
0001f2  f8d1e002          LDR      lr,[r1,#2]            ;424
0001f6  f8cde014          STR      lr,[sp,#0x14]         ;424
0001fa  1d09              ADDS     r1,r1,#4              ;425
0001fc  fb29221b          SMLADX   r2,r9,r11,r2          ;428
000200  fb27441b          SMLADX   r4,r7,r11,r4          ;429
000204  f8dde010          LDR      lr,[sp,#0x10]         ;430
000208  fb2e551b          SMLADX   r5,lr,r11,r5          ;430
00020c  f8dde014          LDR      lr,[sp,#0x14]         ;431
000210  fb2e661b          SMLADX   r6,lr,r11,r6          ;431
                  |L1.532|
000214  f8ddb00c          LDR      r11,[sp,#0xc]         ;434
000218  f1bb0f03          CMP      r11,#3                ;434
00021c  d11f              BNE      |L1.606|
00021e  f8dce000          LDR      lr,[r12,#0]           ;437
000222  f8d1b000          LDR      r11,[r1,#0]           ;440
000226  f8cdb010          STR      r11,[sp,#0x10]        ;440
00022a  f8d1b002          LDR      r11,[r1,#2]           ;443
00022e  fb29221e          SMLADX   r2,r9,lr,r2           ;446
000232  fb27441e          SMLADX   r4,r7,lr,r4           ;447
000236  f8dd9010          LDR      r9,[sp,#0x10]         ;448
00023a  fb29551e          SMLADX   r5,r9,lr,r5           ;448
00023e  fb2b691e          SMLADX   r9,r11,lr,r6          ;449
000242  f83c6c02          LDRH     r6,[r12,#-2]          ;451
000246  e000              B        |L1.586|
                  |L1.584|
000248  e059              B        |L1.766|
                  |L1.586|
00024a  b2b6              UXTH     r6,r6                 ;457
00024c  6849              LDR      r1,[r1,#4]            ;461
00024e  fb272216          SMLADX   r2,r7,r6,r2           ;465
000252  fb2b4406          SMLAD    r4,r11,r6,r4          ;466
000256  fb2b5516          SMLADX   r5,r11,r6,r5          ;467
00025a  fb219616          SMLADX   r6,r1,r6,r9           ;468
                  |L1.606|
00025e  13d1              ASRS     r1,r2,#15             ;474
000260  13e2              ASRS     r2,r4,#15             ;474
000262  eac14102          PKHBT    r1,r1,r2,LSL #16      ;474
000266  6001              STR      r1,[r0,#0]            ;474
000268  13e9              ASRS     r1,r5,#15             ;475
00026a  13f2              ASRS     r2,r6,#15             ;475
00026c  eac14102          PKHBT    r1,r1,r2,LSL #16      ;475
000270  6041              STR      r1,[r0,#4]            ;475
000272  3008              ADDS     r0,r0,#8              ;475
000274  f1080804          ADD      r8,r8,#4              ;485
000278  eb0a0148          ADD      r1,r10,r8,LSL #1      ;488
00027c  f8ddc018          LDR      r12,[sp,#0x18]        ;489
000280  9a02              LDR      r2,[sp,#8]            ;492
000282  1e52              SUBS     r2,r2,#1              ;492
000284  9202              STR      r2,[sp,#8]            ;492
                  |L1.646|
000286  9a02              LDR      r2,[sp,#8]            ;312
000288  2a00              CMP      r2,#0                 ;312
00028a  f47faf63          BNE      |L1.340|
00028e  9a01              LDR      r2,[sp,#4]            ;497
000290  f0020503          AND      r5,r2,#3              ;497
000294  e030              B        |L1.760|
                  |L1.662|
000296  2200              MOVS     r2,#0                 ;502
000298  089c              LSRS     r4,r3,#2              ;505
00029a  e015              B        |L1.712|
                  |L1.668|
00029c  880e              LDRH     r6,[r1,#0]            ;512
00029e  f83c7902          LDRH     r7,[r12],#-2          ;512
0002a2  fb162207          SMLABB   r2,r6,r7,r2           ;512
0002a6  884e              LDRH     r6,[r1,#2]            ;513
0002a8  f83c7902          LDRH     r7,[r12],#-2          ;513
0002ac  fb162207          SMLABB   r2,r6,r7,r2           ;513
0002b0  888e              LDRH     r6,[r1,#4]            ;514
0002b2  f83c7902          LDRH     r7,[r12],#-2          ;514
0002b6  fb162207          SMLABB   r2,r6,r7,r2           ;514
0002ba  88ce              LDRH     r6,[r1,#6]            ;515
0002bc  f83c7902          LDRH     r7,[r12],#-2          ;515
0002c0  3108              ADDS     r1,r1,#8              ;515
0002c2  fb162207          SMLABB   r2,r6,r7,r2           ;515
0002c6  1e64              SUBS     r4,r4,#1              ;518
                  |L1.712|
0002c8  2c00              CMP      r4,#0                 ;509
0002ca  d1e7              BNE      |L1.668|
0002cc  f0030403          AND      r4,r3,#3              ;523
0002d0  e006              B        |L1.736|
                  |L1.722|
0002d2  f8316b02          LDRH     r6,[r1],#2            ;528
0002d6  f83c7902          LDRH     r7,[r12],#-2          ;528
0002da  fb162207          SMLABB   r2,r6,r7,r2           ;528
0002de  1e64              SUBS     r4,r4,#1              ;531
                  |L1.736|
0002e0  2c00              CMP      r4,#0                 ;525
0002e2  d1f6              BNE      |L1.722|
0002e4  13d1              ASRS     r1,r2,#15             ;535
0002e6  f8201b02          STRH     r1,[r0],#2            ;535
0002ea  f1080801          ADD      r8,r8,#1              ;538
0002ee  eb0a0148          ADD      r1,r10,r8,LSL #1      ;541
0002f2  f8ddc018          LDR      r12,[sp,#0x18]        ;542
0002f6  1e6d              SUBS     r5,r5,#1              ;545
                  |L1.760|
0002f8  2d00              CMP      r5,#0                 ;499
0002fa  d1cc              BNE      |L1.662|
0002fc  e019              B        |L1.818|
                  |L1.766|
0002fe  9d01              LDR      r5,[sp,#4]            ;552
000300  e015              B        |L1.814|
                  |L1.770|
000302  2400              MOVS     r4,#0                 ;557
000304  461a              MOV      r2,r3                 ;560
000306  e006              B        |L1.790|
                  |L1.776|
000308  f8316b02          LDRH     r6,[r1],#2            ;565
00030c  f83c7902          LDRH     r7,[r12],#-2          ;565
000310  fb164407          SMLABB   r4,r6,r7,r4           ;565
000314  1e52              SUBS     r2,r2,#1              ;568
                  |L1.790|
000316  2a00              CMP      r2,#0                 ;562
000318  d1f6              BNE      |L1.776|
00031a  13e1              ASRS     r1,r4,#15             ;572
00031c  f8201b02          STRH     r1,[r0],#2            ;572
000320  f1080801          ADD      r8,r8,#1              ;575
000324  eb0a0148          ADD      r1,r10,r8,LSL #1      ;578
000328  f8ddc018          LDR      r12,[sp,#0x18]        ;579
00032c  1e6d              SUBS     r5,r5,#1              ;582
                  |L1.814|
00032e  2d00              CMP      r5,#0                 ;554
000330  d1e7              BNE      |L1.770|
                  |L1.818|
000332  1e5b              SUBS     r3,r3,#1              ;600
000334  990a              LDR      r1,[sp,#0x28]         ;603
000336  eb0a0241          ADD      r2,r10,r1,LSL #1      ;603
00033a  9908              LDR      r1,[sp,#0x20]         ;603
00033c  eba20641          SUB      r6,r2,r1,LSL #1       ;603
000340  4631              MOV      r1,r6                 ;604
000342  9f07              LDR      r7,[sp,#0x1c]         ;607
000344  f1a70c02          SUB      r12,r7,#2             ;608
000348  4664              MOV      r4,r12                ;609
00034a  ea4f0893          LSR      r8,r3,#2              ;620
00034e  e02a              B        |L1.934|
                  |L1.848|
000350  2200              MOVS     r2,#0                 ;625
000352  089d              LSRS     r5,r3,#2              ;628
000354  e00c              B        |L1.880|
                  |L1.854|
000356  f8519b04          LDR      r9,[r1],#4            ;636
00035a  f854a904          LDR      r10,[r4],#-4          ;636
00035e  fb29221a          SMLADX   r2,r9,r10,r2          ;636
000362  f8519b04          LDR      r9,[r1],#4            ;639
000366  f854a904          LDR      r10,[r4],#-4          ;639
00036a  fb29221a          SMLADX   r2,r9,r10,r2          ;639
00036e  1e6d              SUBS     r5,r5,#1              ;642
                  |L1.880|
000370  2d00              CMP      r5,#0                 ;632
000372  d1f0              BNE      |L1.854|
000374  1ca4              ADDS     r4,r4,#2              ;647
000376  f0030503          AND      r5,r3,#3              ;651
00037a  e006              B        |L1.906|
                  |L1.892|
00037c  f9319b02          LDRSH    r9,[r1],#2            ;656
000380  f934a902          LDRSH    r10,[r4],#-2          ;656
000384  fb29220a          SMLAD    r2,r9,r10,r2          ;656
000388  1e6d              SUBS     r5,r5,#1              ;659
                  |L1.906|
00038a  2d00              CMP      r5,#0                 ;653
00038c  d1f6              BNE      |L1.892|
00038e  13d1              ASRS     r1,r2,#15             ;663
000390  f8201b02          STRH     r1,[r0],#2            ;663
000394  1cb1              ADDS     r1,r6,#2              ;666
000396  460e              MOV      r6,r1                 ;666
000398  4664              MOV      r4,r12                ;667
00039a  1e5b              SUBS     r3,r3,#1              ;670
00039c  9a00              LDR      r2,[sp,#0]            ;673
00039e  1e52              SUBS     r2,r2,#1              ;673
0003a0  9200              STR      r2,[sp,#0]            ;673
0003a2  f1a80801          SUB      r8,r8,#1              ;675
                  |L1.934|
0003a6  f1b80f00          CMP      r8,#0                 ;622
0003aa  d002              BEQ      |L1.946|
0003ac  9a00              LDR      r2,[sp,#0]            ;622
0003ae  2a00              CMP      r2,#0                 ;622
0003b0  dcce              BGT      |L1.848|
                  |L1.946|
0003b2  1ca4              ADDS     r4,r4,#2              ;681
0003b4  e015              B        |L1.994|
                  |L1.950|
0003b6  2500              MOVS     r5,#0                 ;686
0003b8  461a              MOV      r2,r3                 ;689
0003ba  e006              B        |L1.970|
                  |L1.956|
0003bc  f931cb02          LDRSH    r12,[r1],#2           ;695
0003c0  f9348902          LDRSH    r8,[r4],#-2           ;695
0003c4  fb2c5508          SMLAD    r5,r12,r8,r5          ;695
0003c8  1e52              SUBS     r2,r2,#1              ;698
                  |L1.970|
0003ca  2a00              CMP      r2,#0                 ;691
0003cc  d1f6              BNE      |L1.956|
0003ce  13e9              ASRS     r1,r5,#15             ;702
0003d0  f8201b02          STRH     r1,[r0],#2            ;702
0003d4  1cb1              ADDS     r1,r6,#2              ;705
0003d6  460e              MOV      r6,r1                 ;705
0003d8  463c              MOV      r4,r7                 ;706
0003da  1e5b              SUBS     r3,r3,#1              ;709
0003dc  9a00              LDR      r2,[sp,#0]            ;712
0003de  1e52              SUBS     r2,r2,#1              ;712
0003e0  9200              STR      r2,[sp,#0]            ;712
                  |L1.994|
0003e2  9a00              LDR      r2,[sp,#0]            ;683
0003e4  2a00              CMP      r2,#0                 ;683
0003e6  dce6              BGT      |L1.950|
0003e8  2000              MOVS     r0,#0                 ;716
0003ea  e618              B        |L1.30|
;;;1489   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_partial_fast_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___27_arm_conv_partial_fast_q15_c_1e37a144____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___27_arm_conv_partial_fast_q15_c_1e37a144____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___27_arm_conv_partial_fast_q15_c_1e37a144____REVSH|
#line 144
|__asm___27_arm_conv_partial_fast_q15_c_1e37a144____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___27_arm_conv_partial_fast_q15_c_1e37a144____RRX|
#line 300
|__asm___27_arm_conv_partial_fast_q15_c_1e37a144____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
