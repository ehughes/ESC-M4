; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_partial_fast_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_partial_fast_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE\_CMSIS_DSP_4_5_O3 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_conv_partial_fast_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_partial_fast_q15.c]
                          THUMB

                          AREA ||i.arm_conv_partial_fast_q15||, CODE, READONLY, ALIGN=2

                  arm_conv_partial_fast_q15 PROC
;;;66     
;;;67     arm_status arm_conv_partial_fast_q15(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;68       q15_t * pSrcA,
;;;69       uint32_t srcALen,
;;;70       q15_t * pSrcB,
;;;71       uint32_t srcBLen,
;;;72       q15_t * pDst,
;;;73       uint32_t firstIndex,
;;;74       uint32_t numPoints)
;;;75     {
000004  468b              MOV      r11,r1
000006  b096              SUB      sp,sp,#0x58
000008  a91f              ADD      r1,sp,#0x7c
;;;76     #ifndef UNALIGNED_SUPPORT_DISABLE
;;;77     
;;;78       q15_t *pIn1;                                   /* inputA pointer               */
;;;79       q15_t *pIn2;                                   /* inputB pointer               */
;;;80       q15_t *pOut = pDst;                            /* output pointer               */
;;;81       q31_t sum, acc0, acc1, acc2, acc3;             /* Accumulator                  */
;;;82       q15_t *px;                                     /* Intermediate inputA pointer  */
;;;83       q15_t *py;                                     /* Intermediate inputB pointer  */
;;;84       q15_t *pSrc1, *pSrc2;                          /* Intermediate pointers        */
;;;85       q31_t x0, x1, x2, x3, c0;
;;;86       uint32_t j, k, count, check, blkCnt;
;;;87       int32_t blockSize1, blockSize2, blockSize3;    /* loop counters                 */
;;;88       arm_status status;                             /* status of Partial convolution */
;;;89     
;;;90       /* Check for range of output samples to be calculated */
;;;91       if((firstIndex + numPoints) > ((srcALen + (srcBLen - 1u))))
00000a  eb0b0703          ADD      r7,r11,r3
00000e  e8910070          LDM      r1,{r4-r6}            ;75
000012  1e7f              SUBS     r7,r7,#1
000014  19a9              ADDS     r1,r5,r6
000016  42b9              CMP      r1,r7
000018  d904              BLS      |L1.36|
;;;92       {
;;;93         /* Set status as ARM_MATH_ARGUMENT_ERROR */
;;;94         status = ARM_MATH_ARGUMENT_ERROR;
00001a  f04f30ff          MOV      r0,#0xffffffff
                  |L1.30|
;;;95       }
;;;96       else
;;;97       {
;;;98     
;;;99         /* The algorithm implementation is based on the lengths of the inputs. */
;;;100        /* srcB is always made to slide across srcA. */
;;;101        /* So srcBLen is always considered as shorter or equal to srcALen */
;;;102        if(srcALen >=srcBLen)
;;;103        {
;;;104          /* Initialization of inputA pointer */
;;;105          pIn1 = pSrcA;
;;;106    
;;;107          /* Initialization of inputB pointer */
;;;108          pIn2 = pSrcB;
;;;109        }
;;;110        else
;;;111        {
;;;112          /* Initialization of inputA pointer */
;;;113          pIn1 = pSrcB;
;;;114    
;;;115          /* Initialization of inputB pointer */
;;;116          pIn2 = pSrcA;
;;;117    
;;;118          /* srcBLen is always considered as shorter or equal to srcALen */
;;;119          j = srcBLen;
;;;120          srcBLen = srcALen;
;;;121          srcALen = j;
;;;122        }
;;;123    
;;;124        /* Conditions to check which loopCounter holds   
;;;125         * the first and last indices of the output samples to be calculated. */
;;;126        check = firstIndex + numPoints;
;;;127        blockSize3 = ((int32_t)check > (int32_t)srcALen) ? (int32_t)check - (int32_t)srcALen : 0;
;;;128        blockSize3 = ((int32_t)firstIndex > (int32_t)srcALen - 1) ? blockSize3 - (int32_t)firstIndex + (int32_t)srcALen : blockSize3;
;;;129        blockSize1 = (((int32_t) srcBLen - 1) - (int32_t) firstIndex);
;;;130        blockSize1 = (blockSize1 > 0) ? ((check > (srcBLen - 1u)) ? blockSize1 :
;;;131                                         (int32_t) numPoints) : 0;
;;;132        blockSize2 = (int32_t) check - ((blockSize3 + blockSize1) +
;;;133                                        (int32_t) firstIndex);
;;;134        blockSize2 = (blockSize2 > 0) ? blockSize2 : 0;
;;;135    
;;;136        /* conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1] */
;;;137        /* The function is internally   
;;;138         * divided into three stages according to the number of multiplications that has to be   
;;;139         * taken place between inputA samples and inputB samples. In the first stage of the   
;;;140         * algorithm, the multiplications increase by one for every iteration.   
;;;141         * In the second stage of the algorithm, srcBLen number of multiplications are done.   
;;;142         * In the third stage of the algorithm, the multiplications decrease by one   
;;;143         * for every iteration. */
;;;144    
;;;145        /* Set the output pointer to point to the firstIndex   
;;;146         * of the output sample to be calculated. */
;;;147        pOut = pDst + firstIndex;
;;;148    
;;;149        /* --------------------------   
;;;150         * Initializations of stage1   
;;;151         * -------------------------*/
;;;152    
;;;153        /* sum = x[0] * y[0]   
;;;154         * sum = x[0] * y[1] + x[1] * y[0]   
;;;155         * ....   
;;;156         * sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]   
;;;157         */
;;;158    
;;;159        /* In this stage the MAC operations are increased by 1 for every iteration.   
;;;160           The count variable holds the number of MAC operations performed.   
;;;161           Since the partial convolution starts from firstIndex   
;;;162           Number of Macs to be performed is firstIndex + 1 */
;;;163        count = 1u + firstIndex;
;;;164    
;;;165        /* Working pointer of inputA */
;;;166        px = pIn1;
;;;167    
;;;168        /* Working pointer of inputB */
;;;169        pSrc2 = pIn2 + firstIndex;
;;;170        py = pSrc2;
;;;171    
;;;172        /* ------------------------   
;;;173         * Stage1 process   
;;;174         * ----------------------*/
;;;175    
;;;176        /* For loop unrolling by 4, this stage is divided into two. */
;;;177        /* First part of this stage computes the MAC operations less than 4 */
;;;178        /* Second part of this stage computes the MAC operations greater than or equal to 4 */
;;;179    
;;;180        /* The first part of the stage starts here */
;;;181        while((count < 4u) && (blockSize1 > 0))
;;;182        {
;;;183          /* Accumulator is made zero for every iteration */
;;;184          sum = 0;
;;;185    
;;;186          /* Loop over number of MAC operations between   
;;;187           * inputA samples and inputB samples */
;;;188          k = count;
;;;189    
;;;190          while(k > 0u)
;;;191          {
;;;192            /* Perform the multiply-accumulates */
;;;193            sum = __SMLAD(*px++, *py--, sum);
;;;194    
;;;195            /* Decrement the loop counter */
;;;196            k--;
;;;197          }
;;;198    
;;;199          /* Store the result in the accumulator in the destination buffer. */
;;;200          *pOut++ = (q15_t) (sum >> 15);
;;;201    
;;;202          /* Update the inputA and inputB pointers for next MAC calculation */
;;;203          py = ++pSrc2;
;;;204          px = pIn1;
;;;205    
;;;206          /* Increment the MAC count */
;;;207          count++;
;;;208    
;;;209          /* Decrement the loop counter */
;;;210          blockSize1--;
;;;211        }
;;;212    
;;;213        /* The second part of the stage starts here */
;;;214        /* The internal loop, over count, is unrolled by 4 */
;;;215        /* To, read the last two inputB samples using SIMD:   
;;;216         * y[srcBLen] and y[srcBLen-1] coefficients, py is decremented by 1 */
;;;217        py = py - 1;
;;;218    
;;;219        while(blockSize1 > 0)
;;;220        {
;;;221          /* Accumulator is made zero for every iteration */
;;;222          sum = 0;
;;;223    
;;;224          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;225          k = count >> 2u;
;;;226    
;;;227          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;228           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;229          while(k > 0u)
;;;230          {
;;;231            /* Perform the multiply-accumulates */
;;;232            /* x[0], x[1] are multiplied with y[srcBLen - 1], y[srcBLen - 2] respectively */
;;;233            sum = __SMLADX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
;;;234            /* x[2], x[3] are multiplied with y[srcBLen - 3], y[srcBLen - 4] respectively */
;;;235            sum = __SMLADX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
;;;236    
;;;237            /* Decrement the loop counter */
;;;238            k--;
;;;239          }
;;;240    
;;;241          /* For the next MAC operations, the pointer py is used without SIMD   
;;;242           * So, py is incremented by 1 */
;;;243          py = py + 1u;
;;;244    
;;;245          /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;246           ** No loop unrolling is used. */
;;;247          k = count % 0x4u;
;;;248    
;;;249          while(k > 0u)
;;;250          {
;;;251            /* Perform the multiply-accumulates */
;;;252            sum = __SMLAD(*px++, *py--, sum);
;;;253    
;;;254            /* Decrement the loop counter */
;;;255            k--;
;;;256          }
;;;257    
;;;258          /* Store the result in the accumulator in the destination buffer. */
;;;259          *pOut++ = (q15_t) (sum >> 15);
;;;260    
;;;261          /* Update the inputA and inputB pointers for next MAC calculation */
;;;262          py = ++pSrc2 - 1u;
;;;263          px = pIn1;
;;;264    
;;;265          /* Increment the MAC count */
;;;266          count++;
;;;267    
;;;268          /* Decrement the loop counter */
;;;269          blockSize1--;
;;;270        }
;;;271    
;;;272        /* --------------------------   
;;;273         * Initializations of stage2   
;;;274         * ------------------------*/
;;;275    
;;;276        /* sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0]   
;;;277         * sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0]   
;;;278         * ....   
;;;279         * sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]   
;;;280         */
;;;281    
;;;282        /* Working pointer of inputA */
;;;283        if((int32_t)firstIndex - (int32_t)srcBLen + 1 > 0)
;;;284        {
;;;285          px = pIn1 + firstIndex - srcBLen + 1;
;;;286        }
;;;287        else
;;;288        {
;;;289          px = pIn1;
;;;290        }
;;;291    
;;;292        /* Working pointer of inputB */
;;;293        pSrc2 = pIn2 + (srcBLen - 1u);
;;;294        py = pSrc2;
;;;295    
;;;296        /* count is the index by which the pointer pIn1 to be incremented */
;;;297        count = 0u;
;;;298    
;;;299    
;;;300        /* --------------------   
;;;301         * Stage2 process   
;;;302         * -------------------*/
;;;303    
;;;304        /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.   
;;;305         * So, to loop unroll over blockSize2,   
;;;306         * srcBLen should be greater than or equal to 4 */
;;;307        if(srcBLen >= 4u)
;;;308        {
;;;309          /* Loop unroll over blockSize2, by 4 */
;;;310          blkCnt = ((uint32_t) blockSize2 >> 2u);
;;;311    
;;;312          while(blkCnt > 0u)
;;;313          {
;;;314          py = py - 1u;
;;;315    
;;;316            /* Set all accumulators to zero */
;;;317            acc0 = 0;
;;;318            acc1 = 0;
;;;319            acc2 = 0;
;;;320            acc3 = 0;
;;;321    
;;;322    
;;;323            /* read x[0], x[1] samples */
;;;324          x0 = *__SIMD32(px);
;;;325            /* read x[1], x[2] samples */
;;;326          x1 = _SIMD32_OFFSET(px+1);
;;;327    	  px+= 2u;
;;;328    
;;;329    
;;;330            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;331            k = srcBLen >> 2u;
;;;332    
;;;333            /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;334             ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;335            do
;;;336            {
;;;337              /* Read the last two inputB samples using SIMD:   
;;;338               * y[srcBLen - 1] and y[srcBLen - 2] */
;;;339            c0 = *__SIMD32(py)--;
;;;340    
;;;341              /* acc0 +=  x[0] * y[srcBLen - 1] + x[1] * y[srcBLen - 2] */
;;;342              acc0 = __SMLADX(x0, c0, acc0);
;;;343    
;;;344              /* acc1 +=  x[1] * y[srcBLen - 1] + x[2] * y[srcBLen - 2] */
;;;345              acc1 = __SMLADX(x1, c0, acc1);
;;;346    
;;;347              /* Read x[2], x[3] */
;;;348            x2 = *__SIMD32(px);
;;;349    
;;;350              /* Read x[3], x[4] */
;;;351            x3 = _SIMD32_OFFSET(px+1);
;;;352    
;;;353              /* acc2 +=  x[2] * y[srcBLen - 1] + x[3] * y[srcBLen - 2] */
;;;354              acc2 = __SMLADX(x2, c0, acc2);
;;;355    
;;;356              /* acc3 +=  x[3] * y[srcBLen - 1] + x[4] * y[srcBLen - 2] */
;;;357              acc3 = __SMLADX(x3, c0, acc3);
;;;358    
;;;359              /* Read y[srcBLen - 3] and y[srcBLen - 4] */
;;;360            c0 = *__SIMD32(py)--;
;;;361    
;;;362              /* acc0 +=  x[2] * y[srcBLen - 3] + x[3] * y[srcBLen - 4] */
;;;363              acc0 = __SMLADX(x2, c0, acc0);
;;;364    
;;;365              /* acc1 +=  x[3] * y[srcBLen - 3] + x[4] * y[srcBLen - 4] */
;;;366              acc1 = __SMLADX(x3, c0, acc1);
;;;367    
;;;368              /* Read x[4], x[5] */
;;;369            x0 = _SIMD32_OFFSET(px+2);
;;;370    
;;;371              /* Read x[5], x[6] */
;;;372            x1 = _SIMD32_OFFSET(px+3);
;;;373    		px += 4u;
;;;374    
;;;375              /* acc2 +=  x[4] * y[srcBLen - 3] + x[5] * y[srcBLen - 4] */
;;;376              acc2 = __SMLADX(x0, c0, acc2);
;;;377    
;;;378              /* acc3 +=  x[5] * y[srcBLen - 3] + x[6] * y[srcBLen - 4] */
;;;379              acc3 = __SMLADX(x1, c0, acc3);
;;;380    
;;;381            } while(--k);
;;;382    
;;;383            /* For the next MAC operations, SIMD is not used   
;;;384             * So, the 16 bit pointer if inputB, py is updated */
;;;385    
;;;386            /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;387             ** No loop unrolling is used. */
;;;388            k = srcBLen % 0x4u;
;;;389    
;;;390            if(k == 1u)
;;;391            {
;;;392              /* Read y[srcBLen - 5] */
;;;393            c0 = *(py+1);
;;;394    #ifdef  ARM_MATH_BIG_ENDIAN
;;;395    
;;;396            c0 = c0 << 16u;
;;;397    
;;;398    #else
;;;399    
;;;400            c0 = c0 & 0x0000FFFF;
;;;401    
;;;402    #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;403    
;;;404              /* Read x[7] */
;;;405            x3 = *__SIMD32(px);
;;;406    		px++;
;;;407    
;;;408              /* Perform the multiply-accumulates */
;;;409              acc0 = __SMLAD(x0, c0, acc0);
;;;410              acc1 = __SMLAD(x1, c0, acc1);
;;;411              acc2 = __SMLADX(x1, c0, acc2);
;;;412              acc3 = __SMLADX(x3, c0, acc3);
;;;413            }
;;;414    
;;;415            if(k == 2u)
;;;416            {
;;;417              /* Read y[srcBLen - 5], y[srcBLen - 6] */
;;;418            c0 = _SIMD32_OFFSET(py);
;;;419    
;;;420              /* Read x[7], x[8] */
;;;421            x3 = *__SIMD32(px);
;;;422    
;;;423            /* Read x[9] */
;;;424            x2 = _SIMD32_OFFSET(px+1);
;;;425    		px += 2u;
;;;426    
;;;427              /* Perform the multiply-accumulates */
;;;428              acc0 = __SMLADX(x0, c0, acc0);
;;;429              acc1 = __SMLADX(x1, c0, acc1);
;;;430              acc2 = __SMLADX(x3, c0, acc2);
;;;431              acc3 = __SMLADX(x2, c0, acc3);
;;;432            }
;;;433    
;;;434            if(k == 3u)
;;;435            {
;;;436              /* Read y[srcBLen - 5], y[srcBLen - 6] */
;;;437            c0 = _SIMD32_OFFSET(py);
;;;438    
;;;439              /* Read x[7], x[8] */
;;;440            x3 = *__SIMD32(px);
;;;441    
;;;442              /* Read x[9] */
;;;443            x2 = _SIMD32_OFFSET(px+1);
;;;444    
;;;445              /* Perform the multiply-accumulates */
;;;446              acc0 = __SMLADX(x0, c0, acc0);
;;;447              acc1 = __SMLADX(x1, c0, acc1);
;;;448              acc2 = __SMLADX(x3, c0, acc2);
;;;449              acc3 = __SMLADX(x2, c0, acc3);
;;;450    
;;;451    		c0 = *(py-1);
;;;452    #ifdef  ARM_MATH_BIG_ENDIAN
;;;453    
;;;454            c0 = c0 << 16u;
;;;455    #else
;;;456    
;;;457            c0 = c0 & 0x0000FFFF;
;;;458    #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;459    
;;;460              /* Read x[10] */
;;;461            x3 =  _SIMD32_OFFSET(px+2);
;;;462    		px += 3u;
;;;463    
;;;464              /* Perform the multiply-accumulates */
;;;465              acc0 = __SMLADX(x1, c0, acc0);
;;;466              acc1 = __SMLAD(x2, c0, acc1);
;;;467              acc2 = __SMLADX(x2, c0, acc2);
;;;468              acc3 = __SMLADX(x3, c0, acc3);
;;;469            }
;;;470    
;;;471            /* Store the results in the accumulators in the destination buffer. */
;;;472    #ifndef ARM_MATH_BIG_ENDIAN
;;;473    
;;;474            *__SIMD32(pOut)++ = __PKHBT(acc0 >> 15, acc1 >> 15, 16);
;;;475            *__SIMD32(pOut)++ = __PKHBT(acc2 >> 15, acc3 >> 15, 16);
;;;476    
;;;477    #else
;;;478    
;;;479            *__SIMD32(pOut)++ = __PKHBT(acc1 >> 15, acc0 >> 15, 16);
;;;480            *__SIMD32(pOut)++ = __PKHBT(acc3 >> 15, acc2 >> 15, 16);
;;;481    
;;;482    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;483    
;;;484            /* Increment the pointer pIn1 index, count by 4 */
;;;485            count += 4u;
;;;486    
;;;487            /* Update the inputA and inputB pointers for next MAC calculation */
;;;488            px = pIn1 + count;
;;;489            py = pSrc2;
;;;490    
;;;491            /* Decrement the loop counter */
;;;492            blkCnt--;
;;;493          }
;;;494    
;;;495          /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.   
;;;496           ** No loop unrolling is used. */
;;;497          blkCnt = (uint32_t) blockSize2 % 0x4u;
;;;498    
;;;499          while(blkCnt > 0u)
;;;500          {
;;;501            /* Accumulator is made zero for every iteration */
;;;502            sum = 0;
;;;503    
;;;504            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;505            k = srcBLen >> 2u;
;;;506    
;;;507            /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;508             ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;509            while(k > 0u)
;;;510            {
;;;511              /* Perform the multiply-accumulates */
;;;512              sum += ((q31_t) * px++ * *py--);
;;;513              sum += ((q31_t) * px++ * *py--);
;;;514              sum += ((q31_t) * px++ * *py--);
;;;515              sum += ((q31_t) * px++ * *py--);
;;;516    
;;;517              /* Decrement the loop counter */
;;;518              k--;
;;;519            }
;;;520    
;;;521            /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;522             ** No loop unrolling is used. */
;;;523            k = srcBLen % 0x4u;
;;;524    
;;;525            while(k > 0u)
;;;526            {
;;;527              /* Perform the multiply-accumulates */
;;;528              sum += ((q31_t) * px++ * *py--);
;;;529    
;;;530              /* Decrement the loop counter */
;;;531              k--;
;;;532            }
;;;533    
;;;534            /* Store the result in the accumulator in the destination buffer. */
;;;535            *pOut++ = (q15_t) (sum >> 15);
;;;536    
;;;537            /* Increment the pointer pIn1 index, count by 1 */
;;;538            count++;
;;;539    
;;;540            /* Update the inputA and inputB pointers for next MAC calculation */
;;;541            px = pIn1 + count;
;;;542            py = pSrc2;
;;;543    
;;;544            /* Decrement the loop counter */
;;;545            blkCnt--;
;;;546          }
;;;547        }
;;;548        else
;;;549        {
;;;550          /* If the srcBLen is not a multiple of 4,   
;;;551           * the blockSize2 loop cannot be unrolled by 4 */
;;;552          blkCnt = (uint32_t) blockSize2;
;;;553    
;;;554          while(blkCnt > 0u)
;;;555          {
;;;556            /* Accumulator is made zero for every iteration */
;;;557            sum = 0;
;;;558    
;;;559            /* srcBLen number of MACS should be performed */
;;;560            k = srcBLen;
;;;561    
;;;562            while(k > 0u)
;;;563            {
;;;564              /* Perform the multiply-accumulate */
;;;565              sum += ((q31_t) * px++ * *py--);
;;;566    
;;;567              /* Decrement the loop counter */
;;;568              k--;
;;;569            }
;;;570    
;;;571            /* Store the result in the accumulator in the destination buffer. */
;;;572            *pOut++ = (q15_t) (sum >> 15);
;;;573    
;;;574            /* Increment the MAC count */
;;;575            count++;
;;;576    
;;;577            /* Update the inputA and inputB pointers for next MAC calculation */
;;;578            px = pIn1 + count;
;;;579            py = pSrc2;
;;;580    
;;;581            /* Decrement the loop counter */
;;;582            blkCnt--;
;;;583          }
;;;584        }
;;;585    
;;;586    
;;;587        /* --------------------------   
;;;588         * Initializations of stage3   
;;;589         * -------------------------*/
;;;590    
;;;591        /* sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1]   
;;;592         * sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2]   
;;;593         * ....   
;;;594         * sum +=  x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2]   
;;;595         * sum +=  x[srcALen-1] * y[srcBLen-1]   
;;;596         */
;;;597    
;;;598        /* In this stage the MAC operations are decreased by 1 for every iteration.   
;;;599           The count variable holds the number of MAC operations performed */
;;;600        count = srcBLen - 1u;
;;;601    
;;;602        /* Working pointer of inputA */
;;;603        pSrc1 = (pIn1 + srcALen) - (srcBLen - 1u);
;;;604        px = pSrc1;
;;;605    
;;;606        /* Working pointer of inputB */
;;;607        pSrc2 = pIn2 + (srcBLen - 1u);
;;;608        pIn2 = pSrc2 - 1u;
;;;609        py = pIn2;
;;;610    
;;;611        /* -------------------   
;;;612         * Stage3 process   
;;;613         * ------------------*/
;;;614    
;;;615        /* For loop unrolling by 4, this stage is divided into two. */
;;;616        /* First part of this stage computes the MAC operations greater than 4 */
;;;617        /* Second part of this stage computes the MAC operations less than or equal to 4 */
;;;618    
;;;619        /* The first part of the stage starts here */
;;;620        j = count >> 2u;
;;;621    
;;;622        while((j > 0u) && (blockSize3 > 0))
;;;623        {
;;;624          /* Accumulator is made zero for every iteration */
;;;625          sum = 0;
;;;626    
;;;627          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;628          k = count >> 2u;
;;;629    
;;;630          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;631           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;632          while(k > 0u)
;;;633          {
;;;634            /* x[srcALen - srcBLen + 1], x[srcALen - srcBLen + 2] are multiplied   
;;;635             * with y[srcBLen - 1], y[srcBLen - 2] respectively */
;;;636            sum = __SMLADX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
;;;637            /* x[srcALen - srcBLen + 3], x[srcALen - srcBLen + 4] are multiplied   
;;;638             * with y[srcBLen - 3], y[srcBLen - 4] respectively */
;;;639            sum = __SMLADX(*__SIMD32(px)++, *__SIMD32(py)--, sum);
;;;640    
;;;641            /* Decrement the loop counter */
;;;642            k--;
;;;643          }
;;;644    
;;;645          /* For the next MAC operations, the pointer py is used without SIMD   
;;;646           * So, py is incremented by 1 */
;;;647          py = py + 1u;
;;;648    
;;;649          /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;650           ** No loop unrolling is used. */
;;;651          k = count % 0x4u;
;;;652    
;;;653          while(k > 0u)
;;;654          {
;;;655            /* sum += x[srcALen - srcBLen + 5] * y[srcBLen - 5] */
;;;656            sum = __SMLAD(*px++, *py--, sum);
;;;657    
;;;658            /* Decrement the loop counter */
;;;659            k--;
;;;660          }
;;;661    
;;;662          /* Store the result in the accumulator in the destination buffer. */
;;;663          *pOut++ = (q15_t) (sum >> 15);
;;;664    
;;;665          /* Update the inputA and inputB pointers for next MAC calculation */
;;;666          px = ++pSrc1;
;;;667          py = pIn2;
;;;668    
;;;669          /* Decrement the MAC count */
;;;670          count--;
;;;671    
;;;672          /* Decrement the loop counter */
;;;673          blockSize3--;
;;;674    
;;;675          j--;
;;;676        }
;;;677    
;;;678        /* The second part of the stage starts here */
;;;679        /* SIMD is not used for the next MAC operations,   
;;;680         * so pointer py is updated to read only one sample at a time */
;;;681        py = py + 1u;
;;;682    
;;;683        while(blockSize3 > 0)
;;;684        {
;;;685          /* Accumulator is made zero for every iteration */
;;;686          sum = 0;
;;;687    
;;;688          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;689          k = count;
;;;690    
;;;691          while(k > 0u)
;;;692          {
;;;693            /* Perform the multiply-accumulates */
;;;694            /* sum +=  x[srcALen-1] * y[srcBLen-1] */
;;;695            sum = __SMLAD(*px++, *py--, sum);
;;;696    
;;;697            /* Decrement the loop counter */
;;;698            k--;
;;;699          }
;;;700    
;;;701          /* Store the result in the accumulator in the destination buffer. */
;;;702          *pOut++ = (q15_t) (sum >> 15);
;;;703    
;;;704          /* Update the inputA and inputB pointers for next MAC calculation */
;;;705          px = ++pSrc1;
;;;706          py = pSrc2;
;;;707    
;;;708          /* Decrement the MAC count */
;;;709          count--;
;;;710    
;;;711          /* Decrement the loop counter */
;;;712          blockSize3--;
;;;713        }
;;;714    
;;;715        /* set status as ARM_MATH_SUCCESS */
;;;716        status = ARM_MATH_SUCCESS;
;;;717      }
;;;718    
;;;719      /* Return to application */
;;;720      return (status);
;;;721    
;;;722    #else
;;;723    
;;;724      q15_t *pIn1;                                   /* inputA pointer               */
;;;725      q15_t *pIn2;                                   /* inputB pointer               */
;;;726      q15_t *pOut = pDst;                            /* output pointer               */
;;;727      q31_t sum, acc0, acc1, acc2, acc3;             /* Accumulator                  */
;;;728      q15_t *px;                                     /* Intermediate inputA pointer  */
;;;729      q15_t *py;                                     /* Intermediate inputB pointer  */
;;;730      q15_t *pSrc1, *pSrc2;                          /* Intermediate pointers        */
;;;731      q31_t x0, x1, x2, x3, c0;
;;;732      uint32_t j, k, count, check, blkCnt;
;;;733      int32_t blockSize1, blockSize2, blockSize3;    /* loop counters                 */
;;;734      arm_status status;                             /* status of Partial convolution */
;;;735      q15_t a, b;
;;;736    
;;;737      /* Check for range of output samples to be calculated */
;;;738      if((firstIndex + numPoints) > ((srcALen + (srcBLen - 1u))))
;;;739      {
;;;740        /* Set status as ARM_MATH_ARGUMENT_ERROR */
;;;741        status = ARM_MATH_ARGUMENT_ERROR;
;;;742      }
;;;743      else
;;;744      {
;;;745    
;;;746        /* The algorithm implementation is based on the lengths of the inputs. */
;;;747        /* srcB is always made to slide across srcA. */
;;;748        /* So srcBLen is always considered as shorter or equal to srcALen */
;;;749        if(srcALen >=srcBLen)
;;;750        {
;;;751          /* Initialization of inputA pointer */
;;;752          pIn1 = pSrcA;
;;;753    
;;;754          /* Initialization of inputB pointer */
;;;755          pIn2 = pSrcB;
;;;756        }
;;;757        else
;;;758        {
;;;759          /* Initialization of inputA pointer */
;;;760          pIn1 = pSrcB;
;;;761    
;;;762          /* Initialization of inputB pointer */
;;;763          pIn2 = pSrcA;
;;;764    
;;;765          /* srcBLen is always considered as shorter or equal to srcALen */
;;;766          j = srcBLen;
;;;767          srcBLen = srcALen;
;;;768          srcALen = j;
;;;769        }
;;;770    
;;;771        /* Conditions to check which loopCounter holds   
;;;772         * the first and last indices of the output samples to be calculated. */
;;;773        check = firstIndex + numPoints;
;;;774        blockSize3 = ((int32_t)check > (int32_t)srcALen) ? (int32_t)check - (int32_t)srcALen : 0;
;;;775        blockSize3 = ((int32_t)firstIndex > (int32_t)srcALen - 1) ? blockSize3 - (int32_t)firstIndex + (int32_t)srcALen : blockSize3;
;;;776        blockSize1 = ((int32_t) srcBLen - 1) - (int32_t) firstIndex;
;;;777        blockSize1 = (blockSize1 > 0) ? ((check > (srcBLen - 1u)) ? blockSize1 :
;;;778                                         (int32_t) numPoints) : 0;
;;;779        blockSize2 = ((int32_t) check - blockSize3) -
;;;780          (blockSize1 + (int32_t) firstIndex);
;;;781        blockSize2 = (blockSize2 > 0) ? blockSize2 : 0;
;;;782    
;;;783        /* conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1] */
;;;784        /* The function is internally   
;;;785         * divided into three stages according to the number of multiplications that has to be   
;;;786         * taken place between inputA samples and inputB samples. In the first stage of the   
;;;787         * algorithm, the multiplications increase by one for every iteration.   
;;;788         * In the second stage of the algorithm, srcBLen number of multiplications are done.   
;;;789         * In the third stage of the algorithm, the multiplications decrease by one   
;;;790         * for every iteration. */
;;;791    
;;;792        /* Set the output pointer to point to the firstIndex   
;;;793         * of the output sample to be calculated. */
;;;794        pOut = pDst + firstIndex;
;;;795    
;;;796        /* --------------------------   
;;;797         * Initializations of stage1   
;;;798         * -------------------------*/
;;;799    
;;;800        /* sum = x[0] * y[0]   
;;;801         * sum = x[0] * y[1] + x[1] * y[0]   
;;;802         * ....   
;;;803         * sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]   
;;;804         */
;;;805    
;;;806        /* In this stage the MAC operations are increased by 1 for every iteration.   
;;;807           The count variable holds the number of MAC operations performed.   
;;;808           Since the partial convolution starts from firstIndex   
;;;809           Number of Macs to be performed is firstIndex + 1 */
;;;810        count = 1u + firstIndex;
;;;811    
;;;812        /* Working pointer of inputA */
;;;813        px = pIn1;
;;;814    
;;;815        /* Working pointer of inputB */
;;;816        pSrc2 = pIn2 + firstIndex;
;;;817        py = pSrc2;
;;;818    
;;;819        /* ------------------------   
;;;820         * Stage1 process   
;;;821         * ----------------------*/
;;;822    
;;;823        /* For loop unrolling by 4, this stage is divided into two. */
;;;824        /* First part of this stage computes the MAC operations less than 4 */
;;;825        /* Second part of this stage computes the MAC operations greater than or equal to 4 */
;;;826    
;;;827        /* The first part of the stage starts here */
;;;828      while((count < 4u) && (blockSize1 > 0))
;;;829        {
;;;830          /* Accumulator is made zero for every iteration */
;;;831          sum = 0;
;;;832    
;;;833          /* Loop over number of MAC operations between   
;;;834           * inputA samples and inputB samples */
;;;835          k = count;
;;;836    
;;;837          while(k > 0u)
;;;838          {
;;;839            /* Perform the multiply-accumulates */
;;;840          sum += ((q31_t) * px++ * *py--);
;;;841    
;;;842            /* Decrement the loop counter */
;;;843            k--;
;;;844          }
;;;845    
;;;846          /* Store the result in the accumulator in the destination buffer. */
;;;847          *pOut++ = (q15_t) (sum >> 15);
;;;848    
;;;849          /* Update the inputA and inputB pointers for next MAC calculation */
;;;850          py = ++pSrc2;
;;;851          px = pIn1;
;;;852    
;;;853          /* Increment the MAC count */
;;;854          count++;
;;;855    
;;;856          /* Decrement the loop counter */
;;;857          blockSize1--;
;;;858        }
;;;859    
;;;860        /* The second part of the stage starts here */
;;;861        /* The internal loop, over count, is unrolled by 4 */
;;;862        /* To, read the last two inputB samples using SIMD:   
;;;863         * y[srcBLen] and y[srcBLen-1] coefficients, py is decremented by 1 */
;;;864        py = py - 1;
;;;865    
;;;866      while(blockSize1 > 0)
;;;867        {
;;;868          /* Accumulator is made zero for every iteration */
;;;869          sum = 0;
;;;870    
;;;871          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;872          k = count >> 2u;
;;;873    
;;;874          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;875           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;876    	py++;
;;;877    
;;;878        while(k > 0u)
;;;879        {
;;;880          /* Perform the multiply-accumulates */
;;;881            sum += ((q31_t) * px++ * *py--);
;;;882            sum += ((q31_t) * px++ * *py--);
;;;883            sum += ((q31_t) * px++ * *py--);
;;;884            sum += ((q31_t) * px++ * *py--);
;;;885    
;;;886          /* Decrement the loop counter */
;;;887          k--;
;;;888        }
;;;889    
;;;890          /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;891           ** No loop unrolling is used. */
;;;892          k = count % 0x4u;
;;;893    
;;;894          while(k > 0u)
;;;895          {
;;;896            /* Perform the multiply-accumulates */
;;;897          sum += ((q31_t) * px++ * *py--);
;;;898    
;;;899            /* Decrement the loop counter */
;;;900            k--;
;;;901          }
;;;902    
;;;903          /* Store the result in the accumulator in the destination buffer. */
;;;904          *pOut++ = (q15_t) (sum >> 15);
;;;905    
;;;906          /* Update the inputA and inputB pointers for next MAC calculation */
;;;907          py = ++pSrc2 - 1u;
;;;908          px = pIn1;
;;;909    
;;;910          /* Increment the MAC count */
;;;911          count++;
;;;912    
;;;913          /* Decrement the loop counter */
;;;914          blockSize1--;
;;;915        }
;;;916    
;;;917        /* --------------------------   
;;;918         * Initializations of stage2   
;;;919         * ------------------------*/
;;;920    
;;;921        /* sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0]   
;;;922         * sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0]   
;;;923         * ....   
;;;924         * sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]   
;;;925         */
;;;926    
;;;927        /* Working pointer of inputA */
;;;928        if((int32_t)firstIndex - (int32_t)srcBLen + 1 > 0)
;;;929        {
;;;930          px = pIn1 + firstIndex - srcBLen + 1;
;;;931        }
;;;932        else
;;;933        {
;;;934          px = pIn1;
;;;935        }
;;;936    
;;;937        /* Working pointer of inputB */
;;;938        pSrc2 = pIn2 + (srcBLen - 1u);
;;;939        py = pSrc2;
;;;940    
;;;941        /* count is the index by which the pointer pIn1 to be incremented */
;;;942        count = 0u;
;;;943    
;;;944    
;;;945        /* --------------------   
;;;946         * Stage2 process   
;;;947         * -------------------*/
;;;948    
;;;949        /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.   
;;;950         * So, to loop unroll over blockSize2,   
;;;951         * srcBLen should be greater than or equal to 4 */
;;;952        if(srcBLen >= 4u)
;;;953        {
;;;954          /* Loop unroll over blockSize2, by 4 */
;;;955          blkCnt = ((uint32_t) blockSize2 >> 2u);
;;;956    
;;;957          while(blkCnt > 0u)
;;;958          {
;;;959          py = py - 1u;
;;;960    
;;;961            /* Set all accumulators to zero */
;;;962            acc0 = 0;
;;;963            acc1 = 0;
;;;964            acc2 = 0;
;;;965            acc3 = 0;
;;;966    
;;;967          /* read x[0], x[1] samples */
;;;968    	  a = *px++;
;;;969    	  b = *px++;
;;;970    
;;;971    #ifndef ARM_MATH_BIG_ENDIAN
;;;972    	
;;;973    	  x0 = __PKHBT(a, b, 16);
;;;974    	  a = *px;
;;;975    	  x1 = __PKHBT(b, a, 16);
;;;976    
;;;977    #else
;;;978    
;;;979    	  x0 = __PKHBT(b, a, 16);
;;;980    	  a = *px;
;;;981    	  x1 = __PKHBT(a, b, 16);
;;;982    
;;;983    #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	   */
;;;984    
;;;985          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;986          k = srcBLen >> 2u;
;;;987    
;;;988          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;989           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;990          do
;;;991          {
;;;992            /* Read the last two inputB samples using SIMD:   
;;;993             * y[srcBLen - 1] and y[srcBLen - 2] */
;;;994    		a = *py;
;;;995    		b = *(py+1);
;;;996    		py -= 2;
;;;997    
;;;998    #ifndef ARM_MATH_BIG_ENDIAN
;;;999    
;;;1000   		c0 = __PKHBT(a, b, 16);
;;;1001   
;;;1002   #else
;;;1003   
;;;1004    		c0 = __PKHBT(b, a, 16);;
;;;1005   
;;;1006   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;1007   
;;;1008           /* acc0 +=  x[0] * y[srcBLen - 1] + x[1] * y[srcBLen - 2] */
;;;1009           acc0 = __SMLADX(x0, c0, acc0);
;;;1010   
;;;1011           /* acc1 +=  x[1] * y[srcBLen - 1] + x[2] * y[srcBLen - 2] */
;;;1012           acc1 = __SMLADX(x1, c0, acc1);
;;;1013   
;;;1014   	  a = *px;
;;;1015   	  b = *(px + 1);
;;;1016   
;;;1017   #ifndef ARM_MATH_BIG_ENDIAN
;;;1018   	
;;;1019   	  x2 = __PKHBT(a, b, 16);
;;;1020   	  a = *(px + 2);
;;;1021   	  x3 = __PKHBT(b, a, 16);
;;;1022   
;;;1023   #else
;;;1024   
;;;1025   	  x2 = __PKHBT(b, a, 16);
;;;1026   	  a = *(px + 2);
;;;1027   	  x3 = __PKHBT(a, b, 16);
;;;1028   
;;;1029   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	   */
;;;1030   
;;;1031           /* acc2 +=  x[2] * y[srcBLen - 1] + x[3] * y[srcBLen - 2] */
;;;1032           acc2 = __SMLADX(x2, c0, acc2);
;;;1033   
;;;1034           /* acc3 +=  x[3] * y[srcBLen - 1] + x[4] * y[srcBLen - 2] */
;;;1035           acc3 = __SMLADX(x3, c0, acc3);
;;;1036   
;;;1037           /* Read y[srcBLen - 3] and y[srcBLen - 4] */
;;;1038   		a = *py;
;;;1039   		b = *(py+1);
;;;1040   		py -= 2;
;;;1041   
;;;1042   #ifndef ARM_MATH_BIG_ENDIAN
;;;1043   
;;;1044   		c0 = __PKHBT(a, b, 16);
;;;1045   
;;;1046   #else
;;;1047   
;;;1048    		c0 = __PKHBT(b, a, 16);;
;;;1049   
;;;1050   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;1051   
;;;1052           /* acc0 +=  x[2] * y[srcBLen - 3] + x[3] * y[srcBLen - 4] */
;;;1053           acc0 = __SMLADX(x2, c0, acc0);
;;;1054   
;;;1055           /* acc1 +=  x[3] * y[srcBLen - 3] + x[4] * y[srcBLen - 4] */
;;;1056           acc1 = __SMLADX(x3, c0, acc1);
;;;1057   
;;;1058           /* Read x[4], x[5], x[6] */
;;;1059   	  a = *(px + 2);
;;;1060   	  b = *(px + 3);
;;;1061   
;;;1062   #ifndef ARM_MATH_BIG_ENDIAN
;;;1063   	
;;;1064   	  x0 = __PKHBT(a, b, 16);
;;;1065   	  a = *(px + 4);
;;;1066   	  x1 = __PKHBT(b, a, 16);
;;;1067   
;;;1068   #else
;;;1069   
;;;1070   	  x0 = __PKHBT(b, a, 16);
;;;1071   	  a = *(px + 4);
;;;1072   	  x1 = __PKHBT(a, b, 16);
;;;1073   
;;;1074   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	   */
;;;1075   
;;;1076   		px += 4u;
;;;1077   
;;;1078           /* acc2 +=  x[4] * y[srcBLen - 3] + x[5] * y[srcBLen - 4] */
;;;1079           acc2 = __SMLADX(x0, c0, acc2);
;;;1080   
;;;1081           /* acc3 +=  x[5] * y[srcBLen - 3] + x[6] * y[srcBLen - 4] */
;;;1082           acc3 = __SMLADX(x1, c0, acc3);
;;;1083   
;;;1084         } while(--k);
;;;1085   
;;;1086         /* For the next MAC operations, SIMD is not used   
;;;1087          * So, the 16 bit pointer if inputB, py is updated */
;;;1088   
;;;1089         /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;1090          ** No loop unrolling is used. */
;;;1091         k = srcBLen % 0x4u;
;;;1092   
;;;1093         if(k == 1u)
;;;1094         {
;;;1095           /* Read y[srcBLen - 5] */
;;;1096           c0 = *(py+1);
;;;1097   
;;;1098   #ifdef  ARM_MATH_BIG_ENDIAN
;;;1099   
;;;1100           c0 = c0 << 16u;
;;;1101   
;;;1102   #else
;;;1103   
;;;1104           c0 = c0 & 0x0000FFFF;
;;;1105   
;;;1106   #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;1107   
;;;1108           /* Read x[7] */
;;;1109   		a = *px;
;;;1110   		b = *(px+1);
;;;1111   		px++;
;;;1112   
;;;1113   #ifndef ARM_MATH_BIG_ENDIAN
;;;1114   
;;;1115   		x3 = __PKHBT(a, b, 16);
;;;1116   
;;;1117   #else
;;;1118   
;;;1119    		x3 = __PKHBT(b, a, 16);;
;;;1120   
;;;1121   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;1122   
;;;1123   
;;;1124           /* Perform the multiply-accumulates */
;;;1125           acc0 = __SMLAD(x0, c0, acc0);
;;;1126           acc1 = __SMLAD(x1, c0, acc1);
;;;1127           acc2 = __SMLADX(x1, c0, acc2);
;;;1128           acc3 = __SMLADX(x3, c0, acc3);
;;;1129         }
;;;1130   
;;;1131         if(k == 2u)
;;;1132         {
;;;1133           /* Read y[srcBLen - 5], y[srcBLen - 6] */
;;;1134   		a = *py;
;;;1135   		b = *(py+1);
;;;1136   
;;;1137   #ifndef ARM_MATH_BIG_ENDIAN
;;;1138   
;;;1139   		c0 = __PKHBT(a, b, 16);
;;;1140   
;;;1141   #else
;;;1142   
;;;1143    		c0 = __PKHBT(b, a, 16);;
;;;1144   
;;;1145   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;1146   
;;;1147           /* Read x[7], x[8], x[9] */
;;;1148   	  a = *px;
;;;1149   	  b = *(px + 1);
;;;1150   
;;;1151   #ifndef ARM_MATH_BIG_ENDIAN
;;;1152   	
;;;1153   	  x3 = __PKHBT(a, b, 16);
;;;1154   	  a = *(px + 2);
;;;1155   	  x2 = __PKHBT(b, a, 16);
;;;1156   
;;;1157   #else
;;;1158   
;;;1159   	  x3 = __PKHBT(b, a, 16);
;;;1160   	  a = *(px + 2);
;;;1161   	  x2 = __PKHBT(a, b, 16);
;;;1162   
;;;1163   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	   */
;;;1164   		px += 2u;
;;;1165   
;;;1166           /* Perform the multiply-accumulates */
;;;1167           acc0 = __SMLADX(x0, c0, acc0);
;;;1168           acc1 = __SMLADX(x1, c0, acc1);
;;;1169           acc2 = __SMLADX(x3, c0, acc2);
;;;1170           acc3 = __SMLADX(x2, c0, acc3);
;;;1171         }
;;;1172   
;;;1173         if(k == 3u)
;;;1174         {
;;;1175           /* Read y[srcBLen - 5], y[srcBLen - 6] */
;;;1176   		a = *py;
;;;1177   		b = *(py+1);
;;;1178   
;;;1179   #ifndef ARM_MATH_BIG_ENDIAN
;;;1180   
;;;1181   		c0 = __PKHBT(a, b, 16);
;;;1182   
;;;1183   #else
;;;1184   
;;;1185    		c0 = __PKHBT(b, a, 16);;
;;;1186   
;;;1187   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;1188   
;;;1189           /* Read x[7], x[8], x[9] */
;;;1190   	  a = *px;
;;;1191   	  b = *(px + 1);
;;;1192   
;;;1193   #ifndef ARM_MATH_BIG_ENDIAN
;;;1194   	
;;;1195   	  x3 = __PKHBT(a, b, 16);
;;;1196   	  a = *(px + 2);
;;;1197   	  x2 = __PKHBT(b, a, 16);
;;;1198   
;;;1199   #else
;;;1200   
;;;1201   	  x3 = __PKHBT(b, a, 16);
;;;1202   	  a = *(px + 2);
;;;1203   	  x2 = __PKHBT(a, b, 16);
;;;1204   
;;;1205   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	   */
;;;1206   
;;;1207           /* Perform the multiply-accumulates */
;;;1208           acc0 = __SMLADX(x0, c0, acc0);
;;;1209           acc1 = __SMLADX(x1, c0, acc1);
;;;1210           acc2 = __SMLADX(x3, c0, acc2);
;;;1211           acc3 = __SMLADX(x2, c0, acc3);
;;;1212   
;;;1213           /* Read y[srcBLen - 7] */
;;;1214   		c0 = *(py-1);
;;;1215   #ifdef  ARM_MATH_BIG_ENDIAN
;;;1216   
;;;1217           c0 = c0 << 16u;
;;;1218   #else
;;;1219   
;;;1220           c0 = c0 & 0x0000FFFF;
;;;1221   #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;1222   
;;;1223           /* Read x[10] */
;;;1224   		a = *(px+2);
;;;1225   		b = *(px+3);
;;;1226   
;;;1227   #ifndef ARM_MATH_BIG_ENDIAN
;;;1228   
;;;1229   		x3 = __PKHBT(a, b, 16);
;;;1230   
;;;1231   #else
;;;1232   
;;;1233    		x3 = __PKHBT(b, a, 16);;
;;;1234   
;;;1235   #endif	/*	#ifndef ARM_MATH_BIG_ENDIAN	*/
;;;1236   
;;;1237   		px += 3u;
;;;1238   
;;;1239           /* Perform the multiply-accumulates */
;;;1240           acc0 = __SMLADX(x1, c0, acc0);
;;;1241           acc1 = __SMLAD(x2, c0, acc1);
;;;1242           acc2 = __SMLADX(x2, c0, acc2);
;;;1243           acc3 = __SMLADX(x3, c0, acc3);
;;;1244         }
;;;1245   
;;;1246         /* Store the results in the accumulators in the destination buffer. */
;;;1247   	  *pOut++ = (q15_t)(acc0 >> 15);
;;;1248   	  *pOut++ = (q15_t)(acc1 >> 15);
;;;1249   	  *pOut++ = (q15_t)(acc2 >> 15);
;;;1250   	  *pOut++ = (q15_t)(acc3 >> 15);
;;;1251   
;;;1252           /* Increment the pointer pIn1 index, count by 4 */
;;;1253           count += 4u;
;;;1254   
;;;1255           /* Update the inputA and inputB pointers for next MAC calculation */
;;;1256           px = pIn1 + count;
;;;1257           py = pSrc2;
;;;1258   
;;;1259           /* Decrement the loop counter */
;;;1260           blkCnt--;
;;;1261         }
;;;1262   
;;;1263         /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.   
;;;1264          ** No loop unrolling is used. */
;;;1265         blkCnt = (uint32_t) blockSize2 % 0x4u;
;;;1266   
;;;1267         while(blkCnt > 0u)
;;;1268         {
;;;1269           /* Accumulator is made zero for every iteration */
;;;1270           sum = 0;
;;;1271   
;;;1272           /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;1273           k = srcBLen >> 2u;
;;;1274   
;;;1275           /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;1276            ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;1277           while(k > 0u)
;;;1278           {
;;;1279             /* Perform the multiply-accumulates */
;;;1280             sum += ((q31_t) * px++ * *py--);
;;;1281             sum += ((q31_t) * px++ * *py--);
;;;1282             sum += ((q31_t) * px++ * *py--);
;;;1283             sum += ((q31_t) * px++ * *py--);
;;;1284   
;;;1285             /* Decrement the loop counter */
;;;1286             k--;
;;;1287           }
;;;1288   
;;;1289           /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;1290            ** No loop unrolling is used. */
;;;1291           k = srcBLen % 0x4u;
;;;1292   
;;;1293           while(k > 0u)
;;;1294           {
;;;1295             /* Perform the multiply-accumulates */
;;;1296             sum += ((q31_t) * px++ * *py--);
;;;1297   
;;;1298             /* Decrement the loop counter */
;;;1299             k--;
;;;1300           }
;;;1301   
;;;1302           /* Store the result in the accumulator in the destination buffer. */
;;;1303           *pOut++ = (q15_t) (sum >> 15);
;;;1304   
;;;1305           /* Increment the pointer pIn1 index, count by 1 */
;;;1306           count++;
;;;1307   
;;;1308           /* Update the inputA and inputB pointers for next MAC calculation */
;;;1309           px = pIn1 + count;
;;;1310           py = pSrc2;
;;;1311   
;;;1312           /* Decrement the loop counter */
;;;1313           blkCnt--;
;;;1314         }
;;;1315       }
;;;1316       else
;;;1317       {
;;;1318         /* If the srcBLen is not a multiple of 4,   
;;;1319          * the blockSize2 loop cannot be unrolled by 4 */
;;;1320         blkCnt = (uint32_t) blockSize2;
;;;1321   
;;;1322         while(blkCnt > 0u)
;;;1323         {
;;;1324           /* Accumulator is made zero for every iteration */
;;;1325           sum = 0;
;;;1326   
;;;1327           /* srcBLen number of MACS should be performed */
;;;1328           k = srcBLen;
;;;1329   
;;;1330           while(k > 0u)
;;;1331           {
;;;1332             /* Perform the multiply-accumulate */
;;;1333             sum += ((q31_t) * px++ * *py--);
;;;1334   
;;;1335             /* Decrement the loop counter */
;;;1336             k--;
;;;1337           }
;;;1338   
;;;1339           /* Store the result in the accumulator in the destination buffer. */
;;;1340           *pOut++ = (q15_t) (sum >> 15);
;;;1341   
;;;1342           /* Increment the MAC count */
;;;1343           count++;
;;;1344   
;;;1345           /* Update the inputA and inputB pointers for next MAC calculation */
;;;1346           px = pIn1 + count;
;;;1347           py = pSrc2;
;;;1348   
;;;1349           /* Decrement the loop counter */
;;;1350           blkCnt--;
;;;1351         }
;;;1352       }
;;;1353   
;;;1354   
;;;1355       /* --------------------------   
;;;1356        * Initializations of stage3   
;;;1357        * -------------------------*/
;;;1358   
;;;1359       /* sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1]   
;;;1360        * sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2]   
;;;1361        * ....   
;;;1362        * sum +=  x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2]   
;;;1363        * sum +=  x[srcALen-1] * y[srcBLen-1]   
;;;1364        */
;;;1365   
;;;1366       /* In this stage the MAC operations are decreased by 1 for every iteration.   
;;;1367          The count variable holds the number of MAC operations performed */
;;;1368       count = srcBLen - 1u;
;;;1369   
;;;1370       /* Working pointer of inputA */
;;;1371       pSrc1 = (pIn1 + srcALen) - (srcBLen - 1u);
;;;1372       px = pSrc1;
;;;1373   
;;;1374       /* Working pointer of inputB */
;;;1375       pSrc2 = pIn2 + (srcBLen - 1u);
;;;1376       pIn2 = pSrc2 - 1u;
;;;1377       py = pIn2;
;;;1378   
;;;1379       /* -------------------   
;;;1380        * Stage3 process   
;;;1381        * ------------------*/
;;;1382   
;;;1383       /* For loop unrolling by 4, this stage is divided into two. */
;;;1384       /* First part of this stage computes the MAC operations greater than 4 */
;;;1385       /* Second part of this stage computes the MAC operations less than or equal to 4 */
;;;1386   
;;;1387       /* The first part of the stage starts here */
;;;1388       j = count >> 2u;
;;;1389   
;;;1390       while((j > 0u) && (blockSize3 > 0))
;;;1391       {
;;;1392         /* Accumulator is made zero for every iteration */
;;;1393         sum = 0;
;;;1394   
;;;1395         /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;1396         k = count >> 2u;
;;;1397   
;;;1398         /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;1399          ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;1400   	py++;
;;;1401   
;;;1402       while(k > 0u)
;;;1403       {	
;;;1404         /* Perform the multiply-accumulates */
;;;1405           sum += ((q31_t) * px++ * *py--);
;;;1406           sum += ((q31_t) * px++ * *py--);
;;;1407           sum += ((q31_t) * px++ * *py--);
;;;1408           sum += ((q31_t) * px++ * *py--);
;;;1409         /* Decrement the loop counter */
;;;1410         k--;
;;;1411       }
;;;1412   
;;;1413   
;;;1414         /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;1415          ** No loop unrolling is used. */
;;;1416         k = count % 0x4u;
;;;1417   
;;;1418         while(k > 0u)
;;;1419         {
;;;1420         /* Perform the multiply-accumulates */
;;;1421           sum += ((q31_t) * px++ * *py--);
;;;1422   
;;;1423           /* Decrement the loop counter */
;;;1424           k--;
;;;1425         }
;;;1426   
;;;1427         /* Store the result in the accumulator in the destination buffer. */
;;;1428         *pOut++ = (q15_t) (sum >> 15);
;;;1429   
;;;1430         /* Update the inputA and inputB pointers for next MAC calculation */
;;;1431         px = ++pSrc1;
;;;1432         py = pIn2;
;;;1433   
;;;1434         /* Decrement the MAC count */
;;;1435         count--;
;;;1436   
;;;1437         /* Decrement the loop counter */
;;;1438         blockSize3--;
;;;1439   
;;;1440         j--;
;;;1441       }
;;;1442   
;;;1443       /* The second part of the stage starts here */
;;;1444       /* SIMD is not used for the next MAC operations,   
;;;1445        * so pointer py is updated to read only one sample at a time */
;;;1446       py = py + 1u;
;;;1447   
;;;1448     while(blockSize3 > 0)
;;;1449       {
;;;1450         /* Accumulator is made zero for every iteration */
;;;1451         sum = 0;
;;;1452   
;;;1453         /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;1454         k = count;
;;;1455   
;;;1456         while(k > 0u)
;;;1457         {
;;;1458           /* Perform the multiply-accumulates */
;;;1459           /* sum +=  x[srcALen-1] * y[srcBLen-1] */
;;;1460           sum += ((q31_t) * px++ * *py--);
;;;1461   
;;;1462           /* Decrement the loop counter */
;;;1463           k--;
;;;1464         }
;;;1465   
;;;1466         /* Store the result in the accumulator in the destination buffer. */
;;;1467         *pOut++ = (q15_t) (sum >> 15);
;;;1468   
;;;1469         /* Update the inputA and inputB pointers for next MAC calculation */
;;;1470         px = ++pSrc1;
;;;1471         py = pSrc2;
;;;1472   
;;;1473         /* Decrement the MAC count */
;;;1474         count--;
;;;1475   
;;;1476         /* Decrement the loop counter */
;;;1477         blockSize3--;
;;;1478       }
;;;1479   
;;;1480       /* set status as ARM_MATH_SUCCESS */
;;;1481       status = ARM_MATH_SUCCESS;
;;;1482     }
;;;1483   
;;;1484     /* Return to application */
;;;1485     return (status);
;;;1486   
;;;1487   #endif /*     #ifndef UNALIGNED_SUPPORT_DISABLE      */
;;;1488   }
00001e  b016              ADD      sp,sp,#0x58
000020  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.36|
000024  465f              MOV      r7,r11                ;102
000026  459b              CMP      r11,r3                ;102
000028  d302              BCC      |L1.48|
00002a  4686              MOV      lr,r0                 ;105
00002c  9202              STR      r2,[sp,#8]            ;108
00002e  e003              B        |L1.56|
                  |L1.48|
000030  469b              MOV      r11,r3                ;119
000032  4696              MOV      lr,r2                 ;113
000034  463b              MOV      r3,r7                 ;120
000036  9002              STR      r0,[sp,#8]            ;120
                  |L1.56|
000038  4559              CMP      r1,r11                ;127
00003a  dd02              BLE      |L1.66|
00003c  eba1000b          SUB      r0,r1,r11             ;127
000040  e000              B        |L1.68|
                  |L1.66|
000042  2000              MOVS     r0,#0                 ;127
                  |L1.68|
000044  f1ab0201          SUB      r2,r11,#1             ;128
000048  4295              CMP      r5,r2                 ;128
00004a  dd02              BLE      |L1.82|
00004c  1b42              SUBS     r2,r0,r5              ;128
00004e  eb02000b          ADD      r0,r2,r11             ;128
                  |L1.82|
000052  9005              STR      r0,[sp,#0x14]         ;129
000054  1b58              SUBS     r0,r3,r5              ;129
000056  1e40              SUBS     r0,r0,#1              ;129
000058  2800              CMP      r0,#0                 ;130
00005a  dd04              BLE      |L1.102|
00005c  1e5a              SUBS     r2,r3,#1              ;130
00005e  4291              CMP      r1,r2                 ;130
000060  d802              BHI      |L1.104|
000062  4630              MOV      r0,r6                 ;131
000064  e000              B        |L1.104|
                  |L1.102|
000066  2000              MOVS     r0,#0                 ;131
                  |L1.104|
000068  9a05              LDR      r2,[sp,#0x14]         ;132
00006a  4681              MOV      r9,r0                 ;131
00006c  eb020009          ADD      r0,r2,r9              ;132
000070  4428              ADD      r0,r0,r5              ;132
000072  1a08              SUBS     r0,r1,r0              ;132
000074  2800              CMP      r0,#0                 ;134
000076  dc00              BGT      |L1.122|
000078  2000              MOVS     r0,#0                 ;134
                  |L1.122|
00007a  9902              LDR      r1,[sp,#8]            ;169
00007c  eb040a45          ADD      r10,r4,r5,LSL #1      ;147
000080  900d              STR      r0,[sp,#0x34]         ;166
000082  eb010145          ADD      r1,r1,r5,LSL #1       ;169
000086  462c              MOV      r4,r5                 ;163
000088  4670              MOV      r0,lr                 ;166
00008a  910e              STR      r1,[sp,#0x38]         ;181
00008c  e014              B        |L1.184|
                  |L1.142|
00008e  2600              MOVS     r6,#0                 ;184
000090  4622              MOV      r2,r4                 ;188
000092  e006              B        |L1.162|
                  |L1.148|
000094  f9307b02          LDRSH    r7,[r0],#2            ;193
000098  f931c902          LDRSH    r12,[r1],#-2          ;193
00009c  fb27660c          SMLAD    r6,r7,r12,r6          ;193
0000a0  1e52              SUBS     r2,r2,#1              ;193
                  |L1.162|
0000a2  2a00              CMP      r2,#0                 ;190
0000a4  d1f6              BNE      |L1.148|
0000a6  13f1              ASRS     r1,r6,#15             ;200
0000a8  f82a1b02          STRH     r1,[r10],#2           ;200
0000ac  990e              LDR      r1,[sp,#0x38]         ;203
0000ae  4670              MOV      r0,lr                 ;204
0000b0  1c89              ADDS     r1,r1,#2              ;203
0000b2  f1a90901          SUB      r9,r9,#1              ;210
0000b6  910e              STR      r1,[sp,#0x38]         ;210
                  |L1.184|
0000b8  1c64              ADDS     r4,r4,#1              ;210
0000ba  2c04              CMP      r4,#4                 ;181
0000bc  d202              BCS      |L1.196|
0000be  f1b90f00          CMP      r9,#0                 ;181
0000c2  dce4              BGT      |L1.142|
                  |L1.196|
0000c4  1e89              SUBS     r1,r1,#2              ;181
0000c6  e02b              B        |L1.288|
                  |L1.200|
0000c8  2200              MOVS     r2,#0                 ;222
0000ca  08a6              LSRS     r6,r4,#2              ;225
0000cc  e00e              B        |L1.236|
0000ce  bf00              NOP                            ;233
                  |L1.208|
0000d0  f8507b04          LDR      r7,[r0],#4            ;233
0000d4  f8d1c000          LDR      r12,[r1,#0]           ;233
0000d8  fb27221c          SMLADX   r2,r7,r12,r2          ;233
0000dc  f8507b04          LDR      r7,[r0],#4            ;235
0000e0  f851cc04          LDR      r12,[r1,#-4]          ;235
0000e4  fb27221c          SMLADX   r2,r7,r12,r2          ;235
0000e8  3908              SUBS     r1,r1,#8              ;235
0000ea  1e76              SUBS     r6,r6,#1              ;235
                  |L1.236|
0000ec  2e00              CMP      r6,#0                 ;229
0000ee  d1ef              BNE      |L1.208|
0000f0  f0040603          AND      r6,r4,#3              ;247
0000f4  1c89              ADDS     r1,r1,#2              ;247
0000f6  e006              B        |L1.262|
                  |L1.248|
0000f8  f9307b02          LDRSH    r7,[r0],#2            ;252
0000fc  f931c902          LDRSH    r12,[r1],#-2          ;252
000100  fb27220c          SMLAD    r2,r7,r12,r2          ;252
000104  1e76              SUBS     r6,r6,#1              ;252
                  |L1.262|
000106  2e00              CMP      r6,#0                 ;249
000108  d1f6              BNE      |L1.248|
00010a  13d1              ASRS     r1,r2,#15             ;259
00010c  f82a1b02          STRH     r1,[r10],#2           ;259
000110  990e              LDR      r1,[sp,#0x38]         ;262
000112  4670              MOV      r0,lr                 ;263
000114  1c89              ADDS     r1,r1,#2              ;262
000116  910e              STR      r1,[sp,#0x38]         ;269
000118  1e89              SUBS     r1,r1,#2              ;269
00011a  f1a90901          SUB      r9,r9,#1              ;269
00011e  1c64              ADDS     r4,r4,#1              ;269
                  |L1.288|
000120  f1b90f00          CMP      r9,#0                 ;219
000124  dcd0              BGT      |L1.200|
000126  1ae9              SUBS     r1,r5,r3              ;283
000128  1c49              ADDS     r1,r1,#1              ;283
00012a  2900              CMP      r1,#0                 ;283
00012c  dd04              BLE      |L1.312|
00012e  eb0e0045          ADD      r0,lr,r5,LSL #1       ;285
000132  eba00043          SUB      r0,r0,r3,LSL #1       ;285
000136  1c80              ADDS     r0,r0,#2              ;285
                  |L1.312|
000138  9902              LDR      r1,[sp,#8]            ;293
00013a  2200              MOVS     r2,#0                 ;297
00013c  eb010143          ADD      r1,r1,r3,LSL #1       ;293
000140  9110              STR      r1,[sp,#0x40]         ;293
000142  1e89              SUBS     r1,r1,#2              ;293
000144  9203              STR      r2,[sp,#0xc]          ;307
000146  910e              STR      r1,[sp,#0x38]         ;307
000148  2b04              CMP      r3,#4                 ;307
00014a  d37c              BCC      |L1.582|
00014c  9a0d              LDR      r2,[sp,#0x34]         ;310
00014e  0892              LSRS     r2,r2,#2              ;310
000150  e074              B        |L1.572|
000152  bf00              NOP                            ;317
                  |L1.340|
000154  f04f0900          MOV      r9,#0                 ;317
000158  f8507b02          LDR      r7,[r0],#2            ;324
00015c  ea4f0c93          LSR      r12,r3,#2             ;331
000160  f8506b02          LDR      r6,[r0],#2            ;326
000164  464a              MOV      r2,r9                 ;318
000166  464c              MOV      r4,r9                 ;319
000168  464d              MOV      r5,r9                 ;320
00016a  1e89              SUBS     r1,r1,#2              ;331
00016c  f8cdc048          STR      r12,[sp,#0x48]        ;331
                  |L1.368|
000170  f8d1c000          LDR      r12,[r1,#0]           ;339
000174  f1a10804          SUB      r8,r1,#4              ;339
000178  fb27971c          SMLADX   r7,r7,r12,r9          ;342
00017c  fb26221c          SMLADX   r2,r6,r12,r2          ;345
000180  f8cd8030          STR      r8,[sp,#0x30]         ;348
000184  920f              STR      r2,[sp,#0x3c]         ;348
000186  f8502b02          LDR      r2,[r0],#2            ;348
00018a  f8506b02          LDR      r6,[r0],#2            ;351
00018e  fb22441c          SMLADX   r4,r2,r12,r4          ;354
000192  fb265c1c          SMLADX   r12,r6,r12,r5         ;357
000196  f8515c04          LDR      r5,[r1,#-4]           ;360
00019a  fb227915          SMLADX   r9,r2,r5,r7           ;363
00019e  9a0f              LDR      r2,[sp,#0x3c]         ;366
0001a0  fb262215          SMLADX   r2,r6,r5,r2           ;366
0001a4  f8507b04          LDR      r7,[r0],#4            ;369
0001a8  f8506c02          LDR      r6,[r0,#-2]           ;372
0001ac  fb274415          SMLADX   r4,r7,r5,r4           ;376
0001b0  fb26c515          SMLADX   r5,r6,r5,r12          ;379
0001b4  f8ddc048          LDR      r12,[sp,#0x48]        ;381
0001b8  f1a10108          SUB      r1,r1,#8              ;381
0001bc  f1bc0c01          SUBS     r12,r12,#1            ;381
0001c0  f8cdc048          STR      r12,[sp,#0x48]        ;381
0001c4  d1d4              BNE      |L1.368|
0001c6  f0030c03          AND      r12,r3,#3             ;388
0001ca  f1bc0f01          CMP      r12,#1                ;390
0001ce  d006              BEQ      |L1.478|
0001d0  f1bc0f02          CMP      r12,#2                ;415
0001d4  d00d              BEQ      |L1.498|
0001d6  f1bc0f03          CMP      r12,#3                ;434
0001da  d038              BEQ      |L1.590|
0001dc  e016              B        |L1.524|
                  |L1.478|
0001de  8849              LDRH     r1,[r1,#2]            ;393
0001e0  6800              LDR      r0,[r0,#0]            ;405
0001e2  b289              UXTH     r1,r1                 ;400
0001e4  fb279901          SMLAD    r9,r7,r1,r9           ;409
0001e8  fb262201          SMLAD    r2,r6,r1,r2           ;410
0001ec  fb264411          SMLADX   r4,r6,r1,r4           ;411
0001f0  e00a              B        |L1.520|
                  |L1.498|
0001f2  f8d0c000          LDR      r12,[r0,#0]           ;421
0001f6  6809              LDR      r1,[r1,#0]            ;418
0001f8  f8d00002          LDR      r0,[r0,#2]            ;424
0001fc  fb279911          SMLADX   r9,r7,r1,r9           ;428
000200  fb262211          SMLADX   r2,r6,r1,r2           ;429
000204  fb2c4411          SMLADX   r4,r12,r1,r4          ;430
                  |L1.520|
000208  fb205511          SMLADX   r5,r0,r1,r5           ;431
                  |L1.524|
00020c  ea4f30e9          ASR      r0,r9,#15             ;474
000210  13d1              ASRS     r1,r2,#15             ;474
000212  eac04101          PKHBT    r1,r0,r1,LSL #16      ;474
000216  f8ca1000          STR      r1,[r10,#0]           ;474
00021a  13e2              ASRS     r2,r4,#15             ;475
00021c  f10a0004          ADD      r0,r10,#4             ;474
000220  13e9              ASRS     r1,r5,#15             ;475
000222  eac24101          PKHBT    r1,r2,r1,LSL #16      ;475
000226  f8401b04          STR      r1,[r0],#4            ;475
00022a  4682              MOV      r10,r0                ;475
00022c  9803              LDR      r0,[sp,#0xc]          ;485
00022e  9a0a              LDR      r2,[sp,#0x28]         ;492
000230  1d00              ADDS     r0,r0,#4              ;485
000232  9003              STR      r0,[sp,#0xc]          ;488
000234  990e              LDR      r1,[sp,#0x38]         ;492
000236  eb0e0040          ADD      r0,lr,r0,LSL #1       ;488
00023a  1e52              SUBS     r2,r2,#1              ;492
                  |L1.572|
00023c  920a              STR      r2,[sp,#0x28]         ;310
00023e  2a00              CMP      r2,#0                 ;310
000240  d188              BNE      |L1.340|
000242  9a0d              LDR      r2,[sp,#0x34]         ;497
000244  e000              B        |L1.584|
                  |L1.582|
000246  e05b              B        |L1.768|
                  |L1.584|
000248  f0020503          AND      r5,r2,#3              ;497
00024c  e055              B        |L1.762|
                  |L1.590|
00024e  f8d1c000          LDR      r12,[r1,#0]           ;437
000252  f8d08000          LDR      r8,[r0,#0]            ;440
000256  f8cd8044          STR      r8,[sp,#0x44]         ;443
00025a  f8d08002          LDR      r8,[r0,#2]            ;443
00025e  fb27971c          SMLADX   r7,r7,r12,r9          ;446
000262  fb26221c          SMLADX   r2,r6,r12,r2          ;447
000266  f8cd8008          STR      r8,[sp,#8]            ;448
00026a  f8dd8044          LDR      r8,[sp,#0x44]         ;448
00026e  fb28441c          SMLADX   r4,r8,r12,r4          ;448
000272  f8dd8008          LDR      r8,[sp,#8]            ;449
000276  fb28551c          SMLADX   r5,r8,r12,r5          ;449
00027a  f8311c02          LDRH     r1,[r1,#-2]           ;451
00027e  6840              LDR      r0,[r0,#4]            ;461
000280  b289              UXTH     r1,r1                 ;457
000282  fb267911          SMLADX   r9,r6,r1,r7           ;465
000286  fb282201          SMLAD    r2,r8,r1,r2           ;466
00028a  fb284411          SMLADX   r4,r8,r1,r4           ;467
00028e  e7bb              B        |L1.520|
                  |L1.656|
000290  2200              MOVS     r2,#0                 ;502
000292  089c              LSRS     r4,r3,#2              ;505
000294  e019              B        |L1.714|
000296  bf00              NOP                            ;512
                  |L1.664|
000298  f8307b02          LDRH     r7,[r0],#2            ;512
00029c  880e              LDRH     r6,[r1,#0]            ;512
00029e  fb172206          SMLABB   r2,r7,r6,r2           ;512
0002a2  1e8e              SUBS     r6,r1,#2              ;512
0002a4  f8307b02          LDRH     r7,[r0],#2            ;513
0002a8  8836              LDRH     r6,[r6,#0]            ;513
0002aa  fb172606          SMLABB   r6,r7,r6,r2           ;513
0002ae  1f0a              SUBS     r2,r1,#4
0002b0  f8307b04          LDRH     r7,[r0],#4            ;514
0002b4  8812              LDRH     r2,[r2,#0]            ;514
0002b6  fb176602          SMLABB   r6,r7,r2,r6           ;514
0002ba  1f8a              SUBS     r2,r1,#6
0002bc  f8307c02          LDRH     r7,[r0,#-2]           ;515
0002c0  8812              LDRH     r2,[r2,#0]            ;515
0002c2  fb176202          SMLABB   r2,r7,r2,r6           ;515
0002c6  3908              SUBS     r1,r1,#8              ;515
0002c8  1e64              SUBS     r4,r4,#1              ;515
                  |L1.714|
0002ca  2c00              CMP      r4,#0                 ;509
0002cc  d1e4              BNE      |L1.664|
0002ce  f0030403          AND      r4,r3,#3              ;523
0002d2  e006              B        |L1.738|
                  |L1.724|
0002d4  f8307b02          LDRH     r7,[r0],#2            ;528
0002d8  f8316902          LDRH     r6,[r1],#-2           ;528
0002dc  fb172206          SMLABB   r2,r7,r6,r2           ;528
0002e0  1e64              SUBS     r4,r4,#1              ;528
                  |L1.738|
0002e2  2c00              CMP      r4,#0                 ;525
0002e4  d1f6              BNE      |L1.724|
0002e6  13d1              ASRS     r1,r2,#15             ;535
0002e8  f82a1b02          STRH     r1,[r10],#2           ;535
0002ec  9803              LDR      r0,[sp,#0xc]          ;538
0002ee  990e              LDR      r1,[sp,#0x38]         ;542
0002f0  1c40              ADDS     r0,r0,#1              ;538
0002f2  9003              STR      r0,[sp,#0xc]          ;541
0002f4  eb0e0040          ADD      r0,lr,r0,LSL #1       ;541
0002f8  1e6d              SUBS     r5,r5,#1              ;542
                  |L1.762|
0002fa  2d00              CMP      r5,#0                 ;499
0002fc  d1c8              BNE      |L1.656|
0002fe  e01a              B        |L1.822|
                  |L1.768|
000300  9d0d              LDR      r5,[sp,#0x34]         ;554
000302  e016              B        |L1.818|
                  |L1.772|
000304  2200              MOVS     r2,#0                 ;557
000306  461c              MOV      r4,r3                 ;560
000308  e007              B        |L1.794|
00030a  bf00              NOP                            ;565
                  |L1.780|
00030c  f8307b02          LDRH     r7,[r0],#2            ;565
000310  f8316902          LDRH     r6,[r1],#-2           ;565
000314  fb172206          SMLABB   r2,r7,r6,r2           ;565
000318  1e64              SUBS     r4,r4,#1              ;565
                  |L1.794|
00031a  2c00              CMP      r4,#0                 ;562
00031c  d1f6              BNE      |L1.780|
00031e  13d1              ASRS     r1,r2,#15             ;572
000320  f82a1b02          STRH     r1,[r10],#2           ;572
000324  9803              LDR      r0,[sp,#0xc]          ;575
000326  990e              LDR      r1,[sp,#0x38]         ;579
000328  1c40              ADDS     r0,r0,#1              ;575
00032a  9003              STR      r0,[sp,#0xc]          ;578
00032c  eb0e0040          ADD      r0,lr,r0,LSL #1       ;578
000330  1e6d              SUBS     r5,r5,#1              ;579
                  |L1.818|
000332  2d00              CMP      r5,#0                 ;554
000334  d1e6              BNE      |L1.772|
                  |L1.822|
000336  eb0e004b          ADD      r0,lr,r11,LSL #1      ;603
00033a  eba00443          SUB      r4,r0,r3,LSL #1       ;603
00033e  9810              LDR      r0,[sp,#0x40]         ;604
000340  1ca4              ADDS     r4,r4,#2              ;603
000342  1e5a              SUBS     r2,r3,#1              ;600
000344  f1a00902          SUB      r9,r0,#2              ;604
000348  1f00              SUBS     r0,r0,#4              ;608
00034a  4621              MOV      r1,r4                 ;604
00034c  4683              MOV      r11,r0                ;608
00034e  0896              LSRS     r6,r2,#2              ;620
000350  e02a              B        |L1.936|
                  |L1.850|
000352  2300              MOVS     r3,#0                 ;625
000354  0895              LSRS     r5,r2,#2              ;628
000356  e00d              B        |L1.884|
                  |L1.856|
000358  f8517b04          LDR      r7,[r1],#4            ;636
00035c  f8d0c000          LDR      r12,[r0,#0]           ;636
000360  fb27331c          SMLADX   r3,r7,r12,r3          ;636
000364  f8517b04          LDR      r7,[r1],#4            ;639
000368  f850cc04          LDR      r12,[r0,#-4]          ;639
00036c  fb27331c          SMLADX   r3,r7,r12,r3          ;639
000370  3808              SUBS     r0,r0,#8              ;639
000372  1e6d              SUBS     r5,r5,#1              ;639
                  |L1.884|
000374  2d00              CMP      r5,#0                 ;632
000376  d1ef              BNE      |L1.856|
000378  f0020503          AND      r5,r2,#3              ;651
00037c  1c80              ADDS     r0,r0,#2              ;651
00037e  e006              B        |L1.910|
                  |L1.896|
000380  f9317b02          LDRSH    r7,[r1],#2            ;656
000384  f930c902          LDRSH    r12,[r0],#-2          ;656
000388  fb27330c          SMLAD    r3,r7,r12,r3          ;656
00038c  1e6d              SUBS     r5,r5,#1              ;656
                  |L1.910|
00038e  2d00              CMP      r5,#0                 ;653
000390  d1f6              BNE      |L1.896|
000392  13d9              ASRS     r1,r3,#15             ;663
000394  f82a1b02          STRH     r1,[r10],#2           ;663
000398  9b05              LDR      r3,[sp,#0x14]         ;673
00039a  1ca1              ADDS     r1,r4,#2              ;666
00039c  1e5b              SUBS     r3,r3,#1              ;673
00039e  1e52              SUBS     r2,r2,#1              ;673
0003a0  460c              MOV      r4,r1                 ;666
0003a2  4658              MOV      r0,r11                ;667
0003a4  1e76              SUBS     r6,r6,#1              ;673
0003a6  9305              STR      r3,[sp,#0x14]         ;673
                  |L1.936|
0003a8  b116              CBZ      r6,|L1.944|
0003aa  9b05              LDR      r3,[sp,#0x14]         ;622
0003ac  2b00              CMP      r3,#0                 ;622
0003ae  dcd0              BGT      |L1.850|
                  |L1.944|
0003b0  f10b0002          ADD      r0,r11,#2             ;681
0003b4  9b05              LDR      r3,[sp,#0x14]         ;683
0003b6  e016              B        |L1.998|
                  |L1.952|
0003b8  2500              MOVS     r5,#0                 ;686
0003ba  4613              MOV      r3,r2                 ;689
0003bc  e007              B        |L1.974|
0003be  bf00              NOP                            ;695
                  |L1.960|
0003c0  f9316b02          LDRSH    r6,[r1],#2            ;695
0003c4  f9307902          LDRSH    r7,[r0],#-2           ;695
0003c8  fb265507          SMLAD    r5,r6,r7,r5           ;695
0003cc  1e5b              SUBS     r3,r3,#1              ;695
                  |L1.974|
0003ce  2b00              CMP      r3,#0                 ;691
0003d0  d1f6              BNE      |L1.960|
0003d2  13e9              ASRS     r1,r5,#15             ;702
0003d4  f82a1b02          STRH     r1,[r10],#2           ;702
0003d8  9b05              LDR      r3,[sp,#0x14]         ;712
0003da  1ca4              ADDS     r4,r4,#2              ;702
0003dc  1e5b              SUBS     r3,r3,#1              ;712
0003de  4621              MOV      r1,r4                 ;705
0003e0  4648              MOV      r0,r9                 ;706
0003e2  1e52              SUBS     r2,r2,#1              ;712
0003e4  9305              STR      r3,[sp,#0x14]         ;712
                  |L1.998|
0003e6  2b00              CMP      r3,#0                 ;683
0003e8  dce6              BGT      |L1.952|
0003ea  2000              MOVS     r0,#0                 ;716
0003ec  e617              B        |L1.30|
;;;1489   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_partial_fast_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___27_arm_conv_partial_fast_q15_c_1e37a144____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___27_arm_conv_partial_fast_q15_c_1e37a144____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___27_arm_conv_partial_fast_q15_c_1e37a144____REVSH|
#line 144
|__asm___27_arm_conv_partial_fast_q15_c_1e37a144____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___27_arm_conv_partial_fast_q15_c_1e37a144____RRX|
#line 300
|__asm___27_arm_conv_partial_fast_q15_c_1e37a144____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
