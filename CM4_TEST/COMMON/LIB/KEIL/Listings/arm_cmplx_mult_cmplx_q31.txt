; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_cmplx_mult_cmplx_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_cmplx_mult_cmplx_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_cmplx_mult_cmplx_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\ComplexMathFunctions\arm_cmplx_mult_cmplx_q31.c]
                          THUMB

                          AREA ||i.arm_cmplx_mult_cmplx_q31||, CODE, READONLY, ALIGN=1

                  arm_cmplx_mult_cmplx_q31 PROC
;;;66     
;;;67     void arm_cmplx_mult_cmplx_q31(
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;68       q31_t * pSrcA,
;;;69       q31_t * pSrcB,
;;;70       q31_t * pDst,
;;;71       uint32_t numSamples)
;;;72     {
;;;73       q31_t a, b, c, d;                              /* Temporary variables to store real and imaginary values */
;;;74       uint32_t blkCnt;                               /* loop counters */
;;;75       q31_t mul1, mul2, mul3, mul4;
;;;76       q31_t out1, out2;
;;;77     
;;;78     #ifndef ARM_MATH_CM0_FAMILY
;;;79     
;;;80       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;81     
;;;82       /* loop Unrolling */
;;;83       blkCnt = numSamples >> 2u;
000004  089c              LSRS     r4,r3,#2
000006  e064              B        |L1.210|
                  |L1.8|
;;;84     
;;;85       /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;86        ** a second loop below computes the remaining 1 to 3 samples. */
;;;87       while(blkCnt > 0u)
;;;88       {
;;;89         /* C[2 * i] = A[2 * i] * B[2 * i] - A[2 * i + 1] * B[2 * i + 1].  */
;;;90         /* C[2 * i + 1] = A[2 * i] * B[2 * i + 1] + A[2 * i + 1] * B[2 * i].  */
;;;91         a = *pSrcA++;
000008  6805              LDR      r5,[r0,#0]
;;;92         b = *pSrcA++;
00000a  6846              LDR      r6,[r0,#4]
;;;93         c = *pSrcB++;
00000c  680f              LDR      r7,[r1,#0]
;;;94         d = *pSrcB++;
00000e  f8d1c004          LDR      r12,[r1,#4]
;;;95     
;;;96         mul1 = (q31_t) (((q63_t) a * c) >> 32);
000012  fb55f807          SMMUL    r8,r5,r7
;;;97         mul2 = (q31_t) (((q63_t) b * d) >> 32);
000016  fb56f90c          SMMUL    r9,r6,r12
;;;98         mul3 = (q31_t) (((q63_t) a * d) >> 32);
00001a  fb55f50c          SMMUL    r5,r5,r12
;;;99         mul4 = (q31_t) (((q63_t) b * c) >> 32);
00001e  fb56f707          SMMUL    r7,r6,r7
;;;100    
;;;101        mul1 = (mul1 >> 1);
000022  ea4f0668          ASR      r6,r8,#1
;;;102        mul2 = (mul2 >> 1);
000026  ea4f0c69          ASR      r12,r9,#1
;;;103        mul3 = (mul3 >> 1);
00002a  106d              ASRS     r5,r5,#1
;;;104        mul4 = (mul4 >> 1);
00002c  107f              ASRS     r7,r7,#1
;;;105    
;;;106        out1 = mul1 - mul2;
00002e  eba6060c          SUB      r6,r6,r12
;;;107        out2 = mul3 + mul4;
000032  443d              ADD      r5,r5,r7
;;;108    
;;;109        /* store the real result in 3.29 format in the destination buffer. */
;;;110        *pDst++ = out1;
000034  6016              STR      r6,[r2,#0]
;;;111        /* store the imag result in 3.29 format in the destination buffer. */
;;;112        *pDst++ = out2;
000036  6055              STR      r5,[r2,#4]
;;;113    
;;;114        a = *pSrcA++;
000038  6885              LDR      r5,[r0,#8]
;;;115        b = *pSrcA++;
00003a  68c6              LDR      r6,[r0,#0xc]
;;;116        c = *pSrcB++;
00003c  688f              LDR      r7,[r1,#8]
;;;117        d = *pSrcB++;
00003e  f8d1c00c          LDR      r12,[r1,#0xc]
;;;118    
;;;119        mul1 = (q31_t) (((q63_t) a * c) >> 32);
000042  fb55f907          SMMUL    r9,r5,r7
;;;120        mul2 = (q31_t) (((q63_t) b * d) >> 32);
000046  fb56f80c          SMMUL    r8,r6,r12
;;;121        mul3 = (q31_t) (((q63_t) a * d) >> 32);
00004a  fb55f50c          SMMUL    r5,r5,r12
;;;122        mul4 = (q31_t) (((q63_t) b * c) >> 32);
00004e  fb56f607          SMMUL    r6,r6,r7
;;;123    
;;;124        mul1 = (mul1 >> 1);
000052  ea4f0769          ASR      r7,r9,#1
;;;125        mul2 = (mul2 >> 1);
000056  ea4f0c68          ASR      r12,r8,#1
;;;126        mul3 = (mul3 >> 1);
00005a  106d              ASRS     r5,r5,#1
;;;127        mul4 = (mul4 >> 1);
00005c  1076              ASRS     r6,r6,#1
;;;128    
;;;129        out1 = mul1 - mul2;
00005e  eba7070c          SUB      r7,r7,r12
;;;130        out2 = mul3 + mul4;
000062  4435              ADD      r5,r5,r6
;;;131    
;;;132        /* store the real result in 3.29 format in the destination buffer. */
;;;133        *pDst++ = out1;
000064  6097              STR      r7,[r2,#8]
;;;134        /* store the imag result in 3.29 format in the destination buffer. */
;;;135        *pDst++ = out2;
000066  60d5              STR      r5,[r2,#0xc]
;;;136    
;;;137        a = *pSrcA++;
000068  6905              LDR      r5,[r0,#0x10]
;;;138        b = *pSrcA++;
00006a  6946              LDR      r6,[r0,#0x14]
;;;139        c = *pSrcB++;
00006c  690f              LDR      r7,[r1,#0x10]
;;;140        d = *pSrcB++;
00006e  f8d1c014          LDR      r12,[r1,#0x14]
;;;141    
;;;142        mul1 = (q31_t) (((q63_t) a * c) >> 32);
000072  fb55f807          SMMUL    r8,r5,r7
;;;143        mul2 = (q31_t) (((q63_t) b * d) >> 32);
000076  fb56f90c          SMMUL    r9,r6,r12
;;;144        mul3 = (q31_t) (((q63_t) a * d) >> 32);
00007a  fb55f50c          SMMUL    r5,r5,r12
;;;145        mul4 = (q31_t) (((q63_t) b * c) >> 32);
00007e  fb56f607          SMMUL    r6,r6,r7
;;;146    
;;;147        mul1 = (mul1 >> 1);
000082  ea4f0768          ASR      r7,r8,#1
;;;148        mul2 = (mul2 >> 1);
000086  ea4f0c69          ASR      r12,r9,#1
;;;149        mul3 = (mul3 >> 1);
00008a  106d              ASRS     r5,r5,#1
;;;150        mul4 = (mul4 >> 1);
00008c  ea4f0866          ASR      r8,r6,#1
;;;151    
;;;152        out1 = mul1 - mul2;
000090  eba7060c          SUB      r6,r7,r12
;;;153        out2 = mul3 + mul4;
000094  4445              ADD      r5,r5,r8
;;;154    
;;;155        /* store the real result in 3.29 format in the destination buffer. */
;;;156        *pDst++ = out1;
000096  6116              STR      r6,[r2,#0x10]
;;;157        /* store the imag result in 3.29 format in the destination buffer. */
;;;158        *pDst++ = out2;
000098  6155              STR      r5,[r2,#0x14]
;;;159    
;;;160        a = *pSrcA++;
00009a  6985              LDR      r5,[r0,#0x18]
;;;161        b = *pSrcA++;
00009c  69c6              LDR      r6,[r0,#0x1c]
00009e  3020              ADDS     r0,r0,#0x20
;;;162        c = *pSrcB++;
0000a0  698f              LDR      r7,[r1,#0x18]
0000a2  311c              ADDS     r1,r1,#0x1c
;;;163        d = *pSrcB++;
0000a4  f851cb04          LDR      r12,[r1],#4
;;;164    
;;;165        mul1 = (q31_t) (((q63_t) a * c) >> 32);
0000a8  fb55f907          SMMUL    r9,r5,r7
;;;166        mul2 = (q31_t) (((q63_t) b * d) >> 32);
0000ac  fb56f80c          SMMUL    r8,r6,r12
;;;167        mul3 = (q31_t) (((q63_t) a * d) >> 32);
0000b0  fb55f50c          SMMUL    r5,r5,r12
;;;168        mul4 = (q31_t) (((q63_t) b * c) >> 32);
0000b4  fb56f707          SMMUL    r7,r6,r7
;;;169    
;;;170        mul1 = (mul1 >> 1);
0000b8  ea4f0669          ASR      r6,r9,#1
;;;171        mul2 = (mul2 >> 1);
0000bc  ea4f0c68          ASR      r12,r8,#1
;;;172        mul3 = (mul3 >> 1);
0000c0  106d              ASRS     r5,r5,#1
;;;173        mul4 = (mul4 >> 1);
0000c2  107f              ASRS     r7,r7,#1
;;;174    
;;;175        out1 = mul1 - mul2;
0000c4  eba6060c          SUB      r6,r6,r12
;;;176        out2 = mul3 + mul4;
0000c8  443d              ADD      r5,r5,r7
;;;177    
;;;178        /* store the real result in 3.29 format in the destination buffer. */
;;;179        *pDst++ = out1;
0000ca  6196              STR      r6,[r2,#0x18]
;;;180        /* store the imag result in 3.29 format in the destination buffer. */
;;;181        *pDst++ = out2;
0000cc  61d5              STR      r5,[r2,#0x1c]
0000ce  3220              ADDS     r2,r2,#0x20
;;;182    
;;;183        /* Decrement the blockSize loop counter */
;;;184        blkCnt--;
0000d0  1e64              SUBS     r4,r4,#1
                  |L1.210|
0000d2  2c00              CMP      r4,#0                 ;87
0000d4  d198              BNE      |L1.8|
;;;185      }
;;;186    
;;;187      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;188       ** No loop unrolling is used. */
;;;189      blkCnt = numSamples % 0x4u;
0000d6  f0030303          AND      r3,r3,#3
;;;190    
;;;191      while(blkCnt > 0u)
0000da  e019              B        |L1.272|
                  |L1.220|
;;;192      {
;;;193        /* C[2 * i] = A[2 * i] * B[2 * i] - A[2 * i + 1] * B[2 * i + 1].  */
;;;194        /* C[2 * i + 1] = A[2 * i] * B[2 * i + 1] + A[2 * i + 1] * B[2 * i].  */
;;;195        a = *pSrcA++;
0000dc  6804              LDR      r4,[r0,#0]
;;;196        b = *pSrcA++;
0000de  6845              LDR      r5,[r0,#4]
0000e0  3008              ADDS     r0,r0,#8
;;;197        c = *pSrcB++;
0000e2  680e              LDR      r6,[r1,#0]
;;;198        d = *pSrcB++;
0000e4  684f              LDR      r7,[r1,#4]
0000e6  3108              ADDS     r1,r1,#8
;;;199    
;;;200        mul1 = (q31_t) (((q63_t) a * c) >> 32);
0000e8  fb54f806          SMMUL    r8,r4,r6
;;;201        mul2 = (q31_t) (((q63_t) b * d) >> 32);
0000ec  fb55fc07          SMMUL    r12,r5,r7
;;;202        mul3 = (q31_t) (((q63_t) a * d) >> 32);
0000f0  fb54f407          SMMUL    r4,r4,r7
;;;203        mul4 = (q31_t) (((q63_t) b * c) >> 32);
0000f4  fb55f606          SMMUL    r6,r5,r6
;;;204    
;;;205        mul1 = (mul1 >> 1);
0000f8  ea4f0568          ASR      r5,r8,#1
;;;206        mul2 = (mul2 >> 1);
0000fc  ea4f076c          ASR      r7,r12,#1
;;;207        mul3 = (mul3 >> 1);
000100  1064              ASRS     r4,r4,#1
;;;208        mul4 = (mul4 >> 1);
000102  1076              ASRS     r6,r6,#1
;;;209    
;;;210        out1 = mul1 - mul2;
000104  1bed              SUBS     r5,r5,r7
;;;211        out2 = mul3 + mul4;
000106  4434              ADD      r4,r4,r6
;;;212    
;;;213        /* store the real result in 3.29 format in the destination buffer. */
;;;214        *pDst++ = out1;
000108  6015              STR      r5,[r2,#0]
;;;215        /* store the imag result in 3.29 format in the destination buffer. */
;;;216        *pDst++ = out2;
00010a  6054              STR      r4,[r2,#4]
00010c  3208              ADDS     r2,r2,#8
;;;217    
;;;218        /* Decrement the blockSize loop counter */
;;;219        blkCnt--;
00010e  1e5b              SUBS     r3,r3,#1
                  |L1.272|
000110  2b00              CMP      r3,#0                 ;191
000112  d1e3              BNE      |L1.220|
;;;220      }
;;;221    
;;;222    #else
;;;223    
;;;224      /* Run the below code for Cortex-M0 */
;;;225    
;;;226      /* loop Unrolling */
;;;227      blkCnt = numSamples >> 1u;
;;;228    
;;;229      /* First part of the processing with loop unrolling.  Compute 2 outputs at a time.     
;;;230       ** a second loop below computes the remaining 1 sample. */
;;;231      while(blkCnt > 0u)
;;;232      {
;;;233        /* C[2 * i] = A[2 * i] * B[2 * i] - A[2 * i + 1] * B[2 * i + 1].  */
;;;234        /* C[2 * i + 1] = A[2 * i] * B[2 * i + 1] + A[2 * i + 1] * B[2 * i].  */
;;;235        a = *pSrcA++;
;;;236        b = *pSrcA++;
;;;237        c = *pSrcB++;
;;;238        d = *pSrcB++;
;;;239    
;;;240        mul1 = (q31_t) (((q63_t) a * c) >> 32);
;;;241        mul2 = (q31_t) (((q63_t) b * d) >> 32);
;;;242        mul3 = (q31_t) (((q63_t) a * d) >> 32);
;;;243        mul4 = (q31_t) (((q63_t) b * c) >> 32);
;;;244    
;;;245        mul1 = (mul1 >> 1);
;;;246        mul2 = (mul2 >> 1);
;;;247        mul3 = (mul3 >> 1);
;;;248        mul4 = (mul4 >> 1);
;;;249    
;;;250        out1 = mul1 - mul2;
;;;251        out2 = mul3 + mul4;
;;;252    
;;;253        /* store the real result in 3.29 format in the destination buffer. */
;;;254        *pDst++ = out1;
;;;255        /* store the imag result in 3.29 format in the destination buffer. */
;;;256        *pDst++ = out2;
;;;257    
;;;258        a = *pSrcA++;
;;;259        b = *pSrcA++;
;;;260        c = *pSrcB++;
;;;261        d = *pSrcB++;
;;;262    
;;;263        mul1 = (q31_t) (((q63_t) a * c) >> 32);
;;;264        mul2 = (q31_t) (((q63_t) b * d) >> 32);
;;;265        mul3 = (q31_t) (((q63_t) a * d) >> 32);
;;;266        mul4 = (q31_t) (((q63_t) b * c) >> 32);
;;;267    
;;;268        mul1 = (mul1 >> 1);
;;;269        mul2 = (mul2 >> 1);
;;;270        mul3 = (mul3 >> 1);
;;;271        mul4 = (mul4 >> 1);
;;;272    
;;;273        out1 = mul1 - mul2;
;;;274        out2 = mul3 + mul4;
;;;275    
;;;276        /* store the real result in 3.29 format in the destination buffer. */
;;;277        *pDst++ = out1;
;;;278        /* store the imag result in 3.29 format in the destination buffer. */
;;;279        *pDst++ = out2;
;;;280    
;;;281        /* Decrement the blockSize loop counter */
;;;282        blkCnt--;
;;;283      }
;;;284    
;;;285      /* If the blockSize is not a multiple of 2, compute any remaining output samples here.     
;;;286       ** No loop unrolling is used. */
;;;287      blkCnt = numSamples % 0x2u;
;;;288    
;;;289      while(blkCnt > 0u)
;;;290      {
;;;291        /* C[2 * i] = A[2 * i] * B[2 * i] - A[2 * i + 1] * B[2 * i + 1].  */
;;;292        /* C[2 * i + 1] = A[2 * i] * B[2 * i + 1] + A[2 * i + 1] * B[2 * i].  */
;;;293        a = *pSrcA++;
;;;294        b = *pSrcA++;
;;;295        c = *pSrcB++;
;;;296        d = *pSrcB++;
;;;297    
;;;298        mul1 = (q31_t) (((q63_t) a * c) >> 32);
;;;299        mul2 = (q31_t) (((q63_t) b * d) >> 32);
;;;300        mul3 = (q31_t) (((q63_t) a * d) >> 32);
;;;301        mul4 = (q31_t) (((q63_t) b * c) >> 32);
;;;302    
;;;303        mul1 = (mul1 >> 1);
;;;304        mul2 = (mul2 >> 1);
;;;305        mul3 = (mul3 >> 1);
;;;306        mul4 = (mul4 >> 1);
;;;307    
;;;308        out1 = mul1 - mul2;
;;;309        out2 = mul3 + mul4;
;;;310    
;;;311        /* store the real result in 3.29 format in the destination buffer. */
;;;312        *pDst++ = out1;
;;;313        /* store the imag result in 3.29 format in the destination buffer. */
;;;314        *pDst++ = out2;
;;;315    
;;;316        /* Decrement the blockSize loop counter */
;;;317        blkCnt--;
;;;318      }
;;;319    
;;;320    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;321    
;;;322    }
000114  e8bd83f0          POP      {r4-r9,pc}
;;;323    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\ComplexMathFunctions\\arm_cmplx_mult_cmplx_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___26_arm_cmplx_mult_cmplx_q31_c_77816546____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___26_arm_cmplx_mult_cmplx_q31_c_77816546____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___26_arm_cmplx_mult_cmplx_q31_c_77816546____REVSH|
#line 144
|__asm___26_arm_cmplx_mult_cmplx_q31_c_77816546____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___26_arm_cmplx_mult_cmplx_q31_c_77816546____RRX|
#line 300
|__asm___26_arm_cmplx_mult_cmplx_q31_c_77816546____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
