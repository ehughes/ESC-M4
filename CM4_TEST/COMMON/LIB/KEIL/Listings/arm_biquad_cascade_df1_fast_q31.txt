; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_biquad_cascade_df1_fast_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_biquad_cascade_df1_fast_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_biquad_cascade_df1_fast_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_biquad_cascade_df1_fast_q31.c]
                          THUMB

                          AREA ||i.arm_biquad_cascade_df1_fast_q31||, CODE, READONLY, ALIGN=1

                  arm_biquad_cascade_df1_fast_q31 PROC
;;;76     
;;;77     void arm_biquad_cascade_df1_fast_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;78       const arm_biquad_casd_df1_inst_q31 * S,
;;;79       q31_t * pSrc,
;;;80       q31_t * pDst,
;;;81       uint32_t blockSize)
;;;82     {
000004  b085              SUB      sp,sp,#0x14
;;;83       q31_t acc = 0;                                 /*  accumulator                   */
;;;84       q31_t Xn1, Xn2, Yn1, Yn2;                      /*  Filter state variables        */
;;;85       q31_t b0, b1, b2, a1, a2;                      /*  Filter coefficients           */
;;;86       q31_t *pIn = pSrc;                             /*  input pointer initialization  */
;;;87       q31_t *pOut = pDst;                            /*  output pointer initialization */
000006  9a07              LDR      r2,[sp,#0x1c]
;;;88       q31_t *pState = S->pState;                     /*  pState pointer initialization */
000008  6843              LDR      r3,[r0,#4]
00000a  9303              STR      r3,[sp,#0xc]
;;;89       q31_t *pCoeffs = S->pCoeffs;                   /*  coeff pointer initialization  */
00000c  6883              LDR      r3,[r0,#8]
00000e  9302              STR      r3,[sp,#8]
;;;90       q31_t Xn;                                      /*  temporary input               */
;;;91       int32_t shift = (int32_t) S->postShift + 1;    /*  Shift to be applied to the output */
000010  f890a00c          LDRB     r10,[r0,#0xc]
000014  f10a0a01          ADD      r10,r10,#1
;;;92       uint32_t sample, stage = S->numStages;         /*  loop counters                     */
000018  6800              LDR      r0,[r0,#0]
00001a  9000              STR      r0,[sp,#0]
;;;93     
;;;94     
;;;95       do
;;;96       {
;;;97         /* Reading the coefficients */
;;;98         b0 = *pCoeffs++;
;;;99         b1 = *pCoeffs++;
;;;100        b2 = *pCoeffs++;
;;;101        a1 = *pCoeffs++;
;;;102        a2 = *pCoeffs++;
;;;103    
;;;104        /* Reading the state values */
;;;105        Xn1 = pState[0];
;;;106        Xn2 = pState[1];
;;;107        Yn1 = pState[2];
;;;108        Yn2 = pState[3];
;;;109    
;;;110        /* Apply loop unrolling and compute 4 output values simultaneously. */
;;;111        /*      The variables acc ... acc3 hold output values that are being computed:       
;;;112         *       
;;;113         *    acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2]       
;;;114         */
;;;115    
;;;116        sample = blockSize >> 2u;
00001c  9808              LDR      r0,[sp,#0x20]
00001e  0880              LSRS     r0,r0,#2
000020  9004              STR      r0,[sp,#0x10]
                  |L1.34|
000022  9802              LDR      r0,[sp,#8]            ;98
000024  6805              LDR      r5,[r0,#0]            ;98
000026  6846              LDR      r6,[r0,#4]            ;99
000028  6887              LDR      r7,[r0,#8]            ;100
00002a  300c              ADDS     r0,r0,#0xc            ;100
00002c  f850cb04          LDR      r12,[r0],#4           ;101
000030  f8508b04          LDR      r8,[r0],#4            ;102
000034  9002              STR      r0,[sp,#8]            ;102
000036  9803              LDR      r0,[sp,#0xc]          ;105
000038  6803              LDR      r3,[r0,#0]            ;105
00003a  9803              LDR      r0,[sp,#0xc]          ;106
00003c  f8d09004          LDR      r9,[r0,#4]            ;106
000040  9803              LDR      r0,[sp,#0xc]          ;107
000042  6880              LDR      r0,[r0,#8]            ;107
000044  9c03              LDR      r4,[sp,#0xc]          ;108
000046  68e4              LDR      r4,[r4,#0xc]          ;108
000048  f8ddb010          LDR      r11,[sp,#0x10]
00004c  f8cdb004          STR      r11,[sp,#4]
;;;117    
;;;118        /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.       
;;;119         ** a second loop below computes the remaining 1 to 3 samples. */
;;;120        while(sample > 0u)
000050  e044              B        |L1.220|
                  |L1.82|
;;;121        {
;;;122          /* Read the input */
;;;123          Xn = *pIn;
000052  f8d1e000          LDR      lr,[r1,#0]
;;;124    
;;;125          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;126          /* acc =  b0 * x[n] */
;;;127          /*acc = (q31_t) (((q63_t) b1 * Xn1) >> 32);*/
;;;128          mult_32x32_keep32_R(acc, b1, Xn1);
000056  fb56fb13          SMMULR   r11,r6,r3
;;;129          /* acc +=  b1 * x[n-1] */
;;;130          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) b0 * (Xn))) >> 32);*/
;;;131          multAcc_32x32_keep32_R(acc, b0, Xn);
00005a  fb55bb1e          SMMLAR   r11,r5,lr,r11
;;;132          /* acc +=  b[2] * x[n-2] */
;;;133          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) b2 * (Xn2))) >> 32);*/
;;;134          multAcc_32x32_keep32_R(acc, b2, Xn2);
00005e  fb57b919          SMMLAR   r9,r7,r9,r11
;;;135          /* acc +=  a1 * y[n-1] */
;;;136          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) a1 * (Yn1))) >> 32);*/
;;;137          multAcc_32x32_keep32_R(acc, a1, Yn1);
000062  fb5c9910          SMMLAR   r9,r12,r0,r9
;;;138          /* acc +=  a2 * y[n-2] */
;;;139          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) a2 * (Yn2))) >> 32);*/
;;;140          multAcc_32x32_keep32_R(acc, a2, Yn2);
000066  fb589414          SMMLAR   r4,r8,r4,r9
;;;141    
;;;142          /* The result is converted to 1.31 , Yn2 variable is reused */
;;;143          Yn2 = acc << shift;
00006a  fa04f40a          LSL      r4,r4,r10
;;;144    
;;;145          /* Read the second input */
;;;146          Xn2 = *(pIn + 1u);
00006e  f8d1b004          LDR      r11,[r1,#4]
;;;147    
;;;148          /* Store the output in the destination buffer. */
;;;149          *pOut = Yn2;
000072  6014              STR      r4,[r2,#0]
;;;150    
;;;151          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;152          /* acc =  b0 * x[n] */
;;;153          /*acc = (q31_t) (((q63_t) b0 * (Xn2)) >> 32);*/
;;;154          mult_32x32_keep32_R(acc, b0, Xn2);
000074  fb55f91b          SMMULR   r9,r5,r11
;;;155          /* acc +=  b1 * x[n-1] */
;;;156          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) b1 * (Xn))) >> 32);*/
;;;157          multAcc_32x32_keep32_R(acc, b1, Xn);
000078  fb56991e          SMMLAR   r9,r6,lr,r9
;;;158          /* acc +=  b[2] * x[n-2] */
;;;159          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) b2 * (Xn1))) >> 32);*/
;;;160          multAcc_32x32_keep32_R(acc, b2, Xn1);
00007c  fb579313          SMMLAR   r3,r7,r3,r9
;;;161          /* acc +=  a1 * y[n-1] */
;;;162          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) a1 * (Yn2))) >> 32);*/
;;;163          multAcc_32x32_keep32_R(acc, a1, Yn2);
000080  fb5c3314          SMMLAR   r3,r12,r4,r3
;;;164          /* acc +=  a2 * y[n-2] */
;;;165          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) a2 * (Yn1))) >> 32);*/
;;;166          multAcc_32x32_keep32_R(acc, a2, Yn1);
000084  fb583010          SMMLAR   r0,r8,r0,r3
;;;167    
;;;168          /* The result is converted to 1.31, Yn1 variable is reused  */
;;;169          Yn1 = acc << shift;
000088  fa00f00a          LSL      r0,r0,r10
;;;170    
;;;171          /* Read the third input  */
;;;172          Xn1 = *(pIn + 2u);
00008c  f8d19008          LDR      r9,[r1,#8]
;;;173    
;;;174          /* Store the output in the destination buffer. */
;;;175          *(pOut + 1u) = Yn1;
000090  6050              STR      r0,[r2,#4]
;;;176    
;;;177          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;178          /* acc =  b0 * x[n] */
;;;179          /*acc = (q31_t) (((q63_t) b0 * (Xn1)) >> 32);*/
;;;180          mult_32x32_keep32_R(acc, b0, Xn1);
000092  fb55f319          SMMULR   r3,r5,r9
;;;181          /* acc +=  b1 * x[n-1] */
;;;182          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) b1 * (Xn2))) >> 32);*/
;;;183          multAcc_32x32_keep32_R(acc, b1, Xn2);
000096  fb56331b          SMMLAR   r3,r6,r11,r3
;;;184          /* acc +=  b[2] * x[n-2] */
;;;185          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) b2 * (Xn))) >> 32);*/
;;;186          multAcc_32x32_keep32_R(acc, b2, Xn);
00009a  fb57331e          SMMLAR   r3,r7,lr,r3
;;;187          /* acc +=  a1 * y[n-1] */
;;;188          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) a1 * (Yn1))) >> 32);*/
;;;189          multAcc_32x32_keep32_R(acc, a1, Yn1);
00009e  fb5c3310          SMMLAR   r3,r12,r0,r3
;;;190          /* acc +=  a2 * y[n-2] */
;;;191          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) a2 * (Yn2))) >> 32);*/
;;;192          multAcc_32x32_keep32_R(acc, a2, Yn2);
0000a2  fb583414          SMMLAR   r4,r8,r4,r3
;;;193    
;;;194          /* The result is converted to 1.31, Yn2 variable is reused  */
;;;195          Yn2 = acc << shift;
0000a6  fa04f40a          LSL      r4,r4,r10
;;;196    
;;;197          /* Read the forth input */
;;;198          Xn = *(pIn + 3u);
0000aa  f8d1e00c          LDR      lr,[r1,#0xc]
;;;199    
;;;200          /* Store the output in the destination buffer. */
;;;201          *(pOut + 2u) = Yn2;
0000ae  6094              STR      r4,[r2,#8]
;;;202          pIn += 4u;
0000b0  3110              ADDS     r1,r1,#0x10
;;;203    
;;;204          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;205          /* acc =  b0 * x[n] */
;;;206          /*acc = (q31_t) (((q63_t) b0 * (Xn)) >> 32);*/
;;;207          mult_32x32_keep32_R(acc, b0, Xn);
0000b2  fb55f31e          SMMULR   r3,r5,lr
;;;208          /* acc +=  b1 * x[n-1] */
;;;209          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) b1 * (Xn1))) >> 32);*/
;;;210          multAcc_32x32_keep32_R(acc, b1, Xn1);
0000b6  fb563319          SMMLAR   r3,r6,r9,r3
;;;211          /* acc +=  b[2] * x[n-2] */
;;;212          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) b2 * (Xn2))) >> 32);*/
;;;213          multAcc_32x32_keep32_R(acc, b2, Xn2);
0000ba  fb57331b          SMMLAR   r3,r7,r11,r3
;;;214          /* acc +=  a1 * y[n-1] */
;;;215          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) a1 * (Yn2))) >> 32);*/
;;;216          multAcc_32x32_keep32_R(acc, a1, Yn2);
0000be  fb5c3314          SMMLAR   r3,r12,r4,r3
;;;217          /* acc +=  a2 * y[n-2] */
;;;218          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) a2 * (Yn1))) >> 32);*/
;;;219          multAcc_32x32_keep32_R(acc, a2, Yn1);
0000c2  fb583010          SMMLAR   r0,r8,r0,r3
;;;220    
;;;221          /* Every time after the output is computed state should be updated. */
;;;222          /* The states should be updated as:  */
;;;223          /* Xn2 = Xn1    */
;;;224          Xn2 = Xn1;
;;;225    
;;;226          /* The result is converted to 1.31, Yn1 variable is reused  */
;;;227          Yn1 = acc << shift;
0000c6  fa00f00a          LSL      r0,r0,r10
;;;228    
;;;229          /* Xn1 = Xn     */
;;;230          Xn1 = Xn;
0000ca  4673              MOV      r3,lr
;;;231    
;;;232          /* Store the output in the destination buffer. */
;;;233          *(pOut + 3u) = Yn1;
0000cc  60d0              STR      r0,[r2,#0xc]
;;;234          pOut += 4u;
0000ce  3210              ADDS     r2,r2,#0x10
;;;235    
;;;236          /* decrement the loop counter */
;;;237          sample--;
0000d0  f8ddb004          LDR      r11,[sp,#4]
0000d4  f1ab0b01          SUB      r11,r11,#1
0000d8  f8cdb004          STR      r11,[sp,#4]
                  |L1.220|
0000dc  f8ddb004          LDR      r11,[sp,#4]           ;120
0000e0  f1bb0f00          CMP      r11,#0                ;120
0000e4  d1b5              BNE      |L1.82|
;;;238        }
;;;239    
;;;240        /* If the blockSize is not a multiple of 4, compute any remaining output samples here.       
;;;241         ** No loop unrolling is used. */
;;;242        sample = (blockSize & 0x3u);
0000e6  f8ddb020          LDR      r11,[sp,#0x20]
0000ea  f00b0b03          AND      r11,r11,#3
0000ee  f8cdb004          STR      r11,[sp,#4]
;;;243    
;;;244       while(sample > 0u)
0000f2  e019              B        |L1.296|
                  |L1.244|
;;;245       {
;;;246          /* Read the input */
;;;247          Xn = *pIn++;
0000f4  f851eb04          LDR      lr,[r1],#4
;;;248    
;;;249          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;250          /* acc =  b0 * x[n] */
;;;251          /*acc = (q31_t) (((q63_t) b0 * (Xn)) >> 32);*/
;;;252          mult_32x32_keep32_R(acc, b0, Xn);
0000f8  fb55fb1e          SMMULR   r11,r5,lr
;;;253          /* acc +=  b1 * x[n-1] */
;;;254          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) b1 * (Xn1))) >> 32);*/
;;;255          multAcc_32x32_keep32_R(acc, b1, Xn1);
0000fc  fb56bb13          SMMLAR   r11,r6,r3,r11
;;;256          /* acc +=  b[2] * x[n-2] */
;;;257          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) b2 * (Xn2))) >> 32);*/
;;;258          multAcc_32x32_keep32_R(acc, b2, Xn2);
000100  fb57b919          SMMLAR   r9,r7,r9,r11
;;;259          /* acc +=  a1 * y[n-1] */
;;;260          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) a1 * (Yn1))) >> 32);*/
;;;261          multAcc_32x32_keep32_R(acc, a1, Yn1);
000104  fb5c9910          SMMLAR   r9,r12,r0,r9
;;;262          /* acc +=  a2 * y[n-2] */
;;;263          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) a2 * (Yn2))) >> 32);*/
;;;264          multAcc_32x32_keep32_R(acc, a2, Yn2);
000108  fb589b14          SMMLAR   r11,r8,r4,r9
;;;265    
;;;266          /* The result is converted to 1.31  */
;;;267          acc = acc << shift;
00010c  fa0bfb0a          LSL      r11,r11,r10
;;;268    
;;;269          /* Every time after the output is computed state should be updated. */
;;;270          /* The states should be updated as:  */
;;;271          /* Xn2 = Xn1    */
;;;272          /* Xn1 = Xn     */
;;;273          /* Yn2 = Yn1    */
;;;274          /* Yn1 = acc    */
;;;275          Xn2 = Xn1;
000110  4699              MOV      r9,r3
;;;276          Xn1 = Xn;
000112  4673              MOV      r3,lr
;;;277          Yn2 = Yn1;
000114  4604              MOV      r4,r0
;;;278          Yn1 = acc;
000116  4658              MOV      r0,r11
;;;279    
;;;280          /* Store the output in the destination buffer. */
;;;281          *pOut++ = acc;
000118  f842bb04          STR      r11,[r2],#4
;;;282    
;;;283          /* decrement the loop counter */
;;;284          sample--;
00011c  f8ddb004          LDR      r11,[sp,#4]
000120  f1ab0b01          SUB      r11,r11,#1
000124  f8cdb004          STR      r11,[sp,#4]
                  |L1.296|
000128  f8ddb004          LDR      r11,[sp,#4]           ;244
00012c  f1bb0f00          CMP      r11,#0                ;244
000130  d1e0              BNE      |L1.244|
;;;285       }
;;;286    
;;;287        /*  The first stage goes from the input buffer to the output buffer. */
;;;288        /*  Subsequent stages occur in-place in the output buffer */
;;;289        pIn = pDst;
;;;290    
;;;291        /* Reset to destination pointer */
;;;292        pOut = pDst;
000132  9907              LDR      r1,[sp,#0x1c]
000134  460a              MOV      r2,r1
;;;293    
;;;294        /*  Store the updated state variables back into the pState array */
;;;295        *pState++ = Xn1;
000136  9d03              LDR      r5,[sp,#0xc]
000138  602b              STR      r3,[r5,#0]
00013a  9b03              LDR      r3,[sp,#0xc]
;;;296        *pState++ = Xn2;
00013c  f8c39004          STR      r9,[r3,#4]
;;;297        *pState++ = Yn1;
000140  6098              STR      r0,[r3,#8]
;;;298        *pState++ = Yn2;
000142  60dc              STR      r4,[r3,#0xc]
000144  3310              ADDS     r3,r3,#0x10
000146  9303              STR      r3,[sp,#0xc]
;;;299    
;;;300      } while(--stage);
000148  9800              LDR      r0,[sp,#0]
00014a  1e40              SUBS     r0,r0,#1
00014c  9000              STR      r0,[sp,#0]
00014e  f47faf68          BNE      |L1.34|
;;;301    }
000152  b009              ADD      sp,sp,#0x24
000154  e8bd8ff0          POP      {r4-r11,pc}
;;;302    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_biquad_cascade_df1_fast_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___33_arm_biquad_cascade_df1_fast_q31_c_0fbfa3c1____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___33_arm_biquad_cascade_df1_fast_q31_c_0fbfa3c1____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___33_arm_biquad_cascade_df1_fast_q31_c_0fbfa3c1____REVSH|
#line 144
|__asm___33_arm_biquad_cascade_df1_fast_q31_c_0fbfa3c1____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___33_arm_biquad_cascade_df1_fast_q31_c_0fbfa3c1____RRX|
#line 300
|__asm___33_arm_biquad_cascade_df1_fast_q31_c_0fbfa3c1____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
