; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_mult_fast_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_mult_fast_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_mat_mult_fast_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\MatrixFunctions\arm_mat_mult_fast_q15.c]
                          THUMB

                          AREA ||i.arm_mat_mult_fast_q15||, CODE, READONLY, ALIGN=1

                  arm_mat_mult_fast_q15 PROC
;;;84     
;;;85     arm_status arm_mat_mult_fast_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;86       const arm_matrix_instance_q15 * pSrcA,
;;;87       const arm_matrix_instance_q15 * pSrcB,
;;;88       arm_matrix_instance_q15 * pDst,
;;;89       q15_t * pState)
;;;90     {
000004  b082              SUB      sp,sp,#8
;;;91       q31_t sum;                                     /* accumulator */
;;;92       q15_t *pSrcBT = pState;                        /* input data matrix pointer for transpose */
000006  9300              STR      r3,[sp,#0]
;;;93       q15_t *pInA = pSrcA->pData;                    /* input data matrix pointer A of Q15 type */
;;;94       q15_t *pInB = pSrcB->pData;                    /* input data matrix pointer B of Q15 type */
000008  684b              LDR      r3,[r1,#4]
;;;95       q15_t *px;                                     /* Temporary output data matrix pointer */
;;;96       uint16_t numRowsA = pSrcA->numRows;            /* number of rows of input matrix A    */
00000a  9802              LDR      r0,[sp,#8]
00000c  f8b08000          LDRH     r8,[r0,#0]
;;;97       uint16_t numColsB = pSrcB->numCols;            /* number of columns of input matrix B */
000010  f8b1a002          LDRH     r10,[r1,#2]
;;;98       uint16_t numColsA = pSrcA->numCols;            /* number of columns of input matrix A */
000014  9802              LDR      r0,[sp,#8]
000016  f8b09002          LDRH     r9,[r0,#2]
;;;99       uint16_t numRowsB = pSrcB->numRows;            /* number of rows of input matrix A    */
00001a  8809              LDRH     r1,[r1,#0]
;;;100      uint16_t col, i = 0u, row = numRowsB, colCnt;  /* loop counters */
00001c  2700              MOVS     r7,#0
00001e  460e              MOV      r6,r1
;;;101      arm_status status;                             /* status of matrix multiplication */
;;;102    
;;;103    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;104    
;;;105      q31_t in;                                      /* Temporary variable to hold the input value */
;;;106      q31_t inA1, inA2, inB1, inB2;
;;;107    
;;;108    #else
;;;109    
;;;110      q15_t in;                                      /* Temporary variable to hold the input value */
;;;111      q15_t inA1, inA2, inB1, inB2;
;;;112    
;;;113    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;114    
;;;115    #ifdef ARM_MATH_MATRIX_CHECK
;;;116      /* Check for matrix mismatch condition */
;;;117      if((pSrcA->numCols != pSrcB->numRows) ||
;;;118         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;119      {
;;;120        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;121        status = ARM_MATH_SIZE_MISMATCH;
;;;122      }
;;;123      else
;;;124    #endif
;;;125      {
;;;126        /* Matrix transpose */
;;;127        do
;;;128        {
;;;129          /* Apply loop unrolling and exchange the columns with row elements */
;;;130          col = numColsB >> 2;
000020  ea4f0c9a          LSR      r12,r10,#2
                  |L1.36|
000024  4664              MOV      r4,r12
;;;131    
;;;132          /* The pointer px is set to starting address of the column being processed */
;;;133          px = pSrcBT + i;
000026  9800              LDR      r0,[sp,#0]
000028  eb000047          ADD      r0,r0,r7,LSL #1
;;;134    
;;;135          /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.        
;;;136           ** a second loop below computes the remaining 1 to 3 samples. */
;;;137          while(col > 0u)
00002c  e012              B        |L1.84|
                  |L1.46|
;;;138          {
;;;139    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;140            /* Read two elements from the row */
;;;141            in = *__SIMD32(pInB)++;
00002e  681d              LDR      r5,[r3,#0]
;;;142    
;;;143            /* Unpack and store one element in the destination */
;;;144    #ifndef ARM_MATH_BIG_ENDIAN
;;;145    
;;;146            *px = (q15_t) in;
000030  8005              STRH     r5,[r0,#0]
;;;147    
;;;148    #else
;;;149    
;;;150            *px = (q15_t) ((in & (q31_t) 0xffff0000) >> 16);
;;;151    
;;;152    #endif /*    #ifndef ARM_MATH_BIG_ENDIAN    */
;;;153    
;;;154            /* Update the pointer px to point to the next row of the transposed matrix */
;;;155            px += numRowsB;
000032  eb000041          ADD      r0,r0,r1,LSL #1
;;;156    
;;;157            /* Unpack and store the second element in the destination */
;;;158    #ifndef ARM_MATH_BIG_ENDIAN
;;;159    
;;;160            *px = (q15_t) ((in & (q31_t) 0xffff0000) >> 16);
000036  142d              ASRS     r5,r5,#16
000038  8005              STRH     r5,[r0,#0]
;;;161    
;;;162    #else
;;;163    
;;;164            *px = (q15_t) in;
;;;165    
;;;166    #endif /*    #ifndef ARM_MATH_BIG_ENDIAN    */
;;;167    
;;;168            /* Update the pointer px to point to the next row of the transposed matrix */
;;;169            px += numRowsB;
00003a  eb000541          ADD      r5,r0,r1,LSL #1
;;;170    
;;;171            /* Read two elements from the row */
;;;172            in = *__SIMD32(pInB)++;
00003e  6858              LDR      r0,[r3,#4]
000040  3308              ADDS     r3,r3,#8
;;;173    
;;;174            /* Unpack and store one element in the destination */
;;;175    #ifndef ARM_MATH_BIG_ENDIAN
;;;176    
;;;177            *px = (q15_t) in;
000042  8028              STRH     r0,[r5,#0]
;;;178    
;;;179    #else
;;;180    
;;;181            *px = (q15_t) ((in & (q31_t) 0xffff0000) >> 16);
;;;182    
;;;183    #endif /*    #ifndef ARM_MATH_BIG_ENDIAN    */
;;;184    
;;;185            /* Update the pointer px to point to the next row of the transposed matrix */
;;;186            px += numRowsB;
000044  eb050541          ADD      r5,r5,r1,LSL #1
;;;187    
;;;188            /* Unpack and store the second element in the destination */
;;;189    
;;;190    #ifndef ARM_MATH_BIG_ENDIAN
;;;191    
;;;192            *px = (q15_t) ((in & (q31_t) 0xffff0000) >> 16);
000048  1400              ASRS     r0,r0,#16
00004a  8028              STRH     r0,[r5,#0]
;;;193    
;;;194    #else
;;;195    
;;;196            *px = (q15_t) in;
;;;197    
;;;198    #endif /*    #ifndef ARM_MATH_BIG_ENDIAN    */
;;;199    
;;;200    #else
;;;201    
;;;202            /* Read one element from the row */
;;;203            in = *pInB++;
;;;204    
;;;205            /* Store one element in the destination */
;;;206            *px = in;
;;;207     
;;;208            /* Update the pointer px to point to the next row of the transposed matrix */
;;;209            px += numRowsB;
;;;210    
;;;211            /* Read one element from the row */
;;;212            in = *pInB++;
;;;213    
;;;214            /* Store one element in the destination */
;;;215            *px = in;
;;;216     
;;;217            /* Update the pointer px to point to the next row of the transposed matrix */
;;;218            px += numRowsB;
;;;219    
;;;220            /* Read one element from the row */
;;;221            in = *pInB++;
;;;222    
;;;223            /* Store one element in the destination */
;;;224            *px = in;
;;;225     
;;;226            /* Update the pointer px to point to the next row of the transposed matrix */
;;;227            px += numRowsB;
;;;228    
;;;229            /* Read one element from the row */
;;;230            in = *pInB++;
;;;231    
;;;232            /* Store one element in the destination */
;;;233            *px = in;
;;;234    
;;;235    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;236            
;;;237    		/* Update the pointer px to point to the next row of the transposed matrix */
;;;238            px += numRowsB;
00004c  eb050041          ADD      r0,r5,r1,LSL #1
;;;239    
;;;240            /* Decrement the column loop counter */
;;;241            col--;
000050  1e64              SUBS     r4,r4,#1
000052  b2a4              UXTH     r4,r4
                  |L1.84|
000054  2c00              CMP      r4,#0                 ;137
000056  d1ea              BNE      |L1.46|
;;;242          }
;;;243    
;;;244          /* If the columns of pSrcB is not a multiple of 4, compute any remaining output samples here.        
;;;245           ** No loop unrolling is used. */
;;;246          col = numColsB % 0x4u;
000058  f00a0503          AND      r5,r10,#3
;;;247    
;;;248          while(col > 0u)
00005c  e006              B        |L1.108|
                  |L1.94|
;;;249          {
;;;250            /* Read and store the input element in the destination */
;;;251            *px = *pInB++;
00005e  f8334b02          LDRH     r4,[r3],#2
000062  8004              STRH     r4,[r0,#0]
;;;252    
;;;253            /* Update the pointer px to point to the next row of the transposed matrix */
;;;254            px += numRowsB;
000064  eb000041          ADD      r0,r0,r1,LSL #1
;;;255    
;;;256            /* Decrement the column loop counter */
;;;257            col--;
000068  1e6d              SUBS     r5,r5,#1
00006a  b2ad              UXTH     r5,r5
                  |L1.108|
00006c  2d00              CMP      r5,#0                 ;248
00006e  d1f6              BNE      |L1.94|
;;;258          }
;;;259    
;;;260          i++;
000070  1c7f              ADDS     r7,r7,#1
000072  b2bf              UXTH     r7,r7
;;;261    
;;;262          /* Decrement the row loop counter */
;;;263          row--;
000074  1e76              SUBS     r6,r6,#1
000076  b2b6              UXTH     r6,r6
;;;264    
;;;265        } while(row > 0u);
000078  2e00              CMP      r6,#0
00007a  d1d3              BNE      |L1.36|
;;;266    
;;;267        /* Reset the variables for the usage in the following multiplication process */
;;;268        row = numRowsA;
;;;269        i = 0u;
;;;270        px = pDst->pData;
00007c  6855              LDR      r5,[r2,#4]
;;;271    
;;;272        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;273        /* row loop */
;;;274        do
;;;275        {
;;;276          /* For every row wise process, the column loop counter is to be initiated */
;;;277          col = numColsB;
;;;278    
;;;279          /* For every row wise process, the pIn2 pointer is set        
;;;280           ** to the starting address of the transposed pSrcB data */
;;;281          pInB = pSrcBT;
;;;282    
;;;283          /* column loop */
;;;284          do
;;;285          {
;;;286            /* Set the variable sum, that acts as accumulator, to zero */
;;;287            sum = 0;
;;;288    
;;;289            /* Apply loop unrolling and compute 2 MACs simultaneously. */
;;;290            colCnt = numColsA >> 2;
00007e  ea4f0099          LSR      r0,r9,#2
000082  9001              STR      r0,[sp,#4]
                  |L1.132|
000084  4654              MOV      r4,r10                ;277
000086  9900              LDR      r1,[sp,#0]            ;281
                  |L1.136|
000088  2200              MOVS     r2,#0                 ;287
00008a  9b01              LDR      r3,[sp,#4]
;;;291    
;;;292            /* Initiate the pointer pIn1 to point to the starting address of the column being processed */
;;;293            pInA = pSrcA->pData + i;
00008c  9802              LDR      r0,[sp,#8]
00008e  6840              LDR      r0,[r0,#4]
000090  eb000046          ADD      r0,r0,r6,LSL #1
;;;294    
;;;295            /* matrix multiplication */
;;;296            while(colCnt > 0u)
000094  e00d              B        |L1.178|
                  |L1.150|
;;;297            {
;;;298              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;299    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;300    
;;;301              inA1 = *__SIMD32(pInA)++;
000096  f8507b04          LDR      r7,[r0],#4
;;;302              inB1 = *__SIMD32(pInB)++;
00009a  f851bb04          LDR      r11,[r1],#4
;;;303              inA2 = *__SIMD32(pInA)++;
00009e  f850cb04          LDR      r12,[r0],#4
;;;304              inB2 = *__SIMD32(pInB)++;
0000a2  f851eb04          LDR      lr,[r1],#4
;;;305    
;;;306              sum = __SMLAD(inA1, inB1, sum);
0000a6  fb27220b          SMLAD    r2,r7,r11,r2
;;;307              sum = __SMLAD(inA2, inB2, sum);
0000aa  fb2c220e          SMLAD    r2,r12,lr,r2
;;;308    
;;;309    #else
;;;310    
;;;311              inA1 = *pInA++;
;;;312              inB1 = *pInB++;
;;;313              inA2 = *pInA++;
;;;314              sum += inA1 * inB1;
;;;315              inB2 = *pInB++;
;;;316    
;;;317              inA1 = *pInA++;
;;;318              inB1 = *pInB++;
;;;319              sum += inA2 * inB2;
;;;320              inA2 = *pInA++;
;;;321              inB2 = *pInB++;
;;;322    
;;;323              sum += inA1 * inB1;
;;;324              sum += inA2 * inB2;
;;;325    
;;;326    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;327    
;;;328              /* Decrement the loop counter */
;;;329              colCnt--;
0000ae  1e5b              SUBS     r3,r3,#1
0000b0  b29b              UXTH     r3,r3
                  |L1.178|
0000b2  2b00              CMP      r3,#0                 ;296
0000b4  d1ef              BNE      |L1.150|
;;;330            }
;;;331    
;;;332            /* process odd column samples */
;;;333            colCnt = numColsA % 0x4u;
0000b6  f0090303          AND      r3,r9,#3
;;;334    
;;;335            while(colCnt > 0u)
0000ba  e007              B        |L1.204|
                  |L1.188|
;;;336            {
;;;337              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;338              sum += (q31_t) (*pInA++) * (*pInB++);
0000bc  f8307b02          LDRH     r7,[r0],#2
0000c0  f831cb02          LDRH     r12,[r1],#2
0000c4  fb17220c          SMLABB   r2,r7,r12,r2
;;;339    
;;;340              colCnt--;
0000c8  1e5b              SUBS     r3,r3,#1
0000ca  b29b              UXTH     r3,r3
                  |L1.204|
0000cc  2b00              CMP      r3,#0                 ;335
0000ce  d1f5              BNE      |L1.188|
;;;341            }
;;;342    
;;;343            /* Saturate and store the result in the destination buffer */
;;;344            *px = (q15_t) (sum >> 15);
0000d0  13d0              ASRS     r0,r2,#15
0000d2  f8250b02          STRH     r0,[r5],#2
;;;345            px++;
;;;346    
;;;347            /* Decrement the column loop counter */
;;;348            col--;
0000d6  1e64              SUBS     r4,r4,#1
0000d8  b2a4              UXTH     r4,r4
;;;349    
;;;350          } while(col > 0u);
0000da  2c00              CMP      r4,#0
0000dc  d1d4              BNE      |L1.136|
;;;351    
;;;352          i = i + numColsA;
0000de  eb060009          ADD      r0,r6,r9
0000e2  b286              UXTH     r6,r0
;;;353    
;;;354          /* Decrement the row loop counter */
;;;355          row--;
0000e4  f1a80801          SUB      r8,r8,#1
0000e8  fa1ff888          UXTH     r8,r8
;;;356    
;;;357        } while(row > 0u);
0000ec  f1b80f00          CMP      r8,#0
0000f0  d1c8              BNE      |L1.132|
;;;358    
;;;359        /* set status as ARM_MATH_SUCCESS */
;;;360        status = ARM_MATH_SUCCESS;
0000f2  2000              MOVS     r0,#0
;;;361      }
;;;362    
;;;363      /* Return to application */
;;;364      return (status);
;;;365    }
0000f4  b006              ADD      sp,sp,#0x18
0000f6  e8bd8ff0          POP      {r4-r11,pc}
;;;366    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\MatrixFunctions\\arm_mat_mult_fast_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_mat_mult_fast_q15_c_9c634344____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___23_arm_mat_mult_fast_q15_c_9c634344____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_mat_mult_fast_q15_c_9c634344____REVSH|
#line 144
|__asm___23_arm_mat_mult_fast_q15_c_9c634344____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_mat_mult_fast_q15_c_9c634344____RRX|
#line 300
|__asm___23_arm_mat_mult_fast_q15_c_9c634344____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
