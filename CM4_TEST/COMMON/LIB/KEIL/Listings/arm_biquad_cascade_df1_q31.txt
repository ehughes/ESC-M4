; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_biquad_cascade_df1_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_biquad_cascade_df1_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_biquad_cascade_df1_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_biquad_cascade_df1_q31.c]
                          THUMB

                          AREA ||i.arm_biquad_cascade_df1_q31||, CODE, READONLY, ALIGN=1

                  arm_biquad_cascade_df1_q31 PROC
;;;73     
;;;74     void arm_biquad_cascade_df1_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;75       const arm_biquad_casd_df1_inst_q31 * S,
;;;76       q31_t * pSrc,
;;;77       q31_t * pDst,
;;;78       uint32_t blockSize)
;;;79     {
000004  b089              SUB      sp,sp,#0x24
000006  460e              MOV      r6,r1
;;;80       q63_t acc;                                     /*  accumulator                   */
;;;81       uint32_t uShift = ((uint32_t) S->postShift + 1u);
000008  7b02              LDRB     r2,[r0,#0xc]
00000a  1c52              ADDS     r2,r2,#1
00000c  9207              STR      r2,[sp,#0x1c]
;;;82       uint32_t lShift = 32u - uShift;                /*  Shift to be applied to the output */
00000e  9a07              LDR      r2,[sp,#0x1c]
000010  f1c20220          RSB      r2,r2,#0x20
000014  9206              STR      r2,[sp,#0x18]
;;;83       q31_t *pIn = pSrc;                             /*  input pointer initialization  */
;;;84       q31_t *pOut = pDst;                            /*  output pointer initialization */
000016  9f0b              LDR      r7,[sp,#0x2c]
;;;85       q31_t *pState = S->pState;                     /*  pState pointer initialization */
000018  6841              LDR      r1,[r0,#4]
00001a  9105              STR      r1,[sp,#0x14]
;;;86       q31_t *pCoeffs = S->pCoeffs;                   /*  coeff pointer initialization  */
00001c  6881              LDR      r1,[r0,#8]
00001e  9104              STR      r1,[sp,#0x10]
;;;87       q31_t Xn1, Xn2, Yn1, Yn2;                      /*  Filter state variables        */
;;;88       q31_t b0, b1, b2, a1, a2;                      /*  Filter coefficients           */
;;;89       q31_t Xn;                                      /*  temporary input               */
;;;90       uint32_t sample, stage = S->numStages;         /*  loop counters                     */
000020  6800              LDR      r0,[r0,#0]
000022  9000              STR      r0,[sp,#0]
;;;91     
;;;92     
;;;93     #ifndef ARM_MATH_CM0_FAMILY_FAMILY
;;;94     
;;;95       q31_t acc_l, acc_h;                            /*  temporary output variables    */
;;;96     
;;;97       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;98     
;;;99       do
;;;100      {
;;;101        /* Reading the coefficients */
;;;102        b0 = *pCoeffs++;
;;;103        b1 = *pCoeffs++;
;;;104        b2 = *pCoeffs++;
;;;105        a1 = *pCoeffs++;
;;;106        a2 = *pCoeffs++;
;;;107    
;;;108        /* Reading the state values */
;;;109        Xn1 = pState[0];
;;;110        Xn2 = pState[1];
;;;111        Yn1 = pState[2];
;;;112        Yn2 = pState[3];
;;;113    
;;;114        /* Apply loop unrolling and compute 4 output values simultaneously. */
;;;115        /*      The variable acc hold output values that are being computed:    
;;;116         *    
;;;117         *    acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2]    
;;;118         */
;;;119    
;;;120        sample = blockSize >> 2u;
000024  980c              LDR      r0,[sp,#0x30]
000026  0880              LSRS     r0,r0,#2
000028  9008              STR      r0,[sp,#0x20]
                  |L1.42|
00002a  9804              LDR      r0,[sp,#0x10]         ;102
00002c  f8d08000          LDR      r8,[r0,#0]            ;102
000030  f8d09004          LDR      r9,[r0,#4]            ;103
000034  f8d0a008          LDR      r10,[r0,#8]           ;104
000038  f8d0b00c          LDR      r11,[r0,#0xc]         ;105
00003c  6901              LDR      r1,[r0,#0x10]         ;106
00003e  3014              ADDS     r0,r0,#0x14           ;106
000040  e9cd1003          STRD     r1,r0,[sp,#0xc]       ;106
000044  9805              LDR      r0,[sp,#0x14]         ;109
000046  6805              LDR      r5,[r0,#0]            ;109
000048  9805              LDR      r0,[sp,#0x14]         ;110
00004a  6843              LDR      r3,[r0,#4]            ;110
00004c  9805              LDR      r0,[sp,#0x14]         ;111
00004e  6884              LDR      r4,[r0,#8]            ;111
000050  9805              LDR      r0,[sp,#0x14]         ;112
000052  68c2              LDR      r2,[r0,#0xc]          ;112
000054  9808              LDR      r0,[sp,#0x20]
000056  9001              STR      r0,[sp,#4]
;;;121    
;;;122        /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;123         ** a second loop below computes the remaining 1 to 3 samples. */
;;;124        while(sample > 0u)
000058  e053              B        |L1.258|
                  |L1.90|
;;;125        {
;;;126          /* Read the input */
;;;127          Xn = *pIn++;
00005a  f8d6c000          LDR      r12,[r6,#0]
;;;128    
;;;129          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;130    
;;;131          /* acc =  b0 * x[n] */
;;;132          acc = (q63_t) b0 *Xn;
00005e  fb88010c          SMULL    r0,r1,r8,r12
;;;133          /* acc +=  b1 * x[n-1] */
;;;134          acc += (q63_t) b1 *Xn1;
000062  fbc90105          SMLAL    r0,r1,r9,r5
;;;135          /* acc +=  b[2] * x[n-2] */
;;;136          acc += (q63_t) b2 *Xn2;
000066  fbca0103          SMLAL    r0,r1,r10,r3
;;;137          /* acc +=  a1 * y[n-1] */
;;;138          acc += (q63_t) a1 *Yn1;
00006a  fbcb0104          SMLAL    r0,r1,r11,r4
;;;139          /* acc +=  a2 * y[n-2] */
;;;140          acc += (q63_t) a2 *Yn2;
00006e  9b03              LDR      r3,[sp,#0xc]
000070  fbc30102          SMLAL    r0,r1,r3,r2
;;;141    
;;;142          /* The result is converted to 1.31 , Yn2 variable is reused */
;;;143    
;;;144          /* Calc lower part of acc */
;;;145          acc_l = acc & 0xffffffff;
;;;146    
;;;147          /* Calc upper part of acc */
;;;148          acc_h = (acc >> 32) & 0xffffffff;
;;;149    
;;;150          /* Apply shift for lower part of acc and upper part of acc */
;;;151          Yn2 = (uint32_t) acc_l >> lShift | acc_h << uShift;
000074  9a06              LDR      r2,[sp,#0x18]
000076  40d0              LSRS     r0,r0,r2
000078  9a07              LDR      r2,[sp,#0x1c]
00007a  4091              LSLS     r1,r1,r2
00007c  ea400201          ORR      r2,r0,r1
;;;152    
;;;153          /* Store the output in the destination buffer. */
;;;154          *pOut++ = Yn2;
000080  603a              STR      r2,[r7,#0]
;;;155    
;;;156          /* Read the second input */
;;;157          Xn2 = *pIn++;
000082  f8d6e004          LDR      lr,[r6,#4]
;;;158    
;;;159          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;160    
;;;161          /* acc =  b0 * x[n] */
;;;162          acc = (q63_t) b0 *Xn2;
000086  fb88010e          SMULL    r0,r1,r8,lr
;;;163          /* acc +=  b1 * x[n-1] */
;;;164          acc += (q63_t) b1 *Xn;
00008a  fbc9010c          SMLAL    r0,r1,r9,r12
;;;165          /* acc +=  b[2] * x[n-2] */
;;;166          acc += (q63_t) b2 *Xn1;
00008e  fbca0105          SMLAL    r0,r1,r10,r5
;;;167          /* acc +=  a1 * y[n-1] */
;;;168          acc += (q63_t) a1 *Yn2;
000092  fbcb0102          SMLAL    r0,r1,r11,r2
;;;169          /* acc +=  a2 * y[n-2] */
;;;170          acc += (q63_t) a2 *Yn1;
000096  9b03              LDR      r3,[sp,#0xc]
000098  fbc30104          SMLAL    r0,r1,r3,r4
;;;171    
;;;172    
;;;173          /* The result is converted to 1.31, Yn1 variable is reused  */
;;;174    
;;;175          /* Calc lower part of acc */
;;;176          acc_l = acc & 0xffffffff;
;;;177    
;;;178          /* Calc upper part of acc */
;;;179          acc_h = (acc >> 32) & 0xffffffff;
;;;180    
;;;181    
;;;182          /* Apply shift for lower part of acc and upper part of acc */
;;;183          Yn1 = (uint32_t) acc_l >> lShift | acc_h << uShift;
00009c  9b06              LDR      r3,[sp,#0x18]
00009e  40d8              LSRS     r0,r0,r3
0000a0  9b07              LDR      r3,[sp,#0x1c]
0000a2  4099              LSLS     r1,r1,r3
0000a4  ea400401          ORR      r4,r0,r1
;;;184    
;;;185          /* Store the output in the destination buffer. */
;;;186          *pOut++ = Yn1;
0000a8  607c              STR      r4,[r7,#4]
;;;187    
;;;188          /* Read the third input  */
;;;189          Xn1 = *pIn++;
0000aa  68b3              LDR      r3,[r6,#8]
;;;190    
;;;191          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;192    
;;;193          /* acc =  b0 * x[n] */
;;;194          acc = (q63_t) b0 *Xn1;
0000ac  fb880103          SMULL    r0,r1,r8,r3
;;;195          /* acc +=  b1 * x[n-1] */
;;;196          acc += (q63_t) b1 *Xn2;
0000b0  fbc9010e          SMLAL    r0,r1,r9,lr
;;;197          /* acc +=  b[2] * x[n-2] */
;;;198          acc += (q63_t) b2 *Xn;
0000b4  fbca010c          SMLAL    r0,r1,r10,r12
;;;199          /* acc +=  a1 * y[n-1] */
;;;200          acc += (q63_t) a1 *Yn1;
0000b8  fbcb0104          SMLAL    r0,r1,r11,r4
;;;201          /* acc +=  a2 * y[n-2] */
;;;202          acc += (q63_t) a2 *Yn2;
0000bc  9d03              LDR      r5,[sp,#0xc]
0000be  fbc50102          SMLAL    r0,r1,r5,r2
;;;203    
;;;204          /* The result is converted to 1.31, Yn2 variable is reused  */
;;;205          /* Calc lower part of acc */
;;;206          acc_l = acc & 0xffffffff;
;;;207    
;;;208          /* Calc upper part of acc */
;;;209          acc_h = (acc >> 32) & 0xffffffff;
;;;210    
;;;211    
;;;212          /* Apply shift for lower part of acc and upper part of acc */
;;;213          Yn2 = (uint32_t) acc_l >> lShift | acc_h << uShift;
0000c2  9a06              LDR      r2,[sp,#0x18]
0000c4  40d0              LSRS     r0,r0,r2
0000c6  9a07              LDR      r2,[sp,#0x1c]
0000c8  4091              LSLS     r1,r1,r2
0000ca  ea400201          ORR      r2,r0,r1
;;;214    
;;;215          /* Store the output in the destination buffer. */
;;;216          *pOut++ = Yn2;
0000ce  60ba              STR      r2,[r7,#8]
;;;217    
;;;218          /* Read the forth input */
;;;219          Xn = *pIn++;
0000d0  68f5              LDR      r5,[r6,#0xc]
0000d2  3610              ADDS     r6,r6,#0x10
;;;220    
;;;221          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;222    
;;;223          /* acc =  b0 * x[n] */
;;;224          acc = (q63_t) b0 *Xn;
0000d4  fb880105          SMULL    r0,r1,r8,r5
;;;225          /* acc +=  b1 * x[n-1] */
;;;226          acc += (q63_t) b1 *Xn1;
0000d8  fbc90103          SMLAL    r0,r1,r9,r3
;;;227          /* acc +=  b[2] * x[n-2] */
;;;228          acc += (q63_t) b2 *Xn2;
0000dc  fbca010e          SMLAL    r0,r1,r10,lr
;;;229          /* acc +=  a1 * y[n-1] */
;;;230          acc += (q63_t) a1 *Yn2;
0000e0  fbcb0102          SMLAL    r0,r1,r11,r2
;;;231          /* acc +=  a2 * y[n-2] */
;;;232          acc += (q63_t) a2 *Yn1;
0000e4  f8ddc00c          LDR      r12,[sp,#0xc]
0000e8  fbcc0104          SMLAL    r0,r1,r12,r4
;;;233    
;;;234          /* The result is converted to 1.31, Yn1 variable is reused  */
;;;235          /* Calc lower part of acc */
;;;236          acc_l = acc & 0xffffffff;
;;;237    
;;;238          /* Calc upper part of acc */
;;;239          acc_h = (acc >> 32) & 0xffffffff;
;;;240    
;;;241          /* Apply shift for lower part of acc and upper part of acc */
;;;242          Yn1 = (uint32_t) acc_l >> lShift | acc_h << uShift;
0000ec  9c06              LDR      r4,[sp,#0x18]
0000ee  40e0              LSRS     r0,r0,r4
0000f0  9c07              LDR      r4,[sp,#0x1c]
0000f2  40a1              LSLS     r1,r1,r4
0000f4  ea400401          ORR      r4,r0,r1
;;;243    
;;;244          /* Every time after the output is computed state should be updated. */
;;;245          /* The states should be updated as:  */
;;;246          /* Xn2 = Xn1    */
;;;247          /* Xn1 = Xn     */
;;;248          /* Yn2 = Yn1    */
;;;249          /* Yn1 = acc    */
;;;250          Xn2 = Xn1;
;;;251          Xn1 = Xn;
;;;252    
;;;253          /* Store the output in the destination buffer. */
;;;254          *pOut++ = Yn1;
0000f8  60fc              STR      r4,[r7,#0xc]
0000fa  3710              ADDS     r7,r7,#0x10
;;;255    
;;;256          /* decrement the loop counter */
;;;257          sample--;
0000fc  9801              LDR      r0,[sp,#4]
0000fe  1e40              SUBS     r0,r0,#1
000100  9001              STR      r0,[sp,#4]
                  |L1.258|
000102  9801              LDR      r0,[sp,#4]            ;124
000104  2800              CMP      r0,#0                 ;124
000106  d1a8              BNE      |L1.90|
;;;258        }
;;;259    
;;;260        /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;261         ** No loop unrolling is used. */
;;;262        sample = (blockSize & 0x3u);
000108  980c              LDR      r0,[sp,#0x30]
00010a  f0000003          AND      r0,r0,#3
00010e  9001              STR      r0,[sp,#4]
;;;263    
;;;264        while(sample > 0u)
000110  e018              B        |L1.324|
                  |L1.274|
;;;265        {
;;;266          /* Read the input */
;;;267          Xn = *pIn++;
000112  ce02              LDM      r6!,{r1}
000114  9102              STR      r1,[sp,#8]
;;;268    
;;;269          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;270    
;;;271          /* acc =  b0 * x[n] */
;;;272          acc = (q63_t) b0 *Xn;
000116  9902              LDR      r1,[sp,#8]
000118  fb880101          SMULL    r0,r1,r8,r1
;;;273          /* acc +=  b1 * x[n-1] */
;;;274          acc += (q63_t) b1 *Xn1;
00011c  fbc90105          SMLAL    r0,r1,r9,r5
;;;275          /* acc +=  b[2] * x[n-2] */
;;;276          acc += (q63_t) b2 *Xn2;
000120  fbca0103          SMLAL    r0,r1,r10,r3
;;;277          /* acc +=  a1 * y[n-1] */
;;;278          acc += (q63_t) a1 *Yn1;
000124  fbcb0104          SMLAL    r0,r1,r11,r4
;;;279          /* acc +=  a2 * y[n-2] */
;;;280          acc += (q63_t) a2 *Yn2;
000128  9b03              LDR      r3,[sp,#0xc]
00012a  fbc30102          SMLAL    r0,r1,r3,r2
;;;281    
;;;282          /* The result is converted to 1.31  */
;;;283          acc = acc >> lShift;
00012e  9a06              LDR      r2,[sp,#0x18]
000130  f7fffffe          BL       __aeabi_lasr
;;;284    
;;;285          /* Every time after the output is computed state should be updated. */
;;;286          /* The states should be updated as:  */
;;;287          /* Xn2 = Xn1    */
;;;288          /* Xn1 = Xn     */
;;;289          /* Yn2 = Yn1    */
;;;290          /* Yn1 = acc    */
;;;291          Xn2 = Xn1;
000134  462b              MOV      r3,r5
;;;292          Xn1 = Xn;
000136  9d02              LDR      r5,[sp,#8]
;;;293          Yn2 = Yn1;
000138  4622              MOV      r2,r4
;;;294          Yn1 = (q31_t) acc;
00013a  4604              MOV      r4,r0
;;;295    
;;;296          /* Store the output in the destination buffer. */
;;;297          *pOut++ = (q31_t) acc;
00013c  c701              STM      r7!,{r0}
;;;298    
;;;299          /* decrement the loop counter */
;;;300          sample--;
00013e  9801              LDR      r0,[sp,#4]
000140  1e40              SUBS     r0,r0,#1
000142  9001              STR      r0,[sp,#4]
                  |L1.324|
000144  9801              LDR      r0,[sp,#4]            ;264
000146  2800              CMP      r0,#0                 ;264
000148  d1e3              BNE      |L1.274|
;;;301        }
;;;302    
;;;303        /*  The first stage goes from the input buffer to the output buffer. */
;;;304        /*  Subsequent stages occur in-place in the output buffer */
;;;305        pIn = pDst;
;;;306    
;;;307        /* Reset to destination pointer */
;;;308        pOut = pDst;
00014a  9e0b              LDR      r6,[sp,#0x2c]
00014c  4637              MOV      r7,r6
;;;309    
;;;310        /*  Store the updated state variables back into the pState array */
;;;311        *pState++ = Xn1;
00014e  9805              LDR      r0,[sp,#0x14]
000150  6005              STR      r5,[r0,#0]
000152  9805              LDR      r0,[sp,#0x14]
;;;312        *pState++ = Xn2;
000154  6043              STR      r3,[r0,#4]
;;;313        *pState++ = Yn1;
000156  6084              STR      r4,[r0,#8]
;;;314        *pState++ = Yn2;
000158  60c2              STR      r2,[r0,#0xc]
00015a  3010              ADDS     r0,r0,#0x10
00015c  9005              STR      r0,[sp,#0x14]
;;;315    
;;;316      } while(--stage);
00015e  9800              LDR      r0,[sp,#0]
000160  1e40              SUBS     r0,r0,#1
000162  9000              STR      r0,[sp,#0]
000164  f47faf61          BNE      |L1.42|
;;;317    
;;;318    #else
;;;319    
;;;320      /* Run the below code for Cortex-M0 */
;;;321    
;;;322      do
;;;323      {
;;;324        /* Reading the coefficients */
;;;325        b0 = *pCoeffs++;
;;;326        b1 = *pCoeffs++;
;;;327        b2 = *pCoeffs++;
;;;328        a1 = *pCoeffs++;
;;;329        a2 = *pCoeffs++;
;;;330    
;;;331        /* Reading the state values */
;;;332        Xn1 = pState[0];
;;;333        Xn2 = pState[1];
;;;334        Yn1 = pState[2];
;;;335        Yn2 = pState[3];
;;;336    
;;;337        /*      The variables acc holds the output value that is computed:         
;;;338         *    acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2]         
;;;339         */
;;;340    
;;;341        sample = blockSize;
;;;342    
;;;343        while(sample > 0u)
;;;344        {
;;;345          /* Read the input */
;;;346          Xn = *pIn++;
;;;347    
;;;348          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;349          /* acc =  b0 * x[n] */
;;;350          acc = (q63_t) b0 *Xn;
;;;351    
;;;352          /* acc +=  b1 * x[n-1] */
;;;353          acc += (q63_t) b1 *Xn1;
;;;354          /* acc +=  b[2] * x[n-2] */
;;;355          acc += (q63_t) b2 *Xn2;
;;;356          /* acc +=  a1 * y[n-1] */
;;;357          acc += (q63_t) a1 *Yn1;
;;;358          /* acc +=  a2 * y[n-2] */
;;;359          acc += (q63_t) a2 *Yn2;
;;;360    
;;;361          /* The result is converted to 1.31  */
;;;362          acc = acc >> lShift;
;;;363    
;;;364          /* Every time after the output is computed state should be updated. */
;;;365          /* The states should be updated as:  */
;;;366          /* Xn2 = Xn1    */
;;;367          /* Xn1 = Xn     */
;;;368          /* Yn2 = Yn1    */
;;;369          /* Yn1 = acc    */
;;;370          Xn2 = Xn1;
;;;371          Xn1 = Xn;
;;;372          Yn2 = Yn1;
;;;373          Yn1 = (q31_t) acc;
;;;374    
;;;375          /* Store the output in the destination buffer. */
;;;376          *pOut++ = (q31_t) acc;
;;;377    
;;;378          /* decrement the loop counter */
;;;379          sample--;
;;;380        }
;;;381    
;;;382        /*  The first stage goes from the input buffer to the output buffer. */
;;;383        /*  Subsequent stages occur in-place in the output buffer */
;;;384        pIn = pDst;
;;;385    
;;;386        /* Reset to destination pointer */
;;;387        pOut = pDst;
;;;388    
;;;389        /*  Store the updated state variables back into the pState array */
;;;390        *pState++ = Xn1;
;;;391        *pState++ = Xn2;
;;;392        *pState++ = Yn1;
;;;393        *pState++ = Yn2;
;;;394    
;;;395      } while(--stage);
;;;396    
;;;397    #endif /*  #ifndef ARM_MATH_CM0_FAMILY_FAMILY */
;;;398    }
000168  b00d              ADD      sp,sp,#0x34
00016a  e8bd8ff0          POP      {r4-r11,pc}
;;;399    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_biquad_cascade_df1_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___28_arm_biquad_cascade_df1_q31_c_d08ca15f____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___28_arm_biquad_cascade_df1_q31_c_d08ca15f____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___28_arm_biquad_cascade_df1_q31_c_d08ca15f____REVSH|
#line 144
|__asm___28_arm_biquad_cascade_df1_q31_c_d08ca15f____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___28_arm_biquad_cascade_df1_q31_c_d08ca15f____RRX|
#line 300
|__asm___28_arm_biquad_cascade_df1_q31_c_d08ca15f____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
