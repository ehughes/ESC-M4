; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_biquad_cascade_df1_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_biquad_cascade_df1_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE\_CMSIS_DSP_4_5_O3 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_biquad_cascade_df1_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_biquad_cascade_df1_q31.c]
                          THUMB

                          AREA ||i.arm_biquad_cascade_df1_q31||, CODE, READONLY, ALIGN=1

                  arm_biquad_cascade_df1_q31 PROC
;;;73     
;;;74     void arm_biquad_cascade_df1_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;75       const arm_biquad_casd_df1_inst_q31 * S,
;;;76       q31_t * pSrc,
;;;77       q31_t * pDst,
;;;78       uint32_t blockSize)
;;;79     {
;;;80       q63_t acc;                                     /*  accumulator                   */
;;;81       uint32_t uShift = ((uint32_t) S->postShift + 1u);
000004  7b02              LDRB     r2,[r0,#0xc]
000006  b08b              SUB      sp,sp,#0x2c           ;79
000008  1c52              ADDS     r2,r2,#1
;;;82       uint32_t lShift = 32u - uShift;                /*  Shift to be applied to the output */
00000a  9205              STR      r2,[sp,#0x14]
00000c  f1c20220          RSB      r2,r2,#0x20
;;;83       q31_t *pIn = pSrc;                             /*  input pointer initialization  */
000010  460d              MOV      r5,r1
;;;84       q31_t *pOut = pDst;                            /*  output pointer initialization */
000012  9204              STR      r2,[sp,#0x10]
;;;85       q31_t *pState = S->pState;                     /*  pState pointer initialization */
;;;86       q31_t *pCoeffs = S->pCoeffs;                   /*  coeff pointer initialization  */
000014  e9d08101          LDRD     r8,r1,[r0,#4]
;;;87       q31_t Xn1, Xn2, Yn1, Yn2;                      /*  Filter state variables        */
;;;88       q31_t b0, b1, b2, a1, a2;                      /*  Filter coefficients           */
;;;89       q31_t Xn;                                      /*  temporary input               */
;;;90       uint32_t sample, stage = S->numStages;         /*  loop counters                     */
000018  9106              STR      r1,[sp,#0x18]
00001a  6800              LDR      r0,[r0,#0]
00001c  9007              STR      r0,[sp,#0x1c]         ;79
;;;91     
;;;92     
;;;93     #ifndef ARM_MATH_CM0_FAMILY_FAMILY
;;;94     
;;;95       q31_t acc_l, acc_h;                            /*  temporary output variables    */
;;;96     
;;;97       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;98     
;;;99       do
;;;100      {
;;;101        /* Reading the coefficients */
;;;102        b0 = *pCoeffs++;
;;;103        b1 = *pCoeffs++;
;;;104        b2 = *pCoeffs++;
;;;105        a1 = *pCoeffs++;
;;;106        a2 = *pCoeffs++;
;;;107    
;;;108        /* Reading the state values */
;;;109        Xn1 = pState[0];
;;;110        Xn2 = pState[1];
;;;111        Yn1 = pState[2];
;;;112        Yn2 = pState[3];
;;;113    
;;;114        /* Apply loop unrolling and compute 4 output values simultaneously. */
;;;115        /*      The variable acc hold output values that are being computed:    
;;;116         *    
;;;117         *    acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2]    
;;;118         */
;;;119    
;;;120        sample = blockSize >> 2u;
00001e  980e              LDR      r0,[sp,#0x38]
000020  9f0d              LDR      r7,[sp,#0x34]         ;85
000022  0880              LSRS     r0,r0,#2
000024  9008              STR      r0,[sp,#0x20]
                  |L1.38|
000026  9806              LDR      r0,[sp,#0x18]         ;102
;;;121    
;;;122        /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;123         ** a second loop below computes the remaining 1 to 3 samples. */
;;;124        while(sample > 0u)
000028  f8dde020          LDR      lr,[sp,#0x20]
00002c  6800              LDR      r0,[r0,#0]            ;102
00002e  9000              STR      r0,[sp,#0]            ;102
000030  9806              LDR      r0,[sp,#0x18]         ;103
000032  6841              LDR      r1,[r0,#4]            ;103
000034  9101              STR      r1,[sp,#4]            ;104
000036  e9d0b902          LDRD     r11,r9,[r0,#8]        ;106
00003a  f8d0a010          LDR      r10,[r0,#0x10]        ;106
00003e  3014              ADDS     r0,r0,#0x14           ;106
000040  9006              STR      r0,[sp,#0x18]         ;106
000042  e9d84102          LDRD     r4,r1,[r8,#8]         ;106
000046  e9d86300          LDRD     r6,r3,[r8,#0]         ;106
00004a  e061              B        |L1.272|
                  |L1.76|
;;;125        {
;;;126          /* Read the input */
;;;127          Xn = *pIn++;
00004c  f855cb04          LDR      r12,[r5],#4
;;;128    
;;;129          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;130    
;;;131          /* acc =  b0 * x[n] */
;;;132          acc = (q63_t) b0 *Xn;
000050  9800              LDR      r0,[sp,#0]
000052  9509              STR      r5,[sp,#0x24]
000054  fb80020c          SMULL    r0,r2,r0,r12
;;;133          /* acc +=  b1 * x[n-1] */
;;;134          acc += (q63_t) b1 *Xn1;
000058  9d01              LDR      r5,[sp,#4]
00005a  f8cdc00c          STR      r12,[sp,#0xc]         ;132
00005e  fbc50206          SMLAL    r0,r2,r5,r6
;;;135          /* acc +=  b[2] * x[n-2] */
;;;136          acc += (q63_t) b2 *Xn2;
000062  fbcb0203          SMLAL    r0,r2,r11,r3
;;;137          /* acc +=  a1 * y[n-1] */
;;;138          acc += (q63_t) a1 *Yn1;
000066  fbc90204          SMLAL    r0,r2,r9,r4
;;;139          /* acc +=  a2 * y[n-2] */
;;;140          acc += (q63_t) a2 *Yn2;
00006a  fbca0201          SMLAL    r0,r2,r10,r1
;;;141    
;;;142          /* The result is converted to 1.31 , Yn2 variable is reused */
;;;143    
;;;144          /* Calc lower part of acc */
;;;145          acc_l = acc & 0xffffffff;
;;;146    
;;;147          /* Calc upper part of acc */
;;;148          acc_h = (acc >> 32) & 0xffffffff;
;;;149    
;;;150          /* Apply shift for lower part of acc and upper part of acc */
;;;151          Yn2 = (uint32_t) acc_l >> lShift | acc_h << uShift;
00006e  9904              LDR      r1,[sp,#0x10]
;;;152    
;;;153          /* Store the output in the destination buffer. */
;;;154          *pOut++ = Yn2;
;;;155    
;;;156          /* Read the second input */
;;;157          Xn2 = *pIn++;
;;;158    
;;;159          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;160    
;;;161          /* acc =  b0 * x[n] */
;;;162          acc = (q63_t) b0 *Xn2;
;;;163          /* acc +=  b1 * x[n-1] */
;;;164          acc += (q63_t) b1 *Xn;
;;;165          /* acc +=  b[2] * x[n-2] */
;;;166          acc += (q63_t) b2 *Xn1;
;;;167          /* acc +=  a1 * y[n-1] */
;;;168          acc += (q63_t) a1 *Yn2;
;;;169          /* acc +=  a2 * y[n-2] */
;;;170          acc += (q63_t) a2 *Yn1;
;;;171    
;;;172    
;;;173          /* The result is converted to 1.31, Yn1 variable is reused  */
;;;174    
;;;175          /* Calc lower part of acc */
;;;176          acc_l = acc & 0xffffffff;
;;;177    
;;;178          /* Calc upper part of acc */
;;;179          acc_h = (acc >> 32) & 0xffffffff;
;;;180    
;;;181    
;;;182          /* Apply shift for lower part of acc and upper part of acc */
;;;183          Yn1 = (uint32_t) acc_l >> lShift | acc_h << uShift;
;;;184    
;;;185          /* Store the output in the destination buffer. */
;;;186          *pOut++ = Yn1;
;;;187    
;;;188          /* Read the third input  */
;;;189          Xn1 = *pIn++;
;;;190    
;;;191          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;192    
;;;193          /* acc =  b0 * x[n] */
;;;194          acc = (q63_t) b0 *Xn1;
;;;195          /* acc +=  b1 * x[n-1] */
;;;196          acc += (q63_t) b1 *Xn2;
;;;197          /* acc +=  b[2] * x[n-2] */
;;;198          acc += (q63_t) b2 *Xn;
;;;199          /* acc +=  a1 * y[n-1] */
;;;200          acc += (q63_t) a1 *Yn1;
;;;201          /* acc +=  a2 * y[n-2] */
;;;202          acc += (q63_t) a2 *Yn2;
;;;203    
;;;204          /* The result is converted to 1.31, Yn2 variable is reused  */
;;;205          /* Calc lower part of acc */
;;;206          acc_l = acc & 0xffffffff;
;;;207    
;;;208          /* Calc upper part of acc */
;;;209          acc_h = (acc >> 32) & 0xffffffff;
;;;210    
;;;211    
;;;212          /* Apply shift for lower part of acc and upper part of acc */
;;;213          Yn2 = (uint32_t) acc_l >> lShift | acc_h << uShift;
;;;214    
;;;215          /* Store the output in the destination buffer. */
;;;216          *pOut++ = Yn2;
;;;217    
;;;218          /* Read the forth input */
;;;219          Xn = *pIn++;
;;;220    
;;;221          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;222    
;;;223          /* acc =  b0 * x[n] */
;;;224          acc = (q63_t) b0 *Xn;
;;;225          /* acc +=  b1 * x[n-1] */
;;;226          acc += (q63_t) b1 *Xn1;
;;;227          /* acc +=  b[2] * x[n-2] */
;;;228          acc += (q63_t) b2 *Xn2;
;;;229          /* acc +=  a1 * y[n-1] */
;;;230          acc += (q63_t) a1 *Yn2;
;;;231          /* acc +=  a2 * y[n-2] */
;;;232          acc += (q63_t) a2 *Yn1;
;;;233    
;;;234          /* The result is converted to 1.31, Yn1 variable is reused  */
;;;235          /* Calc lower part of acc */
;;;236          acc_l = acc & 0xffffffff;
;;;237    
;;;238          /* Calc upper part of acc */
;;;239          acc_h = (acc >> 32) & 0xffffffff;
;;;240    
;;;241          /* Apply shift for lower part of acc and upper part of acc */
;;;242          Yn1 = (uint32_t) acc_l >> lShift | acc_h << uShift;
;;;243    
;;;244          /* Every time after the output is computed state should be updated. */
;;;245          /* The states should be updated as:  */
;;;246          /* Xn2 = Xn1    */
;;;247          /* Xn1 = Xn     */
;;;248          /* Yn2 = Yn1    */
;;;249          /* Yn1 = acc    */
;;;250          Xn2 = Xn1;
;;;251          Xn1 = Xn;
;;;252    
;;;253          /* Store the output in the destination buffer. */
;;;254          *pOut++ = Yn1;
;;;255    
;;;256          /* decrement the loop counter */
;;;257          sample--;
000070  f1ae0e01          SUB      lr,lr,#1
000074  40c8              LSRS     r0,r0,r1              ;151
000076  9905              LDR      r1,[sp,#0x14]         ;151
000078  408a              LSLS     r2,r2,r1              ;151
00007a  4310              ORRS     r0,r0,r2              ;151
00007c  c701              STM      r7!,{r0}              ;154
00007e  9d09              LDR      r5,[sp,#0x24]         ;157
000080  9900              LDR      r1,[sp,#0]            ;162
000082  9b01              LDR      r3,[sp,#4]            ;164
000084  f855cb04          LDR      r12,[r5],#4           ;157
000088  f8cdc008          STR      r12,[sp,#8]           ;162
00008c  fb81210c          SMULL    r2,r1,r1,r12          ;162
000090  f8ddc00c          LDR      r12,[sp,#0xc]         ;164
000094  fbc3210c          SMLAL    r2,r1,r3,r12          ;164
000098  fbcb2106          SMLAL    r2,r1,r11,r6          ;166
00009c  fbc92100          SMLAL    r2,r1,r9,r0           ;168
0000a0  fbca2104          SMLAL    r2,r1,r10,r4          ;170
0000a4  9b04              LDR      r3,[sp,#0x10]         ;183
0000a6  40da              LSRS     r2,r2,r3              ;183
0000a8  9b05              LDR      r3,[sp,#0x14]         ;183
0000aa  4099              LSLS     r1,r1,r3              ;183
0000ac  430a              ORRS     r2,r2,r1              ;183
0000ae  c704              STM      r7!,{r2}              ;186
0000b0  cd08              LDM      r5!,{r3}              ;189
0000b2  9900              LDR      r1,[sp,#0]            ;194
0000b4  e9dd6c01          LDRD     r6,r12,[sp,#4]        ;194
0000b8  fb811403          SMULL    r1,r4,r1,r3           ;194
0000bc  fbc6140c          SMLAL    r1,r4,r6,r12          ;196
0000c0  f8ddc00c          LDR      r12,[sp,#0xc]         ;198
0000c4  fbcb140c          SMLAL    r1,r4,r11,r12         ;198
0000c8  fbc91402          SMLAL    r1,r4,r9,r2           ;200
0000cc  fbca1400          SMLAL    r1,r4,r10,r0          ;202
0000d0  9804              LDR      r0,[sp,#0x10]         ;213
0000d2  40c1              LSRS     r1,r1,r0              ;213
0000d4  9805              LDR      r0,[sp,#0x14]         ;213
0000d6  4084              LSLS     r4,r4,r0              ;213
0000d8  4321              ORRS     r1,r1,r4              ;213
0000da  c702              STM      r7!,{r1}              ;216
0000dc  9703              STR      r7,[sp,#0xc]          ;219
0000de  cd80              LDM      r5!,{r7}              ;219
0000e0  9800              LDR      r0,[sp,#0]            ;224
0000e2  9e01              LDR      r6,[sp,#4]            ;226
0000e4  fb804007          SMULL    r4,r0,r0,r7           ;224
0000e8  fbc64003          SMLAL    r4,r0,r6,r3           ;226
0000ec  f8ddc008          LDR      r12,[sp,#8]           ;228
0000f0  463e              MOV      r6,r7                 ;251
0000f2  fbcb400c          SMLAL    r4,r0,r11,r12         ;228
0000f6  fbc94001          SMLAL    r4,r0,r9,r1           ;230
0000fa  fbca4002          SMLAL    r4,r0,r10,r2          ;232
0000fe  9a04              LDR      r2,[sp,#0x10]         ;242
000100  9f03              LDR      r7,[sp,#0xc]          ;254
000102  40d4              LSRS     r4,r4,r2              ;242
000104  9a05              LDR      r2,[sp,#0x14]         ;242
000106  4090              LSLS     r0,r0,r2              ;242
000108  4304              ORRS     r4,r4,r0              ;242
00010a  603c              STR      r4,[r7,#0]            ;254
00010c  9f03              LDR      r7,[sp,#0xc]
00010e  1d3f              ADDS     r7,r7,#4
                  |L1.272|
000110  f1be0f00          CMP      lr,#0                 ;124
000114  d19a              BNE      |L1.76|
;;;258        }
;;;259    
;;;260        /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;261         ** No loop unrolling is used. */
;;;262        sample = (blockSize & 0x3u);
000116  980e              LDR      r0,[sp,#0x38]
000118  f0000003          AND      r0,r0,#3
;;;263    
;;;264        while(sample > 0u)
00011c  e018              B        |L1.336|
                  |L1.286|
;;;265        {
;;;266          /* Read the input */
;;;267          Xn = *pIn++;
00011e  cd01              LDM      r5!,{r0}
;;;268    
;;;269          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;270    
;;;271          /* acc =  b0 * x[n] */
;;;272          acc = (q63_t) b0 *Xn;
000120  9a00              LDR      r2,[sp,#0]
000122  9002              STR      r0,[sp,#8]
000124  fb820c00          SMULL    r0,r12,r2,r0
;;;273          /* acc +=  b1 * x[n-1] */
;;;274          acc += (q63_t) b1 *Xn1;
000128  9a01              LDR      r2,[sp,#4]
00012a  fbc20c06          SMLAL    r0,r12,r2,r6
;;;275          /* acc +=  b[2] * x[n-2] */
;;;276          acc += (q63_t) b2 *Xn2;
00012e  fbcb0c03          SMLAL    r0,r12,r11,r3
;;;277          /* acc +=  a1 * y[n-1] */
;;;278          acc += (q63_t) a1 *Yn1;
000132  fbc90c04          SMLAL    r0,r12,r9,r4
;;;279          /* acc +=  a2 * y[n-2] */
;;;280          acc += (q63_t) a2 *Yn2;
000136  fbca0c01          SMLAL    r0,r12,r10,r1
00013a  4661              MOV      r1,r12
;;;281    
;;;282          /* The result is converted to 1.31  */
;;;283          acc = acc >> lShift;
00013c  9a04              LDR      r2,[sp,#0x10]
00013e  f7fffffe          BL       __aeabi_lasr
;;;284    
;;;285          /* Every time after the output is computed state should be updated. */
;;;286          /* The states should be updated as:  */
;;;287          /* Xn2 = Xn1    */
;;;288          /* Xn1 = Xn     */
;;;289          /* Yn2 = Yn1    */
;;;290          /* Yn1 = acc    */
;;;291          Xn2 = Xn1;
000142  4633              MOV      r3,r6
;;;292          Xn1 = Xn;
;;;293          Yn2 = Yn1;
;;;294          Yn1 = (q31_t) acc;
;;;295    
;;;296          /* Store the output in the destination buffer. */
;;;297          *pOut++ = (q31_t) acc;
000144  9e02              LDR      r6,[sp,#8]
000146  4621              MOV      r1,r4                 ;293
000148  c701              STM      r7!,{r0}
00014a  4604              MOV      r4,r0                 ;294
;;;298    
;;;299          /* decrement the loop counter */
;;;300          sample--;
00014c  9803              LDR      r0,[sp,#0xc]
00014e  1e40              SUBS     r0,r0,#1
                  |L1.336|
000150  9003              STR      r0,[sp,#0xc]          ;262
000152  2800              CMP      r0,#0                 ;262
000154  d1e3              BNE      |L1.286|
;;;301        }
;;;302    
;;;303        /*  The first stage goes from the input buffer to the output buffer. */
;;;304        /*  Subsequent stages occur in-place in the output buffer */
;;;305        pIn = pDst;
;;;306    
;;;307        /* Reset to destination pointer */
;;;308        pOut = pDst;
000156  9d0d              LDR      r5,[sp,#0x34]
;;;309    
;;;310        /*  Store the updated state variables back into the pState array */
;;;311        *pState++ = Xn1;
000158  f1080004          ADD      r0,r8,#4
;;;312        *pState++ = Xn2;
00015c  f8c86000          STR      r6,[r8,#0]
000160  c008              STM      r0!,{r3}
000162  462f              MOV      r7,r5                 ;308
000164  e8e04102          STRD     r4,r1,[r0],#8
;;;313        *pState++ = Yn1;
;;;314        *pState++ = Yn2;
000168  4680              MOV      r8,r0
;;;315    
;;;316      } while(--stage);
00016a  9807              LDR      r0,[sp,#0x1c]
00016c  1e40              SUBS     r0,r0,#1
00016e  9007              STR      r0,[sp,#0x1c]
000170  f47faf59          BNE      |L1.38|
;;;317    
;;;318    #else
;;;319    
;;;320      /* Run the below code for Cortex-M0 */
;;;321    
;;;322      do
;;;323      {
;;;324        /* Reading the coefficients */
;;;325        b0 = *pCoeffs++;
;;;326        b1 = *pCoeffs++;
;;;327        b2 = *pCoeffs++;
;;;328        a1 = *pCoeffs++;
;;;329        a2 = *pCoeffs++;
;;;330    
;;;331        /* Reading the state values */
;;;332        Xn1 = pState[0];
;;;333        Xn2 = pState[1];
;;;334        Yn1 = pState[2];
;;;335        Yn2 = pState[3];
;;;336    
;;;337        /*      The variables acc holds the output value that is computed:         
;;;338         *    acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2]         
;;;339         */
;;;340    
;;;341        sample = blockSize;
;;;342    
;;;343        while(sample > 0u)
;;;344        {
;;;345          /* Read the input */
;;;346          Xn = *pIn++;
;;;347    
;;;348          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;349          /* acc =  b0 * x[n] */
;;;350          acc = (q63_t) b0 *Xn;
;;;351    
;;;352          /* acc +=  b1 * x[n-1] */
;;;353          acc += (q63_t) b1 *Xn1;
;;;354          /* acc +=  b[2] * x[n-2] */
;;;355          acc += (q63_t) b2 *Xn2;
;;;356          /* acc +=  a1 * y[n-1] */
;;;357          acc += (q63_t) a1 *Yn1;
;;;358          /* acc +=  a2 * y[n-2] */
;;;359          acc += (q63_t) a2 *Yn2;
;;;360    
;;;361          /* The result is converted to 1.31  */
;;;362          acc = acc >> lShift;
;;;363    
;;;364          /* Every time after the output is computed state should be updated. */
;;;365          /* The states should be updated as:  */
;;;366          /* Xn2 = Xn1    */
;;;367          /* Xn1 = Xn     */
;;;368          /* Yn2 = Yn1    */
;;;369          /* Yn1 = acc    */
;;;370          Xn2 = Xn1;
;;;371          Xn1 = Xn;
;;;372          Yn2 = Yn1;
;;;373          Yn1 = (q31_t) acc;
;;;374    
;;;375          /* Store the output in the destination buffer. */
;;;376          *pOut++ = (q31_t) acc;
;;;377    
;;;378          /* decrement the loop counter */
;;;379          sample--;
;;;380        }
;;;381    
;;;382        /*  The first stage goes from the input buffer to the output buffer. */
;;;383        /*  Subsequent stages occur in-place in the output buffer */
;;;384        pIn = pDst;
;;;385    
;;;386        /* Reset to destination pointer */
;;;387        pOut = pDst;
;;;388    
;;;389        /*  Store the updated state variables back into the pState array */
;;;390        *pState++ = Xn1;
;;;391        *pState++ = Xn2;
;;;392        *pState++ = Yn1;
;;;393        *pState++ = Yn2;
;;;394    
;;;395      } while(--stage);
;;;396    
;;;397    #endif /*  #ifndef ARM_MATH_CM0_FAMILY_FAMILY */
;;;398    }
000174  b00f              ADD      sp,sp,#0x3c
000176  e8bd8ff0          POP      {r4-r11,pc}
;;;399    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_biquad_cascade_df1_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___28_arm_biquad_cascade_df1_q31_c_d08ca15f____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___28_arm_biquad_cascade_df1_q31_c_d08ca15f____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___28_arm_biquad_cascade_df1_q31_c_d08ca15f____REVSH|
#line 144
|__asm___28_arm_biquad_cascade_df1_q31_c_d08ca15f____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___28_arm_biquad_cascade_df1_q31_c_d08ca15f____RRX|
#line 300
|__asm___28_arm_biquad_cascade_df1_q31_c_d08ca15f____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
