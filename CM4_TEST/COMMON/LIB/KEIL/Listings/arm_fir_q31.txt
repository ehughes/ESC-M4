; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_fir_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_fir_q31.c]
                          THUMB

                          AREA ||i.arm_fir_q31||, CODE, READONLY, ALIGN=1

                  arm_fir_q31 PROC
;;;71     
;;;72     void arm_fir_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;73       const arm_fir_instance_q31 * S,
;;;74       q31_t * pSrc,
;;;75       q31_t * pDst,
;;;76       uint32_t blockSize)
;;;77     {
000004  b087              SUB      sp,sp,#0x1c
;;;78       q31_t *pState = S->pState;                     /* State pointer */
000006  9807              LDR      r0,[sp,#0x1c]
000008  6847              LDR      r7,[r0,#4]
;;;79       q31_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
00000a  9807              LDR      r0,[sp,#0x1c]
00000c  6880              LDR      r0,[r0,#8]
00000e  9005              STR      r0,[sp,#0x14]
;;;80       q31_t *pStateCurnt;                            /* Points to the current sample of the state */
;;;81     
;;;82     
;;;83     #ifndef ARM_MATH_CM0_FAMILY
;;;84     
;;;85       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;86     
;;;87       q31_t x0, x1, x2;                              /* Temporary variables to hold state */
;;;88       q31_t c0;                                      /* Temporary variable to hold coefficient value */
;;;89       q31_t *px;                                     /* Temporary pointer for state */
;;;90       q31_t *pb;                                     /* Temporary pointer for coefficient buffer */
;;;91       q63_t acc0, acc1, acc2;                        /* Accumulators */
;;;92       uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
000010  9807              LDR      r0,[sp,#0x1c]
000012  8800              LDRH     r0,[r0,#0]
000014  9004              STR      r0,[sp,#0x10]
;;;93       uint32_t i, tapCnt, blkCnt, tapCntN3;          /* Loop counters */
;;;94     
;;;95       /* S->pState points to state array which contains previous frame (numTaps - 1) samples */
;;;96       /* pStateCurnt points to the location where the new input data should be written */
;;;97       pStateCurnt = &(S->pState[(numTaps - 1u)]);
000016  9804              LDR      r0,[sp,#0x10]
000018  1e40              SUBS     r0,r0,#1
00001a  eb070a80          ADD      r10,r7,r0,LSL #2
00001e  9006              STR      r0,[sp,#0x18]
;;;98     
;;;99       /* Apply loop unrolling and compute 4 output values simultaneously.    
;;;100       * The variables acc0 ... acc3 hold output values that are being computed:    
;;;101       *    
;;;102       *    acc0 =  b[numTaps-1] * x[n-numTaps-1] + b[numTaps-2] * x[n-numTaps-2] + b[numTaps-3] * x[n-numTaps-3] +...+ b[0] * x[0]    
;;;103       *    acc1 =  b[numTaps-1] * x[n-numTaps] +   b[numTaps-2] * x[n-numTaps-1] + b[numTaps-3] * x[n-numTaps-2] +...+ b[0] * x[1]    
;;;104       *    acc2 =  b[numTaps-1] * x[n-numTaps+1] + b[numTaps-2] * x[n-numTaps] +   b[numTaps-3] * x[n-numTaps-1] +...+ b[0] * x[2]    
;;;105       *    acc3 =  b[numTaps-1] * x[n-numTaps+2] + b[numTaps-2] * x[n-numTaps+1] + b[numTaps-3] * x[n-numTaps]   +...+ b[0] * x[3]    
;;;106       */
;;;107      blkCnt = blockSize / 3;
000020  2103              MOVS     r1,#3
000022  fbb3f0f1          UDIV     r0,r3,r1
000026  9001              STR      r0,[sp,#4]
;;;108      blockSize = blockSize - (3 * blkCnt);
000028  9801              LDR      r0,[sp,#4]
00002a  eba00080          SUB      r0,r0,r0,LSL #2
00002e  4418              ADD      r0,r0,r3
000030  900a              STR      r0,[sp,#0x28]
;;;109    
;;;110      tapCnt = numTaps / 3;
000032  9804              LDR      r0,[sp,#0x10]
000034  fbb0f0f1          UDIV     r0,r0,r1
000038  9002              STR      r0,[sp,#8]
;;;111      tapCntN3 = numTaps - (3 * tapCnt);
00003a  9802              LDR      r0,[sp,#8]
00003c  eba00180          SUB      r1,r0,r0,LSL #2
000040  9804              LDR      r0,[sp,#0x10]
000042  4408              ADD      r0,r0,r1
000044  9000              STR      r0,[sp,#0]
000046  e077              B        |L1.312|
                  |L1.72|
;;;112    
;;;113      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;114       ** a second loop below computes the remaining 1 to 3 samples. */
;;;115      while(blkCnt > 0u)
;;;116      {
;;;117        /* Copy three new input samples into the state buffer */
;;;118        *pStateCurnt++ = *pSrc++;
000048  9808              LDR      r0,[sp,#0x20]
00004a  6800              LDR      r0,[r0,#0]
00004c  f84a0b04          STR      r0,[r10],#4
000050  9808              LDR      r0,[sp,#0x20]
;;;119        *pStateCurnt++ = *pSrc++;
000052  6841              LDR      r1,[r0,#4]
000054  f84a1b04          STR      r1,[r10],#4
;;;120        *pStateCurnt++ = *pSrc++;
000058  6881              LDR      r1,[r0,#8]
00005a  300c              ADDS     r0,r0,#0xc
00005c  f84a1b04          STR      r1,[r10],#4
000060  9008              STR      r0,[sp,#0x20]
;;;121    
;;;122        /* Set all accumulators to zero */
;;;123        acc0 = 0;
000062  2000              MOVS     r0,#0
000064  4601              MOV      r1,r0
;;;124        acc1 = 0;
000066  2200              MOVS     r2,#0
000068  4613              MOV      r3,r2
;;;125        acc2 = 0;
00006a  2400              MOVS     r4,#0
00006c  4625              MOV      r5,r4
;;;126    
;;;127        /* Initialize state pointer */
;;;128        px = pState;
00006e  46b8              MOV      r8,r7
;;;129    
;;;130        /* Initialize coefficient pointer */
;;;131        pb = pCoeffs;
000070  9e05              LDR      r6,[sp,#0x14]
;;;132    
;;;133        /* Read the first two samples from the state buffer:    
;;;134         *  x[n-numTaps], x[n-numTaps-1] */
;;;135        x0 = *(px++);
000072  f8589b04          LDR      r9,[r8],#4
;;;136        x1 = *(px++);
000076  f858cb04          LDR      r12,[r8],#4
;;;137    
;;;138        /* Loop unrolling.  Process 3 taps at a time. */
;;;139        i = tapCnt;
00007a  f8ddb008          LDR      r11,[sp,#8]
00007e  f8cdb00c          STR      r11,[sp,#0xc]
;;;140    
;;;141        while(i > 0u)
000082  e024              B        |L1.206|
                  |L1.132|
;;;142        {
;;;143          /* Read the b[numTaps] coefficient */
;;;144          c0 = *pb;
000084  f8d6e000          LDR      lr,[r6,#0]
;;;145    
;;;146          /* Read x[n-numTaps-2] sample */
;;;147          x2 = *(px++);
000088  f858bb04          LDR      r11,[r8],#4
;;;148    
;;;149          /* Perform the multiply-accumulates */
;;;150          acc0 += ((q63_t) x0 * c0);
00008c  fbc9010e          SMLAL    r0,r1,r9,lr
;;;151          acc1 += ((q63_t) x1 * c0);
000090  fbcc230e          SMLAL    r2,r3,r12,lr
;;;152          acc2 += ((q63_t) x2 * c0);
000094  fbcb450e          SMLAL    r4,r5,r11,lr
;;;153    
;;;154          /* Read the coefficient and state */
;;;155          c0 = *(pb + 1u);
000098  f8d6e004          LDR      lr,[r6,#4]
;;;156          x0 = *(px++);
00009c  f8589b04          LDR      r9,[r8],#4
;;;157    
;;;158          /* Perform the multiply-accumulates */
;;;159          acc0 += ((q63_t) x1 * c0);
0000a0  fbcc010e          SMLAL    r0,r1,r12,lr
;;;160          acc1 += ((q63_t) x2 * c0);
0000a4  fbcb230e          SMLAL    r2,r3,r11,lr
;;;161          acc2 += ((q63_t) x0 * c0);
0000a8  fbc9450e          SMLAL    r4,r5,r9,lr
;;;162    
;;;163          /* Read the coefficient and state */
;;;164          c0 = *(pb + 2u);
0000ac  f8d6e008          LDR      lr,[r6,#8]
;;;165          x1 = *(px++);
0000b0  f858cb04          LDR      r12,[r8],#4
;;;166    
;;;167          /* update coefficient pointer */
;;;168          pb += 3u;
0000b4  360c              ADDS     r6,r6,#0xc
;;;169    
;;;170          /* Perform the multiply-accumulates */
;;;171          acc0 += ((q63_t) x2 * c0);
0000b6  fbcb010e          SMLAL    r0,r1,r11,lr
;;;172          acc1 += ((q63_t) x0 * c0);
0000ba  fbc9230e          SMLAL    r2,r3,r9,lr
;;;173          acc2 += ((q63_t) x1 * c0);
0000be  fbcc450e          SMLAL    r4,r5,r12,lr
;;;174    
;;;175          /* Decrement the loop counter */
;;;176          i--;
0000c2  f8ddb00c          LDR      r11,[sp,#0xc]
0000c6  f1ab0b01          SUB      r11,r11,#1
0000ca  f8cdb00c          STR      r11,[sp,#0xc]
                  |L1.206|
0000ce  f8ddb00c          LDR      r11,[sp,#0xc]         ;141
0000d2  f1bb0f00          CMP      r11,#0                ;141
0000d6  d1d5              BNE      |L1.132|
;;;177        }
;;;178    
;;;179        /* If the filter length is not a multiple of 3, compute the remaining filter taps */
;;;180    
;;;181        i = tapCntN3;
0000d8  f8ddb000          LDR      r11,[sp,#0]
0000dc  f8cdb00c          STR      r11,[sp,#0xc]
;;;182    
;;;183        while(i > 0u)
0000e0  e011              B        |L1.262|
                  |L1.226|
;;;184        {
;;;185          /* Read coefficients */
;;;186          c0 = *(pb++);
0000e2  f856bb04          LDR      r11,[r6],#4
;;;187    
;;;188          /* Fetch 1 state variable */
;;;189          x2 = *(px++);
0000e6  f858eb04          LDR      lr,[r8],#4
;;;190    
;;;191          /* Perform the multiply-accumulates */
;;;192          acc0 += ((q63_t) x0 * c0);
0000ea  fbc9010b          SMLAL    r0,r1,r9,r11
;;;193          acc1 += ((q63_t) x1 * c0);
0000ee  fbcc230b          SMLAL    r2,r3,r12,r11
;;;194          acc2 += ((q63_t) x2 * c0);
0000f2  fbce450b          SMLAL    r4,r5,lr,r11
;;;195    
;;;196          /* Reuse the present sample states for next sample */
;;;197          x0 = x1;
0000f6  46e1              MOV      r9,r12
;;;198          x1 = x2;
0000f8  46f4              MOV      r12,lr
;;;199    
;;;200          /* Decrement the loop counter */
;;;201          i--;
0000fa  f8ddb00c          LDR      r11,[sp,#0xc]
0000fe  f1ab0b01          SUB      r11,r11,#1
000102  f8cdb00c          STR      r11,[sp,#0xc]
                  |L1.262|
000106  f8ddb00c          LDR      r11,[sp,#0xc]         ;183
00010a  f1bb0f00          CMP      r11,#0                ;183
00010e  d1e8              BNE      |L1.226|
;;;202        }
;;;203    
;;;204        /* Advance the state pointer by 3 to process the next group of 3 samples */
;;;205        pState = pState + 3;
000110  370c              ADDS     r7,r7,#0xc
;;;206    
;;;207        /* The results in the 3 accumulators are in 2.30 format.  Convert to 1.31    
;;;208         ** Then store the 3 outputs in the destination buffer. */
;;;209        *pDst++ = (q31_t) (acc0 >> 31u);
000112  0fc0              LSRS     r0,r0,#31
000114  ea400041          ORR      r0,r0,r1,LSL #1
000118  9909              LDR      r1,[sp,#0x24]
00011a  6008              STR      r0,[r1,#0]
00011c  9809              LDR      r0,[sp,#0x24]
;;;210        *pDst++ = (q31_t) (acc1 >> 31u);
00011e  0fd1              LSRS     r1,r2,#31
000120  ea410143          ORR      r1,r1,r3,LSL #1
000124  6041              STR      r1,[r0,#4]
;;;211        *pDst++ = (q31_t) (acc2 >> 31u);
000126  0fe1              LSRS     r1,r4,#31
000128  ea410145          ORR      r1,r1,r5,LSL #1
00012c  6081              STR      r1,[r0,#8]
00012e  300c              ADDS     r0,r0,#0xc
000130  9009              STR      r0,[sp,#0x24]
;;;212    
;;;213        /* Decrement the samples loop counter */
;;;214        blkCnt--;
000132  9801              LDR      r0,[sp,#4]
000134  1e40              SUBS     r0,r0,#1
000136  9001              STR      r0,[sp,#4]
                  |L1.312|
000138  9801              LDR      r0,[sp,#4]            ;115
00013a  2800              CMP      r0,#0                 ;115
00013c  d184              BNE      |L1.72|
00013e  e020              B        |L1.386|
                  |L1.320|
;;;215      }
;;;216    
;;;217      /* If the blockSize is not a multiple of 3, compute any remaining output samples here.    
;;;218       ** No loop unrolling is used. */
;;;219    
;;;220      while(blockSize > 0u)
;;;221      {
;;;222        /* Copy one sample at a time into state buffer */
;;;223        *pStateCurnt++ = *pSrc++;
000140  9808              LDR      r0,[sp,#0x20]
000142  6800              LDR      r0,[r0,#0]
000144  f84a0b04          STR      r0,[r10],#4
000148  9808              LDR      r0,[sp,#0x20]
00014a  1d00              ADDS     r0,r0,#4
00014c  9008              STR      r0,[sp,#0x20]
;;;224    
;;;225        /* Set the accumulator to zero */
;;;226        acc0 = 0;
00014e  2000              MOVS     r0,#0
000150  4601              MOV      r1,r0
;;;227    
;;;228        /* Initialize state pointer */
;;;229        px = pState;
000152  463a              MOV      r2,r7
;;;230    
;;;231        /* Initialize Coefficient pointer */
;;;232        pb = (pCoeffs);
000154  9b05              LDR      r3,[sp,#0x14]
;;;233    
;;;234        i = numTaps;
000156  9c04              LDR      r4,[sp,#0x10]
                  |L1.344|
;;;235    
;;;236        /* Perform the multiply-accumulates */
;;;237        do
;;;238        {
;;;239          acc0 += (q63_t) * (px++) * (*(pb++));
000158  ca20              LDM      r2!,{r5}
00015a  cb40              LDM      r3!,{r6}
00015c  fb856506          SMULL    r6,r5,r5,r6
000160  1830              ADDS     r0,r6,r0
000162  4169              ADCS     r1,r1,r5
;;;240          i--;
000164  1e64              SUBS     r4,r4,#1
;;;241        } while(i > 0u);
000166  2c00              CMP      r4,#0
000168  d1f6              BNE      |L1.344|
;;;242    
;;;243        /* The result is in 2.62 format.  Convert to 1.31    
;;;244         ** Then store the output in the destination buffer. */
;;;245        *pDst++ = (q31_t) (acc0 >> 31u);
00016a  0fc0              LSRS     r0,r0,#31
00016c  ea400041          ORR      r0,r0,r1,LSL #1
000170  9909              LDR      r1,[sp,#0x24]
000172  6008              STR      r0,[r1,#0]
000174  9809              LDR      r0,[sp,#0x24]
000176  1d00              ADDS     r0,r0,#4
000178  9009              STR      r0,[sp,#0x24]
;;;246    
;;;247        /* Advance state pointer by 1 for the next sample */
;;;248        pState = pState + 1;
00017a  1d3f              ADDS     r7,r7,#4
;;;249    
;;;250        /* Decrement the samples loop counter */
;;;251        blockSize--;
00017c  980a              LDR      r0,[sp,#0x28]
00017e  1e40              SUBS     r0,r0,#1
000180  900a              STR      r0,[sp,#0x28]
                  |L1.386|
000182  980a              LDR      r0,[sp,#0x28]         ;220
000184  2800              CMP      r0,#0                 ;220
000186  d1db              BNE      |L1.320|
;;;252      }
;;;253    
;;;254      /* Processing is complete.    
;;;255       ** Now copy the last numTaps - 1 samples to the satrt of the state buffer.    
;;;256       ** This prepares the state buffer for the next function call. */
;;;257    
;;;258      /* Points to the start of the state buffer */
;;;259      pStateCurnt = S->pState;
000188  9807              LDR      r0,[sp,#0x1c]
00018a  6840              LDR      r0,[r0,#4]
;;;260    
;;;261      tapCnt = (numTaps - 1u) >> 2u;
00018c  9906              LDR      r1,[sp,#0x18]
00018e  0889              LSRS     r1,r1,#2
;;;262    
;;;263      /* copy data */
;;;264      while(tapCnt > 0u)
000190  e00a              B        |L1.424|
                  |L1.402|
;;;265      {
;;;266        *pStateCurnt++ = *pState++;
000192  683a              LDR      r2,[r7,#0]
000194  6002              STR      r2,[r0,#0]
;;;267        *pStateCurnt++ = *pState++;
000196  687a              LDR      r2,[r7,#4]
000198  6042              STR      r2,[r0,#4]
;;;268        *pStateCurnt++ = *pState++;
00019a  68ba              LDR      r2,[r7,#8]
00019c  6082              STR      r2,[r0,#8]
;;;269        *pStateCurnt++ = *pState++;
00019e  68fa              LDR      r2,[r7,#0xc]
0001a0  3710              ADDS     r7,r7,#0x10
0001a2  60c2              STR      r2,[r0,#0xc]
0001a4  3010              ADDS     r0,r0,#0x10
;;;270    
;;;271        /* Decrement the loop counter */
;;;272        tapCnt--;
0001a6  1e49              SUBS     r1,r1,#1
                  |L1.424|
0001a8  2900              CMP      r1,#0                 ;264
0001aa  d1f2              BNE      |L1.402|
;;;273      }
;;;274    
;;;275      /* Calculate remaining number of copies */
;;;276      tapCnt = (numTaps - 1u) % 0x4u;
0001ac  9906              LDR      r1,[sp,#0x18]
0001ae  f0010103          AND      r1,r1,#3
;;;277    
;;;278      /* Copy the remaining q31_t data */
;;;279      while(tapCnt > 0u)
0001b2  e002              B        |L1.442|
                  |L1.436|
;;;280      {
;;;281        *pStateCurnt++ = *pState++;
0001b4  cf04              LDM      r7!,{r2}
0001b6  c004              STM      r0!,{r2}
;;;282    
;;;283        /* Decrement the loop counter */
;;;284        tapCnt--;
0001b8  1e49              SUBS     r1,r1,#1
                  |L1.442|
0001ba  2900              CMP      r1,#0                 ;279
0001bc  d1fa              BNE      |L1.436|
;;;285      }
;;;286    
;;;287    #else
;;;288    
;;;289    /* Run the below code for Cortex-M0 */
;;;290    
;;;291      q31_t *px;                                     /* Temporary pointer for state */
;;;292      q31_t *pb;                                     /* Temporary pointer for coefficient buffer */
;;;293      q63_t acc;                                     /* Accumulator */
;;;294      uint32_t numTaps = S->numTaps;                 /* Length of the filter */
;;;295      uint32_t i, tapCnt, blkCnt;                    /* Loop counters */
;;;296    
;;;297      /* S->pState buffer contains previous frame (numTaps - 1) samples */
;;;298      /* pStateCurnt points to the location where the new input data should be written */
;;;299      pStateCurnt = &(S->pState[(numTaps - 1u)]);
;;;300    
;;;301      /* Initialize blkCnt with blockSize */
;;;302      blkCnt = blockSize;
;;;303    
;;;304      while(blkCnt > 0u)
;;;305      {
;;;306        /* Copy one sample at a time into state buffer */
;;;307        *pStateCurnt++ = *pSrc++;
;;;308    
;;;309        /* Set the accumulator to zero */
;;;310        acc = 0;
;;;311    
;;;312        /* Initialize state pointer */
;;;313        px = pState;
;;;314    
;;;315        /* Initialize Coefficient pointer */
;;;316        pb = pCoeffs;
;;;317    
;;;318        i = numTaps;
;;;319    
;;;320        /* Perform the multiply-accumulates */
;;;321        do
;;;322        {
;;;323          /* acc =  b[numTaps-1] * x[n-numTaps-1] + b[numTaps-2] * x[n-numTaps-2] + b[numTaps-3] * x[n-numTaps-3] +...+ b[0] * x[0] */
;;;324          acc += (q63_t) * px++ * *pb++;
;;;325          i--;
;;;326        } while(i > 0u);
;;;327    
;;;328        /* The result is in 2.62 format.  Convert to 1.31         
;;;329         ** Then store the output in the destination buffer. */
;;;330        *pDst++ = (q31_t) (acc >> 31u);
;;;331    
;;;332        /* Advance state pointer by 1 for the next sample */
;;;333        pState = pState + 1;
;;;334    
;;;335        /* Decrement the samples loop counter */
;;;336        blkCnt--;
;;;337      }
;;;338    
;;;339      /* Processing is complete.         
;;;340       ** Now copy the last numTaps - 1 samples to the starting of the state buffer.       
;;;341       ** This prepares the state buffer for the next function call. */
;;;342    
;;;343      /* Points to the start of the state buffer */
;;;344      pStateCurnt = S->pState;
;;;345    
;;;346      /* Copy numTaps number of values */
;;;347      tapCnt = numTaps - 1u;
;;;348    
;;;349      /* Copy the data */
;;;350      while(tapCnt > 0u)
;;;351      {
;;;352        *pStateCurnt++ = *pState++;
;;;353    
;;;354        /* Decrement the loop counter */
;;;355        tapCnt--;
;;;356      }
;;;357    
;;;358    
;;;359    #endif /*  #ifndef ARM_MATH_CM0_FAMILY */
;;;360    
;;;361    }
0001be  b00b              ADD      sp,sp,#0x2c
0001c0  e8bd8ff0          POP      {r4-r11,pc}
;;;362    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_fir_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_fir_q31_c_0e2cc653____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___13_arm_fir_q31_c_0e2cc653____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_fir_q31_c_0e2cc653____REVSH|
#line 144
|__asm___13_arm_fir_q31_c_0e2cc653____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_fir_q31_c_0e2cc653____RRX|
#line 300
|__asm___13_arm_fir_q31_c_0e2cc653____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
