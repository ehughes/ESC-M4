; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_correlate_opt_q7.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_correlate_opt_q7.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_correlate_opt_q7.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_correlate_opt_q7.c]
                          THUMB

                          AREA ||i.arm_correlate_opt_q7||, CODE, READONLY, ALIGN=1

                  arm_correlate_opt_q7 PROC
;;;82     
;;;83     void arm_correlate_opt_q7(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;84       q7_t * pSrcA,
;;;85       uint32_t srcALen,
;;;86       q7_t * pSrcB,
;;;87       uint32_t srcBLen,
;;;88       q7_t * pDst,
;;;89       q15_t * pScratch1,
;;;90       q15_t * pScratch2)
;;;91     {
000004  b087              SUB      sp,sp,#0x1c
000006  461f              MOV      r7,r3
000008  e9dd9411          LDRD     r9,r4,[sp,#0x44]
00000c  9b10              LDR      r3,[sp,#0x40]
00000e  460e              MOV      r6,r1
;;;92       q7_t *pOut = pDst;                             /* output pointer                */
;;;93       q15_t *pScr1 = pScratch1;                      /* Temporary pointer for scratch */
;;;94       q15_t *pScr2 = pScratch2;                      /* Temporary pointer for scratch */
000010  4621              MOV      r1,r4
;;;95       q7_t *pIn1;                                    /* inputA pointer                */
;;;96       q7_t *pIn2;                                    /* inputB pointer                */
;;;97       q15_t *py;                                     /* Intermediate inputB pointer   */
;;;98       q31_t acc0, acc1, acc2, acc3;                  /* Accumulators                  */
;;;99       uint32_t j, k = 0u, blkCnt;                    /* loop counter                  */
;;;100      int32_t inc = 1;                               /* output pointer increment          */
000012  f04f0b01          MOV      r11,#1
;;;101      uint32_t outBlockSize;                         /* loop counter                  */
;;;102      q15_t x4;                                      /* Temporary input variable      */
;;;103      uint32_t tapCnt;                               /* loop counter                  */
;;;104      q31_t x1, x2, x3, y1;                          /* Temporary input variables     */
;;;105    
;;;106      /* The algorithm implementation is based on the lengths of the inputs. */
;;;107      /* srcB is always made to slide across srcA. */
;;;108      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;109      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;110      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;111      /* and the destination pointer modifier, inc is set to -1 */
;;;112      /* If srcALen > srcBLen, zero pad has to be done to srcB to make the two inputs of same length */
;;;113      /* But to improve the performance,        
;;;114       * we include zeroes in the output instead of zero padding either of the the inputs*/
;;;115      /* If srcALen > srcBLen,        
;;;116       * (srcALen - srcBLen) zeroes has to included in the starting of the output buffer */
;;;117      /* If srcALen < srcBLen,        
;;;118       * (srcALen - srcBLen) zeroes has to included in the ending of the output buffer */
;;;119      if(srcALen >= srcBLen)
;;;120      {
;;;121        /* Initialization of inputA pointer */
;;;122        pIn1 = (pSrcA);
;;;123    
;;;124        /* Initialization of inputB pointer */
;;;125        pIn2 = (pSrcB);
;;;126    
;;;127        /* Number of output samples is calculated */
;;;128        outBlockSize = (2u * srcALen) - 1u;
000016  f04f3cff          MOV      r12,#0xffffffff
00001a  42be              CMP      r6,r7                 ;119
00001c  d30a              BCC      |L1.52|
00001e  4605              MOV      r5,r0                 ;122
000020  eb0c0046          ADD      r0,r12,r6,LSL #1
;;;129    
;;;130        /* When srcALen > srcBLen, zero padding is done to srcB        
;;;131         * to make their lengths equal.        
;;;132         * Instead, (outBlockSize - (srcALen + srcBLen - 1))        
;;;133         * number of output samples are made zero */
;;;134        j = outBlockSize - (srcALen + (srcBLen - 1u));
000024  eb060c07          ADD      r12,r6,r7
000028  eba0000c          SUB      r0,r0,r12
00002c  1c40              ADDS     r0,r0,#1
;;;135    
;;;136        /* Updating the pointer position to non zero value */
;;;137        pOut += j;
00002e  eb030800          ADD      r8,r3,r0
000032  e00a              B        |L1.74|
                  |L1.52|
;;;138    
;;;139      }
;;;140      else
;;;141      {
;;;142        /* Initialization of inputA pointer */
;;;143        pIn1 = (pSrcB);
000034  4615              MOV      r5,r2
;;;144    
;;;145        /* Initialization of inputB pointer */
;;;146        pIn2 = (pSrcA);
000036  4602              MOV      r2,r0
;;;147    
;;;148        /* srcBLen is always considered as shorter or equal to srcALen */
;;;149        j = srcBLen;
000038  4638              MOV      r0,r7
;;;150        srcBLen = srcALen;
00003a  4637              MOV      r7,r6
;;;151        srcALen = j;
00003c  4606              MOV      r6,r0
;;;152    
;;;153        /* CORR(x, y) = Reverse order(CORR(y, x)) */
;;;154        /* Hence set the destination pointer to point to the last output sample */
;;;155        pOut = pDst + ((srcALen + srcBLen) - 2u);
00003e  19f0              ADDS     r0,r6,r7
000040  eb000803          ADD      r8,r0,r3
000044  f1a80802          SUB      r8,r8,#2
;;;156    
;;;157        /* Destination address modifier is set to -1 */
;;;158        inc = -1;
000048  46e3              MOV      r11,r12
                  |L1.74|
;;;159    
;;;160      }
;;;161    
;;;162    
;;;163      /* Copy (srcBLen) samples in scratch buffer */
;;;164      k = srcBLen >> 2u;
00004a  08b8              LSRS     r0,r7,#2
00004c  9006              STR      r0,[sp,#0x18]
;;;165    
;;;166      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;167       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;168      while(k > 0u)
00004e  e00e              B        |L1.110|
                  |L1.80|
;;;169      {
;;;170        /* copy second buffer in reversal manner */
;;;171        x4 = (q15_t) * pIn2++;
000050  f9923000          LDRSB    r3,[r2,#0]
;;;172        *pScr2++ = x4;
000054  800b              STRH     r3,[r1,#0]
;;;173        x4 = (q15_t) * pIn2++;
000056  f9923001          LDRSB    r3,[r2,#1]
;;;174        *pScr2++ = x4;
00005a  804b              STRH     r3,[r1,#2]
;;;175        x4 = (q15_t) * pIn2++;
00005c  f9923002          LDRSB    r3,[r2,#2]
;;;176        *pScr2++ = x4;
000060  808b              STRH     r3,[r1,#4]
;;;177        x4 = (q15_t) * pIn2++;
000062  f9923003          LDRSB    r3,[r2,#3]
000066  1d12              ADDS     r2,r2,#4
;;;178        *pScr2++ = x4;
000068  80cb              STRH     r3,[r1,#6]
00006a  3108              ADDS     r1,r1,#8
;;;179    
;;;180        /* Decrement the loop counter */
;;;181        k--;
00006c  1e40              SUBS     r0,r0,#1
                  |L1.110|
00006e  2800              CMP      r0,#0                 ;168
000070  d1ee              BNE      |L1.80|
;;;182      }
;;;183    
;;;184      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;185       ** No loop unrolling is used. */
;;;186      k = srcBLen % 0x4u;
000072  f0070003          AND      r0,r7,#3
000076  9005              STR      r0,[sp,#0x14]
;;;187    
;;;188      while(k > 0u)
000078  e004              B        |L1.132|
                  |L1.122|
;;;189      {
;;;190        /* copy second buffer in reversal manner for remaining samples */
;;;191        x4 = (q15_t) * pIn2++;
00007a  f9123b01          LDRSB    r3,[r2],#1
;;;192        *pScr2++ = x4;
00007e  f8213b02          STRH     r3,[r1],#2
;;;193    
;;;194        /* Decrement the loop counter */
;;;195        k--;
000082  1e40              SUBS     r0,r0,#1
                  |L1.132|
000084  2800              CMP      r0,#0                 ;188
000086  d1f8              BNE      |L1.122|
;;;196      }
;;;197    
;;;198      /* Fill (srcBLen - 1u) zeros in scratch buffer */
;;;199      arm_fill_q15(0, pScr1, (srcBLen - 1u));
000088  1e7a              SUBS     r2,r7,#1
00008a  4649              MOV      r1,r9
00008c  f7fffffe          BL       arm_fill_q15
;;;200    
;;;201      /* Update temporary scratch pointer */
;;;202      pScr1 += (srcBLen - 1u);
000090  1e79              SUBS     r1,r7,#1
000092  eb090141          ADD      r1,r9,r1,LSL #1
;;;203    
;;;204      /* Copy (srcALen) samples in scratch buffer */
;;;205      k = srcALen >> 2u;
000096  08b0              LSRS     r0,r6,#2
;;;206    
;;;207      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;208       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;209      while(k > 0u)
000098  e00e              B        |L1.184|
                  |L1.154|
;;;210      {
;;;211        /* copy second buffer in reversal manner */
;;;212        x4 = (q15_t) * pIn1++;
00009a  f9952000          LDRSB    r2,[r5,#0]
;;;213        *pScr1++ = x4;
00009e  800a              STRH     r2,[r1,#0]
;;;214        x4 = (q15_t) * pIn1++;
0000a0  f9952001          LDRSB    r2,[r5,#1]
;;;215        *pScr1++ = x4;
0000a4  804a              STRH     r2,[r1,#2]
;;;216        x4 = (q15_t) * pIn1++;
0000a6  f9952002          LDRSB    r2,[r5,#2]
;;;217        *pScr1++ = x4;
0000aa  808a              STRH     r2,[r1,#4]
;;;218        x4 = (q15_t) * pIn1++;
0000ac  f9952003          LDRSB    r2,[r5,#3]
0000b0  1d2d              ADDS     r5,r5,#4
;;;219        *pScr1++ = x4;
0000b2  80ca              STRH     r2,[r1,#6]
0000b4  3108              ADDS     r1,r1,#8
;;;220    
;;;221        /* Decrement the loop counter */
;;;222        k--;
0000b6  1e40              SUBS     r0,r0,#1
                  |L1.184|
0000b8  2800              CMP      r0,#0                 ;209
0000ba  d1ee              BNE      |L1.154|
;;;223      }
;;;224    
;;;225      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;226       ** No loop unrolling is used. */
;;;227      k = srcALen % 0x4u;
0000bc  f0060003          AND      r0,r6,#3
;;;228    
;;;229      while(k > 0u)
0000c0  e004              B        |L1.204|
                  |L1.194|
;;;230      {
;;;231        /* copy second buffer in reversal manner for remaining samples */
;;;232        x4 = (q15_t) * pIn1++;
0000c2  f9152b01          LDRSB    r2,[r5],#1
;;;233        *pScr1++ = x4;
0000c6  f8212b02          STRH     r2,[r1],#2
;;;234    
;;;235        /* Decrement the loop counter */
;;;236        k--;
0000ca  1e40              SUBS     r0,r0,#1
                  |L1.204|
0000cc  2800              CMP      r0,#0                 ;229
0000ce  d1f8              BNE      |L1.194|
;;;237      }
;;;238    
;;;239    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;240    
;;;241      /* Fill (srcBLen - 1u) zeros at end of scratch buffer */
;;;242      arm_fill_q15(0, pScr1, (srcBLen - 1u));
0000d0  1e7a              SUBS     r2,r7,#1
0000d2  f7fffffe          BL       arm_fill_q15
;;;243    
;;;244      /* Update pointer */
;;;245      pScr1 += (srcBLen - 1u);
;;;246    
;;;247    #else
;;;248    
;;;249    /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;250      k = (srcBLen - 1u) >> 2u;
;;;251    
;;;252      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;253       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;254      while(k > 0u)
;;;255      {
;;;256        /* copy second buffer in reversal manner */
;;;257        *pScr1++ = 0;
;;;258        *pScr1++ = 0;
;;;259        *pScr1++ = 0;
;;;260        *pScr1++ = 0;
;;;261    
;;;262        /* Decrement the loop counter */
;;;263        k--;
;;;264      }
;;;265    
;;;266      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;267       ** No loop unrolling is used. */
;;;268      k = (srcBLen - 1u) % 0x4u;
;;;269    
;;;270      while(k > 0u)
;;;271      {
;;;272        /* copy second buffer in reversal manner for remaining samples */
;;;273        *pScr1++ = 0;
;;;274    
;;;275        /* Decrement the loop counter */
;;;276        k--;
;;;277      }
;;;278    
;;;279    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;280    
;;;281      /* Temporary pointer for second sequence */
;;;282      py = pScratch2;
0000d6  9403              STR      r4,[sp,#0xc]
;;;283    
;;;284      /* Initialization of pScr2 pointer */
;;;285      pScr2 = pScratch2;
;;;286    
;;;287      /* Actual correlation process starts here */
;;;288      blkCnt = (srcALen + srcBLen - 1u) >> 2;
0000d8  19f0              ADDS     r0,r6,r7
0000da  1e40              SUBS     r0,r0,#1
0000dc  9004              STR      r0,[sp,#0x10]
0000de  0880              LSRS     r0,r0,#2
0000e0  9002              STR      r0,[sp,#8]
;;;289    
;;;290      while(blkCnt > 0)
0000e2  e06a              B        |L1.442|
                  |L1.228|
;;;291      {
;;;292        /* Initialze temporary scratch pointer as scratch1 */
;;;293        pScr1 = pScratch1;
0000e4  46ca              MOV      r10,r9
;;;294    
;;;295        /* Clear Accumlators */
;;;296        acc0 = 0;
0000e6  2500              MOVS     r5,#0
;;;297        acc1 = 0;
0000e8  2600              MOVS     r6,#0
;;;298        acc2 = 0;
0000ea  2100              MOVS     r1,#0
;;;299        acc3 = 0;
0000ec  2300              MOVS     r3,#0
;;;300    
;;;301        /* Read two samples from scratch1 buffer */
;;;302        x1 = *__SIMD32(pScr1)++;
0000ee  f85a0b04          LDR      r0,[r10],#4
;;;303    
;;;304        /* Read next two samples from scratch1 buffer */
;;;305        x2 = *__SIMD32(pScr1)++;
0000f2  f85a2b04          LDR      r2,[r10],#4
;;;306    
;;;307        tapCnt = (srcBLen) >> 2u;
0000f6  f8ddc018          LDR      r12,[sp,#0x18]
0000fa  f8cdc004          STR      r12,[sp,#4]
;;;308    
;;;309        while(tapCnt > 0u)
0000fe  e023              B        |L1.328|
                  |L1.256|
;;;310        {
;;;311    
;;;312          /* Read four samples from smaller buffer */
;;;313          y1 = _SIMD32_OFFSET(pScr2);
000100  f8d4c000          LDR      r12,[r4,#0]
;;;314    
;;;315          /* multiply and accumlate */
;;;316          acc0 = __SMLAD(x1, y1, acc0);
000104  fb20550c          SMLAD    r5,r0,r12,r5
;;;317          acc2 = __SMLAD(x2, y1, acc2);
000108  fb22110c          SMLAD    r1,r2,r12,r1
;;;318    
;;;319          /* pack input data */
;;;320    #ifndef ARM_MATH_BIG_ENDIAN
;;;321          x3 = __PKHBT(x2, x1, 0);
00010c  eac20000          PKHBT    r0,r2,r0
;;;322    #else
;;;323          x3 = __PKHBT(x1, x2, 0);
;;;324    #endif
;;;325    
;;;326          /* multiply and accumlate */
;;;327          acc1 = __SMLADX(x3, y1, acc1);
000110  fb206e1c          SMLADX   lr,r0,r12,r6
;;;328    
;;;329          /* Read next two samples from scratch1 buffer */
;;;330          x1 = *__SIMD32(pScr1)++;
000114  f85a0b04          LDR      r0,[r10],#4
;;;331    
;;;332          /* pack input data */
;;;333    #ifndef ARM_MATH_BIG_ENDIAN
;;;334          x3 = __PKHBT(x1, x2, 0);
000118  eac00602          PKHBT    r6,r0,r2
;;;335    #else
;;;336          x3 = __PKHBT(x2, x1, 0);
;;;337    #endif
;;;338    
;;;339          acc3 = __SMLADX(x3, y1, acc3);
00011c  fb263c1c          SMLADX   r12,r6,r12,r3
;;;340    
;;;341          /* Read four samples from smaller buffer */
;;;342          y1 = _SIMD32_OFFSET(pScr2 + 2u);
000120  6863              LDR      r3,[r4,#4]
;;;343    
;;;344          acc0 = __SMLAD(x2, y1, acc0);
000122  fb225503          SMLAD    r5,r2,r3,r5
;;;345    
;;;346          acc2 = __SMLAD(x1, y1, acc2);
000126  fb201103          SMLAD    r1,r0,r3,r1
;;;347    
;;;348          acc1 = __SMLADX(x3, y1, acc1);
00012a  fb26e613          SMLADX   r6,r6,r3,lr
;;;349    
;;;350          x2 = *__SIMD32(pScr1)++;
00012e  f85a2b04          LDR      r2,[r10],#4
;;;351    
;;;352    #ifndef ARM_MATH_BIG_ENDIAN
;;;353          x3 = __PKHBT(x2, x1, 0);
000132  eac20e00          PKHBT    lr,r2,r0
;;;354    #else
;;;355          x3 = __PKHBT(x1, x2, 0);
;;;356    #endif
;;;357    
;;;358          acc3 = __SMLADX(x3, y1, acc3);
000136  fb2ec313          SMLADX   r3,lr,r3,r12
;;;359    
;;;360          pScr2 += 4u;
00013a  3408              ADDS     r4,r4,#8
;;;361    
;;;362    
;;;363          /* Decrement the loop counter */
;;;364          tapCnt--;
00013c  f8ddc004          LDR      r12,[sp,#4]
000140  f1ac0c01          SUB      r12,r12,#1
000144  f8cdc004          STR      r12,[sp,#4]
                  |L1.328|
000148  f8ddc004          LDR      r12,[sp,#4]           ;309
00014c  f1bc0f00          CMP      r12,#0                ;309
000150  d1d6              BNE      |L1.256|
;;;365        }
;;;366    
;;;367    
;;;368    
;;;369        /* Update scratch pointer for remaining samples of smaller length sequence */
;;;370        pScr1 -= 4u;
000152  f1aa0a08          SUB      r10,r10,#8
;;;371    
;;;372    
;;;373        /* apply same above for remaining samples of smaller length sequence */
;;;374        tapCnt = (srcBLen) & 3u;
000156  9a05              LDR      r2,[sp,#0x14]
;;;375    
;;;376        while(tapCnt > 0u)
000158  e014              B        |L1.388|
                  |L1.346|
;;;377        {
;;;378    
;;;379          /* accumlate the results */
;;;380          acc0 += (*pScr1++ * *pScr2);
00015a  f83acb02          LDRH     r12,[r10],#2
00015e  f8340b02          LDRH     r0,[r4],#2
000162  fb1c5500          SMLABB   r5,r12,r0,r5
;;;381          acc1 += (*pScr1++ * *pScr2);
000166  f83acb02          LDRH     r12,[r10],#2
00016a  fb1c6600          SMLABB   r6,r12,r0,r6
;;;382          acc2 += (*pScr1++ * *pScr2);
00016e  f83acb02          LDRH     r12,[r10],#2
000172  fb1c1100          SMLABB   r1,r12,r0,r1
;;;383          acc3 += (*pScr1++ * *pScr2++);
000176  f8bac000          LDRH     r12,[r10,#0]
00017a  fb1c3300          SMLABB   r3,r12,r0,r3
;;;384    
;;;385          pScr1 -= 3u;
00017e  f1aa0a04          SUB      r10,r10,#4
;;;386    
;;;387          /* Decrement the loop counter */
;;;388          tapCnt--;
000182  1e52              SUBS     r2,r2,#1
                  |L1.388|
000184  2a00              CMP      r2,#0                 ;376
000186  d1e8              BNE      |L1.346|
;;;389        }
;;;390    
;;;391        blkCnt--;
000188  9802              LDR      r0,[sp,#8]
00018a  1e40              SUBS     r0,r0,#1
00018c  9002              STR      r0,[sp,#8]
;;;392    
;;;393        /* Store the result in the accumulator in the destination buffer. */
;;;394        *pOut = (q7_t) (__SSAT(acc0 >> 7u, 8));
00018e  f32510c7          SSAT     r0,#8,r5,ASR #7
000192  f8880000          STRB     r0,[r8,#0]
;;;395        pOut += inc;
000196  eb08000b          ADD      r0,r8,r11
;;;396        *pOut = (q7_t) (__SSAT(acc1 >> 7u, 8));
00019a  f32612c7          SSAT     r2,#8,r6,ASR #7
00019e  7002              STRB     r2,[r0,#0]
;;;397        pOut += inc;
0001a0  4458              ADD      r0,r0,r11
;;;398        *pOut = (q7_t) (__SSAT(acc2 >> 7u, 8));
0001a2  f32111c7          SSAT     r1,#8,r1,ASR #7
0001a6  7001              STRB     r1,[r0,#0]
;;;399        pOut += inc;
0001a8  4458              ADD      r0,r0,r11
;;;400        *pOut = (q7_t) (__SSAT(acc3 >> 7u, 8));
0001aa  f32311c7          SSAT     r1,#8,r3,ASR #7
0001ae  7001              STRB     r1,[r0,#0]
;;;401        pOut += inc;
0001b0  eb00080b          ADD      r8,r0,r11
;;;402    
;;;403        /* Initialization of inputB pointer */
;;;404        pScr2 = py;
0001b4  9c03              LDR      r4,[sp,#0xc]
;;;405    
;;;406        pScratch1 += 4u;
0001b6  f1090908          ADD      r9,r9,#8
                  |L1.442|
0001ba  9802              LDR      r0,[sp,#8]            ;290
0001bc  2800              CMP      r0,#0                 ;290
0001be  d191              BNE      |L1.228|
;;;407    
;;;408      }
;;;409    
;;;410    
;;;411      blkCnt = (srcALen + srcBLen - 1u) & 0x3;
0001c0  9804              LDR      r0,[sp,#0x10]
0001c2  f0000303          AND      r3,r0,#3
;;;412    
;;;413      /* Calculate correlation for remaining samples of Bigger length sequence */
;;;414      while(blkCnt > 0)
0001c6  e025              B        |L1.532|
                  |L1.456|
;;;415      {
;;;416        /* Initialze temporary scratch pointer as scratch1 */
;;;417        pScr1 = pScratch1;
0001c8  4648              MOV      r0,r9
;;;418    
;;;419        /* Clear Accumlators */
;;;420        acc0 = 0;
0001ca  2100              MOVS     r1,#0
;;;421    
;;;422        tapCnt = (srcBLen) >> 1u;
0001cc  087a              LSRS     r2,r7,#1
;;;423    
;;;424        while(tapCnt > 0u)
0001ce  e00a              B        |L1.486|
                  |L1.464|
;;;425        {
;;;426          acc0 += (*pScr1++ * *pScr2++);
0001d0  8805              LDRH     r5,[r0,#0]
0001d2  8826              LDRH     r6,[r4,#0]
0001d4  fb151106          SMLABB   r1,r5,r6,r1
;;;427          acc0 += (*pScr1++ * *pScr2++);
0001d8  8845              LDRH     r5,[r0,#2]
0001da  1d00              ADDS     r0,r0,#4
0001dc  8866              LDRH     r6,[r4,#2]
0001de  1d24              ADDS     r4,r4,#4
0001e0  fb151106          SMLABB   r1,r5,r6,r1
;;;428    
;;;429          /* Decrement the loop counter */
;;;430          tapCnt--;
0001e4  1e52              SUBS     r2,r2,#1
                  |L1.486|
0001e6  2a00              CMP      r2,#0                 ;424
0001e8  d1f2              BNE      |L1.464|
;;;431        }
;;;432    
;;;433        tapCnt = (srcBLen) & 1u;
0001ea  f0070201          AND      r2,r7,#1
;;;434    
;;;435        /* apply same above for remaining samples of smaller length sequence */
;;;436        while(tapCnt > 0u)
0001ee  e006              B        |L1.510|
                  |L1.496|
;;;437        {
;;;438    
;;;439          /* accumlate the results */
;;;440          acc0 += (*pScr1++ * *pScr2++);
0001f0  f8305b02          LDRH     r5,[r0],#2
0001f4  f8346b02          LDRH     r6,[r4],#2
0001f8  fb151106          SMLABB   r1,r5,r6,r1
;;;441    
;;;442          /* Decrement the loop counter */
;;;443          tapCnt--;
0001fc  1e52              SUBS     r2,r2,#1
                  |L1.510|
0001fe  2a00              CMP      r2,#0                 ;436
000200  d1f6              BNE      |L1.496|
;;;444        }
;;;445    
;;;446        blkCnt--;
000202  1e5b              SUBS     r3,r3,#1
;;;447    
;;;448        /* Store the result in the accumulator in the destination buffer. */
;;;449        *pOut = (q7_t) (__SSAT(acc0 >> 7u, 8));
000204  f32110c7          SSAT     r0,#8,r1,ASR #7
000208  f8880000          STRB     r0,[r8,#0]
;;;450    
;;;451        pOut += inc;
00020c  44d8              ADD      r8,r8,r11
;;;452    
;;;453        /* Initialization of inputB pointer */
;;;454        pScr2 = py;
00020e  9c03              LDR      r4,[sp,#0xc]
;;;455    
;;;456        pScratch1 += 1u;
000210  f1090902          ADD      r9,r9,#2
                  |L1.532|
000214  2b00              CMP      r3,#0                 ;414
000216  d1d7              BNE      |L1.456|
;;;457    
;;;458      }
;;;459    
;;;460    }
000218  b007              ADD      sp,sp,#0x1c
00021a  e8bd8ff0          POP      {r4-r11,pc}
;;;461    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_correlate_opt_q7.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_correlate_opt_q7_c_3f380595____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___22_arm_correlate_opt_q7_c_3f380595____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_correlate_opt_q7_c_3f380595____REVSH|
#line 144
|__asm___22_arm_correlate_opt_q7_c_3f380595____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_correlate_opt_q7_c_3f380595____RRX|
#line 300
|__asm___22_arm_correlate_opt_q7_c_3f380595____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
