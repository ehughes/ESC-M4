; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_cmplx_mult_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_cmplx_mult_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_mat_cmplx_mult_f32.crf ..\..\SRC\CMSIS_DSP_4_5\src\MatrixFunctions\arm_mat_cmplx_mult_f32.c]
                          THUMB

                          AREA ||i.arm_mat_cmplx_mult_f32||, CODE, READONLY, ALIGN=2

                  arm_mat_cmplx_mult_f32 PROC
;;;72     
;;;73     arm_status arm_mat_cmplx_mult_f32(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;74       const arm_matrix_instance_f32 * pSrcA,
;;;75       const arm_matrix_instance_f32 * pSrcB,
;;;76       arm_matrix_instance_f32 * pDst)
;;;77     {
;;;78       float32_t *pIn1 = pSrcA->pData;                /* input data matrix pointer A */
000004  f8d0c004          LDR      r12,[r0,#4]
;;;79       float32_t *pIn2 = pSrcB->pData;                /* input data matrix pointer B */
;;;80       float32_t *pInA = pSrcA->pData;                /* input data matrix pointer A  */
;;;81       float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
000008  f8d2e004          LDR      lr,[r2,#4]
;;;82       float32_t *px;                                 /* Temporary output data matrix pointer */
;;;83       uint16_t numRowsA = pSrcA->numRows;            /* number of rows of input matrix A */
00000c  f8b08000          LDRH     r8,[r0,#0]
;;;84       uint16_t numColsB = pSrcB->numCols;            /* number of columns of input matrix B */
000010  884a              LDRH     r2,[r1,#2]
;;;85       uint16_t numColsA = pSrcA->numCols;            /* number of columns of input matrix A */
000012  f8b09002          LDRH     r9,[r0,#2]
;;;86       float32_t sumReal1, sumImag1;                  /* accumulator */
;;;87       float32_t a0, b0, c0, d0;
;;;88       float32_t a1, b1, c1, d1;
;;;89       float32_t sumReal2, sumImag2;                  /* accumulator */
;;;90     
;;;91     
;;;92       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;93     
;;;94       uint16_t col, i = 0u, j, row = numRowsA, colCnt;      /* loop counters */
000016  f04f0a00          MOV      r10,#0
;;;95       arm_status status;                             /* status of matrix multiplication */
;;;96     
;;;97     #ifdef ARM_MATH_MATRIX_CHECK
;;;98     
;;;99     
;;;100      /* Check for matrix mismatch condition */
;;;101      if((pSrcA->numCols != pSrcB->numRows) ||
;;;102         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;103      {
;;;104    
;;;105        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;106        status = ARM_MATH_SIZE_MISMATCH;
;;;107      }
;;;108      else
;;;109    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;110    
;;;111      {
;;;112        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;113        /* row loop */
;;;114        do
;;;115        {
;;;116          /* Output pointer is set to starting address of the row being processed */
;;;117          px = pOut + 2 * i;
;;;118    
;;;119          /* For every row wise process, the column loop counter is to be initiated */
;;;120          col = numColsB;
;;;121    
;;;122          /* For every row wise process, the pIn2 pointer is set      
;;;123           ** to the starting address of the pSrcB data */
;;;124          pIn2 = pSrcB->pData;
;;;125    
;;;126          j = 0u;
;;;127    
;;;128          /* column loop */
;;;129          do
;;;130          {
;;;131            /* Set the variable sum, that acts as accumulator, to zero */
;;;132            sumReal1 = 0.0f;
00001a  ed9f5a58          VLDR     s10,|L1.380|
;;;133            sumImag1 = 0.0f;
;;;134    
;;;135            sumReal2 = 0.0f;
;;;136            sumImag2 = 0.0f;
;;;137    
;;;138            /* Initiate the pointer pIn1 to point to the starting address of the column being processed */
;;;139            pIn1 = pInA;
;;;140    
;;;141            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;142            colCnt = numColsA >> 2;
00001e  ea4f0b99          LSR      r11,r9,#2
                  |L1.34|
000022  eb0e05ca          ADD      r5,lr,r10,LSL #3      ;117
000026  4616              MOV      r6,r2                 ;120
000028  6848              LDR      r0,[r1,#4]            ;124
00002a  2700              MOVS     r7,#0                 ;126
                  |L1.44|
00002c  eeb00a45          VMOV.F32 s0,s10                ;132
000030  eef00a40          VMOV.F32 s1,s0                 ;133
000034  eeb01a40          VMOV.F32 s2,s0                 ;135
000038  eef01a40          VMOV.F32 s3,s0                 ;136
00003c  4663              MOV      r3,r12                ;139
00003e  465c              MOV      r4,r11
;;;143    
;;;144            /* matrix multiplication        */
;;;145            while(colCnt > 0u)
000040  e05d              B        |L1.254|
                  |L1.66|
;;;146            {
;;;147    
;;;148              /* Reading real part of complex matrix A */
;;;149              a0 = *pIn1;
000042  ed932a00          VLDR     s4,[r3,#0]
;;;150    
;;;151              /* Reading real part of complex matrix B */
;;;152              c0 = *pIn2;
000046  ed903a00          VLDR     s6,[r0,#0]
;;;153    
;;;154              /* Reading imaginary part of complex matrix A */
;;;155              b0 = *(pIn1 + 1u);
00004a  edd32a01          VLDR     s5,[r3,#4]
;;;156    
;;;157              /* Reading imaginary part of complex matrix B */
;;;158              d0 = *(pIn2 + 1u);
00004e  edd03a01          VLDR     s7,[r0,#4]
;;;159    
;;;160              sumReal1 += a0 * c0;
000052  eef04a40          VMOV.F32 s9,s0
000056  ee424a03          VMLA.F32 s9,s4,s6
;;;161              sumImag1 += b0 * c0;
00005a  eeb04a60          VMOV.F32 s8,s1
00005e  ee024a83          VMLA.F32 s8,s5,s6
;;;162    
;;;163              pIn1 += 2u;
000062  3308              ADDS     r3,r3,#8
;;;164              pIn2 += 2 * numColsB;
000064  eb0000c2          ADD      r0,r0,r2,LSL #3
;;;165    
;;;166              sumReal2 -= b0 * d0;
000068  eeb03a41          VMOV.F32 s6,s2
00006c  ee023ae3          VMLS.F32 s6,s5,s7
;;;167              sumImag2 += a0 * d0;
000070  eef02a61          VMOV.F32 s5,s3
000074  ee422a23          VMLA.F32 s5,s4,s7
;;;168    
;;;169              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;170    
;;;171              a1 = *pIn1;
000078  ed931a00          VLDR     s2,[r3,#0]
;;;172              c1 = *pIn2;
00007c  ed900a00          VLDR     s0,[r0,#0]
;;;173    
;;;174              b1 = *(pIn1 + 1u);
000080  edd31a01          VLDR     s3,[r3,#4]
;;;175              d1 = *(pIn2 + 1u);
000084  edd00a01          VLDR     s1,[r0,#4]
;;;176    
;;;177              sumReal1 += a1 * c1;
000088  ee414a00          VMLA.F32 s9,s2,s0
;;;178              sumImag1 += b1 * c1;
00008c  ee014a80          VMLA.F32 s8,s3,s0
;;;179    
;;;180              pIn1 += 2u;
000090  3308              ADDS     r3,r3,#8
;;;181              pIn2 += 2 * numColsB;
000092  eb0000c2          ADD      r0,r0,r2,LSL #3
;;;182    
;;;183              sumReal2 -= b1 * d1;
000096  ee013ae0          VMLS.F32 s6,s3,s1
;;;184              sumImag2 += a1 * d1;
00009a  ee412a20          VMLA.F32 s5,s2,s1
;;;185    
;;;186              a0 = *pIn1;
00009e  ed930a00          VLDR     s0,[r3,#0]
;;;187              c0 = *pIn2;
0000a2  ed901a00          VLDR     s2,[r0,#0]
;;;188    
;;;189              b0 = *(pIn1 + 1u);
0000a6  edd30a01          VLDR     s1,[r3,#4]
;;;190              d0 = *(pIn2 + 1u);
0000aa  edd01a01          VLDR     s3,[r0,#4]
;;;191    
;;;192              sumReal1 += a0 * c0;
0000ae  ee404a01          VMLA.F32 s9,s0,s2
;;;193              sumImag1 += b0 * c0;
0000b2  ee004a81          VMLA.F32 s8,s1,s2
;;;194    
;;;195              pIn1 += 2u;
0000b6  3308              ADDS     r3,r3,#8
;;;196              pIn2 += 2 * numColsB;
0000b8  eb0000c2          ADD      r0,r0,r2,LSL #3
;;;197    
;;;198              sumReal2 -= b0 * d0;
0000bc  ee003ae1          VMLS.F32 s6,s1,s3
;;;199              sumImag2 += a0 * d0;
0000c0  ee402a21          VMLA.F32 s5,s0,s3
;;;200    
;;;201              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;202    
;;;203              a1 = *pIn1;
0000c4  edd31a00          VLDR     s3,[r3,#0]
;;;204              c1 = *pIn2;
0000c8  edd00a00          VLDR     s1,[r0,#0]
;;;205    
;;;206              b1 = *(pIn1 + 1u);
0000cc  ed931a01          VLDR     s2,[r3,#4]
;;;207              d1 = *(pIn2 + 1u);
0000d0  ed902a01          VLDR     s4,[r0,#4]
;;;208    
;;;209              sumReal1 += a1 * c1;
0000d4  eeb00a64          VMOV.F32 s0,s9
0000d8  ee010aa0          VMLA.F32 s0,s3,s1
;;;210              sumImag1 += b1 * c1;
0000dc  ee014a20          VMLA.F32 s8,s2,s1
0000e0  eef00a44          VMOV.F32 s1,s8
;;;211    
;;;212              pIn1 += 2u;
0000e4  3308              ADDS     r3,r3,#8
;;;213              pIn2 += 2 * numColsB;
0000e6  eb0000c2          ADD      r0,r0,r2,LSL #3
;;;214    
;;;215              sumReal2 -= b1 * d1;
0000ea  ee013a42          VMLS.F32 s6,s2,s4
0000ee  eeb01a43          VMOV.F32 s2,s6
;;;216              sumImag2 += a1 * d1;
0000f2  ee412a82          VMLA.F32 s5,s3,s4
0000f6  eef01a62          VMOV.F32 s3,s5
;;;217    
;;;218              /* Decrement the loop count */
;;;219              colCnt--;
0000fa  1e64              SUBS     r4,r4,#1
0000fc  b2a4              UXTH     r4,r4
                  |L1.254|
0000fe  2c00              CMP      r4,#0                 ;145
000100  d19f              BNE      |L1.66|
;;;220            }
;;;221    
;;;222            /* If the columns of pSrcA is not a multiple of 4, compute any remaining MACs here.      
;;;223             ** No loop unrolling is used. */
;;;224            colCnt = numColsA % 0x4u;
000102  f0090403          AND      r4,r9,#3
;;;225    
;;;226            while(colCnt > 0u)
000106  e014              B        |L1.306|
                  |L1.264|
;;;227            {
;;;228              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;229              a1 = *pIn1;
000108  ed932a00          VLDR     s4,[r3,#0]
;;;230              c1 = *pIn2;
00010c  ed903a00          VLDR     s6,[r0,#0]
;;;231    
;;;232              b1 = *(pIn1 + 1u);
000110  edd32a01          VLDR     s5,[r3,#4]
;;;233              d1 = *(pIn2 + 1u);
000114  edd03a01          VLDR     s7,[r0,#4]
;;;234    
;;;235              sumReal1 += a1 * c1;
000118  ee020a03          VMLA.F32 s0,s4,s6
;;;236              sumImag1 += b1 * c1;
00011c  ee420a83          VMLA.F32 s1,s5,s6
;;;237    
;;;238              pIn1 += 2u;
000120  3308              ADDS     r3,r3,#8
;;;239              pIn2 += 2 * numColsB;
000122  eb0000c2          ADD      r0,r0,r2,LSL #3
;;;240    
;;;241              sumReal2 -= b1 * d1;
000126  ee021ae3          VMLS.F32 s2,s5,s7
;;;242              sumImag2 += a1 * d1;
00012a  ee421a23          VMLA.F32 s3,s4,s7
;;;243    
;;;244              /* Decrement the loop counter */
;;;245              colCnt--;
00012e  1e64              SUBS     r4,r4,#1
000130  b2a4              UXTH     r4,r4
                  |L1.306|
000132  2c00              CMP      r4,#0                 ;226
000134  d1e8              BNE      |L1.264|
;;;246            }
;;;247    
;;;248            sumReal1 += sumReal2;
000136  ee300a01          VADD.F32 s0,s0,s2
;;;249            sumImag1 += sumImag2;
00013a  ee700aa1          VADD.F32 s1,s1,s3
;;;250    
;;;251            /* Store the result in the destination buffer */
;;;252            *px++ = sumReal1;
00013e  eca50a01          VSTM     r5!,{s0}
;;;253            *px++ = sumImag1;
000142  ece50a01          VSTM     r5!,{s1}
;;;254    
;;;255            /* Update the pointer pIn2 to point to the  starting address of the next column */
;;;256            j++;
000146  1c7f              ADDS     r7,r7,#1
000148  b2bf              UXTH     r7,r7
;;;257            pIn2 = pSrcB->pData + 2u * j;
00014a  6848              LDR      r0,[r1,#4]
00014c  eb0000c7          ADD      r0,r0,r7,LSL #3
;;;258    
;;;259            /* Decrement the column loop counter */
;;;260            col--;
000150  1e76              SUBS     r6,r6,#1
000152  b2b6              UXTH     r6,r6
;;;261    
;;;262          } while(col > 0u);
000154  2e00              CMP      r6,#0
000156  f47faf69          BNE      |L1.44|
;;;263    
;;;264          /* Update the pointer pInA to point to the  starting address of the next row */
;;;265          i = i + numColsB;
00015a  eb0a0002          ADD      r0,r10,r2
00015e  fa1ffa80          UXTH     r10,r0
;;;266          pInA = pInA + 2 * numColsA;
000162  eb0c0cc9          ADD      r12,r12,r9,LSL #3
;;;267    
;;;268          /* Decrement the row loop counter */
;;;269          row--;
000166  f1a80801          SUB      r8,r8,#1
00016a  fa1ff888          UXTH     r8,r8
;;;270    
;;;271        } while(row > 0u);
00016e  f1b80f00          CMP      r8,#0
000172  f47faf56          BNE      |L1.34|
;;;272    
;;;273        /* Set status as ARM_MATH_SUCCESS */
;;;274        status = ARM_MATH_SUCCESS;
000176  2000              MOVS     r0,#0
;;;275      }
;;;276    
;;;277      /* Return to application */
;;;278      return (status);
;;;279    }
000178  e8bd8ff0          POP      {r4-r11,pc}
;;;280    
                          ENDP

                  |L1.380|
00017c  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\MatrixFunctions\\arm_mat_cmplx_mult_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_mat_cmplx_mult_f32_c_6efc6a0b____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___24_arm_mat_cmplx_mult_f32_c_6efc6a0b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_mat_cmplx_mult_f32_c_6efc6a0b____REVSH|
#line 144
|__asm___24_arm_mat_cmplx_mult_f32_c_6efc6a0b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_mat_cmplx_mult_f32_c_6efc6a0b____RRX|
#line 300
|__asm___24_arm_mat_cmplx_mult_f32_c_6efc6a0b____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
