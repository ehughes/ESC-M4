; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_mult_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_mult_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_mat_mult_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\MatrixFunctions\arm_mat_mult_q31.c]
                          THUMB

                          AREA ||i.arm_mat_mult_q31||, CODE, READONLY, ALIGN=1

                  arm_mat_mult_q31 PROC
;;;77     
;;;78     arm_status arm_mat_mult_q31(
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;79       const arm_matrix_instance_q31 * pSrcA,
;;;80       const arm_matrix_instance_q31 * pSrcB,
;;;81       arm_matrix_instance_q31 * pDst)
;;;82     {
000004  b086              SUB      sp,sp,#0x18
;;;83       q31_t *pIn1 = pSrcA->pData;                    /* input data matrix pointer A */
000006  f8d08004          LDR      r8,[r0,#4]
;;;84       q31_t *pIn2 = pSrcB->pData;                    /* input data matrix pointer B */
;;;85       q31_t *pInA = pSrcA->pData;                    /* input data matrix pointer A */
;;;86       q31_t *pOut = pDst->pData;                     /* output data matrix pointer */
00000a  6851              LDR      r1,[r2,#4]
00000c  9104              STR      r1,[sp,#0x10]
;;;87       q31_t *px;                                     /* Temporary output data matrix pointer */
;;;88       q63_t sum;                                     /* Accumulator */
;;;89       uint16_t numRowsA = pSrcA->numRows;            /* number of rows of input matrix A    */
00000e  8801              LDRH     r1,[r0,#0]
;;;90       uint16_t numColsB = pSrcB->numCols;            /* number of columns of input matrix B */
000010  9a07              LDR      r2,[sp,#0x1c]
000012  8854              LDRH     r4,[r2,#2]
;;;91       uint16_t numColsA = pSrcA->numCols;            /* number of columns of input matrix A */
000014  8840              LDRH     r0,[r0,#2]
000016  9003              STR      r0,[sp,#0xc]
;;;92     
;;;93     #ifndef ARM_MATH_CM0_FAMILY
;;;94     
;;;95       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;96     
;;;97       uint16_t col, i = 0u, j, row = numRowsA, colCnt;      /* loop counters */
000018  2000              MOVS     r0,#0
00001a  9002              STR      r0,[sp,#8]
00001c  9101              STR      r1,[sp,#4]
;;;98       arm_status status;                             /* status of matrix multiplication */
;;;99       q31_t a0, a1, a2, a3, b0, b1, b2, b3;
;;;100    
;;;101    #ifdef ARM_MATH_MATRIX_CHECK
;;;102    
;;;103    
;;;104      /* Check for matrix mismatch condition */
;;;105      if((pSrcA->numCols != pSrcB->numRows) ||
;;;106         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;107      {
;;;108        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;109        status = ARM_MATH_SIZE_MISMATCH;
;;;110      }
;;;111      else
;;;112    #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;113    
;;;114      {
;;;115        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;116        /* row loop */
;;;117        do
;;;118        {
;;;119          /* Output pointer is set to starting address of the row being processed */
;;;120          px = pOut + i;
;;;121    
;;;122          /* For every row wise process, the column loop counter is to be initiated */
;;;123          col = numColsB;
;;;124    
;;;125          /* For every row wise process, the pIn2 pointer is set    
;;;126           ** to the starting address of the pSrcB data */
;;;127          pIn2 = pSrcB->pData;
;;;128    
;;;129          j = 0u;
;;;130    
;;;131          /* column loop */
;;;132          do
;;;133          {
;;;134            /* Set the variable sum, that acts as accumulator, to zero */
;;;135            sum = 0;
;;;136    
;;;137            /* Initiate the pointer pIn1 to point to the starting address of pInA */
;;;138            pIn1 = pInA;
;;;139    
;;;140            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;141            colCnt = numColsA >> 2;
00001e  9803              LDR      r0,[sp,#0xc]
000020  0880              LSRS     r0,r0,#2
000022  9005              STR      r0,[sp,#0x14]
                  |L1.36|
000024  9902              LDR      r1,[sp,#8]            ;120
000026  9804              LDR      r0,[sp,#0x10]         ;120
000028  eb000c81          ADD      r12,r0,r1,LSL #2      ;120
00002c  4626              MOV      r6,r4                 ;123
00002e  9807              LDR      r0,[sp,#0x1c]         ;127
000030  6842              LDR      r2,[r0,#4]            ;127
000032  2700              MOVS     r7,#0                 ;129
                  |L1.52|
000034  2000              MOVS     r0,#0                 ;135
000036  4601              MOV      r1,r0                 ;135
000038  4643              MOV      r3,r8                 ;138
00003a  9d05              LDR      r5,[sp,#0x14]
;;;142    
;;;143    
;;;144            /* matrix multiplication */
;;;145            while(colCnt > 0u)
00003c  e025              B        |L1.138|
                  |L1.62|
;;;146            {
;;;147              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;148              /* Perform the multiply-accumulates */
;;;149              b0 = *pIn2;
00003e  f8d29000          LDR      r9,[r2,#0]
;;;150              pIn2 += numColsB;
000042  eb020284          ADD      r2,r2,r4,LSL #2
;;;151    
;;;152              a0 = *pIn1++;
000046  f853ab04          LDR      r10,[r3],#4
;;;153              a1 = *pIn1++;
00004a  f853bb04          LDR      r11,[r3],#4
00004e  f8cdb000          STR      r11,[sp,#0]
;;;154    
;;;155              b1 = *pIn2;
000052  f8d2e000          LDR      lr,[r2,#0]
;;;156              pIn2 += numColsB;
000056  eb020284          ADD      r2,r2,r4,LSL #2
;;;157              b2 = *pIn2;
00005a  f8d2b000          LDR      r11,[r2,#0]
;;;158              pIn2 += numColsB;
00005e  eb020284          ADD      r2,r2,r4,LSL #2
;;;159    
;;;160              sum += (q63_t) a0 *b0;
000062  fbca0109          SMLAL    r0,r1,r10,r9
;;;161              sum += (q63_t) a1 *b1;
000066  f8dd9000          LDR      r9,[sp,#0]
00006a  fbc9010e          SMLAL    r0,r1,r9,lr
;;;162    
;;;163              a2 = *pIn1++;
00006e  f8539b04          LDR      r9,[r3],#4
;;;164              a3 = *pIn1++;
000072  f853ab04          LDR      r10,[r3],#4
;;;165    
;;;166              b3 = *pIn2;
000076  f8d2e000          LDR      lr,[r2,#0]
;;;167              pIn2 += numColsB;
00007a  eb020284          ADD      r2,r2,r4,LSL #2
;;;168    
;;;169              sum += (q63_t) a2 *b2;
00007e  fbc9010b          SMLAL    r0,r1,r9,r11
;;;170              sum += (q63_t) a3 *b3;
000082  fbca010e          SMLAL    r0,r1,r10,lr
;;;171    
;;;172              /* Decrement the loop counter */
;;;173              colCnt--;
000086  1e6d              SUBS     r5,r5,#1
000088  b2ad              UXTH     r5,r5
                  |L1.138|
00008a  2d00              CMP      r5,#0                 ;145
00008c  d1d7              BNE      |L1.62|
;;;174            }
;;;175    
;;;176            /* If the columns of pSrcA is not a multiple of 4, compute any remaining output samples here.    
;;;177             ** No loop unrolling is used. */
;;;178            colCnt = numColsA % 0x4u;
00008e  9d03              LDR      r5,[sp,#0xc]
000090  f0050503          AND      r5,r5,#3
;;;179    
;;;180            while(colCnt > 0u)
000094  e00d              B        |L1.178|
                  |L1.150|
;;;181            {
;;;182              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;183              /* Perform the multiply-accumulates */
;;;184              sum += (q63_t) * pIn1++ * *pIn2;
000096  f8539b04          LDR      r9,[r3],#4
00009a  f8d2a000          LDR      r10,[r2,#0]
00009e  fb89a90a          SMULL    r10,r9,r9,r10
0000a2  eb1a0000          ADDS     r0,r10,r0
0000a6  eb490101          ADC      r1,r9,r1
;;;185              pIn2 += numColsB;
0000aa  eb020284          ADD      r2,r2,r4,LSL #2
;;;186    
;;;187              /* Decrement the loop counter */
;;;188              colCnt--;
0000ae  1e6d              SUBS     r5,r5,#1
0000b0  b2ad              UXTH     r5,r5
                  |L1.178|
0000b2  2d00              CMP      r5,#0                 ;180
0000b4  d1ef              BNE      |L1.150|
;;;189            }
;;;190    
;;;191            /* Convert the result from 2.62 to 1.31 format and store in destination buffer */
;;;192            *px++ = (q31_t) (sum >> 31);
0000b6  0fc0              LSRS     r0,r0,#31
0000b8  ea400041          ORR      r0,r0,r1,LSL #1
0000bc  f84c0b04          STR      r0,[r12],#4
;;;193    
;;;194            /* Update the pointer pIn2 to point to the  starting address of the next column */
;;;195            j++;
0000c0  1c7f              ADDS     r7,r7,#1
0000c2  b2bf              UXTH     r7,r7
;;;196            pIn2 = (pSrcB->pData) + j;
0000c4  9807              LDR      r0,[sp,#0x1c]
0000c6  6840              LDR      r0,[r0,#4]
0000c8  eb000287          ADD      r2,r0,r7,LSL #2
;;;197    
;;;198            /* Decrement the column loop counter */
;;;199            col--;
0000cc  1e76              SUBS     r6,r6,#1
0000ce  b2b6              UXTH     r6,r6
;;;200    
;;;201          } while(col > 0u);
0000d0  2e00              CMP      r6,#0
0000d2  d1af              BNE      |L1.52|
;;;202    
;;;203    #else
;;;204    
;;;205      /* Run the below code for Cortex-M0 */
;;;206    
;;;207      q31_t *pInB = pSrcB->pData;                    /* input data matrix pointer B */
;;;208      uint16_t col, i = 0u, row = numRowsA, colCnt;  /* loop counters */
;;;209      arm_status status;                             /* status of matrix multiplication */
;;;210    
;;;211    
;;;212    #ifdef ARM_MATH_MATRIX_CHECK
;;;213    
;;;214      /* Check for matrix mismatch condition */
;;;215      if((pSrcA->numCols != pSrcB->numRows) ||
;;;216         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;217      {
;;;218        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;219        status = ARM_MATH_SIZE_MISMATCH;
;;;220      }
;;;221      else
;;;222    #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;223    
;;;224      {
;;;225        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;226        /* row loop */
;;;227        do
;;;228        {
;;;229          /* Output pointer is set to starting address of the row being processed */
;;;230          px = pOut + i;
;;;231    
;;;232          /* For every row wise process, the column loop counter is to be initiated */
;;;233          col = numColsB;
;;;234    
;;;235          /* For every row wise process, the pIn2 pointer is set          
;;;236           ** to the starting address of the pSrcB data */
;;;237          pIn2 = pSrcB->pData;
;;;238    
;;;239          /* column loop */
;;;240          do
;;;241          {
;;;242            /* Set the variable sum, that acts as accumulator, to zero */
;;;243            sum = 0;
;;;244    
;;;245            /* Initiate the pointer pIn1 to point to the starting address of pInA */
;;;246            pIn1 = pInA;
;;;247    
;;;248            /* Matrix A columns number of MAC operations are to be performed */
;;;249            colCnt = numColsA;
;;;250    
;;;251            /* matrix multiplication */
;;;252            while(colCnt > 0u)
;;;253            {
;;;254              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;255              /* Perform the multiply-accumulates */
;;;256              sum += (q63_t) * pIn1++ * *pIn2;
;;;257              pIn2 += numColsB;
;;;258    
;;;259              /* Decrement the loop counter */
;;;260              colCnt--;
;;;261            }
;;;262    
;;;263            /* Convert the result from 2.62 to 1.31 format and store in destination buffer */
;;;264            *px++ = (q31_t) clip_q63_to_q31(sum >> 31);
;;;265    
;;;266            /* Decrement the column loop counter */
;;;267            col--;
;;;268    
;;;269            /* Update the pointer pIn2 to point to the  starting address of the next column */
;;;270            pIn2 = pInB + (numColsB - col);
;;;271    
;;;272          } while(col > 0u);
;;;273    
;;;274    #endif
;;;275    
;;;276          /* Update the pointer pInA to point to the  starting address of the next row */
;;;277          i = i + numColsB;
0000d4  9802              LDR      r0,[sp,#8]
0000d6  4420              ADD      r0,r0,r4
0000d8  b280              UXTH     r0,r0
0000da  9002              STR      r0,[sp,#8]
;;;278          pInA = pInA + numColsA;
0000dc  9803              LDR      r0,[sp,#0xc]
0000de  eb080880          ADD      r8,r8,r0,LSL #2
;;;279    
;;;280          /* Decrement the row loop counter */
;;;281          row--;
0000e2  9801              LDR      r0,[sp,#4]
0000e4  1e40              SUBS     r0,r0,#1
0000e6  b280              UXTH     r0,r0
0000e8  9001              STR      r0,[sp,#4]
;;;282    
;;;283        } while(row > 0u);
0000ea  9801              LDR      r0,[sp,#4]
0000ec  2800              CMP      r0,#0
0000ee  d199              BNE      |L1.36|
;;;284    
;;;285        /* set status as ARM_MATH_SUCCESS */
;;;286        status = ARM_MATH_SUCCESS;
;;;287      }
;;;288      /* Return to application */
;;;289      return (status);
;;;290    }
0000f0  b009              ADD      sp,sp,#0x24
0000f2  e8bd8ff0          POP      {r4-r11,pc}
;;;291    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\MatrixFunctions\\arm_mat_mult_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_mat_mult_q31_c_50491542____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___18_arm_mat_mult_q31_c_50491542____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_mat_mult_q31_c_50491542____REVSH|
#line 144
|__asm___18_arm_mat_mult_q31_c_50491542____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_mat_mult_q31_c_50491542____RRX|
#line 300
|__asm___18_arm_mat_mult_q31_c_50491542____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
