; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_lms_norm_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_lms_norm_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_lms_norm_f32.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_lms_norm_f32.c]
                          THUMB

                          AREA ||i.arm_lms_norm_f32||, CODE, READONLY, ALIGN=2

                  arm_lms_norm_f32 PROC
;;;172    
;;;173    void arm_lms_norm_f32(
000000  e92d4ffc          PUSH     {r2-r11,lr}
;;;174      arm_lms_norm_instance_f32 * S,
;;;175      float32_t * pSrc,
;;;176      float32_t * pRef,
;;;177      float32_t * pOut,
;;;178      float32_t * pErr,
;;;179      uint32_t blockSize)
;;;180    {
000004  e9ddac0b          LDRD     r10,r12,[sp,#0x2c]
;;;181      float32_t *pState = S->pState;                 /* State pointer */
000008  6844              LDR      r4,[r0,#4]
;;;182      float32_t *pCoeffs = S->pCoeffs;               /* Coefficient pointer */
00000a  f8d0b008          LDR      r11,[r0,#8]
;;;183      float32_t *pStateCurnt;                        /* Points to the current sample of the state */
;;;184      float32_t *px, *pb;                            /* Temporary pointers for state and coefficient buffers */
;;;185      float32_t mu = S->mu;                          /* Adaptive factor */
00000e  edd01a03          VLDR     s3,[r0,#0xc]
;;;186      uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
000012  f8b09000          LDRH     r9,[r0,#0]
;;;187      uint32_t tapCnt, blkCnt;                       /* Loop counters */
;;;188      float32_t energy;                              /* Energy of the input */
;;;189      float32_t sum, e, d;                           /* accumulator, error, reference data sample */
;;;190      float32_t w, x0, in;                           /* weight factor, temporary variable to hold input sample and state */
;;;191    
;;;192      /* Initializations of error,  difference, Coefficient update */
;;;193      e = 0.0f;
000016  ed9f2a60          VLDR     s4,|L1.408|
;;;194      d = 0.0f;
;;;195      w = 0.0f;
;;;196    
;;;197      energy = S->energy;
00001a  edd00a04          VLDR     s1,[r0,#0x10]
;;;198      x0 = S->x0;
00001e  ed900a05          VLDR     s0,[r0,#0x14]
;;;199    
;;;200      /* S->pState points to buffer which contains previous frame (numTaps - 1) samples */
;;;201      /* pStateCurnt points to the location where the new input data should be written */
;;;202      pStateCurnt = &(S->pState[(numTaps - 1u)]);
000022  f1a90501          SUB      r5,r9,#1
000026  eb040885          ADD      r8,r4,r5,LSL #2
00002a  9501              STR      r5,[sp,#4]
00002c  e088              B        |L1.320|
                  |L1.46|
;;;203    
;;;204      /* Loop over blockSize number of values */
;;;205      blkCnt = blockSize;
;;;206    
;;;207    
;;;208    #ifndef ARM_MATH_CM0_FAMILY
;;;209    
;;;210      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;211    
;;;212      while(blkCnt > 0u)
;;;213      {
;;;214        /* Copy the new input sample into the state buffer */
;;;215        *pStateCurnt++ = *pSrc;
00002e  ed911a00          VLDR     s2,[r1,#0]
000032  eca81a01          VSTM     r8!,{s2}
;;;216    
;;;217        /* Initialize pState pointer */
;;;218        px = pState;
000036  4626              MOV      r6,r4
;;;219    
;;;220        /* Initialize coeff pointer */
;;;221        pb = (pCoeffs);
000038  465d              MOV      r5,r11
;;;222    
;;;223        /* Read the sample from input buffer */
;;;224        in = *pSrc++;
00003a  ecb11a01          VLDM     r1!,{s2}
;;;225    
;;;226        /* Update the energy calculation */
;;;227        energy -= x0 * x0;
00003e  ee400a40          VMLS.F32 s1,s0,s0
;;;228        energy += in * in;
000042  ee410a01          VMLA.F32 s1,s2,s2
;;;229    
;;;230        /* Set the accumulator to zero */
;;;231        sum = 0.0f;
000046  eeb00a42          VMOV.F32 s0,s4
;;;232    
;;;233        /* Loop unrolling.  Process 4 taps at a time. */
;;;234        tapCnt = numTaps >> 2;
00004a  ea4f0799          LSR      r7,r9,#2
00004e  46be              MOV      lr,r7
;;;235    
;;;236        while(tapCnt > 0u)
000050  e018              B        |L1.132|
                  |L1.82|
;;;237        {
;;;238          /* Perform the multiply-accumulate */
;;;239          sum += (*px++) * (*pb++);
000052  ecb61a01          VLDM     r6!,{s2}
000056  ecf52a01          VLDM     r5!,{s5}
00005a  ee010a22          VMLA.F32 s0,s2,s5
;;;240          sum += (*px++) * (*pb++);
00005e  ecb61a01          VLDM     r6!,{s2}
000062  ecf52a01          VLDM     r5!,{s5}
000066  ee010a22          VMLA.F32 s0,s2,s5
;;;241          sum += (*px++) * (*pb++);
00006a  ecb61a01          VLDM     r6!,{s2}
00006e  ecf52a01          VLDM     r5!,{s5}
000072  ee010a22          VMLA.F32 s0,s2,s5
;;;242          sum += (*px++) * (*pb++);
000076  ecb61a01          VLDM     r6!,{s2}
00007a  ecf52a01          VLDM     r5!,{s5}
00007e  ee010a22          VMLA.F32 s0,s2,s5
;;;243    
;;;244          /* Decrement the loop counter */
;;;245          tapCnt--;
000082  1e7f              SUBS     r7,r7,#1
                  |L1.132|
000084  2f00              CMP      r7,#0                 ;236
000086  d1e4              BNE      |L1.82|
;;;246        }
;;;247    
;;;248        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;249        tapCnt = numTaps % 0x4u;
000088  f0090703          AND      r7,r9,#3
00008c  9700              STR      r7,[sp,#0]
;;;250    
;;;251        while(tapCnt > 0u)
00008e  e006              B        |L1.158|
                  |L1.144|
;;;252        {
;;;253          /* Perform the multiply-accumulate */
;;;254          sum += (*px++) * (*pb++);
000090  ecb61a01          VLDM     r6!,{s2}
000094  ecf52a01          VLDM     r5!,{s5}
000098  ee010a22          VMLA.F32 s0,s2,s5
;;;255    
;;;256          /* Decrement the loop counter */
;;;257          tapCnt--;
00009c  1e7f              SUBS     r7,r7,#1
                  |L1.158|
00009e  2f00              CMP      r7,#0                 ;251
0000a0  d1f6              BNE      |L1.144|
;;;258        }
;;;259    
;;;260        /* The result in the accumulator, store in the destination buffer. */
;;;261        *pOut++ = sum;
0000a2  eca30a01          VSTM     r3!,{s0}
;;;262    
;;;263        /* Compute and store error */
;;;264        d = (float32_t) (*pRef++);
0000a6  ecb21a01          VLDM     r2!,{s2}
;;;265        e = d - sum;
0000aa  ee310a40          VSUB.F32 s0,s2,s0
;;;266        *pErr++ = e;
0000ae  ecaa0a01          VSTM     r10!,{s0}
;;;267    
;;;268        /* Calculation of Weighting factor for updating filter coefficients */
;;;269        /* epsilon value 0.000000119209289f */
;;;270        w = (e * mu) / (energy + 0.000000119209289f);
0000b2  ee201a21          VMUL.F32 s2,s0,s3
0000b6  ed9f0a39          VLDR     s0,|L1.412|
0000ba  ee702a80          VADD.F32 s5,s1,s0
0000be  ee810a22          VDIV.F32 s0,s2,s5
;;;271    
;;;272        /* Initialize pState pointer */
;;;273        px = pState;
0000c2  4626              MOV      r6,r4
;;;274    
;;;275        /* Initialize coeff pointer */
;;;276        pb = (pCoeffs);
0000c4  465d              MOV      r5,r11
;;;277    
;;;278        /* Loop unrolling.  Process 4 taps at a time. */
;;;279        tapCnt = numTaps >> 2;
;;;280    
;;;281        /* Update filter coefficients */
;;;282        while(tapCnt > 0u)
0000c6  e025              B        |L1.276|
                  |L1.200|
;;;283        {
;;;284          /* Perform the multiply-accumulate */
;;;285          *pb += w * (*px++);
0000c8  ecf62a01          VLDM     r6!,{s5}
0000cc  ed951a00          VLDR     s2,[r5,#0]
0000d0  ee001a22          VMLA.F32 s2,s0,s5
0000d4  ed851a00          VSTR     s2,[r5,#0]
;;;286          pb++;
0000d8  1d2d              ADDS     r5,r5,#4
;;;287    
;;;288          *pb += w * (*px++);
0000da  ecf62a01          VLDM     r6!,{s5}
0000de  ed951a00          VLDR     s2,[r5,#0]
0000e2  ee001a22          VMLA.F32 s2,s0,s5
0000e6  ed851a00          VSTR     s2,[r5,#0]
;;;289          pb++;
0000ea  1d2d              ADDS     r5,r5,#4
;;;290    
;;;291          *pb += w * (*px++);
0000ec  ecf62a01          VLDM     r6!,{s5}
0000f0  ed951a00          VLDR     s2,[r5,#0]
0000f4  ee001a22          VMLA.F32 s2,s0,s5
0000f8  ed851a00          VSTR     s2,[r5,#0]
;;;292          pb++;
0000fc  1d2d              ADDS     r5,r5,#4
;;;293    
;;;294          *pb += w * (*px++);
0000fe  ecf62a01          VLDM     r6!,{s5}
000102  ed951a00          VLDR     s2,[r5,#0]
000106  ee001a22          VMLA.F32 s2,s0,s5
00010a  ed851a00          VSTR     s2,[r5,#0]
;;;295          pb++;
00010e  1d2d              ADDS     r5,r5,#4
;;;296    
;;;297    
;;;298          /* Decrement the loop counter */
;;;299          tapCnt--;
000110  f1ae0e01          SUB      lr,lr,#1
                  |L1.276|
000114  f1be0f00          CMP      lr,#0                 ;282
000118  d1d6              BNE      |L1.200|
;;;300        }
;;;301    
;;;302        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;303        tapCnt = numTaps % 0x4u;
00011a  9f00              LDR      r7,[sp,#0]
;;;304    
;;;305        while(tapCnt > 0u)
00011c  e009              B        |L1.306|
                  |L1.286|
;;;306        {
;;;307          /* Perform the multiply-accumulate */
;;;308          *pb += w * (*px++);
00011e  ecf62a01          VLDM     r6!,{s5}
000122  ed951a00          VLDR     s2,[r5,#0]
000126  ee001a22          VMLA.F32 s2,s0,s5
00012a  ed851a00          VSTR     s2,[r5,#0]
;;;309          pb++;
00012e  1d2d              ADDS     r5,r5,#4
;;;310    
;;;311          /* Decrement the loop counter */
;;;312          tapCnt--;
000130  1e7f              SUBS     r7,r7,#1
                  |L1.306|
000132  2f00              CMP      r7,#0                 ;305
000134  d1f3              BNE      |L1.286|
;;;313        }
;;;314    
;;;315        x0 = *pState;
000136  ed940a00          VLDR     s0,[r4,#0]
;;;316    
;;;317        /* Advance state pointer by 1 for the next sample */
;;;318        pState = pState + 1;
00013a  1d24              ADDS     r4,r4,#4
;;;319    
;;;320        /* Decrement the loop counter */
;;;321        blkCnt--;
00013c  f1ac0c01          SUB      r12,r12,#1
                  |L1.320|
000140  f1bc0f00          CMP      r12,#0                ;212
000144  f47faf73          BNE      |L1.46|
;;;322      }
;;;323    
;;;324      S->energy = energy;
000148  edc00a04          VSTR     s1,[r0,#0x10]
;;;325      S->x0 = x0;
00014c  ed800a05          VSTR     s0,[r0,#0x14]
;;;326    
;;;327      /* Processing is complete. Now copy the last numTaps - 1 samples to the    
;;;328         satrt of the state buffer. This prepares the state buffer for the    
;;;329         next function call. */
;;;330    
;;;331      /* Points to the start of the pState buffer */
;;;332      pStateCurnt = S->pState;
000150  6840              LDR      r0,[r0,#4]
;;;333    
;;;334      /* Loop unrolling for (numTaps - 1u)/4 samples copy */
;;;335      tapCnt = (numTaps - 1u) >> 2u;
000152  9901              LDR      r1,[sp,#4]
000154  0889              LSRS     r1,r1,#2
;;;336    
;;;337      /* copy data */
;;;338      while(tapCnt > 0u)
000156  e010              B        |L1.378|
                  |L1.344|
;;;339      {
;;;340        *pStateCurnt++ = *pState++;
000158  ecb40a01          VLDM     r4!,{s0}
00015c  eca00a01          VSTM     r0!,{s0}
;;;341        *pStateCurnt++ = *pState++;
000160  ecb40a01          VLDM     r4!,{s0}
000164  eca00a01          VSTM     r0!,{s0}
;;;342        *pStateCurnt++ = *pState++;
000168  ecb40a01          VLDM     r4!,{s0}
00016c  eca00a01          VSTM     r0!,{s0}
;;;343        *pStateCurnt++ = *pState++;
000170  ecb40a01          VLDM     r4!,{s0}
000174  eca00a01          VSTM     r0!,{s0}
;;;344    
;;;345        /* Decrement the loop counter */
;;;346        tapCnt--;
000178  1e49              SUBS     r1,r1,#1
                  |L1.378|
00017a  2900              CMP      r1,#0                 ;338
00017c  d1ec              BNE      |L1.344|
;;;347      }
;;;348    
;;;349      /* Calculate remaining number of copies */
;;;350      tapCnt = (numTaps - 1u) % 0x4u;
00017e  9901              LDR      r1,[sp,#4]
000180  f0010103          AND      r1,r1,#3
;;;351    
;;;352      /* Copy the remaining q31_t data */
;;;353      while(tapCnt > 0u)
000184  e004              B        |L1.400|
                  |L1.390|
;;;354      {
;;;355        *pStateCurnt++ = *pState++;
000186  ecb40a01          VLDM     r4!,{s0}
00018a  eca00a01          VSTM     r0!,{s0}
;;;356    
;;;357        /* Decrement the loop counter */
;;;358        tapCnt--;
00018e  1e49              SUBS     r1,r1,#1
                  |L1.400|
000190  2900              CMP      r1,#0                 ;353
000192  d1f8              BNE      |L1.390|
;;;359      }
;;;360    
;;;361    #else
;;;362    
;;;363      /* Run the below code for Cortex-M0 */
;;;364    
;;;365      while(blkCnt > 0u)
;;;366      {
;;;367        /* Copy the new input sample into the state buffer */
;;;368        *pStateCurnt++ = *pSrc;
;;;369    
;;;370        /* Initialize pState pointer */
;;;371        px = pState;
;;;372    
;;;373        /* Initialize pCoeffs pointer */
;;;374        pb = pCoeffs;
;;;375    
;;;376        /* Read the sample from input buffer */
;;;377        in = *pSrc++;
;;;378    
;;;379        /* Update the energy calculation */
;;;380        energy -= x0 * x0;
;;;381        energy += in * in;
;;;382    
;;;383        /* Set the accumulator to zero */
;;;384        sum = 0.0f;
;;;385    
;;;386        /* Loop over numTaps number of values */
;;;387        tapCnt = numTaps;
;;;388    
;;;389        while(tapCnt > 0u)
;;;390        {
;;;391          /* Perform the multiply-accumulate */
;;;392          sum += (*px++) * (*pb++);
;;;393    
;;;394          /* Decrement the loop counter */
;;;395          tapCnt--;
;;;396        }
;;;397    
;;;398        /* The result in the accumulator is stored in the destination buffer. */
;;;399        *pOut++ = sum;
;;;400    
;;;401        /* Compute and store error */
;;;402        d = (float32_t) (*pRef++);
;;;403        e = d - sum;
;;;404        *pErr++ = e;
;;;405    
;;;406        /* Calculation of Weighting factor for updating filter coefficients */
;;;407        /* epsilon value 0.000000119209289f */
;;;408        w = (e * mu) / (energy + 0.000000119209289f);
;;;409    
;;;410        /* Initialize pState pointer */
;;;411        px = pState;
;;;412    
;;;413        /* Initialize pCcoeffs pointer */
;;;414        pb = pCoeffs;
;;;415    
;;;416        /* Loop over numTaps number of values */
;;;417        tapCnt = numTaps;
;;;418    
;;;419        while(tapCnt > 0u)
;;;420        {
;;;421          /* Perform the multiply-accumulate */
;;;422          *pb += w * (*px++);
;;;423          pb++;
;;;424    
;;;425          /* Decrement the loop counter */
;;;426          tapCnt--;
;;;427        }
;;;428    
;;;429        x0 = *pState;
;;;430    
;;;431        /* Advance state pointer by 1 for the next sample */
;;;432        pState = pState + 1;
;;;433    
;;;434        /* Decrement the loop counter */
;;;435        blkCnt--;
;;;436      }
;;;437    
;;;438      S->energy = energy;
;;;439      S->x0 = x0;
;;;440    
;;;441      /* Processing is complete. Now copy the last numTaps - 1 samples to the        
;;;442         satrt of the state buffer. This prepares the state buffer for the        
;;;443         next function call. */
;;;444    
;;;445      /* Points to the start of the pState buffer */
;;;446      pStateCurnt = S->pState;
;;;447    
;;;448      /* Copy (numTaps - 1u) samples  */
;;;449      tapCnt = (numTaps - 1u);
;;;450    
;;;451      /* Copy the remaining q31_t data */
;;;452      while(tapCnt > 0u)
;;;453      {
;;;454        *pStateCurnt++ = *pState++;
;;;455    
;;;456        /* Decrement the loop counter */
;;;457        tapCnt--;
;;;458      }
;;;459    
;;;460    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;461    
;;;462    }
000194  e8bd8ffc          POP      {r2-r11,pc}
;;;463    
                          ENDP

                  |L1.408|
000198  00000000          DCFS     0x00000000 ; 0
                  |L1.412|
00019c  34000000          DCFS     0x34000000 ; 1.1920928955078125e-07

;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_lms_norm_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_lms_norm_f32_c_ba4766a7____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___18_arm_lms_norm_f32_c_ba4766a7____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_lms_norm_f32_c_ba4766a7____REVSH|
#line 144
|__asm___18_arm_lms_norm_f32_c_ba4766a7____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_lms_norm_f32_c_ba4766a7____RRX|
#line 300
|__asm___18_arm_lms_norm_f32_c_ba4766a7____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
