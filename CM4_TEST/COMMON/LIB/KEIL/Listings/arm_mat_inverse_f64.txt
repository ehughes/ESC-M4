; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_inverse_f64.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_inverse_f64.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE\_CMSIS_DSP_4_5_O3 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_mat_inverse_f64.crf ..\..\SRC\CMSIS_DSP_4_5\src\MatrixFunctions\arm_mat_inverse_f64.c]
                          THUMB

                          AREA ||i.arm_mat_inverse_f64||, CODE, READONLY, ALIGN=2

                  arm_mat_inverse_f64 PROC
;;;84     
;;;85     arm_status arm_mat_inverse_f64(
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;86       const arm_matrix_instance_f64 * pSrc,
;;;87       arm_matrix_instance_f64 * pDst)
;;;88     {
000004  ed2d8b08          VPUSH    {d8-d11}
000008  b097              SUB      sp,sp,#0x5c
;;;89       float64_t *pIn = pSrc->pData;                  /* input data matrix pointer */
00000a  981f              LDR      r0,[sp,#0x7c]
00000c  6840              LDR      r0,[r0,#4]
;;;90       float64_t *pOut = pDst->pData;                 /* output data matrix pointer */
00000e  900c              STR      r0,[sp,#0x30]
;;;91       float64_t *pInT1, *pInT2;                      /* Temporary input data matrix pointer */
;;;92       float64_t *pOutT1, *pOutT2;                    /* Temporary output data matrix pointer */
;;;93       float64_t *pPivotRowIn, *pPRT_in, *pPivotRowDst, *pPRT_pDst;  /* Temporary input and output data matrix pointer */
;;;94       uint32_t numRows = pSrc->numRows;              /* Number of rows in the matrix  */
000010  981f              LDR      r0,[sp,#0x7c]
000012  6849              LDR      r1,[r1,#4]            ;90
000014  910d              STR      r1,[sp,#0x34]
000016  f8b09000          LDRH     r9,[r0,#0]
;;;95       uint32_t numCols = pSrc->numCols;              /* Number of Cols in the matrix  */
00001a  8844              LDRH     r4,[r0,#2]
;;;96     
;;;97     #ifndef ARM_MATH_CM0_FAMILY
;;;98       float64_t maxC;                                /* maximum value in the column */
;;;99     
;;;100      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;101    
;;;102      float64_t Xchg, in = 0.0f, in1;                /* Temporary input values  */
00001c  ed9f8bca          VLDR     d8,|L1.840|
;;;103      uint32_t i, rowCnt, flag = 0u, j, loopCnt, k, l;      /* loop counters */
000020  2000              MOVS     r0,#0
;;;104      arm_status status;                             /* status of matrix inverse */
;;;105    
;;;106    #ifdef ARM_MATH_MATRIX_CHECK
;;;107    
;;;108    
;;;109      /* Check for matrix mismatch condition */
;;;110      if((pSrc->numRows != pSrc->numCols) || (pDst->numRows != pDst->numCols)
;;;111         || (pSrc->numRows != pDst->numRows))
;;;112      {
;;;113        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;114        status = ARM_MATH_SIZE_MISMATCH;
;;;115      }
;;;116      else
;;;117    #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;118    
;;;119      {
;;;120    
;;;121        /*--------------------------------------------------------------------------------------------------------------    
;;;122    	 * Matrix Inverse can be solved using elementary row operations.    
;;;123    	 *    
;;;124    	 *	Gauss-Jordan Method:    
;;;125    	 *    
;;;126    	 *	   1. First combine the identity matrix and the input matrix separated by a bar to form an    
;;;127    	 *        augmented matrix as follows:    
;;;128    	 *				        _ 	      	       _         _	       _    
;;;129    	 *					   |  a11  a12 | 1   0  |       |  X11 X12  |    
;;;130    	 *					   |           |        |   =   |           |    
;;;131    	 *					   |_ a21  a22 | 0   1 _|       |_ X21 X21 _|    
;;;132    	 *    
;;;133    	 *		2. In our implementation, pDst Matrix is used as identity matrix.    
;;;134    	 *    
;;;135    	 *		3. Begin with the first row. Let i = 1.    
;;;136    	 *    
;;;137    	 *	    4. Check to see if the pivot for column i is the greatest of the column.    
;;;138    	 *		   The pivot is the element of the main diagonal that is on the current row.    
;;;139    	 *		   For instance, if working with row i, then the pivot element is aii.    
;;;140    	 *		   If the pivot is not the most significant of the columns, exchange that row with a row
;;;141    	 *		   below it that does contain the most significant value in column i. If the most
;;;142    	 *         significant value of the column is zero, then an inverse to that matrix does not exist.
;;;143    	 *		   The most significant value of the column is the absolute maximum.
;;;144    	 *    
;;;145    	 *	    5. Divide every element of row i by the pivot.    
;;;146    	 *    
;;;147    	 *	    6. For every row below and  row i, replace that row with the sum of that row and    
;;;148    	 *		   a multiple of row i so that each new element in column i below row i is zero.    
;;;149    	 *    
;;;150    	 *	    7. Move to the next row and column and repeat steps 2 through 5 until you have zeros    
;;;151    	 *		   for every element below and above the main diagonal.    
;;;152    	 *    
;;;153    	 *		8. Now an identical matrix is formed to the left of the bar(input matrix, pSrc).    
;;;154    	 *		   Therefore, the matrix to the right of the bar is our solution(pDst matrix, pDst).    
;;;155    	 *----------------------------------------------------------------------------------------------------------------*/
;;;156    
;;;157        /* Working pointer for destination matrix */
;;;158        pOutT1 = pOut;
;;;159    
;;;160        /* Loop over the number of rows */
;;;161        rowCnt = numRows;
000022  900b              STR      r0,[sp,#0x2c]
000024  eeb09a48          VMOV.F32 s18,s16               ;102
000028  eef09a68          VMOV.F32 s19,s17               ;102
00002c  4648              MOV      r0,r9
;;;162    
;;;163        /* Making the destination matrix as identity matrix */
;;;164        while(rowCnt > 0u)
;;;165        {
;;;166          /* Writing all zeroes in lower triangle of the destination matrix */
;;;167          j = numRows - rowCnt;
;;;168          while(j > 0u)
;;;169          {
;;;170            *pOutT1++ = 0.0f;
;;;171            j--;
;;;172          }
;;;173    
;;;174          /* Writing all ones in the diagonal of the destination matrix */
;;;175          *pOutT1++ = 1.0f;
00002e  ed9f1bc8          VLDR     d1,|L1.848|
000032  e01b              B        |L1.108|
                  |L1.52|
000034  eba90200          SUB      r2,r9,r0              ;167
000038  e007              B        |L1.74|
00003a  bf00              NOP                            ;170
                  |L1.60|
00003c  eeb00a48          VMOV.F32 s0,s16                ;170
000040  eef00a68          VMOV.F32 s1,s17                ;170
000044  eca10b02          VSTM     r1!,{d0}              ;170
000048  1e52              SUBS     r2,r2,#1              ;170
                  |L1.74|
00004a  2a00              CMP      r2,#0                 ;168
00004c  d1f6              BNE      |L1.60|
00004e  eca11b02          VSTM     r1!,{d1}
;;;176    
;;;177          /* Writing all zeroes in upper triangle of the destination matrix */
;;;178          j = rowCnt - 1u;
000052  1e42              SUBS     r2,r0,#1
000054  eeb00a48          VMOV.F32 s0,s16                ;102
000058  eef00a68          VMOV.F32 s1,s17                ;102
;;;179          while(j > 0u)
00005c  e003              B        |L1.102|
;;;180          {
;;;181            *pOutT1++ = 0.0f;
00005e  bf00              NOP      
                  |L1.96|
000060  eca10b02          VSTM     r1!,{d0}
000064  1e52              SUBS     r2,r2,#1
                  |L1.102|
000066  2a00              CMP      r2,#0                 ;179
000068  d1fa              BNE      |L1.96|
00006a  1e40              SUBS     r0,r0,#1              ;179
                  |L1.108|
00006c  2800              CMP      r0,#0                 ;164
00006e  d1e1              BNE      |L1.52|
;;;182            j--;
;;;183          }
;;;184    
;;;185          /* Decrement the loop counter */
;;;186          rowCnt--;
;;;187        }
;;;188    
;;;189        /* Loop over the number of columns of the input matrix.    
;;;190           All the elements in each column are processed by the row operations */
;;;191        loopCnt = numCols;
;;;192    
;;;193        /* Index modifier to navigate through the columns */
;;;194        l = 0u;
;;;195    
;;;196        while(loopCnt > 0u)
000070  9412              STR      r4,[sp,#0x48]
000072  e13f              B        |L1.756|
                  |L1.116|
;;;197        {
;;;198          /* Check if the pivot element is zero..    
;;;199           * If it is zero then interchange the row with non zero row below.    
;;;200           * If there is no non zero element to replace in the rows below,    
;;;201           * then the matrix is Singular. */
;;;202    
;;;203          /* Working pointer for the input matrix that points    
;;;204           * to the pivot element of the particular row  */
;;;205          pInT1 = pIn + (l * numCols);
000074  990c              LDR      r1,[sp,#0x30]
000076  fb0af004          MUL      r0,r10,r4
00007a  eb0105c0          ADD      r5,r1,r0,LSL #3
;;;206    
;;;207          /* Working pointer for the destination matrix that points    
;;;208           * to the pivot element of the particular row  */
;;;209          pOutT1 = pOut + (l * numCols);
00007e  9508              STR      r5,[sp,#0x20]
000080  990d              LDR      r1,[sp,#0x34]
;;;210    
;;;211          /* Temporary variable to hold the pivot value */
;;;212          in = *pInT1;
;;;213    
;;;214          /* Grab the most significant value from column l */
;;;215          maxC = 0;
000082  eeb09a48          VMOV.F32 s18,s16
000086  eb0106c0          ADD      r6,r1,r0,LSL #3       ;209
00008a  9606              STR      r6,[sp,#0x18]         ;212
00008c  ed95bb00          VLDR     d11,[r5,#0]           ;212
000090  eef09a68          VMOV.F32 s19,s17
;;;216          for (i = l; i < numRows; i++)
000094  4657              MOV      r7,r10
000096  eeb0aa48          VMOV.F32 s20,s16               ;102
00009a  eef0aa68          VMOV.F32 s21,s17               ;102
00009e  e028              B        |L1.242|
                  |L1.160|
;;;217          {
;;;218            maxC = *pInT1 > 0 ? (*pInT1 > maxC ? *pInT1 : maxC) : (-*pInT1 > maxC ? -*pInT1 : maxC);
0000a0  ed950b00          VLDR     d0,[r5,#0]
0000a4  ec532b1a          VMOV     r2,r3,d10
0000a8  ec510b10          VMOV     r0,r1,d0
0000ac  f7fffffe          BL       __aeabi_cdrcmple
0000b0  ed950b00          VLDR     d0,[r5,#0]
0000b4  d209              BCS      |L1.202|
0000b6  ec532b19          VMOV     r2,r3,d9
0000ba  ec510b10          VMOV     r0,r1,d0
0000be  f7fffffe          BL       __aeabi_cdrcmple
0000c2  d213              BCS      |L1.236|
0000c4  ed959b00          VLDR     d9,[r5,#0]
0000c8  e010              B        |L1.236|
                  |L1.202|
0000ca  ec510b10          VMOV     r0,r1,d0
0000ce  f7fffffe          BL       __aeabi_dneg
0000d2  ec532b19          VMOV     r2,r3,d9
0000d6  f7fffffe          BL       __aeabi_cdrcmple
0000da  d207              BCS      |L1.236|
0000dc  ed950b00          VLDR     d0,[r5,#0]
0000e0  ec510b10          VMOV     r0,r1,d0
0000e4  f7fffffe          BL       __aeabi_dneg
0000e8  ec410b19          VMOV     d9,r0,r1
                  |L1.236|
;;;219            pInT1 += numCols;
0000ec  eb0505c4          ADD      r5,r5,r4,LSL #3
0000f0  1c7f              ADDS     r7,r7,#1
                  |L1.242|
0000f2  454f              CMP      r7,r9                 ;216
0000f4  d3d4              BCC      |L1.160|
;;;220          }
;;;221    
;;;222          /* Update the status if the matrix is singular */
;;;223          if(maxC == 0.0f)
0000f6  ec532b1a          VMOV     r2,r3,d10
0000fa  ec510b19          VMOV     r0,r1,d9
0000fe  f7fffffe          BL       __aeabi_cdcmpeq
000102  d071              BEQ      |L1.488|
;;;224          {
;;;225            return ARM_MATH_SINGULAR;
;;;226          }
;;;227    
;;;228          /* Restore pInT1  */
;;;229          pInT1 = pIn;
;;;230    
;;;231          /* Destination pointer modifier */
;;;232          k = 1u;
000104  2001              MOVS     r0,#1
;;;233          
;;;234          /* Check if the pivot element is the most significant of the column */
;;;235          if( (in > 0.0f ? in : -in) != maxC)
000106  900a              STR      r0,[sp,#0x28]
000108  9f0c              LDR      r7,[sp,#0x30]         ;232
00010a  ec532b1a          VMOV     r2,r3,d10
00010e  ec510b1b          VMOV     r0,r1,d11
000112  f7fffffe          BL       __aeabi_cdrcmple
000116  d204              BCS      |L1.290|
000118  eeb00a4b          VMOV.F32 s0,s22
00011c  eef00a6b          VMOV.F32 s1,s23
000120  e005              B        |L1.302|
                  |L1.290|
000122  ec510b1b          VMOV     r0,r1,d11
000126  f7fffffe          BL       __aeabi_dneg
00012a  ec410b10          VMOV     d0,r0,r1
                  |L1.302|
00012e  ec532b19          VMOV     r2,r3,d9
000132  ec510b10          VMOV     r0,r1,d0
000136  f7fffffe          BL       __aeabi_cdcmpeq
00013a  d04b              BEQ      |L1.468|
;;;236          {
;;;237            /* Loop over the number rows present below */
;;;238            i = numRows - (l + 1u);
00013c  eba9000a          SUB      r0,r9,r10
000140  1e40              SUBS     r0,r0,#1
;;;239    
;;;240            while(i > 0u)
000142  e044              B        |L1.462|
                  |L1.324|
;;;241            {
;;;242              /* Update the input and destination pointers */
;;;243              pInT2 = pInT1 + (numCols * l);
000144  fb04f00a          MUL      r0,r4,r10
000148  eb0705c0          ADD      r5,r7,r0,LSL #3
;;;244              pOutT2 = pOutT1 + (numCols * k);
00014c  980a              LDR      r0,[sp,#0x28]
;;;245    
;;;246              /* Look for the most significant element to    
;;;247               * replace in the rows below */
;;;248              if((*pInT2 > 0.0f ? *pInT2: -*pInT2) == maxC)
00014e  ed950b00          VLDR     d0,[r5,#0]
000152  4360              MULS     r0,r4,r0              ;244
000154  eb0608c0          ADD      r8,r6,r0,LSL #3       ;244
000158  ec532b1a          VMOV     r2,r3,d10
00015c  ec510b10          VMOV     r0,r1,d0
000160  f7fffffe          BL       __aeabi_cdrcmple
000164  ed950b00          VLDR     d0,[r5,#0]
000168  d305              BCC      |L1.374|
00016a  ec510b10          VMOV     r0,r1,d0
00016e  f7fffffe          BL       __aeabi_dneg
000172  ec410b10          VMOV     d0,r0,r1
                  |L1.374|
000176  ec532b19          VMOV     r2,r3,d9
00017a  ec510b10          VMOV     r0,r1,d0
00017e  f7fffffe          BL       __aeabi_cdcmpeq
000182  d11f              BNE      |L1.452|
;;;249              {
;;;250                /* Loop over number of columns    
;;;251                 * to the right of the pilot element */
;;;252                j = numCols - l;
000184  eba4000a          SUB      r0,r4,r10
;;;253    
;;;254                while(j > 0u)
000188  e009              B        |L1.414|
;;;255                {
;;;256                  /* Exchange the row elements of the input matrix */
;;;257                  Xchg = *pInT2;
00018a  bf00              NOP      
                  |L1.396|
00018c  ed950b00          VLDR     d0,[r5,#0]
;;;258                  *pInT2++ = *pInT1;
000190  ed971b00          VLDR     d1,[r7,#0]
;;;259                  *pInT1++ = Xchg;
000194  1e40              SUBS     r0,r0,#1
000196  eca51b02          VSTM     r5!,{d1}              ;258
00019a  eca70b02          VSTM     r7!,{d0}
                  |L1.414|
00019e  2800              CMP      r0,#0                 ;254
0001a0  d1f4              BNE      |L1.396|
;;;260    
;;;261                  /* Decrement the loop counter */
;;;262                  j--;
;;;263                }
;;;264    
;;;265                /* Loop over number of columns of the destination matrix */
;;;266                j = numCols;
0001a2  4620              MOV      r0,r4
;;;267    
;;;268                while(j > 0u)
0001a4  e009              B        |L1.442|
;;;269                {
;;;270                  /* Exchange the row elements of the destination matrix */
;;;271                  Xchg = *pOutT2;
0001a6  bf00              NOP      
                  |L1.424|
0001a8  ed980b00          VLDR     d0,[r8,#0]
;;;272                  *pOutT2++ = *pOutT1;
0001ac  ed961b00          VLDR     d1,[r6,#0]
;;;273                  *pOutT1++ = Xchg;
0001b0  1e40              SUBS     r0,r0,#1
0001b2  eca81b02          VSTM     r8!,{d1}              ;272
0001b6  eca60b02          VSTM     r6!,{d0}
                  |L1.442|
0001ba  2800              CMP      r0,#0                 ;268
0001bc  d1f4              BNE      |L1.424|
;;;274    
;;;275                  /* Decrement the loop counter */
;;;276                  j--;
;;;277                }
;;;278    
;;;279                /* Flag to indicate whether exchange is done or not */
;;;280                flag = 1u;
0001be  2001              MOVS     r0,#1
;;;281    
;;;282                /* Break after exchange is done */
;;;283                break;
0001c0  900b              STR      r0,[sp,#0x2c]
0001c2  e018              B        |L1.502|
                  |L1.452|
;;;284              }
;;;285    
;;;286              /* Update the destination pointer modifier */
;;;287              k++;
0001c4  980a              LDR      r0,[sp,#0x28]
0001c6  1c40              ADDS     r0,r0,#1
;;;288    
;;;289              /* Decrement the loop counter */
;;;290              i--;
0001c8  900a              STR      r0,[sp,#0x28]
0001ca  f1ab0001          SUB      r0,r11,#1
                  |L1.462|
0001ce  ea5f0b00          MOVS     r11,r0                ;238
0001d2  d1b7              BNE      |L1.324|
                  |L1.468|
;;;291            }
;;;292          }
;;;293    
;;;294          /* Update the status if the matrix is singular */
;;;295          if((flag != 1u) && (in == 0.0f))
0001d4  980b              LDR      r0,[sp,#0x2c]
0001d6  2801              CMP      r0,#1
0001d8  d00d              BEQ      |L1.502|
0001da  ec532b1a          VMOV     r2,r3,d10
0001de  ec510b1b          VMOV     r0,r1,d11
0001e2  f7fffffe          BL       __aeabi_cdcmpeq
0001e6  d106              BNE      |L1.502|
                  |L1.488|
;;;296          {
;;;297            return ARM_MATH_SINGULAR;
0001e8  f06f0004          MVN      r0,#4
                  |L1.492|
;;;298          }
;;;299    
;;;300          /* Points to the pivot row of input and destination matrices */
;;;301          pPivotRowIn = pIn + (l * numCols);
;;;302          pPivotRowDst = pOut + (l * numCols);
;;;303    
;;;304          /* Temporary pointers to the pivot row pointers */
;;;305          pInT1 = pPivotRowIn;
;;;306          pInT2 = pPivotRowDst;
;;;307    
;;;308          /* Pivot element of the row */
;;;309          in = *pPivotRowIn;
;;;310    
;;;311          /* Loop over number of columns    
;;;312           * to the right of the pilot element */
;;;313          j = (numCols - l);
;;;314    
;;;315          while(j > 0u)
;;;316          {
;;;317            /* Divide each element of the row of the input matrix    
;;;318             * by the pivot element */
;;;319            in1 = *pInT1;
;;;320            *pInT1++ = in1 / in;
;;;321    
;;;322            /* Decrement the loop counter */
;;;323            j--;
;;;324          }
;;;325    
;;;326          /* Loop over number of columns of the destination matrix */
;;;327          j = numCols;
;;;328    
;;;329          while(j > 0u)
;;;330          {
;;;331            /* Divide each element of the row of the destination matrix    
;;;332             * by the pivot element */
;;;333            in1 = *pInT2;
;;;334            *pInT2++ = in1 / in;
;;;335    
;;;336            /* Decrement the loop counter */
;;;337            j--;
;;;338          }
;;;339    
;;;340          /* Replace the rows with the sum of that row and a multiple of row i    
;;;341           * so that each new element in column i above row i is zero.*/
;;;342    
;;;343          /* Temporary pointers for input and destination matrices */
;;;344          pInT1 = pIn;
;;;345          pInT2 = pOut;
;;;346    
;;;347          /* index used to check for pivot element */
;;;348          i = 0u;
;;;349    
;;;350          /* Loop over number of rows */
;;;351          /*  to be replaced by the sum of that row and a multiple of row i */
;;;352          k = numRows;
;;;353    
;;;354          while(k > 0u)
;;;355          {
;;;356            /* Check for the pivot element */
;;;357            if(i == l)
;;;358            {
;;;359              /* If the processing element is the pivot element,    
;;;360                 only the columns to the right are to be processed */
;;;361              pInT1 += numCols - l;
;;;362    
;;;363              pInT2 += numCols;
;;;364            }
;;;365            else
;;;366            {
;;;367              /* Element of the reference row */
;;;368              in = *pInT1;
;;;369    
;;;370              /* Working pointers for input and destination pivot rows */
;;;371              pPRT_in = pPivotRowIn;
;;;372              pPRT_pDst = pPivotRowDst;
;;;373    
;;;374              /* Loop over the number of columns to the right of the pivot element,    
;;;375                 to replace the elements in the input matrix */
;;;376              j = (numCols - l);
;;;377    
;;;378              while(j > 0u)
;;;379              {
;;;380                /* Replace the element by the sum of that row    
;;;381                   and a multiple of the reference row  */
;;;382                in1 = *pInT1;
;;;383                *pInT1++ = in1 - (in * *pPRT_in++);
;;;384    
;;;385                /* Decrement the loop counter */
;;;386                j--;
;;;387              }
;;;388    
;;;389              /* Loop over the number of columns to    
;;;390                 replace the elements in the destination matrix */
;;;391              j = numCols;
;;;392    
;;;393              while(j > 0u)
;;;394              {
;;;395                /* Replace the element by the sum of that row    
;;;396                   and a multiple of the reference row  */
;;;397                in1 = *pInT2;
;;;398                *pInT2++ = in1 - (in * *pPRT_pDst++);
;;;399    
;;;400                /* Decrement the loop counter */
;;;401                j--;
;;;402              }
;;;403    
;;;404            }
;;;405    
;;;406            /* Increment the temporary input pointer */
;;;407            pInT1 = pInT1 + l;
;;;408    
;;;409            /* Decrement the loop counter */
;;;410            k--;
;;;411    
;;;412            /* Increment the pivot index */
;;;413            i++;
;;;414          }
;;;415    
;;;416          /* Increment the input pointer */
;;;417          pIn++;
;;;418    
;;;419          /* Decrement the loop counter */
;;;420          loopCnt--;
;;;421    
;;;422          /* Increment the index modifier */
;;;423          l++;
;;;424        }
;;;425    
;;;426    
;;;427    #else
;;;428    
;;;429      /* Run the below code for Cortex-M0 */
;;;430    
;;;431      float64_t Xchg, in = 0.0f;                     /* Temporary input values  */
;;;432      uint32_t i, rowCnt, flag = 0u, j, loopCnt, k, l;      /* loop counters */
;;;433      arm_status status;                             /* status of matrix inverse */
;;;434    
;;;435    #ifdef ARM_MATH_MATRIX_CHECK
;;;436    
;;;437      /* Check for matrix mismatch condition */
;;;438      if((pSrc->numRows != pSrc->numCols) || (pDst->numRows != pDst->numCols)
;;;439         || (pSrc->numRows != pDst->numRows))
;;;440      {
;;;441        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;442        status = ARM_MATH_SIZE_MISMATCH;
;;;443      }
;;;444      else
;;;445    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;446      {
;;;447    
;;;448        /*--------------------------------------------------------------------------------------------------------------       
;;;449    	 * Matrix Inverse can be solved using elementary row operations.        
;;;450    	 *        
;;;451    	 *	Gauss-Jordan Method:       
;;;452    	 *	 	       
;;;453    	 *	   1. First combine the identity matrix and the input matrix separated by a bar to form an        
;;;454    	 *        augmented matrix as follows:        
;;;455    	 *				        _  _	      _	    _	   _   _         _	       _       
;;;456    	 *					   |  |  a11  a12  | | | 1   0  |   |       |  X11 X12  |         
;;;457    	 *					   |  |            | | |        |   |   =   |           |        
;;;458    	 *					   |_ |_ a21  a22 _| | |_0   1 _|  _|       |_ X21 X21 _|       
;;;459    	 *					          
;;;460    	 *		2. In our implementation, pDst Matrix is used as identity matrix.    
;;;461    	 *       
;;;462    	 *		3. Begin with the first row. Let i = 1.       
;;;463    	 *       
;;;464    	 *	    4. Check to see if the pivot for row i is zero.       
;;;465    	 *		   The pivot is the element of the main diagonal that is on the current row.       
;;;466    	 *		   For instance, if working with row i, then the pivot element is aii.       
;;;467    	 *		   If the pivot is zero, exchange that row with a row below it that does not        
;;;468    	 *		   contain a zero in column i. If this is not possible, then an inverse        
;;;469    	 *		   to that matrix does not exist.       
;;;470    	 *	       
;;;471    	 *	    5. Divide every element of row i by the pivot.       
;;;472    	 *	       
;;;473    	 *	    6. For every row below and  row i, replace that row with the sum of that row and        
;;;474    	 *		   a multiple of row i so that each new element in column i below row i is zero.       
;;;475    	 *	       
;;;476    	 *	    7. Move to the next row and column and repeat steps 2 through 5 until you have zeros       
;;;477    	 *		   for every element below and above the main diagonal.        
;;;478    	 *		   		          
;;;479    	 *		8. Now an identical matrix is formed to the left of the bar(input matrix, src).       
;;;480    	 *		   Therefore, the matrix to the right of the bar is our solution(dst matrix, dst).         
;;;481    	 *----------------------------------------------------------------------------------------------------------------*/
;;;482    
;;;483        /* Working pointer for destination matrix */
;;;484        pOutT1 = pOut;
;;;485    
;;;486        /* Loop over the number of rows */
;;;487        rowCnt = numRows;
;;;488    
;;;489        /* Making the destination matrix as identity matrix */
;;;490        while(rowCnt > 0u)
;;;491        {
;;;492          /* Writing all zeroes in lower triangle of the destination matrix */
;;;493          j = numRows - rowCnt;
;;;494          while(j > 0u)
;;;495          {
;;;496            *pOutT1++ = 0.0f;
;;;497            j--;
;;;498          }
;;;499    
;;;500          /* Writing all ones in the diagonal of the destination matrix */
;;;501          *pOutT1++ = 1.0f;
;;;502    
;;;503          /* Writing all zeroes in upper triangle of the destination matrix */
;;;504          j = rowCnt - 1u;
;;;505          while(j > 0u)
;;;506          {
;;;507            *pOutT1++ = 0.0f;
;;;508            j--;
;;;509          }
;;;510    
;;;511          /* Decrement the loop counter */
;;;512          rowCnt--;
;;;513        }
;;;514    
;;;515        /* Loop over the number of columns of the input matrix.     
;;;516           All the elements in each column are processed by the row operations */
;;;517        loopCnt = numCols;
;;;518    
;;;519        /* Index modifier to navigate through the columns */
;;;520        l = 0u;
;;;521        //for(loopCnt = 0u; loopCnt < numCols; loopCnt++)   
;;;522        while(loopCnt > 0u)
;;;523        {
;;;524          /* Check if the pivot element is zero..    
;;;525           * If it is zero then interchange the row with non zero row below.   
;;;526           * If there is no non zero element to replace in the rows below,   
;;;527           * then the matrix is Singular. */
;;;528    
;;;529          /* Working pointer for the input matrix that points     
;;;530           * to the pivot element of the particular row  */
;;;531          pInT1 = pIn + (l * numCols);
;;;532    
;;;533          /* Working pointer for the destination matrix that points     
;;;534           * to the pivot element of the particular row  */
;;;535          pOutT1 = pOut + (l * numCols);
;;;536    
;;;537          /* Temporary variable to hold the pivot value */
;;;538          in = *pInT1;
;;;539    
;;;540          /* Destination pointer modifier */
;;;541          k = 1u;
;;;542    
;;;543          /* Check if the pivot element is zero */
;;;544          if(*pInT1 == 0.0f)
;;;545          {
;;;546            /* Loop over the number rows present below */
;;;547            for (i = (l + 1u); i < numRows; i++)
;;;548            {
;;;549              /* Update the input and destination pointers */
;;;550              pInT2 = pInT1 + (numCols * l);
;;;551              pOutT2 = pOutT1 + (numCols * k);
;;;552    
;;;553              /* Check if there is a non zero pivot element to     
;;;554               * replace in the rows below */
;;;555              if(*pInT2 != 0.0f)
;;;556              {
;;;557                /* Loop over number of columns     
;;;558                 * to the right of the pilot element */
;;;559                for (j = 0u; j < (numCols - l); j++)
;;;560                {
;;;561                  /* Exchange the row elements of the input matrix */
;;;562                  Xchg = *pInT2;
;;;563                  *pInT2++ = *pInT1;
;;;564                  *pInT1++ = Xchg;
;;;565                }
;;;566    
;;;567                for (j = 0u; j < numCols; j++)
;;;568                {
;;;569                  Xchg = *pOutT2;
;;;570                  *pOutT2++ = *pOutT1;
;;;571                  *pOutT1++ = Xchg;
;;;572                }
;;;573    
;;;574                /* Flag to indicate whether exchange is done or not */
;;;575                flag = 1u;
;;;576    
;;;577                /* Break after exchange is done */
;;;578                break;
;;;579              }
;;;580    
;;;581              /* Update the destination pointer modifier */
;;;582              k++;
;;;583            }
;;;584          }
;;;585    
;;;586          /* Update the status if the matrix is singular */
;;;587          if((flag != 1u) && (in == 0.0f))
;;;588          {
;;;589            return ARM_MATH_SINGULAR;
;;;590          }
;;;591    
;;;592          /* Points to the pivot row of input and destination matrices */
;;;593          pPivotRowIn = pIn + (l * numCols);
;;;594          pPivotRowDst = pOut + (l * numCols);
;;;595    
;;;596          /* Temporary pointers to the pivot row pointers */
;;;597          pInT1 = pPivotRowIn;
;;;598          pOutT1 = pPivotRowDst;
;;;599    
;;;600          /* Pivot element of the row */
;;;601          in = *(pIn + (l * numCols));
;;;602    
;;;603          /* Loop over number of columns     
;;;604           * to the right of the pilot element */
;;;605          for (j = 0u; j < (numCols - l); j++)
;;;606          {
;;;607            /* Divide each element of the row of the input matrix     
;;;608             * by the pivot element */
;;;609            *pInT1 = *pInT1 / in;
;;;610            pInT1++;
;;;611          }
;;;612          for (j = 0u; j < numCols; j++)
;;;613          {
;;;614            /* Divide each element of the row of the destination matrix     
;;;615             * by the pivot element */
;;;616            *pOutT1 = *pOutT1 / in;
;;;617            pOutT1++;
;;;618          }
;;;619    
;;;620          /* Replace the rows with the sum of that row and a multiple of row i     
;;;621           * so that each new element in column i above row i is zero.*/
;;;622    
;;;623          /* Temporary pointers for input and destination matrices */
;;;624          pInT1 = pIn;
;;;625          pOutT1 = pOut;
;;;626    
;;;627          for (i = 0u; i < numRows; i++)
;;;628          {
;;;629            /* Check for the pivot element */
;;;630            if(i == l)
;;;631            {
;;;632              /* If the processing element is the pivot element,     
;;;633                 only the columns to the right are to be processed */
;;;634              pInT1 += numCols - l;
;;;635              pOutT1 += numCols;
;;;636            }
;;;637            else
;;;638            {
;;;639              /* Element of the reference row */
;;;640              in = *pInT1;
;;;641    
;;;642              /* Working pointers for input and destination pivot rows */
;;;643              pPRT_in = pPivotRowIn;
;;;644              pPRT_pDst = pPivotRowDst;
;;;645    
;;;646              /* Loop over the number of columns to the right of the pivot element,     
;;;647                 to replace the elements in the input matrix */
;;;648              for (j = 0u; j < (numCols - l); j++)
;;;649              {
;;;650                /* Replace the element by the sum of that row     
;;;651                   and a multiple of the reference row  */
;;;652                *pInT1 = *pInT1 - (in * *pPRT_in++);
;;;653                pInT1++;
;;;654              }
;;;655              /* Loop over the number of columns to     
;;;656                 replace the elements in the destination matrix */
;;;657              for (j = 0u; j < numCols; j++)
;;;658              {
;;;659                /* Replace the element by the sum of that row     
;;;660                   and a multiple of the reference row  */
;;;661                *pOutT1 = *pOutT1 - (in * *pPRT_pDst++);
;;;662                pOutT1++;
;;;663              }
;;;664    
;;;665            }
;;;666            /* Increment the temporary input pointer */
;;;667            pInT1 = pInT1 + l;
;;;668          }
;;;669          /* Increment the input pointer */
;;;670          pIn++;
;;;671    
;;;672          /* Decrement the loop counter */
;;;673          loopCnt--;
;;;674          /* Increment the index modifier */
;;;675          l++;
;;;676        }
;;;677    
;;;678    
;;;679    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;680    
;;;681        /* Set status as ARM_MATH_SUCCESS */
;;;682        status = ARM_MATH_SUCCESS;
;;;683    
;;;684        if((flag != 1u) && (in == 0.0f))
;;;685        {
;;;686          pIn = pSrc->pData;
;;;687          for (i = 0; i < numRows * numCols; i++)
;;;688          {
;;;689            if (pIn[i] != 0.0f)
;;;690                break;
;;;691          }
;;;692          
;;;693          if (i == numRows * numCols)
;;;694            status = ARM_MATH_SINGULAR;
;;;695        }
;;;696      }
;;;697      /* Return to application */
;;;698      return (status);
;;;699    }
0001ec  b017              ADD      sp,sp,#0x5c
0001ee  ecbd8b08          VPOP     {d8-d11}
0001f2  e8bd8ffc          POP      {r2-r11,pc}
                  |L1.502|
0001f6  9d08              LDR      r5,[sp,#0x20]         ;302
0001f8  9e06              LDR      r6,[sp,#0x18]         ;302
0001fa  9611              STR      r6,[sp,#0x44]         ;309
0001fc  ed959b00          VLDR     d9,[r5,#0]            ;309
000200  eba4070a          SUB      r7,r4,r10             ;313
000204  9704              STR      r7,[sp,#0x10]         ;315
000206  e00a              B        |L1.542|
                  |L1.520|
000208  ed950b00          VLDR     d0,[r5,#0]            ;319
00020c  ec532b19          VMOV     r2,r3,d9              ;320
000210  ec510b10          VMOV     r0,r1,d0              ;320
000214  f7fffffe          BL       __aeabi_ddiv
000218  e8e50102          STRD     r0,r1,[r5],#8         ;320
00021c  1e7f              SUBS     r7,r7,#1              ;320
                  |L1.542|
00021e  2f00              CMP      r7,#0                 ;315
000220  d1f2              BNE      |L1.520|
000222  4625              MOV      r5,r4                 ;327
000224  e00b              B        |L1.574|
000226  bf00              NOP                            ;333
                  |L1.552|
000228  ed960b00          VLDR     d0,[r6,#0]            ;333
00022c  ec532b19          VMOV     r2,r3,d9              ;334
000230  ec510b10          VMOV     r0,r1,d0              ;334
000234  f7fffffe          BL       __aeabi_ddiv
000238  e8e60102          STRD     r0,r1,[r6],#8         ;334
00023c  1e6d              SUBS     r5,r5,#1              ;334
                  |L1.574|
00023e  2d00              CMP      r5,#0                 ;329
000240  d1f2              BNE      |L1.552|
000242  e9dd560c          LDRD     r5,r6,[sp,#0x30]      ;348
000246  2000              MOVS     r0,#0                 ;348
000248  9003              STR      r0,[sp,#0xc]          ;352
00024a  4648              MOV      r0,r9                 ;352
00024c  f8cd9028          STR      r9,[sp,#0x28]         ;354
000250  e046              B        |L1.736|
                  |L1.594|
000252  9803              LDR      r0,[sp,#0xc]          ;357
000254  4550              CMP      r0,r10                ;357
000256  d105              BNE      |L1.612|
000258  9804              LDR      r0,[sp,#0x10]         ;361
00025a  eb0606c4          ADD      r6,r6,r4,LSL #3       ;363
00025e  eb0505c0          ADD      r5,r5,r0,LSL #3       ;361
000262  e034              B        |L1.718|
                  |L1.612|
000264  ed959b00          VLDR     d9,[r5,#0]            ;368
000268  f8ddb020          LDR      r11,[sp,#0x20]        ;378
00026c  f8dd8044          LDR      r8,[sp,#0x44]         ;378
000270  9f04              LDR      r7,[sp,#0x10]         ;378
000272  e012              B        |L1.666|
                  |L1.628|
000274  ed9b0b00          VLDR     d0,[r11,#0]           ;383
000278  ed95ab00          VLDR     d10,[r5,#0]           ;382
00027c  ec532b10          VMOV     r2,r3,d0              ;383
000280  ec510b19          VMOV     r0,r1,d9              ;383
000284  f7fffffe          BL       __aeabi_dmul
000288  ec532b1a          VMOV     r2,r3,d10             ;383
00028c  f7fffffe          BL       __aeabi_drsub
000290  e8e50102          STRD     r0,r1,[r5],#8         ;383
000294  f10b0b08          ADD      r11,r11,#8            ;383
000298  1e7f              SUBS     r7,r7,#1              ;383
                  |L1.666|
00029a  2f00              CMP      r7,#0                 ;378
00029c  d1ea              BNE      |L1.628|
00029e  4627              MOV      r7,r4                 ;391
0002a0  e013              B        |L1.714|
0002a2  bf00              NOP                            ;397
                  |L1.676|
0002a4  ed980b00          VLDR     d0,[r8,#0]            ;398
0002a8  ed96ab00          VLDR     d10,[r6,#0]           ;397
0002ac  ec532b10          VMOV     r2,r3,d0              ;398
0002b0  ec510b19          VMOV     r0,r1,d9              ;398
0002b4  f7fffffe          BL       __aeabi_dmul
0002b8  ec532b1a          VMOV     r2,r3,d10             ;398
0002bc  f7fffffe          BL       __aeabi_drsub
0002c0  e8e60102          STRD     r0,r1,[r6],#8         ;398
0002c4  f1080808          ADD      r8,r8,#8              ;398
0002c8  1e7f              SUBS     r7,r7,#1              ;398
                  |L1.714|
0002ca  2f00              CMP      r7,#0                 ;393
0002cc  d1ea              BNE      |L1.676|
                  |L1.718|
0002ce  980a              LDR      r0,[sp,#0x28]         ;410
0002d0  eb0505ca          ADD      r5,r5,r10,LSL #3      ;407
0002d4  1e40              SUBS     r0,r0,#1              ;410
0002d6  900a              STR      r0,[sp,#0x28]         ;413
0002d8  9803              LDR      r0,[sp,#0xc]          ;413
0002da  1c40              ADDS     r0,r0,#1              ;413
0002dc  9003              STR      r0,[sp,#0xc]          ;354
0002de  980a              LDR      r0,[sp,#0x28]         ;354
                  |L1.736|
0002e0  2800              CMP      r0,#0                 ;354
0002e2  d1b6              BNE      |L1.594|
0002e4  980c              LDR      r0,[sp,#0x30]         ;417
0002e6  3008              ADDS     r0,r0,#8              ;417
0002e8  900c              STR      r0,[sp,#0x30]         ;420
0002ea  9812              LDR      r0,[sp,#0x48]         ;420
0002ec  1e40              SUBS     r0,r0,#1              ;420
0002ee  9012              STR      r0,[sp,#0x48]         ;423
0002f0  f10a0001          ADD      r0,r10,#1             ;423
                  |L1.756|
0002f4  4682              MOV      r10,r0                ;194
0002f6  9812              LDR      r0,[sp,#0x48]         ;196
0002f8  2800              CMP      r0,#0                 ;196
0002fa  f47faebb          BNE      |L1.116|
0002fe  980b              LDR      r0,[sp,#0x2c]         ;684
000300  2600              MOVS     r6,#0                 ;682
000302  2801              CMP      r0,#1                 ;684
000304  d01e              BEQ      |L1.836|
000306  ec532b18          VMOV     r2,r3,d8              ;684
00030a  ec510b19          VMOV     r0,r1,d9              ;684
00030e  f7fffffe          BL       __aeabi_cdcmpeq
000312  d117              BNE      |L1.836|
000314  981f              LDR      r0,[sp,#0x7c]         ;686
000316  2500              MOVS     r5,#0                 ;687
000318  fb09f804          MUL      r8,r9,r4              ;687
00031c  6847              LDR      r7,[r0,#4]            ;687
00031e  e00b              B        |L1.824|
                  |L1.800|
000320  eb0700c5          ADD      r0,r7,r5,LSL #3       ;689
000324  ec532b18          VMOV     r2,r3,d8              ;689
000328  ed900b00          VLDR     d0,[r0,#0]            ;689
00032c  ec510b10          VMOV     r0,r1,d0              ;689
000330  f7fffffe          BL       __aeabi_cdcmpeq
000334  d102              BNE      |L1.828|
000336  1c6d              ADDS     r5,r5,#1              ;689
                  |L1.824|
000338  45a8              CMP      r8,r5                 ;687
00033a  d8f1              BHI      |L1.800|
                  |L1.828|
00033c  45a8              CMP      r8,r5                 ;693
00033e  d101              BNE      |L1.836|
000340  f06f0604          MVN      r6,#4                 ;694
                  |L1.836|
000344  4630              MOV      r0,r6                 ;698
000346  e751              B        |L1.492|
;;;700    
                          ENDP

                  |L1.840|
000348  00000000          DCFD     0x0000000000000000 ; 0
00034c  00000000
                  |L1.848|
000350  00000000          DCFD     0x3ff0000000000000 ; 1
000354  3ff00000

;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\MatrixFunctions\\arm_mat_inverse_f64.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_mat_inverse_f64_c_3978fe55____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___21_arm_mat_inverse_f64_c_3978fe55____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_mat_inverse_f64_c_3978fe55____REVSH|
#line 144
|__asm___21_arm_mat_inverse_f64_c_3978fe55____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_mat_inverse_f64_c_3978fe55____RRX|
#line 300
|__asm___21_arm_mat_inverse_f64_c_3978fe55____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
