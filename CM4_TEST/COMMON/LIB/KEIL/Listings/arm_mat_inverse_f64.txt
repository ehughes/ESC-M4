; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_inverse_f64.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_inverse_f64.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_mat_inverse_f64.crf ..\..\SRC\CMSIS_DSP_4_5\src\MatrixFunctions\arm_mat_inverse_f64.c]
                          THUMB

                          AREA ||i.arm_mat_inverse_f64||, CODE, READONLY, ALIGN=2

                  arm_mat_inverse_f64 PROC
;;;84     
;;;85     arm_status arm_mat_inverse_f64(
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;86       const arm_matrix_instance_f64 * pSrc,
;;;87       arm_matrix_instance_f64 * pDst)
;;;88     {
000004  ed2d8b08          VPUSH    {d8-d11}
000008  b08b              SUB      sp,sp,#0x2c
;;;89       float64_t *pIn = pSrc->pData;                  /* input data matrix pointer */
00000a  9813              LDR      r0,[sp,#0x4c]
00000c  6840              LDR      r0,[r0,#4]
00000e  9007              STR      r0,[sp,#0x1c]
;;;90       float64_t *pOut = pDst->pData;                 /* output data matrix pointer */
000010  6848              LDR      r0,[r1,#4]
000012  9006              STR      r0,[sp,#0x18]
;;;91       float64_t *pInT1, *pInT2;                      /* Temporary input data matrix pointer */
;;;92       float64_t *pOutT1, *pOutT2;                    /* Temporary output data matrix pointer */
;;;93       float64_t *pPivotRowIn, *pPRT_in, *pPivotRowDst, *pPRT_pDst;  /* Temporary input and output data matrix pointer */
;;;94       uint32_t numRows = pSrc->numRows;              /* Number of rows in the matrix  */
000014  9813              LDR      r0,[sp,#0x4c]
000016  8801              LDRH     r1,[r0,#0]
000018  9103              STR      r1,[sp,#0xc]
;;;95       uint32_t numCols = pSrc->numCols;              /* Number of Cols in the matrix  */
00001a  9813              LDR      r0,[sp,#0x4c]
00001c  8845              LDRH     r5,[r0,#2]
;;;96     
;;;97     #ifndef ARM_MATH_CM0_FAMILY
;;;98       float64_t maxC;                                /* maximum value in the column */
;;;99     
;;;100      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;101    
;;;102      float64_t Xchg, in = 0.0f, in1;                /* Temporary input values  */
00001e  ed9fbbcd          VLDR     d11,|L1.852|
000022  eeb09a4b          VMOV.F32 s18,s22
000026  eef09a6b          VMOV.F32 s19,s23
;;;103      uint32_t i, rowCnt, flag = 0u, j, loopCnt, k, l;      /* loop counters */
00002a  2000              MOVS     r0,#0
00002c  9001              STR      r0,[sp,#4]
;;;104      arm_status status;                             /* status of matrix inverse */
;;;105    
;;;106    #ifdef ARM_MATH_MATRIX_CHECK
;;;107    
;;;108    
;;;109      /* Check for matrix mismatch condition */
;;;110      if((pSrc->numRows != pSrc->numCols) || (pDst->numRows != pDst->numCols)
;;;111         || (pSrc->numRows != pDst->numRows))
;;;112      {
;;;113        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;114        status = ARM_MATH_SIZE_MISMATCH;
;;;115      }
;;;116      else
;;;117    #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;118    
;;;119      {
;;;120    
;;;121        /*--------------------------------------------------------------------------------------------------------------    
;;;122    	 * Matrix Inverse can be solved using elementary row operations.    
;;;123    	 *    
;;;124    	 *	Gauss-Jordan Method:    
;;;125    	 *    
;;;126    	 *	   1. First combine the identity matrix and the input matrix separated by a bar to form an    
;;;127    	 *        augmented matrix as follows:    
;;;128    	 *				        _ 	      	       _         _	       _    
;;;129    	 *					   |  a11  a12 | 1   0  |       |  X11 X12  |    
;;;130    	 *					   |           |        |   =   |           |    
;;;131    	 *					   |_ a21  a22 | 0   1 _|       |_ X21 X21 _|    
;;;132    	 *    
;;;133    	 *		2. In our implementation, pDst Matrix is used as identity matrix.    
;;;134    	 *    
;;;135    	 *		3. Begin with the first row. Let i = 1.    
;;;136    	 *    
;;;137    	 *	    4. Check to see if the pivot for column i is the greatest of the column.    
;;;138    	 *		   The pivot is the element of the main diagonal that is on the current row.    
;;;139    	 *		   For instance, if working with row i, then the pivot element is aii.    
;;;140    	 *		   If the pivot is not the most significant of the columns, exchange that row with a row
;;;141    	 *		   below it that does contain the most significant value in column i. If the most
;;;142    	 *         significant value of the column is zero, then an inverse to that matrix does not exist.
;;;143    	 *		   The most significant value of the column is the absolute maximum.
;;;144    	 *    
;;;145    	 *	    5. Divide every element of row i by the pivot.    
;;;146    	 *    
;;;147    	 *	    6. For every row below and  row i, replace that row with the sum of that row and    
;;;148    	 *		   a multiple of row i so that each new element in column i below row i is zero.    
;;;149    	 *    
;;;150    	 *	    7. Move to the next row and column and repeat steps 2 through 5 until you have zeros    
;;;151    	 *		   for every element below and above the main diagonal.    
;;;152    	 *    
;;;153    	 *		8. Now an identical matrix is formed to the left of the bar(input matrix, pSrc).    
;;;154    	 *		   Therefore, the matrix to the right of the bar is our solution(pDst matrix, pDst).    
;;;155    	 *----------------------------------------------------------------------------------------------------------------*/
;;;156    
;;;157        /* Working pointer for destination matrix */
;;;158        pOutT1 = pOut;
00002e  9806              LDR      r0,[sp,#0x18]
;;;159    
;;;160        /* Loop over the number of rows */
;;;161        rowCnt = numRows;
000030  9903              LDR      r1,[sp,#0xc]
000032  e017              B        |L1.100|
                  |L1.52|
;;;162    
;;;163        /* Making the destination matrix as identity matrix */
;;;164        while(rowCnt > 0u)
;;;165        {
;;;166          /* Writing all zeroes in lower triangle of the destination matrix */
;;;167          j = numRows - rowCnt;
000034  9a03              LDR      r2,[sp,#0xc]
000036  1a52              SUBS     r2,r2,r1
000038  eeb00a4b          VMOV.F32 s0,s22                ;102
00003c  eef00a6b          VMOV.F32 s1,s23                ;102
;;;168          while(j > 0u)
000040  e002              B        |L1.72|
                  |L1.66|
;;;169          {
;;;170            *pOutT1++ = 0.0f;
000042  eca00b02          VSTM     r0!,{d0}
;;;171            j--;
000046  1e52              SUBS     r2,r2,#1
                  |L1.72|
000048  2a00              CMP      r2,#0                 ;168
00004a  d1fa              BNE      |L1.66|
;;;172          }
;;;173    
;;;174          /* Writing all ones in the diagonal of the destination matrix */
;;;175          *pOutT1++ = 1.0f;
00004c  ed9f1bc3          VLDR     d1,|L1.860|
000050  eca01b02          VSTM     r0!,{d1}
;;;176    
;;;177          /* Writing all zeroes in upper triangle of the destination matrix */
;;;178          j = rowCnt - 1u;
000054  1e4a              SUBS     r2,r1,#1
;;;179          while(j > 0u)
000056  e002              B        |L1.94|
                  |L1.88|
;;;180          {
;;;181            *pOutT1++ = 0.0f;
000058  eca00b02          VSTM     r0!,{d0}
;;;182            j--;
00005c  1e52              SUBS     r2,r2,#1
                  |L1.94|
00005e  2a00              CMP      r2,#0                 ;179
000060  d1fa              BNE      |L1.88|
;;;183          }
;;;184    
;;;185          /* Decrement the loop counter */
;;;186          rowCnt--;
000062  1e49              SUBS     r1,r1,#1
                  |L1.100|
000064  2900              CMP      r1,#0                 ;164
000066  d1e5              BNE      |L1.52|
;;;187        }
;;;188    
;;;189        /* Loop over the number of columns of the input matrix.    
;;;190           All the elements in each column are processed by the row operations */
;;;191        loopCnt = numCols;
000068  9500              STR      r5,[sp,#0]
;;;192    
;;;193        /* Index modifier to navigate through the columns */
;;;194        l = 0u;
00006a  2600              MOVS     r6,#0
;;;195    
;;;196        while(loopCnt > 0u)
00006c  e149              B        |L1.770|
                  |L1.110|
;;;197        {
;;;198          /* Check if the pivot element is zero..    
;;;199           * If it is zero then interchange the row with non zero row below.    
;;;200           * If there is no non zero element to replace in the rows below,    
;;;201           * then the matrix is Singular. */
;;;202    
;;;203          /* Working pointer for the input matrix that points    
;;;204           * to the pivot element of the particular row  */
;;;205          pInT1 = pIn + (l * numCols);
00006e  9907              LDR      r1,[sp,#0x1c]
000070  fb06f005          MUL      r0,r6,r5
000074  eb0104c0          ADD      r4,r1,r0,LSL #3
000078  940a              STR      r4,[sp,#0x28]
;;;206    
;;;207          /* Working pointer for the destination matrix that points    
;;;208           * to the pivot element of the particular row  */
;;;209          pOutT1 = pOut + (l * numCols);
00007a  9906              LDR      r1,[sp,#0x18]
00007c  eb0108c0          ADD      r8,r1,r0,LSL #3
000080  f8cd8024          STR      r8,[sp,#0x24]
;;;210    
;;;211          /* Temporary variable to hold the pivot value */
;;;212          in = *pInT1;
000084  ed94ab00          VLDR     d10,[r4,#0]
;;;213    
;;;214          /* Grab the most significant value from column l */
;;;215          maxC = 0;
000088  eeb08a4b          VMOV.F32 s16,s22
00008c  eef08a6b          VMOV.F32 s17,s23
;;;216          for (i = l; i < numRows; i++)
000090  4637              MOV      r7,r6
000092  eeb09a48          VMOV.F32 s18,s16               ;102
000096  eef09a68          VMOV.F32 s19,s17               ;102
00009a  e030              B        |L1.254|
                  |L1.156|
;;;217          {
;;;218            maxC = *pInT1 > 0 ? (*pInT1 > maxC ? *pInT1 : maxC) : (-*pInT1 > maxC ? -*pInT1 : maxC);
00009c  ed940b00          VLDR     d0,[r4,#0]
0000a0  ec532b19          VMOV     r2,r3,d9
0000a4  ec510b10          VMOV     r0,r1,d0
0000a8  f7fffffe          BL       __aeabi_cdrcmple
0000ac  d20e              BCS      |L1.204|
0000ae  ed940b00          VLDR     d0,[r4,#0]
0000b2  ec532b18          VMOV     r2,r3,d8
0000b6  ec510b10          VMOV     r0,r1,d0
0000ba  f7fffffe          BL       __aeabi_cdrcmple
0000be  d202              BCS      |L1.198|
0000c0  e9d40100          LDRD     r0,r1,[r4,#0]
0000c4  e016              B        |L1.244|
                  |L1.198|
0000c6  ec510b18          VMOV     r0,r1,d8
0000ca  e013              B        |L1.244|
                  |L1.204|
0000cc  ed940b00          VLDR     d0,[r4,#0]
0000d0  ec510b10          VMOV     r0,r1,d0
0000d4  f7fffffe          BL       __aeabi_dneg
0000d8  ec532b18          VMOV     r2,r3,d8
0000dc  f7fffffe          BL       __aeabi_cdrcmple
0000e0  d206              BCS      |L1.240|
0000e2  ed940b00          VLDR     d0,[r4,#0]
0000e6  ec510b10          VMOV     r0,r1,d0
0000ea  f7fffffe          BL       __aeabi_dneg
0000ee  e001              B        |L1.244|
                  |L1.240|
0000f0  ec510b18          VMOV     r0,r1,d8
                  |L1.244|
0000f4  ec410b18          VMOV     d8,r0,r1
;;;219            pInT1 += numCols;
0000f8  eb0404c5          ADD      r4,r4,r5,LSL #3
0000fc  1c7f              ADDS     r7,r7,#1              ;216
                  |L1.254|
0000fe  9803              LDR      r0,[sp,#0xc]          ;216
000100  4287              CMP      r7,r0                 ;216
000102  d3cb              BCC      |L1.156|
;;;220          }
;;;221    
;;;222          /* Update the status if the matrix is singular */
;;;223          if(maxC == 0.0f)
000104  ec532b19          VMOV     r2,r3,d9
000108  ec510b18          VMOV     r0,r1,d8
00010c  f7fffffe          BL       __aeabi_cdcmpeq
000110  d106              BNE      |L1.288|
;;;224          {
;;;225            return ARM_MATH_SINGULAR;
000112  f06f0004          MVN      r0,#4
                  |L1.278|
;;;226          }
;;;227    
;;;228          /* Restore pInT1  */
;;;229          pInT1 = pIn;
;;;230    
;;;231          /* Destination pointer modifier */
;;;232          k = 1u;
;;;233          
;;;234          /* Check if the pivot element is the most significant of the column */
;;;235          if( (in > 0.0f ? in : -in) != maxC)
;;;236          {
;;;237            /* Loop over the number rows present below */
;;;238            i = numRows - (l + 1u);
;;;239    
;;;240            while(i > 0u)
;;;241            {
;;;242              /* Update the input and destination pointers */
;;;243              pInT2 = pInT1 + (numCols * l);
;;;244              pOutT2 = pOutT1 + (numCols * k);
;;;245    
;;;246              /* Look for the most significant element to    
;;;247               * replace in the rows below */
;;;248              if((*pInT2 > 0.0f ? *pInT2: -*pInT2) == maxC)
;;;249              {
;;;250                /* Loop over number of columns    
;;;251                 * to the right of the pilot element */
;;;252                j = numCols - l;
;;;253    
;;;254                while(j > 0u)
;;;255                {
;;;256                  /* Exchange the row elements of the input matrix */
;;;257                  Xchg = *pInT2;
;;;258                  *pInT2++ = *pInT1;
;;;259                  *pInT1++ = Xchg;
;;;260    
;;;261                  /* Decrement the loop counter */
;;;262                  j--;
;;;263                }
;;;264    
;;;265                /* Loop over number of columns of the destination matrix */
;;;266                j = numCols;
;;;267    
;;;268                while(j > 0u)
;;;269                {
;;;270                  /* Exchange the row elements of the destination matrix */
;;;271                  Xchg = *pOutT2;
;;;272                  *pOutT2++ = *pOutT1;
;;;273                  *pOutT1++ = Xchg;
;;;274    
;;;275                  /* Decrement the loop counter */
;;;276                  j--;
;;;277                }
;;;278    
;;;279                /* Flag to indicate whether exchange is done or not */
;;;280                flag = 1u;
;;;281    
;;;282                /* Break after exchange is done */
;;;283                break;
;;;284              }
;;;285    
;;;286              /* Update the destination pointer modifier */
;;;287              k++;
;;;288    
;;;289              /* Decrement the loop counter */
;;;290              i--;
;;;291            }
;;;292          }
;;;293    
;;;294          /* Update the status if the matrix is singular */
;;;295          if((flag != 1u) && (in == 0.0f))
;;;296          {
;;;297            return ARM_MATH_SINGULAR;
;;;298          }
;;;299    
;;;300          /* Points to the pivot row of input and destination matrices */
;;;301          pPivotRowIn = pIn + (l * numCols);
;;;302          pPivotRowDst = pOut + (l * numCols);
;;;303    
;;;304          /* Temporary pointers to the pivot row pointers */
;;;305          pInT1 = pPivotRowIn;
;;;306          pInT2 = pPivotRowDst;
;;;307    
;;;308          /* Pivot element of the row */
;;;309          in = *pPivotRowIn;
;;;310    
;;;311          /* Loop over number of columns    
;;;312           * to the right of the pilot element */
;;;313          j = (numCols - l);
;;;314    
;;;315          while(j > 0u)
;;;316          {
;;;317            /* Divide each element of the row of the input matrix    
;;;318             * by the pivot element */
;;;319            in1 = *pInT1;
;;;320            *pInT1++ = in1 / in;
;;;321    
;;;322            /* Decrement the loop counter */
;;;323            j--;
;;;324          }
;;;325    
;;;326          /* Loop over number of columns of the destination matrix */
;;;327          j = numCols;
;;;328    
;;;329          while(j > 0u)
;;;330          {
;;;331            /* Divide each element of the row of the destination matrix    
;;;332             * by the pivot element */
;;;333            in1 = *pInT2;
;;;334            *pInT2++ = in1 / in;
;;;335    
;;;336            /* Decrement the loop counter */
;;;337            j--;
;;;338          }
;;;339    
;;;340          /* Replace the rows with the sum of that row and a multiple of row i    
;;;341           * so that each new element in column i above row i is zero.*/
;;;342    
;;;343          /* Temporary pointers for input and destination matrices */
;;;344          pInT1 = pIn;
;;;345          pInT2 = pOut;
;;;346    
;;;347          /* index used to check for pivot element */
;;;348          i = 0u;
;;;349    
;;;350          /* Loop over number of rows */
;;;351          /*  to be replaced by the sum of that row and a multiple of row i */
;;;352          k = numRows;
;;;353    
;;;354          while(k > 0u)
;;;355          {
;;;356            /* Check for the pivot element */
;;;357            if(i == l)
;;;358            {
;;;359              /* If the processing element is the pivot element,    
;;;360                 only the columns to the right are to be processed */
;;;361              pInT1 += numCols - l;
;;;362    
;;;363              pInT2 += numCols;
;;;364            }
;;;365            else
;;;366            {
;;;367              /* Element of the reference row */
;;;368              in = *pInT1;
;;;369    
;;;370              /* Working pointers for input and destination pivot rows */
;;;371              pPRT_in = pPivotRowIn;
;;;372              pPRT_pDst = pPivotRowDst;
;;;373    
;;;374              /* Loop over the number of columns to the right of the pivot element,    
;;;375                 to replace the elements in the input matrix */
;;;376              j = (numCols - l);
;;;377    
;;;378              while(j > 0u)
;;;379              {
;;;380                /* Replace the element by the sum of that row    
;;;381                   and a multiple of the reference row  */
;;;382                in1 = *pInT1;
;;;383                *pInT1++ = in1 - (in * *pPRT_in++);
;;;384    
;;;385                /* Decrement the loop counter */
;;;386                j--;
;;;387              }
;;;388    
;;;389              /* Loop over the number of columns to    
;;;390                 replace the elements in the destination matrix */
;;;391              j = numCols;
;;;392    
;;;393              while(j > 0u)
;;;394              {
;;;395                /* Replace the element by the sum of that row    
;;;396                   and a multiple of the reference row  */
;;;397                in1 = *pInT2;
;;;398                *pInT2++ = in1 - (in * *pPRT_pDst++);
;;;399    
;;;400                /* Decrement the loop counter */
;;;401                j--;
;;;402              }
;;;403    
;;;404            }
;;;405    
;;;406            /* Increment the temporary input pointer */
;;;407            pInT1 = pInT1 + l;
;;;408    
;;;409            /* Decrement the loop counter */
;;;410            k--;
;;;411    
;;;412            /* Increment the pivot index */
;;;413            i++;
;;;414          }
;;;415    
;;;416          /* Increment the input pointer */
;;;417          pIn++;
;;;418    
;;;419          /* Decrement the loop counter */
;;;420          loopCnt--;
;;;421    
;;;422          /* Increment the index modifier */
;;;423          l++;
;;;424        }
;;;425    
;;;426    
;;;427    #else
;;;428    
;;;429      /* Run the below code for Cortex-M0 */
;;;430    
;;;431      float64_t Xchg, in = 0.0f;                     /* Temporary input values  */
;;;432      uint32_t i, rowCnt, flag = 0u, j, loopCnt, k, l;      /* loop counters */
;;;433      arm_status status;                             /* status of matrix inverse */
;;;434    
;;;435    #ifdef ARM_MATH_MATRIX_CHECK
;;;436    
;;;437      /* Check for matrix mismatch condition */
;;;438      if((pSrc->numRows != pSrc->numCols) || (pDst->numRows != pDst->numCols)
;;;439         || (pSrc->numRows != pDst->numRows))
;;;440      {
;;;441        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;442        status = ARM_MATH_SIZE_MISMATCH;
;;;443      }
;;;444      else
;;;445    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;446      {
;;;447    
;;;448        /*--------------------------------------------------------------------------------------------------------------       
;;;449    	 * Matrix Inverse can be solved using elementary row operations.        
;;;450    	 *        
;;;451    	 *	Gauss-Jordan Method:       
;;;452    	 *	 	       
;;;453    	 *	   1. First combine the identity matrix and the input matrix separated by a bar to form an        
;;;454    	 *        augmented matrix as follows:        
;;;455    	 *				        _  _	      _	    _	   _   _         _	       _       
;;;456    	 *					   |  |  a11  a12  | | | 1   0  |   |       |  X11 X12  |         
;;;457    	 *					   |  |            | | |        |   |   =   |           |        
;;;458    	 *					   |_ |_ a21  a22 _| | |_0   1 _|  _|       |_ X21 X21 _|       
;;;459    	 *					          
;;;460    	 *		2. In our implementation, pDst Matrix is used as identity matrix.    
;;;461    	 *       
;;;462    	 *		3. Begin with the first row. Let i = 1.       
;;;463    	 *       
;;;464    	 *	    4. Check to see if the pivot for row i is zero.       
;;;465    	 *		   The pivot is the element of the main diagonal that is on the current row.       
;;;466    	 *		   For instance, if working with row i, then the pivot element is aii.       
;;;467    	 *		   If the pivot is zero, exchange that row with a row below it that does not        
;;;468    	 *		   contain a zero in column i. If this is not possible, then an inverse        
;;;469    	 *		   to that matrix does not exist.       
;;;470    	 *	       
;;;471    	 *	    5. Divide every element of row i by the pivot.       
;;;472    	 *	       
;;;473    	 *	    6. For every row below and  row i, replace that row with the sum of that row and        
;;;474    	 *		   a multiple of row i so that each new element in column i below row i is zero.       
;;;475    	 *	       
;;;476    	 *	    7. Move to the next row and column and repeat steps 2 through 5 until you have zeros       
;;;477    	 *		   for every element below and above the main diagonal.        
;;;478    	 *		   		          
;;;479    	 *		8. Now an identical matrix is formed to the left of the bar(input matrix, src).       
;;;480    	 *		   Therefore, the matrix to the right of the bar is our solution(dst matrix, dst).         
;;;481    	 *----------------------------------------------------------------------------------------------------------------*/
;;;482    
;;;483        /* Working pointer for destination matrix */
;;;484        pOutT1 = pOut;
;;;485    
;;;486        /* Loop over the number of rows */
;;;487        rowCnt = numRows;
;;;488    
;;;489        /* Making the destination matrix as identity matrix */
;;;490        while(rowCnt > 0u)
;;;491        {
;;;492          /* Writing all zeroes in lower triangle of the destination matrix */
;;;493          j = numRows - rowCnt;
;;;494          while(j > 0u)
;;;495          {
;;;496            *pOutT1++ = 0.0f;
;;;497            j--;
;;;498          }
;;;499    
;;;500          /* Writing all ones in the diagonal of the destination matrix */
;;;501          *pOutT1++ = 1.0f;
;;;502    
;;;503          /* Writing all zeroes in upper triangle of the destination matrix */
;;;504          j = rowCnt - 1u;
;;;505          while(j > 0u)
;;;506          {
;;;507            *pOutT1++ = 0.0f;
;;;508            j--;
;;;509          }
;;;510    
;;;511          /* Decrement the loop counter */
;;;512          rowCnt--;
;;;513        }
;;;514    
;;;515        /* Loop over the number of columns of the input matrix.     
;;;516           All the elements in each column are processed by the row operations */
;;;517        loopCnt = numCols;
;;;518    
;;;519        /* Index modifier to navigate through the columns */
;;;520        l = 0u;
;;;521        //for(loopCnt = 0u; loopCnt < numCols; loopCnt++)   
;;;522        while(loopCnt > 0u)
;;;523        {
;;;524          /* Check if the pivot element is zero..    
;;;525           * If it is zero then interchange the row with non zero row below.   
;;;526           * If there is no non zero element to replace in the rows below,   
;;;527           * then the matrix is Singular. */
;;;528    
;;;529          /* Working pointer for the input matrix that points     
;;;530           * to the pivot element of the particular row  */
;;;531          pInT1 = pIn + (l * numCols);
;;;532    
;;;533          /* Working pointer for the destination matrix that points     
;;;534           * to the pivot element of the particular row  */
;;;535          pOutT1 = pOut + (l * numCols);
;;;536    
;;;537          /* Temporary variable to hold the pivot value */
;;;538          in = *pInT1;
;;;539    
;;;540          /* Destination pointer modifier */
;;;541          k = 1u;
;;;542    
;;;543          /* Check if the pivot element is zero */
;;;544          if(*pInT1 == 0.0f)
;;;545          {
;;;546            /* Loop over the number rows present below */
;;;547            for (i = (l + 1u); i < numRows; i++)
;;;548            {
;;;549              /* Update the input and destination pointers */
;;;550              pInT2 = pInT1 + (numCols * l);
;;;551              pOutT2 = pOutT1 + (numCols * k);
;;;552    
;;;553              /* Check if there is a non zero pivot element to     
;;;554               * replace in the rows below */
;;;555              if(*pInT2 != 0.0f)
;;;556              {
;;;557                /* Loop over number of columns     
;;;558                 * to the right of the pilot element */
;;;559                for (j = 0u; j < (numCols - l); j++)
;;;560                {
;;;561                  /* Exchange the row elements of the input matrix */
;;;562                  Xchg = *pInT2;
;;;563                  *pInT2++ = *pInT1;
;;;564                  *pInT1++ = Xchg;
;;;565                }
;;;566    
;;;567                for (j = 0u; j < numCols; j++)
;;;568                {
;;;569                  Xchg = *pOutT2;
;;;570                  *pOutT2++ = *pOutT1;
;;;571                  *pOutT1++ = Xchg;
;;;572                }
;;;573    
;;;574                /* Flag to indicate whether exchange is done or not */
;;;575                flag = 1u;
;;;576    
;;;577                /* Break after exchange is done */
;;;578                break;
;;;579              }
;;;580    
;;;581              /* Update the destination pointer modifier */
;;;582              k++;
;;;583            }
;;;584          }
;;;585    
;;;586          /* Update the status if the matrix is singular */
;;;587          if((flag != 1u) && (in == 0.0f))
;;;588          {
;;;589            return ARM_MATH_SINGULAR;
;;;590          }
;;;591    
;;;592          /* Points to the pivot row of input and destination matrices */
;;;593          pPivotRowIn = pIn + (l * numCols);
;;;594          pPivotRowDst = pOut + (l * numCols);
;;;595    
;;;596          /* Temporary pointers to the pivot row pointers */
;;;597          pInT1 = pPivotRowIn;
;;;598          pOutT1 = pPivotRowDst;
;;;599    
;;;600          /* Pivot element of the row */
;;;601          in = *(pIn + (l * numCols));
;;;602    
;;;603          /* Loop over number of columns     
;;;604           * to the right of the pilot element */
;;;605          for (j = 0u; j < (numCols - l); j++)
;;;606          {
;;;607            /* Divide each element of the row of the input matrix     
;;;608             * by the pivot element */
;;;609            *pInT1 = *pInT1 / in;
;;;610            pInT1++;
;;;611          }
;;;612          for (j = 0u; j < numCols; j++)
;;;613          {
;;;614            /* Divide each element of the row of the destination matrix     
;;;615             * by the pivot element */
;;;616            *pOutT1 = *pOutT1 / in;
;;;617            pOutT1++;
;;;618          }
;;;619    
;;;620          /* Replace the rows with the sum of that row and a multiple of row i     
;;;621           * so that each new element in column i above row i is zero.*/
;;;622    
;;;623          /* Temporary pointers for input and destination matrices */
;;;624          pInT1 = pIn;
;;;625          pOutT1 = pOut;
;;;626    
;;;627          for (i = 0u; i < numRows; i++)
;;;628          {
;;;629            /* Check for the pivot element */
;;;630            if(i == l)
;;;631            {
;;;632              /* If the processing element is the pivot element,     
;;;633                 only the columns to the right are to be processed */
;;;634              pInT1 += numCols - l;
;;;635              pOutT1 += numCols;
;;;636            }
;;;637            else
;;;638            {
;;;639              /* Element of the reference row */
;;;640              in = *pInT1;
;;;641    
;;;642              /* Working pointers for input and destination pivot rows */
;;;643              pPRT_in = pPivotRowIn;
;;;644              pPRT_pDst = pPivotRowDst;
;;;645    
;;;646              /* Loop over the number of columns to the right of the pivot element,     
;;;647                 to replace the elements in the input matrix */
;;;648              for (j = 0u; j < (numCols - l); j++)
;;;649              {
;;;650                /* Replace the element by the sum of that row     
;;;651                   and a multiple of the reference row  */
;;;652                *pInT1 = *pInT1 - (in * *pPRT_in++);
;;;653                pInT1++;
;;;654              }
;;;655              /* Loop over the number of columns to     
;;;656                 replace the elements in the destination matrix */
;;;657              for (j = 0u; j < numCols; j++)
;;;658              {
;;;659                /* Replace the element by the sum of that row     
;;;660                   and a multiple of the reference row  */
;;;661                *pOutT1 = *pOutT1 - (in * *pPRT_pDst++);
;;;662                pOutT1++;
;;;663              }
;;;664    
;;;665            }
;;;666            /* Increment the temporary input pointer */
;;;667            pInT1 = pInT1 + l;
;;;668          }
;;;669          /* Increment the input pointer */
;;;670          pIn++;
;;;671    
;;;672          /* Decrement the loop counter */
;;;673          loopCnt--;
;;;674          /* Increment the index modifier */
;;;675          l++;
;;;676        }
;;;677    
;;;678    
;;;679    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;680    
;;;681        /* Set status as ARM_MATH_SUCCESS */
;;;682        status = ARM_MATH_SUCCESS;
;;;683    
;;;684        if((flag != 1u) && (in == 0.0f))
;;;685        {
;;;686          pIn = pSrc->pData;
;;;687          for (i = 0; i < numRows * numCols; i++)
;;;688          {
;;;689            if (pIn[i] != 0.0f)
;;;690                break;
;;;691          }
;;;692          
;;;693          if (i == numRows * numCols)
;;;694            status = ARM_MATH_SINGULAR;
;;;695        }
;;;696      }
;;;697      /* Return to application */
;;;698      return (status);
;;;699    }
000116  b00b              ADD      sp,sp,#0x2c
000118  ecbd8b08          VPOP     {d8-d11}
00011c  e8bd8ffc          POP      {r2-r11,pc}
                  |L1.288|
000120  9f07              LDR      r7,[sp,#0x1c]         ;229
000122  f04f0b01          MOV      r11,#1                ;232
000126  ec532b19          VMOV     r2,r3,d9              ;235
00012a  ec510b1a          VMOV     r0,r1,d10             ;235
00012e  f7fffffe          BL       __aeabi_cdrcmple
000132  d202              BCS      |L1.314|
000134  ec510b1a          VMOV     r0,r1,d10             ;235
000138  e003              B        |L1.322|
                  |L1.314|
00013a  ec510b1a          VMOV     r0,r1,d10             ;235
00013e  f7fffffe          BL       __aeabi_dneg
                  |L1.322|
000142  ec532b18          VMOV     r2,r3,d8              ;235
000146  f7fffffe          BL       __aeabi_cdcmpeq
00014a  d048              BEQ      |L1.478|
00014c  9803              LDR      r0,[sp,#0xc]          ;238
00014e  eba00a06          SUB      r10,r0,r6             ;238
000152  f1aa0a01          SUB      r10,r10,#1            ;238
000156  e03f              B        |L1.472|
                  |L1.344|
000158  fb05f006          MUL      r0,r5,r6              ;243
00015c  eb0704c0          ADD      r4,r7,r0,LSL #3       ;243
000160  fb05f00b          MUL      r0,r5,r11             ;244
000164  eb0809c0          ADD      r9,r8,r0,LSL #3       ;244
000168  ed940b00          VLDR     d0,[r4,#0]            ;248
00016c  ec532b19          VMOV     r2,r3,d9              ;248
000170  ec510b10          VMOV     r0,r1,d0              ;248
000174  f7fffffe          BL       __aeabi_cdrcmple
000178  d202              BCS      |L1.384|
00017a  e9d40100          LDRD     r0,r1,[r4,#0]         ;248
00017e  e005              B        |L1.396|
                  |L1.384|
000180  ed940b00          VLDR     d0,[r4,#0]            ;248
000184  ec510b10          VMOV     r0,r1,d0              ;248
000188  f7fffffe          BL       __aeabi_dneg
                  |L1.396|
00018c  ec532b18          VMOV     r2,r3,d8              ;248
000190  f7fffffe          BL       __aeabi_cdcmpeq
000194  d11c              BNE      |L1.464|
000196  1ba8              SUBS     r0,r5,r6              ;252
000198  e008              B        |L1.428|
                  |L1.410|
00019a  ed940b00          VLDR     d0,[r4,#0]            ;257
00019e  ed971b00          VLDR     d1,[r7,#0]            ;258
0001a2  eca41b02          VSTM     r4!,{d1}              ;258
0001a6  eca70b02          VSTM     r7!,{d0}              ;259
0001aa  1e40              SUBS     r0,r0,#1              ;262
                  |L1.428|
0001ac  2800              CMP      r0,#0                 ;254
0001ae  d1f4              BNE      |L1.410|
0001b0  4628              MOV      r0,r5                 ;266
0001b2  e008              B        |L1.454|
                  |L1.436|
0001b4  ed990b00          VLDR     d0,[r9,#0]            ;271
0001b8  ed981b00          VLDR     d1,[r8,#0]            ;272
0001bc  eca91b02          VSTM     r9!,{d1}              ;272
0001c0  eca80b02          VSTM     r8!,{d0}              ;273
0001c4  1e40              SUBS     r0,r0,#1              ;276
                  |L1.454|
0001c6  2800              CMP      r0,#0                 ;268
0001c8  d1f4              BNE      |L1.436|
0001ca  2001              MOVS     r0,#1                 ;280
0001cc  9001              STR      r0,[sp,#4]            ;280
0001ce  e006              B        |L1.478|
                  |L1.464|
0001d0  f10b0b01          ADD      r11,r11,#1            ;287
0001d4  f1aa0a01          SUB      r10,r10,#1            ;290
                  |L1.472|
0001d8  f1ba0f00          CMP      r10,#0                ;240
0001dc  d1bc              BNE      |L1.344|
                  |L1.478|
0001de  9801              LDR      r0,[sp,#4]            ;295
0001e0  2801              CMP      r0,#1                 ;295
0001e2  d009              BEQ      |L1.504|
0001e4  ec532b19          VMOV     r2,r3,d9              ;295
0001e8  ec510b1a          VMOV     r0,r1,d10             ;295
0001ec  f7fffffe          BL       __aeabi_cdcmpeq
0001f0  d102              BNE      |L1.504|
0001f2  f06f0004          MVN      r0,#4                 ;297
0001f6  e78e              B        |L1.278|
                  |L1.504|
0001f8  9c0a              LDR      r4,[sp,#0x28]         ;301
0001fa  9405              STR      r4,[sp,#0x14]         ;301
0001fc  9f09              LDR      r7,[sp,#0x24]         ;302
0001fe  9704              STR      r7,[sp,#0x10]         ;302
000200  9f04              LDR      r7,[sp,#0x10]         ;306
000202  9c05              LDR      r4,[sp,#0x14]         ;309
000204  ed949b00          VLDR     d9,[r4,#0]            ;309
000208  eba50806          SUB      r8,r5,r6              ;313
00020c  f8cd8020          STR      r8,[sp,#0x20]         ;313
000210  e00c              B        |L1.556|
                  |L1.530|
000212  ed940b00          VLDR     d0,[r4,#0]            ;319
000216  ec532b19          VMOV     r2,r3,d9              ;320
00021a  ec510b10          VMOV     r0,r1,d0              ;320
00021e  f7fffffe          BL       __aeabi_ddiv
000222  e9c40100          STRD     r0,r1,[r4,#0]         ;320
000226  3408              ADDS     r4,r4,#8              ;320
000228  f1a80801          SUB      r8,r8,#1              ;323
                  |L1.556|
00022c  f1b80f00          CMP      r8,#0                 ;315
000230  d1ef              BNE      |L1.530|
000232  462c              MOV      r4,r5                 ;327
000234  e00b              B        |L1.590|
                  |L1.566|
000236  ed970b00          VLDR     d0,[r7,#0]            ;333
00023a  ec532b19          VMOV     r2,r3,d9              ;334
00023e  ec510b10          VMOV     r0,r1,d0              ;334
000242  f7fffffe          BL       __aeabi_ddiv
000246  e9c70100          STRD     r0,r1,[r7,#0]         ;334
00024a  3708              ADDS     r7,r7,#8              ;334
00024c  1e64              SUBS     r4,r4,#1              ;337
                  |L1.590|
00024e  2c00              CMP      r4,#0                 ;329
000250  d1f1              BNE      |L1.566|
000252  9c07              LDR      r4,[sp,#0x1c]         ;344
000254  9f06              LDR      r7,[sp,#0x18]         ;345
000256  2000              MOVS     r0,#0                 ;348
000258  9002              STR      r0,[sp,#8]            ;348
00025a  f8ddb00c          LDR      r11,[sp,#0xc]         ;352
00025e  e046              B        |L1.750|
                  |L1.608|
000260  9802              LDR      r0,[sp,#8]            ;357
000262  42b0              CMP      r0,r6                 ;357
000264  d105              BNE      |L1.626|
000266  9808              LDR      r0,[sp,#0x20]         ;361
000268  eb0404c0          ADD      r4,r4,r0,LSL #3       ;361
00026c  eb0707c5          ADD      r7,r7,r5,LSL #3       ;363
000270  e036              B        |L1.736|
                  |L1.626|
000272  ed949b00          VLDR     d9,[r4,#0]            ;368
000276  f8dd8014          LDR      r8,[sp,#0x14]         ;371
00027a  f8dda010          LDR      r10,[sp,#0x10]        ;372
00027e  f8dd9020          LDR      r9,[sp,#0x20]         ;376
000282  e012              B        |L1.682|
                  |L1.644|
000284  ed94ab00          VLDR     d10,[r4,#0]           ;382
000288  ec510b19          VMOV     r0,r1,d9              ;383
00028c  ecb80b02          VLDM     r8!,{d0}              ;383
000290  ec532b10          VMOV     r2,r3,d0              ;383
000294  f7fffffe          BL       __aeabi_dmul
000298  ec532b1a          VMOV     r2,r3,d10             ;383
00029c  f7fffffe          BL       __aeabi_drsub
0002a0  e9c40100          STRD     r0,r1,[r4,#0]         ;383
0002a4  3408              ADDS     r4,r4,#8              ;383
0002a6  f1a90901          SUB      r9,r9,#1              ;386
                  |L1.682|
0002aa  f1b90f00          CMP      r9,#0                 ;378
0002ae  d1e9              BNE      |L1.644|
0002b0  46a8              MOV      r8,r5                 ;391
0002b2  e012              B        |L1.730|
                  |L1.692|
0002b4  ed97ab00          VLDR     d10,[r7,#0]           ;397
0002b8  ec510b19          VMOV     r0,r1,d9              ;398
0002bc  ecba0b02          VLDM     r10!,{d0}             ;398
0002c0  ec532b10          VMOV     r2,r3,d0              ;398
0002c4  f7fffffe          BL       __aeabi_dmul
0002c8  ec532b1a          VMOV     r2,r3,d10             ;398
0002cc  f7fffffe          BL       __aeabi_drsub
0002d0  e9c70100          STRD     r0,r1,[r7,#0]         ;398
0002d4  3708              ADDS     r7,r7,#8              ;398
0002d6  f1a80801          SUB      r8,r8,#1              ;401
                  |L1.730|
0002da  f1b80f00          CMP      r8,#0                 ;393
0002de  d1e9              BNE      |L1.692|
                  |L1.736|
0002e0  eb0404c6          ADD      r4,r4,r6,LSL #3       ;407
0002e4  f1ab0b01          SUB      r11,r11,#1            ;410
0002e8  9802              LDR      r0,[sp,#8]            ;413
0002ea  1c40              ADDS     r0,r0,#1              ;413
0002ec  9002              STR      r0,[sp,#8]            ;413
                  |L1.750|
0002ee  ea5f000b          MOVS     r0,r11                ;354
0002f2  d1b5              BNE      |L1.608|
0002f4  9807              LDR      r0,[sp,#0x1c]         ;417
0002f6  3008              ADDS     r0,r0,#8              ;417
0002f8  9007              STR      r0,[sp,#0x1c]         ;417
0002fa  9800              LDR      r0,[sp,#0]            ;420
0002fc  1e40              SUBS     r0,r0,#1              ;420
0002fe  9000              STR      r0,[sp,#0]            ;420
000300  1c76              ADDS     r6,r6,#1              ;423
                  |L1.770|
000302  9800              LDR      r0,[sp,#0]            ;196
000304  2800              CMP      r0,#0                 ;196
000306  f47faeb2          BNE      |L1.110|
00030a  4680              MOV      r8,r0                 ;682
00030c  9801              LDR      r0,[sp,#4]            ;684
00030e  2801              CMP      r0,#1                 ;684
000310  d01e              BEQ      |L1.848|
000312  ec532b1b          VMOV     r2,r3,d11             ;684
000316  ec510b19          VMOV     r0,r1,d9              ;684
00031a  f7fffffe          BL       __aeabi_cdcmpeq
00031e  d117              BNE      |L1.848|
000320  9813              LDR      r0,[sp,#0x4c]         ;686
000322  6847              LDR      r7,[r0,#4]            ;686
000324  2400              MOVS     r4,#0                 ;687
000326  9e03              LDR      r6,[sp,#0xc]          ;687
000328  436e              MULS     r6,r5,r6              ;687
00032a  e00b              B        |L1.836|
                  |L1.812|
00032c  eb0700c4          ADD      r0,r7,r4,LSL #3       ;689
000330  ec532b1b          VMOV     r2,r3,d11             ;689
000334  ed900b00          VLDR     d0,[r0,#0]            ;689
000338  ec510b10          VMOV     r0,r1,d0              ;689
00033c  f7fffffe          BL       __aeabi_cdcmpeq
000340  d102              BNE      |L1.840|
000342  1c64              ADDS     r4,r4,#1              ;687
                  |L1.836|
000344  42a6              CMP      r6,r4                 ;687
000346  d8f1              BHI      |L1.812|
                  |L1.840|
000348  42a6              CMP      r6,r4                 ;693
00034a  d101              BNE      |L1.848|
00034c  f06f0804          MVN      r8,#4                 ;694
                  |L1.848|
000350  4640              MOV      r0,r8                 ;698
000352  e6e0              B        |L1.278|
;;;700    
                          ENDP

                  |L1.852|
000354  00000000          DCFD     0x0000000000000000 ; 0
000358  00000000
                  |L1.860|
00035c  00000000          DCFD     0x3ff0000000000000 ; 1
000360  3ff00000

;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\MatrixFunctions\\arm_mat_inverse_f64.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_mat_inverse_f64_c_3978fe55____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___21_arm_mat_inverse_f64_c_3978fe55____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_mat_inverse_f64_c_3978fe55____REVSH|
#line 144
|__asm___21_arm_mat_inverse_f64_c_3978fe55____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_mat_inverse_f64_c_3978fe55____RRX|
#line 300
|__asm___21_arm_mat_inverse_f64_c_3978fe55____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
