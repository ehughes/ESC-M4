; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_biquad_cascade_df1_fast_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_biquad_cascade_df1_fast_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_biquad_cascade_df1_fast_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_biquad_cascade_df1_fast_q15.c]
                          THUMB

                          AREA ||i.arm_biquad_cascade_df1_fast_q15||, CODE, READONLY, ALIGN=1

                  arm_biquad_cascade_df1_fast_q15 PROC
;;;74     
;;;75     void arm_biquad_cascade_df1_fast_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;76       const arm_biquad_casd_df1_inst_q15 * S,
;;;77       q15_t * pSrc,
;;;78       q15_t * pDst,
;;;79       uint32_t blockSize)
;;;80     {
000004  b082              SUB      sp,sp,#8
;;;81       q15_t *pIn = pSrc;                             /*  Source pointer                               */
;;;82       q15_t *pOut = pDst;                            /*  Destination pointer                          */
000006  9c04              LDR      r4,[sp,#0x10]
;;;83       q31_t in;                                      /*  Temporary variable to hold input value       */
;;;84       q31_t out;                                     /*  Temporary variable to hold output value      */
;;;85       q31_t b0;                                      /*  Temporary variable to hold bo value          */
;;;86       q31_t b1, a1;                                  /*  Filter coefficients                          */
;;;87       q31_t state_in, state_out;                     /*  Filter state variables                       */
;;;88       q31_t acc;                                     /*  Accumulator                                  */
;;;89       int32_t shift = (int32_t) (15 - S->postShift); /*  Post shift                                   */
000008  f990200c          LDRSB    r2,[r0,#0xc]
00000c  f1c2080f          RSB      r8,r2,#0xf
;;;90       q15_t *pState = S->pState;                     /*  State pointer                                */
000010  6843              LDR      r3,[r0,#4]
;;;91       q15_t *pCoeffs = S->pCoeffs;                   /*  Coefficient pointer                          */
000012  f8d09008          LDR      r9,[r0,#8]
;;;92       uint32_t sample, stage = S->numStages;         /*  Stage loop counter                           */
000016  f990a000          LDRSB    r10,[r0,#0]
;;;93     
;;;94     
;;;95     
;;;96       do
;;;97       {
;;;98     
;;;99         /* Read the b0 and 0 coefficients using SIMD  */
;;;100        b0 = *__SIMD32(pCoeffs)++;
;;;101    
;;;102        /* Read the b1 and b2 coefficients using SIMD */
;;;103        b1 = *__SIMD32(pCoeffs)++;
;;;104    
;;;105        /* Read the a1 and a2 coefficients using SIMD */
;;;106        a1 = *__SIMD32(pCoeffs)++;
;;;107    
;;;108        /* Read the input state values from the state buffer:  x[n-1], x[n-2] */
;;;109        state_in = *__SIMD32(pState)++;
;;;110    
;;;111        /* Read the output state values from the state buffer:  y[n-1], y[n-2] */
;;;112        state_out = *__SIMD32(pState)--;
;;;113    
;;;114        /* Apply loop unrolling and compute 2 output values simultaneously. */
;;;115        /*      The variable acc hold output values that are being computed:       
;;;116         *    
;;;117         *    acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2]       
;;;118         *    acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2]       
;;;119         */
;;;120        sample = blockSize >> 1u;
00001a  9805              LDR      r0,[sp,#0x14]
00001c  0840              LSRS     r0,r0,#1
00001e  9001              STR      r0,[sp,#4]
                  |L1.32|
000020  f8596b04          LDR      r6,[r9],#4            ;100
000024  f8597b04          LDR      r7,[r9],#4            ;103
000028  f859cb04          LDR      r12,[r9],#4           ;106
00002c  6818              LDR      r0,[r3,#0]            ;109
00002e  685a              LDR      r2,[r3,#4]            ;112
000030  9300              STR      r3,[sp,#0]            ;112
000032  9d01              LDR      r5,[sp,#4]
;;;121    
;;;122        /* First part of the processing with loop unrolling.  Compute 2 outputs at a time.    
;;;123         ** a second loop below computes the remaining 1 sample. */
;;;124        while(sample > 0u)
000034  e023              B        |L1.126|
                  |L1.54|
;;;125        {
;;;126    
;;;127          /* Read the input */
;;;128          in = *__SIMD32(pIn)++;
000036  f8513b04          LDR      r3,[r1],#4
;;;129    
;;;130          /* out =  b0 * x[n] + 0 * 0 */
;;;131          out = __SMUAD(b0, in);
00003a  fb26fb03          SMUAD    r11,r6,r3
;;;132          /* acc =  b1 * x[n-1] + acc +=  b2 * x[n-2] + out */
;;;133          acc = __SMLAD(b1, state_in, out);
00003e  fb27bb00          SMLAD    r11,r7,r0,r11
;;;134          /* acc +=  a1 * y[n-1] + acc +=  a2 * y[n-2] */
;;;135          acc = __SMLAD(a1, state_out, acc);
000042  fb2cbb02          SMLAD    r11,r12,r2,r11
;;;136    
;;;137          /* The result is converted from 3.29 to 1.31 and then saturation is applied */
;;;138          out = __SSAT((acc >> shift), 16);
000046  fa4bfb08          ASR      r11,r11,r8
00004a  f30b0b0f          SSAT     r11,#16,r11
;;;139    
;;;140          /* Every time after the output is computed state should be updated. */
;;;141          /* The states should be updated as:  */
;;;142          /* Xn2 = Xn1    */
;;;143          /* Xn1 = Xn     */
;;;144          /* Yn2 = Yn1    */
;;;145          /* Yn1 = acc   */
;;;146          /* x[n-N], x[n-N-1] are packed together to make state_in of type q31 */
;;;147          /* y[n-N], y[n-N-1] are packed together to make state_out of type q31 */
;;;148    
;;;149    #ifndef  ARM_MATH_BIG_ENDIAN
;;;150    
;;;151          state_in = __PKHBT(in, state_in, 16);
00004e  eac34000          PKHBT    r0,r3,r0,LSL #16
;;;152          state_out = __PKHBT(out, state_out, 16);
000052  eacb4202          PKHBT    r2,r11,r2,LSL #16
;;;153    
;;;154    #else
;;;155    
;;;156          state_in = __PKHBT(state_in >> 16, (in >> 16), 16);
;;;157          state_out = __PKHBT(state_out >> 16, (out), 16);
;;;158    
;;;159    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;160    
;;;161          /* out =  b0 * x[n] + 0 * 0 */
;;;162          out = __SMUADX(b0, in);
000056  fb26fb13          SMUADX   r11,r6,r3
;;;163          /* acc0 =  b1 * x[n-1] , acc0 +=  b2 * x[n-2] + out */
;;;164          acc = __SMLAD(b1, state_in, out);
00005a  fb27bb00          SMLAD    r11,r7,r0,r11
;;;165          /* acc +=  a1 * y[n-1] + acc +=  a2 * y[n-2] */
;;;166          acc = __SMLAD(a1, state_out, acc);
00005e  fb2cbb02          SMLAD    r11,r12,r2,r11
;;;167    
;;;168          /* The result is converted from 3.29 to 1.31 and then saturation is applied */
;;;169          out = __SSAT((acc >> shift), 16);
000062  fa4bfb08          ASR      r11,r11,r8
000066  f30b0b0f          SSAT     r11,#16,r11
;;;170    
;;;171    
;;;172          /* Store the output in the destination buffer. */
;;;173    
;;;174    #ifndef  ARM_MATH_BIG_ENDIAN
;;;175    
;;;176          *__SIMD32(pOut)++ = __PKHBT(state_out, out, 16);
00006a  eac24e0b          PKHBT    lr,r2,r11,LSL #16
00006e  f844eb04          STR      lr,[r4],#4
;;;177    
;;;178    #else
;;;179    
;;;180          *__SIMD32(pOut)++ = __PKHBT(out, state_out >> 16, 16);
;;;181    
;;;182    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;183    
;;;184          /* Every time after the output is computed state should be updated. */
;;;185          /* The states should be updated as:  */
;;;186          /* Xn2 = Xn1    */
;;;187          /* Xn1 = Xn     */
;;;188          /* Yn2 = Yn1    */
;;;189          /* Yn1 = acc   */
;;;190          /* x[n-N], x[n-N-1] are packed together to make state_in of type q31 */
;;;191          /* y[n-N], y[n-N-1] are packed together to make state_out of type q31 */
;;;192    
;;;193    #ifndef  ARM_MATH_BIG_ENDIAN
;;;194    
;;;195          state_in = __PKHBT(in >> 16, state_in, 16);
000072  141b              ASRS     r3,r3,#16
000074  eac34000          PKHBT    r0,r3,r0,LSL #16
;;;196          state_out = __PKHBT(out, state_out, 16);
000078  eacb4202          PKHBT    r2,r11,r2,LSL #16
;;;197    
;;;198    #else
;;;199    
;;;200          state_in = __PKHBT(state_in >> 16, in, 16);
;;;201          state_out = __PKHBT(state_out >> 16, out, 16);
;;;202    
;;;203    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;204    
;;;205    
;;;206          /* Decrement the loop counter */
;;;207          sample--;
00007c  1e6d              SUBS     r5,r5,#1
                  |L1.126|
00007e  2d00              CMP      r5,#0                 ;124
000080  d1d9              BNE      |L1.54|
;;;208    
;;;209        }
;;;210    
;;;211        /* If the blockSize is not a multiple of 2, compute any remaining output samples here.    
;;;212         ** No loop unrolling is used. */
;;;213    
;;;214        if((blockSize & 0x1u) != 0u)
000082  9b05              LDR      r3,[sp,#0x14]
000084  07db              LSLS     r3,r3,#31
000086  d010              BEQ      |L1.170|
;;;215        {
;;;216          /* Read the input */
;;;217          in = *pIn++;
000088  f9b13000          LDRSH    r3,[r1,#0]
;;;218    
;;;219          /* out =  b0 * x[n] + 0 * 0 */
;;;220    
;;;221    #ifndef  ARM_MATH_BIG_ENDIAN
;;;222    
;;;223          out = __SMUAD(b0, in);
00008c  fb26f103          SMUAD    r1,r6,r3
;;;224    
;;;225    #else
;;;226    
;;;227          out = __SMUADX(b0, in);
;;;228    
;;;229    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;230    
;;;231          /* acc =  b1 * x[n-1], acc +=  b2 * x[n-2] + out */
;;;232          acc = __SMLAD(b1, state_in, out);
000090  fb271100          SMLAD    r1,r7,r0,r1
;;;233          /* acc +=  a1 * y[n-1] + acc +=  a2 * y[n-2] */
;;;234          acc = __SMLAD(a1, state_out, acc);
000094  fb2c1102          SMLAD    r1,r12,r2,r1
;;;235    
;;;236          /* The result is converted from 3.29 to 1.31 and then saturation is applied */
;;;237          out = __SSAT((acc >> shift), 16);
000098  fa41f108          ASR      r1,r1,r8
00009c  f301010f          SSAT     r1,#16,r1
;;;238    
;;;239          /* Store the output in the destination buffer. */
;;;240          *pOut++ = (q15_t) out;
0000a0  8021              STRH     r1,[r4,#0]
;;;241    
;;;242          /* Every time after the output is computed state should be updated. */
;;;243          /* The states should be updated as:  */
;;;244          /* Xn2 = Xn1    */
;;;245          /* Xn1 = Xn     */
;;;246          /* Yn2 = Yn1    */
;;;247          /* Yn1 = acc   */
;;;248          /* x[n-N], x[n-N-1] are packed together to make state_in of type q31 */
;;;249          /* y[n-N], y[n-N-1] are packed together to make state_out of type q31 */
;;;250    
;;;251    #ifndef  ARM_MATH_BIG_ENDIAN
;;;252    
;;;253          state_in = __PKHBT(in, state_in, 16);
0000a2  eac34000          PKHBT    r0,r3,r0,LSL #16
;;;254          state_out = __PKHBT(out, state_out, 16);
0000a6  eac14202          PKHBT    r2,r1,r2,LSL #16
                  |L1.170|
;;;255    
;;;256    #else
;;;257    
;;;258          state_in = __PKHBT(state_in >> 16, in, 16);
;;;259          state_out = __PKHBT(state_out >> 16, out, 16);
;;;260    
;;;261    #endif /*   #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;262    
;;;263        }
;;;264    
;;;265        /*  The first stage goes from the input buffer to the output buffer.  */
;;;266        /*  Subsequent (numStages - 1) occur in-place in the output buffer  */
;;;267        pIn = pDst;
;;;268    
;;;269        /* Reset the output pointer */
;;;270        pOut = pDst;
0000aa  9904              LDR      r1,[sp,#0x10]
0000ac  460c              MOV      r4,r1
;;;271    
;;;272        /*  Store the updated state variables back into the state array */
;;;273        *__SIMD32(pState)++ = state_in;
0000ae  9b00              LDR      r3,[sp,#0]
0000b0  6018              STR      r0,[r3,#0]
0000b2  9b00              LDR      r3,[sp,#0]
;;;274        *__SIMD32(pState)++ = state_out;
0000b4  605a              STR      r2,[r3,#4]
0000b6  3308              ADDS     r3,r3,#8
;;;275    
;;;276    
;;;277        /* Decrement the loop counter */
;;;278        stage--;
0000b8  f1aa0a01          SUB      r10,r10,#1
;;;279    
;;;280      } while(stage > 0u);
0000bc  f1ba0f00          CMP      r10,#0
0000c0  d1ae              BNE      |L1.32|
;;;281    }
0000c2  b006              ADD      sp,sp,#0x18
0000c4  e8bd8ff0          POP      {r4-r11,pc}
;;;282    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_biquad_cascade_df1_fast_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___33_arm_biquad_cascade_df1_fast_q15_c_3ae4055a____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___33_arm_biquad_cascade_df1_fast_q15_c_3ae4055a____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___33_arm_biquad_cascade_df1_fast_q15_c_3ae4055a____REVSH|
#line 144
|__asm___33_arm_biquad_cascade_df1_fast_q15_c_3ae4055a____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___33_arm_biquad_cascade_df1_fast_q15_c_3ae4055a____RRX|
#line 300
|__asm___33_arm_biquad_cascade_df1_fast_q15_c_3ae4055a____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
