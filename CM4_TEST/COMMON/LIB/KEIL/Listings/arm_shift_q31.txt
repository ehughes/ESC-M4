; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_shift_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_shift_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_shift_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\BasicMathFunctions\arm_shift_q31.c]
                          THUMB

                          AREA ||i.arm_shift_q31||, CODE, READONLY, ALIGN=1

                  arm_shift_q31 PROC
;;;83     
;;;84     void arm_shift_q31(
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;85       q31_t * pSrc,
;;;86       int8_t shiftBits,
;;;87       q31_t * pDst,
;;;88       uint32_t blockSize)
;;;89     {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;90       uint32_t blkCnt;                               /* loop counter */
;;;91       uint8_t sign = (shiftBits & 0x80);             /* Sign of shiftBits */
00000a  f0060a80          AND      r10,r6,#0x80
;;;92     
;;;93     #ifndef ARM_MATH_CM0_FAMILY
;;;94     
;;;95       q31_t in1, in2, in3, in4;                      /* Temporary input variables */
;;;96       q31_t out1, out2, out3, out4;                  /* Temporary output variables */
;;;97     
;;;98       /*loop Unrolling */
;;;99       blkCnt = blockSize >> 2u;
00000e  9803              LDR      r0,[sp,#0xc]
000010  0880              LSRS     r0,r0,#2
;;;100    
;;;101    
;;;102      if(sign == 0u)
;;;103      {
;;;104        /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;105         ** a second loop below computes the remaining 1 to 3 samples. */
;;;106        while(blkCnt > 0u)
;;;107        {
;;;108          /* C = A  << shiftBits */
;;;109          /* Shift the input and then store the results in the destination buffer. */
;;;110          in1 = *pSrc;
;;;111          in2 = *(pSrc + 1);
;;;112          out1 = in1 << shiftBits;
;;;113          in3 = *(pSrc + 2);
;;;114          out2 = in2 << shiftBits;
;;;115          in4 = *(pSrc + 3);
;;;116          if(in1 != (out1 >> shiftBits))
;;;117            out1 = 0x7FFFFFFF ^ (in1 >> 31);
;;;118    
;;;119          if(in2 != (out2 >> shiftBits))
;;;120            out2 = 0x7FFFFFFF ^ (in2 >> 31);
;;;121    
;;;122          *pDst = out1;
;;;123          out3 = in3 << shiftBits;
;;;124          *(pDst + 1) = out2;
;;;125          out4 = in4 << shiftBits;
;;;126    
;;;127          if(in3 != (out3 >> shiftBits))
;;;128            out3 = 0x7FFFFFFF ^ (in3 >> 31);
;;;129    
;;;130          if(in4 != (out4 >> shiftBits))
;;;131            out4 = 0x7FFFFFFF ^ (in4 >> 31);
;;;132    
;;;133          *(pDst + 2) = out3;
;;;134          *(pDst + 3) = out4;
;;;135    
;;;136          /* Update destination pointer to process next sampels */
;;;137          pSrc += 4u;
;;;138          pDst += 4u;
;;;139    
;;;140          /* Decrement the loop counter */
;;;141          blkCnt--;
;;;142        }
;;;143      }
;;;144      else
;;;145      {
;;;146    
;;;147        /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;148         ** a second loop below computes the remaining 1 to 3 samples. */
;;;149        while(blkCnt > 0u)
;;;150        {
;;;151          /* C = A >>  shiftBits */
;;;152          /* Shift the input and then store the results in the destination buffer. */
;;;153          in1 = *pSrc;
;;;154          in2 = *(pSrc + 1);
;;;155          in3 = *(pSrc + 2);
;;;156          in4 = *(pSrc + 3);
;;;157    
;;;158          *pDst = (in1 >> -shiftBits);
000012  4277              RSBS     r7,r6,#0
000014  f06f4900          MVN      r9,#0x80000000        ;117
000018  f1ba0f00          CMP      r10,#0                ;102
00001c  d02f              BEQ      |L1.126|
00001e  e043              B        |L1.168|
                  |L1.32|
000020  f8d4c000          LDR      r12,[r4,#0]           ;110
000024  f8d48004          LDR      r8,[r4,#4]            ;111
000028  fa0cf306          LSL      r3,r12,r6             ;112
00002c  68a2              LDR      r2,[r4,#8]            ;113
00002e  fa08f106          LSL      r1,r8,r6              ;114
000032  f8d4b00c          LDR      r11,[r4,#0xc]         ;115
000036  fa43fe06          ASR      lr,r3,r6              ;116
00003a  45e6              CMP      lr,r12                ;116
00003c  d001              BEQ      |L1.66|
00003e  ea8973ec          EOR      r3,r9,r12,ASR #31     ;117
                  |L1.66|
000042  fa41fc06          ASR      r12,r1,r6             ;119
000046  45c4              CMP      r12,r8                ;119
000048  d001              BEQ      |L1.78|
00004a  ea8971e8          EOR      r1,r9,r8,ASR #31      ;120
                  |L1.78|
00004e  602b              STR      r3,[r5,#0]            ;122
000050  fa02f306          LSL      r3,r2,r6              ;123
000054  6069              STR      r1,[r5,#4]            ;124
000056  fa0bf806          LSL      r8,r11,r6             ;125
00005a  fa43f106          ASR      r1,r3,r6              ;127
00005e  4291              CMP      r1,r2                 ;127
000060  d001              BEQ      |L1.102|
000062  ea8973e2          EOR      r3,r9,r2,ASR #31      ;128
                  |L1.102|
000066  fa48f106          ASR      r1,r8,r6              ;130
00006a  4559              CMP      r1,r11                ;130
00006c  d001              BEQ      |L1.114|
00006e  ea8978eb          EOR      r8,r9,r11,ASR #31     ;131
                  |L1.114|
000072  60ab              STR      r3,[r5,#8]            ;133
000074  f8c5800c          STR      r8,[r5,#0xc]          ;134
000078  3410              ADDS     r4,r4,#0x10           ;137
00007a  3510              ADDS     r5,r5,#0x10           ;138
00007c  1e40              SUBS     r0,r0,#1              ;141
                  |L1.126|
00007e  2800              CMP      r0,#0                 ;106
000080  d1ce              BNE      |L1.32|
000082  e013              B        |L1.172|
                  |L1.132|
000084  6821              LDR      r1,[r4,#0]            ;153
000086  6863              LDR      r3,[r4,#4]            ;154
000088  f8d4c008          LDR      r12,[r4,#8]           ;155
00008c  68e2              LDR      r2,[r4,#0xc]          ;156
00008e  4139              ASRS     r1,r1,r7
000090  6029              STR      r1,[r5,#0]
;;;159          *(pDst + 1) = (in2 >> -shiftBits);
000092  413b              ASRS     r3,r3,r7
000094  606b              STR      r3,[r5,#4]
;;;160          *(pDst + 2) = (in3 >> -shiftBits);
000096  fa4cfc07          ASR      r12,r12,r7
00009a  f8c5c008          STR      r12,[r5,#8]
;;;161          *(pDst + 3) = (in4 >> -shiftBits);
00009e  413a              ASRS     r2,r2,r7
0000a0  60ea              STR      r2,[r5,#0xc]
;;;162    
;;;163    
;;;164          pSrc += 4u;
0000a2  3410              ADDS     r4,r4,#0x10
;;;165          pDst += 4u;
0000a4  3510              ADDS     r5,r5,#0x10
;;;166    
;;;167          blkCnt--;
0000a6  1e40              SUBS     r0,r0,#1
                  |L1.168|
0000a8  2800              CMP      r0,#0                 ;149
0000aa  d1eb              BNE      |L1.132|
                  |L1.172|
;;;168        }
;;;169    
;;;170      }
;;;171    
;;;172      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;173       ** No loop unrolling is used. */
;;;174      blkCnt = blockSize % 0x4u;
0000ac  9803              LDR      r0,[sp,#0xc]
0000ae  f0000803          AND      r8,r0,#3
;;;175    
;;;176    #else
;;;177    
;;;178      /* Run the below code for Cortex-M0 */
;;;179    
;;;180    
;;;181      /* Initialize blkCnt with number of samples */
;;;182      blkCnt = blockSize;
;;;183    
;;;184    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;185    
;;;186    
;;;187      while(blkCnt > 0u)
0000b2  e007              B        |L1.196|
                  |L1.180|
;;;188      {
;;;189        /* C = A (>> or <<) shiftBits */
;;;190        /* Shift the input and then store the result in the destination buffer. */
;;;191        *pDst++ = (sign == 0u) ? clip_q63_to_q31((q63_t) * pSrc++ << shiftBits) :
0000b4  f1ba0f00          CMP      r10,#0
0000b8  d009              BEQ      |L1.206|
;;;192          (*pSrc++ >> -shiftBits);
0000ba  cc01              LDM      r4!,{r0}
0000bc  4138              ASRS     r0,r0,r7
                  |L1.190|
0000be  c501              STM      r5!,{r0}
;;;193    
;;;194        /* Decrement the loop counter */
;;;195        blkCnt--;
0000c0  f1a80801          SUB      r8,r8,#1
                  |L1.196|
0000c4  f1b80f00          CMP      r8,#0                 ;187
0000c8  d1f4              BNE      |L1.180|
;;;196      }
;;;197    
;;;198    
;;;199    }
0000ca  e8bd9fff          POP      {r0-r12,pc}
                  |L1.206|
0000ce  cc01              LDM      r4!,{r0}              ;191
0000d0  4632              MOV      r2,r6                 ;191
0000d2  17c1              ASRS     r1,r0,#31             ;191
0000d4  f7fffffe          BL       __aeabi_llsl
0000d8  17ca              ASRS     r2,r1,#31             ;191
0000da  ebb17fe0          CMP      r1,r0,ASR #31         ;191
0000de  d0ee              BEQ      |L1.190|
0000e0  ea820009          EOR      r0,r2,r9              ;191
0000e4  e7eb              B        |L1.190|
;;;200    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\BasicMathFunctions\\arm_shift_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_arm_shift_q31_c_a226c331____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___15_arm_shift_q31_c_a226c331____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_arm_shift_q31_c_a226c331____REVSH|
#line 144
|__asm___15_arm_shift_q31_c_a226c331____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_arm_shift_q31_c_a226c331____RRX|
#line 300
|__asm___15_arm_shift_q31_c_a226c331____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
