; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_sparse_q7.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_sparse_q7.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_fir_sparse_q7.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_fir_sparse_q7.c]
                          THUMB

                          AREA ||i.arm_circularRead_q7||, CODE, READONLY, ALIGN=1

                  arm_circularRead_q7 PROC
;;;6395      */
;;;6396     static __INLINE void arm_circularRead_q7(
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;6397     q7_t * circBuffer,
;;;6398     int32_t L,
;;;6399     int32_t * readOffset,
;;;6400     int32_t bufferInc,
;;;6401     q7_t * dst,
;;;6402     q7_t * dst_base,
;;;6403     int32_t dst_length,
;;;6404     int32_t dstInc,
;;;6405     uint32_t blockSize)
;;;6406     {
000004  e9dd7c09          LDRD     r7,r12,[sp,#0x24]
000008  e9dd5807          LDRD     r5,r8,[sp,#0x1c]
00000c  9e0b              LDR      r6,[sp,#0x2c]
;;;6407       uint32_t i = 0;
;;;6408       int32_t rOffset, dst_end;
;;;6409   
;;;6410       /* Copy the value of Index pointer that points
;;;6411        * to the current location from where the input samples to be read */
;;;6412       rOffset = *readOffset;
00000e  6814              LDR      r4,[r2,#0]
;;;6413   
;;;6414       dst_end = (int32_t) (dst_base + dst_length);
000010  4447              ADD      r7,r7,r8
000012  e00c              B        |L1.46|
                  |L1.20|
;;;6415   
;;;6416       /* Loop over the blockSize */
;;;6417       i = blockSize;
;;;6418   
;;;6419       while(i > 0u)
;;;6420       {
;;;6421         /* copy the sample from the circular buffer to the destination buffer */
;;;6422         *dst = circBuffer[rOffset];
000014  f8109004          LDRB     r9,[r0,r4]
000018  f8859000          STRB     r9,[r5,#0]
;;;6423   
;;;6424         /* Update the input pointer */
;;;6425         dst += dstInc;
00001c  4465              ADD      r5,r5,r12
;;;6426   
;;;6427         if(dst == (q7_t *) dst_end)
00001e  42bd              CMP      r5,r7
000020  d100              BNE      |L1.36|
;;;6428         {
;;;6429           dst = dst_base;
000022  4645              MOV      r5,r8
                  |L1.36|
;;;6430         }
;;;6431   
;;;6432         /* Circularly update rOffset.  Watch out for positive and negative value */
;;;6433         rOffset += bufferInc;
000024  441c              ADD      r4,r4,r3
;;;6434   
;;;6435         if(rOffset >= L)
000026  428c              CMP      r4,r1
000028  db00              BLT      |L1.44|
;;;6436         {
;;;6437           rOffset -= L;
00002a  1a64              SUBS     r4,r4,r1
                  |L1.44|
;;;6438         }
;;;6439   
;;;6440         /* Decrement the loop counter */
;;;6441         i--;
00002c  1e76              SUBS     r6,r6,#1
                  |L1.46|
00002e  2e00              CMP      r6,#0                 ;6419
000030  d1f0              BNE      |L1.20|
;;;6442       }
;;;6443   
;;;6444       /* Update the index pointer */
;;;6445       *readOffset = rOffset;
000032  6014              STR      r4,[r2,#0]
;;;6446     }
000034  e8bd83f0          POP      {r4-r9,pc}
;;;6447   
                          ENDP


                          AREA ||i.arm_fir_sparse_q7||, CODE, READONLY, ALIGN=1

                  arm_fir_sparse_q7 PROC
;;;72     
;;;73     void arm_fir_sparse_q7(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;74       arm_fir_sparse_instance_q7 * S,
;;;75       q7_t * pSrc,
;;;76       q7_t * pDst,
;;;77       q7_t * pScratchIn,
;;;78       q31_t * pScratchOut,
;;;79       uint32_t blockSize)
;;;80     {
000004  b08d              SUB      sp,sp,#0x34
000006  4681              MOV      r9,r0
000008  e9dd4516          LDRD     r4,r5,[sp,#0x58]
00000c  4617              MOV      r7,r2
00000e  461e              MOV      r6,r3
;;;81     
;;;82       q7_t *pState = S->pState;                      /* State pointer */
000010  f8d9c004          LDR      r12,[r9,#4]
000014  f8cdc028          STR      r12,[sp,#0x28]
;;;83       q7_t *pCoeffs = S->pCoeffs;                    /* Coefficient pointer */
000018  f8d9a008          LDR      r10,[r9,#8]
;;;84       q7_t *px;                                      /* Scratch buffer pointer */
;;;85       q7_t *py = pState;                             /* Temporary pointers for state buffer */
00001c  f8ddc028          LDR      r12,[sp,#0x28]
;;;86       q7_t *pb = pScratchIn;                         /* Temporary pointers for scratch buffer */
;;;87       q7_t *pOut = pDst;                             /* Destination pointer */
;;;88       int32_t *pTapDelay = S->pTapDelay;             /* Pointer to the array containing offset of the non-zero tap values. */
000020  f8d9b010          LDR      r11,[r9,#0x10]
;;;89       uint32_t delaySize = S->maxDelay + blockSize;  /* state length */
000024  f8b9000c          LDRH     r0,[r9,#0xc]
000028  1943              ADDS     r3,r0,r5
00002a  9309              STR      r3,[sp,#0x24]
;;;90       uint16_t numTaps = S->numTaps;                 /* Filter order */
00002c  f8b90000          LDRH     r0,[r9,#0]
000030  9008              STR      r0,[sp,#0x20]
;;;91       int32_t readIndex;                             /* Read index of the state buffer */
;;;92       uint32_t tapCnt, blkCnt;                       /* loop counters */
;;;93       q7_t coeff = *pCoeffs++;                       /* Read the coefficient value */
000032  f91a8b01          LDRSB    r8,[r10],#1
;;;94       q31_t *pScr2 = pScratchOut;                    /* Working pointer for scratch buffer of output values */
;;;95       q31_t in;
;;;96     
;;;97     
;;;98     #ifndef ARM_MATH_CM0_FAMILY
;;;99     
;;;100      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;101    
;;;102      q7_t in1, in2, in3, in4;
;;;103    
;;;104      /* BlockSize of Input samples are copied into the state buffer */
;;;105      /* StateIndex points to the starting position to write in the state buffer */
;;;106      arm_circularWrite_q7(py, (int32_t) delaySize, &S->stateIndex, 1, pSrc, 1,
000036  f1090002          ADD      r0,r9,#2
00003a  9003              STR      r0,[sp,#0xc]
00003c  2001              MOVS     r0,#1
00003e  9b09              LDR      r3,[sp,#0x24]
000040  9004              STR      r0,[sp,#0x10]
000042  462a              MOV      r2,r5
000044  9005              STR      r0,[sp,#0x14]
000046  9803              LDR      r0,[sp,#0xc]
000048  8800              LDRH     r0,[r0,#0]
00004a  e00d              B        |L2.104|
                  |L2.76|
00004c  f891e000          LDRB     lr,[r1,#0]            ;80
000050  f80ce000          STRB     lr,[r12,r0]           ;80
000054  f8dde014          LDR      lr,[sp,#0x14]         ;80
000058  4471              ADD      r1,r1,lr              ;80
00005a  f8dde010          LDR      lr,[sp,#0x10]         ;80
00005e  4470              ADD      r0,r0,lr              ;80
000060  4298              CMP      r0,r3                 ;80
000062  db00              BLT      |L2.102|
000064  1ac0              SUBS     r0,r0,r3              ;80
                  |L2.102|
000066  1e52              SUBS     r2,r2,#1              ;80
                  |L2.104|
000068  2a00              CMP      r2,#0                 ;80
00006a  d1ef              BNE      |L2.76|
00006c  9903              LDR      r1,[sp,#0xc]          ;80
00006e  8008              STRH     r0,[r1,#0]            ;80
;;;107                           blockSize);
;;;108    
;;;109      /* Loop over the number of taps. */
;;;110      tapCnt = numTaps;
;;;111    
;;;112      /* Read Index, from where the state buffer should be read, is calculated. */
;;;113      readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
000070  f8b91002          LDRH     r1,[r9,#2]
000074  f85b0b04          LDR      r0,[r11],#4
000078  1b49              SUBS     r1,r1,r5
00007a  1a08              SUBS     r0,r1,r0
00007c  9007              STR      r0,[sp,#0x1c]
;;;114    
;;;115      /* Wraparound of readIndex */
;;;116      if(readIndex < 0)
00007e  2800              CMP      r0,#0
000080  da02              BGE      |L2.136|
;;;117      {
;;;118        readIndex += (int32_t) delaySize;
000082  9909              LDR      r1,[sp,#0x24]
000084  4408              ADD      r0,r0,r1
000086  9007              STR      r0,[sp,#0x1c]
                  |L2.136|
;;;119      }
;;;120    
;;;121      /* Working pointer for state buffer is updated */
;;;122      py = pState;
000088  980a              LDR      r0,[sp,#0x28]
;;;123    
;;;124      /* blockSize samples are read from the state buffer */
;;;125      arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,
00008a  e9cd6501          STRD     r6,r5,[sp,#4]
00008e  2101              MOVS     r1,#1
000090  9600              STR      r6,[sp,#0]
000092  e9cd1503          STRD     r1,r5,[sp,#0xc]
000096  460b              MOV      r3,r1
000098  aa07              ADD      r2,sp,#0x1c
00009a  9909              LDR      r1,[sp,#0x24]
00009c  f7fffffe          BL       arm_circularRead_q7
;;;126                          (int32_t) blockSize, 1, blockSize);
;;;127    
;;;128      /* Working pointer for the scratch buffer of state values */
;;;129      px = pb;
0000a0  4632              MOV      r2,r6
;;;130    
;;;131      /* Working pointer for scratch buffer of output values */
;;;132      pScratchOut = pScr2;
0000a2  4621              MOV      r1,r4
;;;133    
;;;134      /* Loop over the blockSize. Unroll by a factor of 4.    
;;;135       * Compute 4 multiplications at a time. */
;;;136      blkCnt = blockSize >> 2;
0000a4  08a8              LSRS     r0,r5,#2
0000a6  900c              STR      r0,[sp,#0x30]
;;;137    
;;;138      while(blkCnt > 0u)
0000a8  e016              B        |L2.216|
                  |L2.170|
;;;139      {
;;;140        /* Perform multiplication and store in the scratch buffer */
;;;141        *pScratchOut++ = ((q31_t) * px++ * coeff);
0000aa  f9923000          LDRSB    r3,[r2,#0]
0000ae  fb03f308          MUL      r3,r3,r8
0000b2  600b              STR      r3,[r1,#0]
;;;142        *pScratchOut++ = ((q31_t) * px++ * coeff);
0000b4  f9923001          LDRSB    r3,[r2,#1]
0000b8  fb03f308          MUL      r3,r3,r8
0000bc  604b              STR      r3,[r1,#4]
;;;143        *pScratchOut++ = ((q31_t) * px++ * coeff);
0000be  f9923002          LDRSB    r3,[r2,#2]
0000c2  fb03f308          MUL      r3,r3,r8
0000c6  608b              STR      r3,[r1,#8]
;;;144        *pScratchOut++ = ((q31_t) * px++ * coeff);
0000c8  f9923003          LDRSB    r3,[r2,#3]
0000cc  1d12              ADDS     r2,r2,#4
0000ce  fb03f308          MUL      r3,r3,r8
0000d2  60cb              STR      r3,[r1,#0xc]
0000d4  3110              ADDS     r1,r1,#0x10
;;;145    
;;;146        /* Decrement the loop counter */
;;;147        blkCnt--;
0000d6  1e40              SUBS     r0,r0,#1
                  |L2.216|
0000d8  2800              CMP      r0,#0                 ;138
0000da  d1e6              BNE      |L2.170|
;;;148      }
;;;149    
;;;150      /* If the blockSize is not a multiple of 4,    
;;;151       * compute the remaining samples */
;;;152      blkCnt = blockSize % 0x4u;
0000dc  f0050003          AND      r0,r5,#3
0000e0  900b              STR      r0,[sp,#0x2c]
;;;153    
;;;154      while(blkCnt > 0u)
0000e2  e005              B        |L2.240|
                  |L2.228|
;;;155      {
;;;156        /* Perform multiplication and store in the scratch buffer */
;;;157        *pScratchOut++ = ((q31_t) * px++ * coeff);
0000e4  f9123b01          LDRSB    r3,[r2],#1
0000e8  fb03f308          MUL      r3,r3,r8
0000ec  c108              STM      r1!,{r3}
;;;158    
;;;159        /* Decrement the loop counter */
;;;160        blkCnt--;
0000ee  1e40              SUBS     r0,r0,#1
                  |L2.240|
0000f0  2800              CMP      r0,#0                 ;154
0000f2  d1f7              BNE      |L2.228|
;;;161      }
;;;162    
;;;163      /* Load the coefficient value and    
;;;164       * increment the coefficient buffer for the next set of state values */
;;;165      coeff = *pCoeffs++;
0000f4  f91a8b01          LDRSB    r8,[r10],#1
;;;166    
;;;167      /* Read Index, from where the state buffer should be read, is calculated. */
;;;168      readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
0000f8  f8b91002          LDRH     r1,[r9,#2]
0000fc  f85b0b04          LDR      r0,[r11],#4
000100  1b49              SUBS     r1,r1,r5
000102  1a08              SUBS     r0,r1,r0
000104  9007              STR      r0,[sp,#0x1c]
;;;169    
;;;170      /* Wraparound of readIndex */
;;;171      if(readIndex < 0)
000106  2800              CMP      r0,#0
000108  da02              BGE      |L2.272|
;;;172      {
;;;173        readIndex += (int32_t) delaySize;
00010a  9909              LDR      r1,[sp,#0x24]
00010c  4408              ADD      r0,r0,r1
00010e  9007              STR      r0,[sp,#0x1c]
                  |L2.272|
;;;174      }
;;;175    
;;;176      /* Loop over the number of taps. */
;;;177      tapCnt = (uint32_t) numTaps - 2u;
000110  9808              LDR      r0,[sp,#0x20]
000112  1e80              SUBS     r0,r0,#2
000114  9006              STR      r0,[sp,#0x18]
;;;178    
;;;179      while(tapCnt > 0u)
000116  e04d              B        |L2.436|
                  |L2.280|
;;;180      {
;;;181        /* Working pointer for state buffer is updated */
;;;182        py = pState;
000118  980a              LDR      r0,[sp,#0x28]
;;;183    
;;;184        /* blockSize samples are read from the state buffer */
;;;185        arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,
00011a  e9cd6501          STRD     r6,r5,[sp,#4]
00011e  2101              MOVS     r1,#1
000120  9600              STR      r6,[sp,#0]
000122  e9cd1503          STRD     r1,r5,[sp,#0xc]
000126  460b              MOV      r3,r1
000128  aa07              ADD      r2,sp,#0x1c
00012a  9909              LDR      r1,[sp,#0x24]
00012c  f7fffffe          BL       arm_circularRead_q7
;;;186                            (int32_t) blockSize, 1, blockSize);
;;;187    
;;;188        /* Working pointer for the scratch buffer of state values */
;;;189        px = pb;
000130  4632              MOV      r2,r6
;;;190    
;;;191        /* Working pointer for scratch buffer of output values */
;;;192        pScratchOut = pScr2;
000132  4620              MOV      r0,r4
;;;193    
;;;194        /* Loop over the blockSize. Unroll by a factor of 4.    
;;;195         * Compute 4 MACS at a time. */
;;;196        blkCnt = blockSize >> 2;
000134  990c              LDR      r1,[sp,#0x30]
;;;197    
;;;198        while(blkCnt > 0u)
000136  e01e              B        |L2.374|
                  |L2.312|
;;;199        {
;;;200          /* Perform Multiply-Accumulate */
;;;201          in = *pScratchOut + ((q31_t) * px++ * coeff);
000138  f9923000          LDRSB    r3,[r2,#0]
00013c  f8d0c000          LDR      r12,[r0,#0]
000140  fb03c308          MLA      r3,r3,r8,r12
;;;202          *pScratchOut++ = in;
000144  6003              STR      r3,[r0,#0]
;;;203          in = *pScratchOut + ((q31_t) * px++ * coeff);
000146  f9923001          LDRSB    r3,[r2,#1]
00014a  f8d0c004          LDR      r12,[r0,#4]
00014e  fb03c308          MLA      r3,r3,r8,r12
;;;204          *pScratchOut++ = in;
000152  6043              STR      r3,[r0,#4]
;;;205          in = *pScratchOut + ((q31_t) * px++ * coeff);
000154  f9923002          LDRSB    r3,[r2,#2]
000158  f8d0c008          LDR      r12,[r0,#8]
00015c  fb03c308          MLA      r3,r3,r8,r12
;;;206          *pScratchOut++ = in;
000160  6083              STR      r3,[r0,#8]
;;;207          in = *pScratchOut + ((q31_t) * px++ * coeff);
000162  f9923003          LDRSB    r3,[r2,#3]
000166  f8d0c00c          LDR      r12,[r0,#0xc]
00016a  1d12              ADDS     r2,r2,#4
00016c  fb03c308          MLA      r3,r3,r8,r12
;;;208          *pScratchOut++ = in;
000170  60c3              STR      r3,[r0,#0xc]
000172  3010              ADDS     r0,r0,#0x10
;;;209    
;;;210          /* Decrement the loop counter */
;;;211          blkCnt--;
000174  1e49              SUBS     r1,r1,#1
                  |L2.374|
000176  2900              CMP      r1,#0                 ;198
000178  d1de              BNE      |L2.312|
;;;212        }
;;;213    
;;;214        /* If the blockSize is not a multiple of 4,    
;;;215         * compute the remaining samples */
;;;216        blkCnt = blockSize % 0x4u;
00017a  990b              LDR      r1,[sp,#0x2c]
;;;217    
;;;218        while(blkCnt > 0u)
00017c  e007              B        |L2.398|
                  |L2.382|
;;;219        {
;;;220          /* Perform Multiply-Accumulate */
;;;221          in = *pScratchOut + ((q31_t) * px++ * coeff);
00017e  f9123b01          LDRSB    r3,[r2],#1
000182  f8d0c000          LDR      r12,[r0,#0]
000186  fb03c308          MLA      r3,r3,r8,r12
;;;222          *pScratchOut++ = in;
00018a  c008              STM      r0!,{r3}
;;;223    
;;;224          /* Decrement the loop counter */
;;;225          blkCnt--;
00018c  1e49              SUBS     r1,r1,#1
                  |L2.398|
00018e  2900              CMP      r1,#0                 ;218
000190  d1f5              BNE      |L2.382|
;;;226        }
;;;227    
;;;228        /* Load the coefficient value and    
;;;229         * increment the coefficient buffer for the next set of state values */
;;;230        coeff = *pCoeffs++;
000192  f91a8b01          LDRSB    r8,[r10],#1
;;;231    
;;;232        /* Read Index, from where the state buffer should be read, is calculated. */
;;;233        readIndex = ((int32_t) S->stateIndex -
000196  f8b91002          LDRH     r1,[r9,#2]
00019a  f85b0b04          LDR      r0,[r11],#4
00019e  1b49              SUBS     r1,r1,r5
0001a0  1a08              SUBS     r0,r1,r0
0001a2  9007              STR      r0,[sp,#0x1c]
;;;234                     (int32_t) blockSize) - *pTapDelay++;
;;;235    
;;;236        /* Wraparound of readIndex */
;;;237        if(readIndex < 0)
0001a4  2800              CMP      r0,#0
0001a6  da02              BGE      |L2.430|
;;;238        {
;;;239          readIndex += (int32_t) delaySize;
0001a8  9909              LDR      r1,[sp,#0x24]
0001aa  4408              ADD      r0,r0,r1
0001ac  9007              STR      r0,[sp,#0x1c]
                  |L2.430|
;;;240        }
;;;241    
;;;242        /* Decrement the tap loop counter */
;;;243        tapCnt--;
0001ae  9806              LDR      r0,[sp,#0x18]
0001b0  1e40              SUBS     r0,r0,#1
0001b2  9006              STR      r0,[sp,#0x18]
                  |L2.436|
0001b4  9806              LDR      r0,[sp,#0x18]         ;179
0001b6  2800              CMP      r0,#0                 ;179
0001b8  d1ae              BNE      |L2.280|
;;;244      }
;;;245    	
;;;246    	/* Compute last tap without the final read of pTapDelay */	
;;;247    	
;;;248    	/* Working pointer for state buffer is updated */
;;;249    	py = pState;
0001ba  980a              LDR      r0,[sp,#0x28]
;;;250    
;;;251    	/* blockSize samples are read from the state buffer */
;;;252    	arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,
0001bc  e9cd6501          STRD     r6,r5,[sp,#4]
0001c0  2101              MOVS     r1,#1
0001c2  9600              STR      r6,[sp,#0]
0001c4  e9cd1503          STRD     r1,r5,[sp,#0xc]
0001c8  460b              MOV      r3,r1
0001ca  aa07              ADD      r2,sp,#0x1c
0001cc  9909              LDR      r1,[sp,#0x24]
0001ce  f7fffffe          BL       arm_circularRead_q7
;;;253    											(int32_t) blockSize, 1, blockSize);
;;;254    
;;;255    	/* Working pointer for the scratch buffer of state values */
;;;256    	px = pb;
;;;257    
;;;258    	/* Working pointer for scratch buffer of output values */
;;;259    	pScratchOut = pScr2;
0001d2  4620              MOV      r0,r4
;;;260    
;;;261    	/* Loop over the blockSize. Unroll by a factor of 4.    
;;;262    	 * Compute 4 MACS at a time. */
;;;263    	blkCnt = blockSize >> 2;
0001d4  990c              LDR      r1,[sp,#0x30]
;;;264    
;;;265    	while(blkCnt > 0u)
0001d6  e01a              B        |L2.526|
                  |L2.472|
;;;266    	{
;;;267    		/* Perform Multiply-Accumulate */
;;;268    		in = *pScratchOut + ((q31_t) * px++ * coeff);
0001d8  f9962000          LDRSB    r2,[r6,#0]
0001dc  6803              LDR      r3,[r0,#0]
0001de  fb023208          MLA      r2,r2,r8,r3
;;;269    		*pScratchOut++ = in;
0001e2  6002              STR      r2,[r0,#0]
;;;270    		in = *pScratchOut + ((q31_t) * px++ * coeff);
0001e4  f9962001          LDRSB    r2,[r6,#1]
0001e8  6843              LDR      r3,[r0,#4]
0001ea  fb023208          MLA      r2,r2,r8,r3
;;;271    		*pScratchOut++ = in;
0001ee  6042              STR      r2,[r0,#4]
;;;272    		in = *pScratchOut + ((q31_t) * px++ * coeff);
0001f0  f9962002          LDRSB    r2,[r6,#2]
0001f4  6883              LDR      r3,[r0,#8]
0001f6  fb023208          MLA      r2,r2,r8,r3
;;;273    		*pScratchOut++ = in;
0001fa  6082              STR      r2,[r0,#8]
;;;274    		in = *pScratchOut + ((q31_t) * px++ * coeff);
0001fc  f9962003          LDRSB    r2,[r6,#3]
000200  68c3              LDR      r3,[r0,#0xc]
000202  1d36              ADDS     r6,r6,#4
000204  fb023208          MLA      r2,r2,r8,r3
;;;275    		*pScratchOut++ = in;
000208  60c2              STR      r2,[r0,#0xc]
00020a  3010              ADDS     r0,r0,#0x10
;;;276    
;;;277    		/* Decrement the loop counter */
;;;278    		blkCnt--;
00020c  1e49              SUBS     r1,r1,#1
                  |L2.526|
00020e  2900              CMP      r1,#0                 ;265
000210  d1e2              BNE      |L2.472|
;;;279    	}
;;;280    
;;;281    	/* If the blockSize is not a multiple of 4,    
;;;282    	 * compute the remaining samples */
;;;283    	blkCnt = blockSize % 0x4u;
000212  990b              LDR      r1,[sp,#0x2c]
;;;284    
;;;285    	while(blkCnt > 0u)
000214  e006              B        |L2.548|
                  |L2.534|
;;;286    	{
;;;287    		/* Perform Multiply-Accumulate */
;;;288    		in = *pScratchOut + ((q31_t) * px++ * coeff);
000216  f9162b01          LDRSB    r2,[r6],#1
00021a  6803              LDR      r3,[r0,#0]
00021c  fb023208          MLA      r2,r2,r8,r3
;;;289    		*pScratchOut++ = in;
000220  c004              STM      r0!,{r2}
;;;290    
;;;291    		/* Decrement the loop counter */
;;;292    		blkCnt--;
000222  1e49              SUBS     r1,r1,#1
                  |L2.548|
000224  2900              CMP      r1,#0                 ;285
000226  d1f6              BNE      |L2.534|
;;;293    	}
;;;294    
;;;295      /* All the output values are in pScratchOut buffer.    
;;;296         Convert them into 1.15 format, saturate and store in the destination buffer. */
;;;297      /* Loop over the blockSize. */
;;;298      blkCnt = blockSize >> 2;
000228  980c              LDR      r0,[sp,#0x30]
;;;299    
;;;300      while(blkCnt > 0u)
00022a  e01a              B        |L2.610|
                  |L2.556|
;;;301      {
;;;302        in1 = (q7_t) __SSAT(*pScr2++ >> 7, 8);
00022c  6821              LDR      r1,[r4,#0]
00022e  f32111c7          SSAT     r1,#8,r1,ASR #7
;;;303        in2 = (q7_t) __SSAT(*pScr2++ >> 7, 8);
000232  6862              LDR      r2,[r4,#4]
000234  f32212c7          SSAT     r2,#8,r2,ASR #7
;;;304        in3 = (q7_t) __SSAT(*pScr2++ >> 7, 8);
000238  68a3              LDR      r3,[r4,#8]
00023a  f32313c7          SSAT     r3,#8,r3,ASR #7
;;;305        in4 = (q7_t) __SSAT(*pScr2++ >> 7, 8);
00023e  68e5              LDR      r5,[r4,#0xc]
000240  3410              ADDS     r4,r4,#0x10
000242  f32515c7          SSAT     r5,#8,r5,ASR #7
;;;306    
;;;307        *__SIMD32(pOut)++ = __PACKq7(in1, in2, in3, in4);
000246  f64f76ff          MOV      r6,#0xffff
00024a  b2c9              UXTB     r1,r1
00024c  ea062202          AND      r2,r6,r2,LSL #8
000250  4311              ORRS     r1,r1,r2
000252  b2da              UXTB     r2,r3
000254  ea414102          ORR      r1,r1,r2,LSL #16
000258  ea416105          ORR      r1,r1,r5,LSL #24
00025c  f8471b04          STR      r1,[r7],#4
;;;308    
;;;309        /* Decrement the blockSize loop counter */
;;;310        blkCnt--;
000260  1e40              SUBS     r0,r0,#1
                  |L2.610|
000262  2800              CMP      r0,#0                 ;300
000264  d1e2              BNE      |L2.556|
;;;311      }
;;;312    
;;;313      /* If the blockSize is not a multiple of 4,    
;;;314         remaining samples are processed in the below loop */
;;;315      blkCnt = blockSize % 0x4u;
000266  980b              LDR      r0,[sp,#0x2c]
;;;316    
;;;317      while(blkCnt > 0u)
000268  e005              B        |L2.630|
                  |L2.618|
;;;318      {
;;;319        *pOut++ = (q7_t) __SSAT(*pScr2++ >> 7, 8);
00026a  cc02              LDM      r4!,{r1}
00026c  f32111c7          SSAT     r1,#8,r1,ASR #7
000270  f8071b01          STRB     r1,[r7],#1
;;;320    
;;;321        /* Decrement the blockSize loop counter */
;;;322        blkCnt--;
000274  1e40              SUBS     r0,r0,#1
                  |L2.630|
000276  2800              CMP      r0,#0                 ;317
000278  d1f7              BNE      |L2.618|
;;;323      }
;;;324    
;;;325    #else
;;;326    
;;;327      /* Run the below code for Cortex-M0 */
;;;328    
;;;329      /* BlockSize of Input samples are copied into the state buffer */
;;;330      /* StateIndex points to the starting position to write in the state buffer */
;;;331      arm_circularWrite_q7(py, (int32_t) delaySize, &S->stateIndex, 1, pSrc, 1,
;;;332                           blockSize);
;;;333    
;;;334      /* Loop over the number of taps. */
;;;335      tapCnt = numTaps;
;;;336    
;;;337      /* Read Index, from where the state buffer should be read, is calculated. */
;;;338      readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
;;;339    
;;;340      /* Wraparound of readIndex */
;;;341      if(readIndex < 0)
;;;342      {
;;;343        readIndex += (int32_t) delaySize;
;;;344      }
;;;345    
;;;346      /* Working pointer for state buffer is updated */
;;;347      py = pState;
;;;348    
;;;349      /* blockSize samples are read from the state buffer */
;;;350      arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,
;;;351                          (int32_t) blockSize, 1, blockSize);
;;;352    
;;;353      /* Working pointer for the scratch buffer of state values */
;;;354      px = pb;
;;;355    
;;;356      /* Working pointer for scratch buffer of output values */
;;;357      pScratchOut = pScr2;
;;;358    
;;;359      /* Loop over the blockSize */
;;;360      blkCnt = blockSize;
;;;361    
;;;362      while(blkCnt > 0u)
;;;363      {
;;;364        /* Perform multiplication and store in the scratch buffer */
;;;365        *pScratchOut++ = ((q31_t) * px++ * coeff);
;;;366    
;;;367        /* Decrement the loop counter */
;;;368        blkCnt--;
;;;369      }
;;;370    
;;;371      /* Load the coefficient value and           
;;;372       * increment the coefficient buffer for the next set of state values */
;;;373      coeff = *pCoeffs++;
;;;374    
;;;375      /* Read Index, from where the state buffer should be read, is calculated. */
;;;376      readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
;;;377    
;;;378      /* Wraparound of readIndex */
;;;379      if(readIndex < 0)
;;;380      {
;;;381        readIndex += (int32_t) delaySize;
;;;382      }
;;;383    
;;;384      /* Loop over the number of taps. */
;;;385      tapCnt = (uint32_t) numTaps - 2u;
;;;386    
;;;387      while(tapCnt > 0u)
;;;388      {
;;;389        /* Working pointer for state buffer is updated */
;;;390        py = pState;
;;;391    
;;;392        /* blockSize samples are read from the state buffer */
;;;393        arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,
;;;394                            (int32_t) blockSize, 1, blockSize);
;;;395    
;;;396        /* Working pointer for the scratch buffer of state values */
;;;397        px = pb;
;;;398    
;;;399        /* Working pointer for scratch buffer of output values */
;;;400        pScratchOut = pScr2;
;;;401    
;;;402        /* Loop over the blockSize */
;;;403        blkCnt = blockSize;
;;;404    
;;;405        while(blkCnt > 0u)
;;;406        {
;;;407          /* Perform Multiply-Accumulate */
;;;408          in = *pScratchOut + ((q31_t) * px++ * coeff);
;;;409          *pScratchOut++ = in;
;;;410    
;;;411          /* Decrement the loop counter */
;;;412          blkCnt--;
;;;413        }
;;;414    
;;;415        /* Load the coefficient value and           
;;;416         * increment the coefficient buffer for the next set of state values */
;;;417        coeff = *pCoeffs++;
;;;418    
;;;419        /* Read Index, from where the state buffer should be read, is calculated. */
;;;420        readIndex =
;;;421          ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
;;;422    
;;;423        /* Wraparound of readIndex */
;;;424        if(readIndex < 0)
;;;425        {
;;;426          readIndex += (int32_t) delaySize;
;;;427        }
;;;428    
;;;429        /* Decrement the tap loop counter */
;;;430        tapCnt--;
;;;431      }
;;;432    	
;;;433    	/* Compute last tap without the final read of pTapDelay */	
;;;434    	
;;;435    	/* Working pointer for state buffer is updated */
;;;436    	py = pState;
;;;437    
;;;438    	/* blockSize samples are read from the state buffer */
;;;439    	arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,
;;;440    											(int32_t) blockSize, 1, blockSize);
;;;441    
;;;442    	/* Working pointer for the scratch buffer of state values */
;;;443    	px = pb;
;;;444    
;;;445    	/* Working pointer for scratch buffer of output values */
;;;446    	pScratchOut = pScr2;
;;;447    
;;;448    	/* Loop over the blockSize */
;;;449    	blkCnt = blockSize;
;;;450    
;;;451    	while(blkCnt > 0u)
;;;452    	{
;;;453    		/* Perform Multiply-Accumulate */
;;;454    		in = *pScratchOut + ((q31_t) * px++ * coeff);
;;;455    		*pScratchOut++ = in;
;;;456    
;;;457    		/* Decrement the loop counter */
;;;458    		blkCnt--;
;;;459    	}
;;;460    
;;;461      /* All the output values are in pScratchOut buffer.       
;;;462         Convert them into 1.15 format, saturate and store in the destination buffer. */
;;;463      /* Loop over the blockSize. */
;;;464      blkCnt = blockSize;
;;;465    
;;;466      while(blkCnt > 0u)
;;;467      {
;;;468        *pOut++ = (q7_t) __SSAT(*pScr2++ >> 7, 8);
;;;469    
;;;470        /* Decrement the blockSize loop counter */
;;;471        blkCnt--;
;;;472      }
;;;473    
;;;474    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;475    
;;;476    }
00027a  b00d              ADD      sp,sp,#0x34
00027c  e8bd8ff0          POP      {r4-r11,pc}
;;;477    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_fir_sparse_q7.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_fir_sparse_q7_c_0adf4ae3____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___19_arm_fir_sparse_q7_c_0adf4ae3____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_fir_sparse_q7_c_0adf4ae3____REVSH|
#line 144
|__asm___19_arm_fir_sparse_q7_c_0adf4ae3____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_fir_sparse_q7_c_0adf4ae3____RRX|
#line 300
|__asm___19_arm_fir_sparse_q7_c_0adf4ae3____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
