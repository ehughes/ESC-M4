; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_iir_lattice_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_iir_lattice_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_iir_lattice_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_iir_lattice_q15.c]
                          THUMB

                          AREA ||i.arm_iir_lattice_q15||, CODE, READONLY, ALIGN=1

                  arm_iir_lattice_q15 PROC
;;;70     
;;;71     void arm_iir_lattice_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;72       const arm_iir_lattice_instance_q15 * S,
;;;73       q15_t * pSrc,
;;;74       q15_t * pDst,
;;;75       uint32_t blockSize)
;;;76     {
000004  b084              SUB      sp,sp,#0x10
;;;77     
;;;78     
;;;79     #ifndef ARM_MATH_CM0_FAMILY
;;;80     
;;;81       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;82     
;;;83       q31_t fcurr, fnext, gcurr = 0, gnext;          /* Temporary variables for lattice stages */
;;;84       q15_t gnext1, gnext2;                          /* Temporary variables for lattice stages */
;;;85       uint32_t stgCnt;                               /* Temporary variables for counts */
;;;86       q63_t acc;                                     /* Accumlator */
;;;87       uint32_t blkCnt, tapCnt;                       /* Temporary variables for counts */
;;;88       q15_t *px1, *px2, *pk, *pv;                    /* temporary pointers for state and coef */
;;;89       uint32_t numStages = S->numStages;             /* number of stages */
000006  8801              LDRH     r1,[r0,#0]
000008  9100              STR      r1,[sp,#0]
;;;90       q15_t *pState;                                 /* State pointer */
;;;91       q15_t *pStateCurnt;                            /* State current pointer */
;;;92       q15_t out;                                     /* Temporary variable for output */
;;;93       q31_t v;                                       /* Temporary variable for ladder coefficient */
;;;94     #ifdef UNALIGNED_SUPPORT_DISABLE
;;;95     	q15_t v1, v2;
;;;96     #endif
;;;97     
;;;98     
;;;99       blkCnt = blockSize;
00000a  f8dde01c          LDR      lr,[sp,#0x1c]
;;;100    
;;;101      pState = &S->pState[0];
00000e  f8d08004          LDR      r8,[r0,#4]
000012  e0ca              B        |L1.426|
                  |L1.20|
;;;102    
;;;103      /* Sample processing */
;;;104      while(blkCnt > 0u)
;;;105      {
;;;106        /* Read Sample from input buffer */
;;;107        /* fN(n) = x(n) */
;;;108        fcurr = *pSrc++;
000014  9905              LDR      r1,[sp,#0x14]
000016  f9317b02          LDRSH    r7,[r1],#2
00001a  9105              STR      r1,[sp,#0x14]
;;;109    
;;;110        /* Initialize state read pointer */
;;;111        px1 = pState;
;;;112        /* Initialize state write pointer */
;;;113        px2 = pState;
00001c  4643              MOV      r3,r8
;;;114        /* Set accumulator to zero */
;;;115        acc = 0;
;;;116        /* Initialize Ladder coeff pointer */
;;;117        pv = &S->pvCoeffs[0];
00001e  68c4              LDR      r4,[r0,#0xc]
;;;118        /* Initialize Reflection coeff pointer */
;;;119        pk = &S->pkCoeffs[0];
000020  6886              LDR      r6,[r0,#8]
;;;120    
;;;121    
;;;122        /* Process sample for first tap */
;;;123        gcurr = *px1++;
000022  f9b31000          LDRSH    r1,[r3,#0]
000026  1c9d              ADDS     r5,r3,#2
;;;124        /* fN-1(n) = fN(n) - kN * gN-1(n-1) */
;;;125        fnext = fcurr - (((q31_t) gcurr * (*pk)) >> 15);
000028  f9362b02          LDRSH    r2,[r6],#2
00002c  fb12fc01          SMULBB   r12,r2,r1
000030  eba737ec          SUB      r7,r7,r12,ASR #15
;;;126        fnext = __SSAT(fnext, 16);
000034  f307070f          SSAT     r7,#16,r7
;;;127        /* gN(n) = kN * fN-1(n) + gN-1(n-1) */
;;;128        gnext = (((q31_t) fnext * (*pk++)) >> 15) + gcurr;
000038  437a              MULS     r2,r7,r2
00003a  eb0131e2          ADD      r1,r1,r2,ASR #15
;;;129        gnext = __SSAT(gnext, 16);
00003e  f301020f          SSAT     r2,#16,r1
;;;130        /* write gN(n) into state for next sample processing */
;;;131        *px2++ = (q15_t) gnext;
000042  f8232b02          STRH     r2,[r3],#2
;;;132        /* y(n) += gN(n) * vN  */
;;;133        acc += (q31_t) ((gnext * (*pv++)));
000046  f9341b02          LDRSH    r1,[r4],#2
00004a  4351              MULS     r1,r2,r1
00004c  17ca              ASRS     r2,r1,#31
;;;134    
;;;135    
;;;136        /* Update f values for next coefficient processing */
;;;137        fcurr = fnext;
;;;138    
;;;139        /* Loop unrolling.  Process 4 taps at a time. */
;;;140        tapCnt = (numStages - 1u) >> 2;
00004e  f8ddc000          LDR      r12,[sp,#0]
000052  f1ac0c01          SUB      r12,r12,#1
000056  f8cdc00c          STR      r12,[sp,#0xc]
00005a  ea4f0c9c          LSR      r12,r12,#2
;;;141    
;;;142        while(tapCnt > 0u)
00005e  e061              B        |L1.292|
                  |L1.96|
;;;143        {
;;;144    
;;;145          /* Process sample for 2nd, 6th ...taps */
;;;146          /* Read gN-2(n-1) from state buffer */
;;;147          gcurr = *px1++;
000060  f9359b02          LDRSH    r9,[r5],#2
;;;148          /* Process sample for 2nd, 6th .. taps */
;;;149          /* fN-2(n) = fN-1(n) - kN-1 * gN-2(n-1) */
;;;150          fnext = fcurr - (((q31_t) gcurr * (*pk)) >> 15);
000064  f9b6a000          LDRSH    r10,[r6,#0]
000068  fb1afb09          SMULBB   r11,r10,r9
00006c  eba737eb          SUB      r7,r7,r11,ASR #15
;;;151          fnext = __SSAT(fnext, 16);
000070  f307070f          SSAT     r7,#16,r7
;;;152          /* gN-1(n) = kN-1 * fN-2(n) + gN-2(n-1) */
;;;153          gnext = (((q31_t) fnext * (*pk++)) >> 15) + gcurr;
000074  fb0afa07          MUL      r10,r10,r7
000078  1cb6              ADDS     r6,r6,#2
00007a  eb0939ea          ADD      r9,r9,r10,ASR #15
;;;154          gnext1 = (q15_t) __SSAT(gnext, 16);
00007e  f309090f          SSAT     r9,#16,r9
;;;155          /* write gN-1(n) into state */
;;;156          *px2++ = (q15_t) gnext1;
000082  f8239b02          STRH     r9,[r3],#2
;;;157    
;;;158    
;;;159          /* Process sample for 3nd, 7th ...taps */
;;;160          /* Read gN-3(n-1) from state */
;;;161          gcurr = *px1++;
000086  f935ab02          LDRSH    r10,[r5],#2
;;;162          /* Process sample for 3rd, 7th .. taps */
;;;163          /* fN-3(n) = fN-2(n) - kN-2 * gN-3(n-1) */
;;;164          fcurr = fnext - (((q31_t) gcurr * (*pk)) >> 15);
00008a  f9b6b000          LDRSH    r11,[r6,#0]
00008e  f8cdb008          STR      r11,[sp,#8]
000092  fb1bfb0a          SMULBB   r11,r11,r10
000096  eba737eb          SUB      r7,r7,r11,ASR #15
;;;165          fcurr = __SSAT(fcurr, 16);
00009a  f307070f          SSAT     r7,#16,r7
;;;166          /* gN-2(n) = kN-2 * fN-3(n) + gN-3(n-1) */
;;;167          gnext = (((q31_t) fcurr * (*pk++)) >> 15) + gcurr;
00009e  f8ddb008          LDR      r11,[sp,#8]
0000a2  1cb6              ADDS     r6,r6,#2
0000a4  fb0bfb07          MUL      r11,r11,r7
0000a8  eb0a3aeb          ADD      r10,r10,r11,ASR #15
;;;168          gnext2 = (q15_t) __SSAT(gnext, 16);
0000ac  f30a0a0f          SSAT     r10,#16,r10
;;;169          /* write gN-2(n) into state */
;;;170          *px2++ = (q15_t) gnext2;
0000b0  f823ab02          STRH     r10,[r3],#2
;;;171    
;;;172          /* Read vN-1 and vN-2 at a time */
;;;173    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;174    
;;;175          v = *__SIMD32(pv)++;
0000b4  f854bb04          LDR      r11,[r4],#4
;;;176    
;;;177    #else
;;;178    
;;;179    	  v1 = *pv++;
;;;180    	  v2 = *pv++;
;;;181    
;;;182    #ifndef ARM_MATH_BIG_ENDIAN
;;;183    
;;;184    	  v = __PKHBT(v1, v2, 16);
;;;185    
;;;186    #else
;;;187    
;;;188    	  v = __PKHBT(v2, v1, 16);
;;;189    
;;;190    #endif	/* 	#ifndef ARM_MATH_BIG_ENDIAN		*/
;;;191    
;;;192    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE */
;;;193    
;;;194    
;;;195          /* Pack gN-1(n) and gN-2(n) */
;;;196    
;;;197    #ifndef  ARM_MATH_BIG_ENDIAN
;;;198    
;;;199          gnext = __PKHBT(gnext1, gnext2, 16);
0000b8  eac9490a          PKHBT    r9,r9,r10,LSL #16
;;;200    
;;;201    #else
;;;202    
;;;203          gnext = __PKHBT(gnext2, gnext1, 16);
;;;204    
;;;205    #endif /*   #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;206    
;;;207          /* y(n) += gN-1(n) * vN-1  */
;;;208          /* process for gN-5(n) * vN-5, gN-9(n) * vN-9 ... */
;;;209          /* y(n) += gN-2(n) * vN-2  */
;;;210          /* process for gN-6(n) * vN-6, gN-10(n) * vN-10 ... */
;;;211          acc = __SMLALD(gnext, v, acc);
0000bc  fbc912cb          SMLALD   r1,r2,r9,r11
;;;212    
;;;213    
;;;214          /* Process sample for 4th, 8th ...taps */
;;;215          /* Read gN-4(n-1) from state */
;;;216          gcurr = *px1++;
0000c0  f9359b02          LDRSH    r9,[r5],#2
;;;217          /* Process sample for 4th, 8th .. taps */
;;;218          /* fN-4(n) = fN-3(n) - kN-3 * gN-4(n-1) */
;;;219          fnext = fcurr - (((q31_t) gcurr * (*pk)) >> 15);
0000c4  f9b6a000          LDRSH    r10,[r6,#0]
0000c8  fb1afb09          SMULBB   r11,r10,r9
0000cc  eba737eb          SUB      r7,r7,r11,ASR #15
;;;220          fnext = __SSAT(fnext, 16);
0000d0  f307070f          SSAT     r7,#16,r7
;;;221          /* gN-3(n) = kN-3 * fN-1(n) + gN-1(n-1) */
;;;222          gnext = (((q31_t) fnext * (*pk++)) >> 15) + gcurr;
0000d4  fb0afa07          MUL      r10,r10,r7
0000d8  1cb6              ADDS     r6,r6,#2
0000da  eb0939ea          ADD      r9,r9,r10,ASR #15
;;;223          gnext1 = (q15_t) __SSAT(gnext, 16);
0000de  f309090f          SSAT     r9,#16,r9
;;;224          /* write  gN-3(n) for the next sample process */
;;;225          *px2++ = (q15_t) gnext1;
0000e2  f8239b02          STRH     r9,[r3],#2
;;;226    
;;;227    
;;;228          /* Process sample for 5th, 9th ...taps */
;;;229          /* Read gN-5(n-1) from state */
;;;230          gcurr = *px1++;
0000e6  f935ab02          LDRSH    r10,[r5],#2
;;;231          /* Process sample for 5th, 9th .. taps */
;;;232          /* fN-5(n) = fN-4(n) - kN-4 * gN-5(n-1) */
;;;233          fcurr = fnext - (((q31_t) gcurr * (*pk)) >> 15);
0000ea  f9b6b000          LDRSH    r11,[r6,#0]
0000ee  f8cdb004          STR      r11,[sp,#4]
0000f2  fb1bfb0a          SMULBB   r11,r11,r10
0000f6  eba737eb          SUB      r7,r7,r11,ASR #15
;;;234          fcurr = __SSAT(fcurr, 16);
0000fa  f307070f          SSAT     r7,#16,r7
;;;235          /* gN-4(n) = kN-4 * fN-5(n) + gN-5(n-1) */
;;;236          gnext = (((q31_t) fcurr * (*pk++)) >> 15) + gcurr;
0000fe  f8ddb004          LDR      r11,[sp,#4]
000102  1cb6              ADDS     r6,r6,#2
000104  fb0bfb07          MUL      r11,r11,r7
000108  eb0a3aeb          ADD      r10,r10,r11,ASR #15
;;;237          gnext2 = (q15_t) __SSAT(gnext, 16);
00010c  f30a0a0f          SSAT     r10,#16,r10
;;;238          /* write      gN-4(n) for the next sample process */
;;;239          *px2++ = (q15_t) gnext2;
000110  f823ab02          STRH     r10,[r3],#2
;;;240    
;;;241          /* Read vN-3 and vN-4 at a time */
;;;242    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;243    
;;;244          v = *__SIMD32(pv)++;
000114  f854bb04          LDR      r11,[r4],#4
;;;245    
;;;246    #else
;;;247    
;;;248    	  v1 = *pv++;
;;;249    	  v2 = *pv++;
;;;250    
;;;251    #ifndef ARM_MATH_BIG_ENDIAN
;;;252    
;;;253    	  v = __PKHBT(v1, v2, 16);
;;;254    
;;;255    #else
;;;256    
;;;257    	  v = __PKHBT(v2, v1, 16);
;;;258    
;;;259    #endif	/* #ifndef ARM_MATH_BIG_ENDIAN	 */
;;;260    
;;;261    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE */
;;;262    
;;;263    
;;;264          /* Pack gN-3(n) and gN-4(n) */
;;;265    #ifndef  ARM_MATH_BIG_ENDIAN
;;;266    
;;;267          gnext = __PKHBT(gnext1, gnext2, 16);
000118  eac9490a          PKHBT    r9,r9,r10,LSL #16
;;;268    
;;;269    #else
;;;270    
;;;271          gnext = __PKHBT(gnext2, gnext1, 16);
;;;272    
;;;273    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;274    
;;;275          /* y(n) += gN-4(n) * vN-4  */
;;;276          /* process for gN-8(n) * vN-8, gN-12(n) * vN-12 ... */
;;;277          /* y(n) += gN-3(n) * vN-3  */
;;;278          /* process for gN-7(n) * vN-7, gN-11(n) * vN-11 ... */
;;;279          acc = __SMLALD(gnext, v, acc);
00011c  fbc912cb          SMLALD   r1,r2,r9,r11
;;;280    
;;;281          tapCnt--;
000120  f1ac0c01          SUB      r12,r12,#1
                  |L1.292|
000124  f1bc0f00          CMP      r12,#0                ;142
000128  d19a              BNE      |L1.96|
;;;282    
;;;283        }
;;;284    
;;;285        fnext = fcurr;
00012a  46bc              MOV      r12,r7
;;;286    
;;;287        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;288        tapCnt = (numStages - 1u) % 0x4u;
00012c  f8dd900c          LDR      r9,[sp,#0xc]
000130  f0090903          AND      r9,r9,#3
;;;289    
;;;290        while(tapCnt > 0u)
000134  e01d              B        |L1.370|
                  |L1.310|
;;;291        {
;;;292          gcurr = *px1++;
000136  f935ab02          LDRSH    r10,[r5],#2
;;;293          /* Process sample for last taps */
;;;294          fnext = fcurr - (((q31_t) gcurr * (*pk)) >> 15);
00013a  f9b6b000          LDRSH    r11,[r6,#0]
00013e  fb1bfc0a          SMULBB   r12,r11,r10
000142  eba737ec          SUB      r7,r7,r12,ASR #15
;;;295          fnext = __SSAT(fnext, 16);
000146  f3070c0f          SSAT     r12,#16,r7
;;;296          gnext = (((q31_t) fnext * (*pk++)) >> 15) + gcurr;
00014a  fb0bfb0c          MUL      r11,r11,r12
00014e  1cb6              ADDS     r6,r6,#2
000150  eb0a37eb          ADD      r7,r10,r11,ASR #15
;;;297          gnext = __SSAT(gnext, 16);
000154  f307070f          SSAT     r7,#16,r7
;;;298          /* Output samples for last taps */
;;;299          acc += (q31_t) (((q31_t) gnext * (*pv++)));
000158  f934ab02          LDRSH    r10,[r4],#2
00015c  fb0afa07          MUL      r10,r10,r7
000160  eb1a0101          ADDS     r1,r10,r1
000164  eb4272ea          ADC      r2,r2,r10,ASR #31
;;;300          *px2++ = (q15_t) gnext;
000168  f8237b02          STRH     r7,[r3],#2
;;;301          fcurr = fnext;
00016c  4667              MOV      r7,r12
;;;302    
;;;303          tapCnt--;
00016e  f1a90901          SUB      r9,r9,#1
                  |L1.370|
000172  f1b90f00          CMP      r9,#0                 ;290
000176  d1de              BNE      |L1.310|
;;;304        }
;;;305    
;;;306        /* y(n) += g0(n) * v0 */
;;;307        acc += (q31_t) (((q31_t) fnext * (*pv++)));
000178  f9b44000          LDRSH    r4,[r4,#0]
00017c  fb04f40c          MUL      r4,r4,r12
000180  1861              ADDS     r1,r4,r1
000182  eb4272e4          ADC      r2,r2,r4,ASR #31
;;;308    
;;;309        out = (q15_t) __SSAT(acc >> 15, 16);
000186  ea4f31d1          LSR      r1,r1,#15
00018a  ea414142          ORR      r1,r1,r2,LSL #17
00018e  f301010f          SSAT     r1,#16,r1
;;;310        *px2++ = (q15_t) fnext;
000192  f8a3c000          STRH     r12,[r3,#0]
;;;311    
;;;312        /* write out into pDst */
;;;313        *pDst++ = out;
000196  9a06              LDR      r2,[sp,#0x18]
000198  8011              STRH     r1,[r2,#0]
00019a  9906              LDR      r1,[sp,#0x18]
00019c  f1010102          ADD      r1,r1,#2
0001a0  9106              STR      r1,[sp,#0x18]
;;;314    
;;;315        /* Advance the state pointer by 4 to process the next group of 4 samples */
;;;316        pState = pState + 1u;
0001a2  f1080802          ADD      r8,r8,#2
;;;317        blkCnt--;
0001a6  f1ae0e01          SUB      lr,lr,#1
                  |L1.426|
0001aa  f1be0f00          CMP      lr,#0                 ;104
0001ae  f47faf31          BNE      |L1.20|
;;;318    
;;;319      }
;;;320    
;;;321      /* Processing is complete. Now copy last S->numStages samples to start of the buffer    
;;;322         for the preperation of next frame process */
;;;323      /* Points to the start of the state buffer */
;;;324      pStateCurnt = &S->pState[0];
0001b2  6840              LDR      r0,[r0,#4]
;;;325      pState = &S->pState[blockSize];
0001b4  9907              LDR      r1,[sp,#0x1c]
0001b6  eb000141          ADD      r1,r0,r1,LSL #1
;;;326    
;;;327      stgCnt = (numStages >> 2u);
0001ba  9a00              LDR      r2,[sp,#0]
0001bc  0892              LSRS     r2,r2,#2
;;;328    
;;;329      /* copy data */
;;;330      while(stgCnt > 0u)
0001be  e006              B        |L1.462|
                  |L1.448|
;;;331      {
;;;332    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;333    
;;;334        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
0001c0  680b              LDR      r3,[r1,#0]
0001c2  6003              STR      r3,[r0,#0]
;;;335        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
0001c4  684b              LDR      r3,[r1,#4]
0001c6  3108              ADDS     r1,r1,#8
0001c8  6043              STR      r3,[r0,#4]
0001ca  3008              ADDS     r0,r0,#8
;;;336    
;;;337    #else
;;;338    
;;;339        *pStateCurnt++ = *pState++;
;;;340        *pStateCurnt++ = *pState++;
;;;341        *pStateCurnt++ = *pState++;
;;;342        *pStateCurnt++ = *pState++;
;;;343    
;;;344    #endif /*	#ifndef UNALIGNED_SUPPORT_DISABLE */
;;;345    
;;;346        /* Decrement the loop counter */
;;;347        stgCnt--;
0001cc  1e52              SUBS     r2,r2,#1
                  |L1.462|
0001ce  2a00              CMP      r2,#0                 ;330
0001d0  d1f6              BNE      |L1.448|
;;;348    
;;;349      }
;;;350    
;;;351      /* Calculation of count for remaining q15_t data */
;;;352      stgCnt = (numStages) % 0x4u;
0001d2  9a00              LDR      r2,[sp,#0]
0001d4  f0020203          AND      r2,r2,#3
;;;353    
;;;354      /* copy data */
;;;355      while(stgCnt > 0u)
0001d8  e004              B        |L1.484|
                  |L1.474|
;;;356      {
;;;357        *pStateCurnt++ = *pState++;
0001da  f8313b02          LDRH     r3,[r1],#2
0001de  f8203b02          STRH     r3,[r0],#2
;;;358    
;;;359        /* Decrement the loop counter */
;;;360        stgCnt--;
0001e2  1e52              SUBS     r2,r2,#1
                  |L1.484|
0001e4  2a00              CMP      r2,#0                 ;355
0001e6  d1f8              BNE      |L1.474|
;;;361      }
;;;362    
;;;363    #else
;;;364    
;;;365      /* Run the below code for Cortex-M0 */
;;;366    
;;;367      q31_t fcurr, fnext = 0, gcurr = 0, gnext;      /* Temporary variables for lattice stages */
;;;368      uint32_t stgCnt;                               /* Temporary variables for counts */
;;;369      q63_t acc;                                     /* Accumlator */
;;;370      uint32_t blkCnt, tapCnt;                       /* Temporary variables for counts */
;;;371      q15_t *px1, *px2, *pk, *pv;                    /* temporary pointers for state and coef */
;;;372      uint32_t numStages = S->numStages;             /* number of stages */
;;;373      q15_t *pState;                                 /* State pointer */
;;;374      q15_t *pStateCurnt;                            /* State current pointer */
;;;375      q15_t out;                                     /* Temporary variable for output */
;;;376    
;;;377    
;;;378      blkCnt = blockSize;
;;;379    
;;;380      pState = &S->pState[0];
;;;381    
;;;382      /* Sample processing */
;;;383      while(blkCnt > 0u)
;;;384      {
;;;385        /* Read Sample from input buffer */
;;;386        /* fN(n) = x(n) */
;;;387        fcurr = *pSrc++;
;;;388    
;;;389        /* Initialize state read pointer */
;;;390        px1 = pState;
;;;391        /* Initialize state write pointer */
;;;392        px2 = pState;
;;;393        /* Set accumulator to zero */
;;;394        acc = 0;
;;;395        /* Initialize Ladder coeff pointer */
;;;396        pv = &S->pvCoeffs[0];
;;;397        /* Initialize Reflection coeff pointer */
;;;398        pk = &S->pkCoeffs[0];
;;;399    
;;;400        tapCnt = numStages;
;;;401    
;;;402        while(tapCnt > 0u)
;;;403        {
;;;404          gcurr = *px1++;
;;;405          /* Process sample */
;;;406          /* fN-1(n) = fN(n) - kN * gN-1(n-1) */
;;;407          fnext = fcurr - ((gcurr * (*pk)) >> 15);
;;;408          fnext = __SSAT(fnext, 16);
;;;409          /* gN(n) = kN * fN-1(n) + gN-1(n-1) */
;;;410          gnext = ((fnext * (*pk++)) >> 15) + gcurr;
;;;411          gnext = __SSAT(gnext, 16);
;;;412          /* Output samples */
;;;413          /* y(n) += gN(n) * vN */
;;;414          acc += (q31_t) ((gnext * (*pv++)));
;;;415          /* write gN(n) into state for next sample processing */
;;;416          *px2++ = (q15_t) gnext;
;;;417          /* Update f values for next coefficient processing */
;;;418          fcurr = fnext;
;;;419    
;;;420          tapCnt--;
;;;421        }
;;;422    
;;;423        /* y(n) += g0(n) * v0 */
;;;424        acc += (q31_t) ((fnext * (*pv++)));
;;;425    
;;;426        out = (q15_t) __SSAT(acc >> 15, 16);
;;;427        *px2++ = (q15_t) fnext;
;;;428    
;;;429        /* write out into pDst */
;;;430        *pDst++ = out;
;;;431    
;;;432        /* Advance the state pointer by 1 to process the next group of samples */
;;;433        pState = pState + 1u;
;;;434        blkCnt--;
;;;435    
;;;436      }
;;;437    
;;;438      /* Processing is complete. Now copy last S->numStages samples to start of the buffer           
;;;439         for the preperation of next frame process */
;;;440      /* Points to the start of the state buffer */
;;;441      pStateCurnt = &S->pState[0];
;;;442      pState = &S->pState[blockSize];
;;;443    
;;;444      stgCnt = numStages;
;;;445    
;;;446      /* copy data */
;;;447      while(stgCnt > 0u)
;;;448      {
;;;449        *pStateCurnt++ = *pState++;
;;;450    
;;;451        /* Decrement the loop counter */
;;;452        stgCnt--;
;;;453      }
;;;454    
;;;455    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;456    
;;;457    }
0001e8  b008              ADD      sp,sp,#0x20
0001ea  e8bd8ff0          POP      {r4-r11,pc}
;;;458    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_iir_lattice_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_iir_lattice_q15_c_79236d2a____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___21_arm_iir_lattice_q15_c_79236d2a____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_iir_lattice_q15_c_79236d2a____REVSH|
#line 144
|__asm___21_arm_iir_lattice_q15_c_79236d2a____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_iir_lattice_q15_c_79236d2a____RRX|
#line 300
|__asm___21_arm_iir_lattice_q15_c_79236d2a____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
