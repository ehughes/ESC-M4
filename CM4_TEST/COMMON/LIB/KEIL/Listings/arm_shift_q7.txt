; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_shift_q7.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_shift_q7.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_shift_q7.crf ..\..\SRC\CMSIS_DSP_4_5\src\BasicMathFunctions\arm_shift_q7.c]
                          THUMB

                          AREA ||i.arm_shift_q7||, CODE, READONLY, ALIGN=1

                  arm_shift_q7 PROC
;;;70     
;;;71     void arm_shift_q7(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;72       q7_t * pSrc,
;;;73       int8_t shiftBits,
;;;74       q7_t * pDst,
;;;75       uint32_t blockSize)
;;;76     {
;;;77       uint32_t blkCnt;                               /* loop counter */
;;;78       uint8_t sign;                                  /* Sign of shiftBits */
;;;79     
;;;80     #ifndef ARM_MATH_CM0_FAMILY
;;;81     
;;;82     /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;83       q7_t in1;                                      /* Input value1 */
;;;84       q7_t in2;                                      /* Input value2 */
;;;85       q7_t in3;                                      /* Input value3 */
;;;86       q7_t in4;                                      /* Input value4 */
;;;87     
;;;88     
;;;89       /*loop Unrolling */
;;;90       blkCnt = blockSize >> 2u;
000004  089c              LSRS     r4,r3,#2
;;;91     
;;;92       /* Getting the sign of shiftBits */
;;;93       sign = (shiftBits & 0x80);
000006  f0010580          AND      r5,r1,#0x80
;;;94     
;;;95       /* If the shift value is positive then do right shift else left shift */
;;;96       if(sign == 0u)
;;;97       {
;;;98         /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;99          ** a second loop below computes the remaining 1 to 3 samples. */
;;;100        while(blkCnt > 0u)
;;;101        {
;;;102          /* C = A << shiftBits */
;;;103          /* Read 4 inputs */
;;;104          in1 = *pSrc;
;;;105          in2 = *(pSrc + 1);
;;;106          in3 = *(pSrc + 2);
;;;107          in4 = *(pSrc + 3);
;;;108    
;;;109          /* Store the Shifted result in the destination buffer in single cycle by packing the outputs */
;;;110          *__SIMD32(pDst)++ = __PACKq7(__SSAT((in1 << shiftBits), 8),
;;;111                                       __SSAT((in2 << shiftBits), 8),
;;;112                                       __SSAT((in3 << shiftBits), 8),
;;;113                                       __SSAT((in4 << shiftBits), 8));
;;;114          /* Update source pointer to process next sampels */
;;;115          pSrc += 4u;
;;;116    
;;;117          /* Decrement the loop counter */
;;;118          blkCnt--;
;;;119        }
;;;120    
;;;121        /* If the blockSize is not a multiple of 4, compute any remaining output samples here.        
;;;122         ** No loop unrolling is used. */
;;;123        blkCnt = blockSize % 0x4u;
00000a  f0030303          AND      r3,r3,#3
00000e  f64f78ff          MOV      r8,#0xffff            ;110
000012  2d00              CMP      r5,#0                 ;96
000014  d026              BEQ      |L1.100|
;;;124    
;;;125        while(blkCnt > 0u)
;;;126        {
;;;127          /* C = A << shiftBits */
;;;128          /* Shift the input and then store the result in the destination buffer. */
;;;129          *pDst++ = (q7_t) __SSAT((*pSrc++ << shiftBits), 8);
;;;130    
;;;131          /* Decrement the loop counter */
;;;132          blkCnt--;
;;;133        }
;;;134      }
;;;135      else
;;;136      {
;;;137        shiftBits = -shiftBits;
000016  4249              RSBS     r1,r1,#0
000018  b249              SXTB     r1,r1
;;;138        /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;139         ** a second loop below computes the remaining 1 to 3 samples. */
;;;140        while(blkCnt > 0u)
00001a  e04c              B        |L1.182|
                  |L1.28|
00001c  f990c000          LDRSB    r12,[r0,#0]           ;104
000020  f9905001          LDRSB    r5,[r0,#1]            ;105
000024  f9906002          LDRSB    r6,[r0,#2]            ;106
000028  f9907003          LDRSB    r7,[r0,#3]            ;107
00002c  fa0cfc01          LSL      r12,r12,r1            ;110
000030  408d              LSLS     r5,r5,r1              ;110
000032  f30c0c07          SSAT     r12,#8,r12            ;110
000036  f3050507          SSAT     r5,#8,r5              ;110
00003a  f00c0cff          AND      r12,r12,#0xff         ;110
00003e  ea082505          AND      r5,r8,r5,LSL #8       ;110
000042  408e              LSLS     r6,r6,r1              ;110
000044  ea4c0c05          ORR      r12,r12,r5            ;110
000048  f3060507          SSAT     r5,#8,r6              ;110
00004c  b2ed              UXTB     r5,r5                 ;110
00004e  408f              LSLS     r7,r7,r1              ;110
000050  ea4c4505          ORR      r5,r12,r5,LSL #16     ;110
000054  f3070607          SSAT     r6,#8,r7              ;110
000058  ea456506          ORR      r5,r5,r6,LSL #24      ;110
00005c  f8425b04          STR      r5,[r2],#4            ;110
000060  1d00              ADDS     r0,r0,#4              ;115
000062  1e64              SUBS     r4,r4,#1              ;118
                  |L1.100|
000064  2c00              CMP      r4,#0                 ;100
000066  d1d9              BNE      |L1.28|
000068  e007              B        |L1.122|
                  |L1.106|
00006a  f9104b01          LDRSB    r4,[r0],#1            ;129
00006e  408c              LSLS     r4,r4,r1              ;129
000070  f3040407          SSAT     r4,#8,r4              ;129
000074  f8024b01          STRB     r4,[r2],#1            ;129
000078  1e5b              SUBS     r3,r3,#1              ;132
                  |L1.122|
00007a  2b00              CMP      r3,#0                 ;125
00007c  d1f5              BNE      |L1.106|
                  |L1.126|
;;;141        {
;;;142          /* C = A >> shiftBits */
;;;143          /* Read 4 inputs */
;;;144          in1 = *pSrc;
;;;145          in2 = *(pSrc + 1);
;;;146          in3 = *(pSrc + 2);
;;;147          in4 = *(pSrc + 3);
;;;148    
;;;149          /* Store the Shifted result in the destination buffer in single cycle by packing the outputs */
;;;150          *__SIMD32(pDst)++ = __PACKq7((in1 >> shiftBits), (in2 >> shiftBits),
;;;151                                       (in3 >> shiftBits), (in4 >> shiftBits));
;;;152    
;;;153    
;;;154          pSrc += 4u;
;;;155    
;;;156          /* Decrement the loop counter */
;;;157          blkCnt--;
;;;158        }
;;;159    
;;;160        /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;161         ** No loop unrolling is used. */
;;;162        blkCnt = blockSize % 0x4u;
;;;163    
;;;164        while(blkCnt > 0u)
;;;165        {
;;;166          /* C = A >> shiftBits */
;;;167          /* Shift the input and then store the result in the destination buffer. */
;;;168          in1 = *pSrc++;
;;;169          *pDst++ = (in1 >> shiftBits);
;;;170    
;;;171          /* Decrement the loop counter */
;;;172          blkCnt--;
;;;173        }
;;;174      }
;;;175    
;;;176    #else
;;;177    
;;;178      /* Run the below code for Cortex-M0 */
;;;179    
;;;180      /* Getting the sign of shiftBits */
;;;181      sign = (shiftBits & 0x80);
;;;182    
;;;183      /* If the shift value is positive then do right shift else left shift */
;;;184      if(sign == 0u)
;;;185      {
;;;186        /* Initialize blkCnt with number of samples */
;;;187        blkCnt = blockSize;
;;;188    
;;;189        while(blkCnt > 0u)
;;;190        {
;;;191          /* C = A << shiftBits */
;;;192          /* Shift the input and then store the result in the destination buffer. */
;;;193          *pDst++ = (q7_t) __SSAT(((q15_t) * pSrc++ << shiftBits), 8);
;;;194    
;;;195          /* Decrement the loop counter */
;;;196          blkCnt--;
;;;197        }
;;;198      }
;;;199      else
;;;200      {
;;;201        /* Initialize blkCnt with number of samples */
;;;202        blkCnt = blockSize;
;;;203    
;;;204        while(blkCnt > 0u)
;;;205        {
;;;206          /* C = A >> shiftBits */
;;;207          /* Shift the input and then store the result in the destination buffer. */
;;;208          *pDst++ = (*pSrc++ >> -shiftBits);
;;;209    
;;;210          /* Decrement the loop counter */
;;;211          blkCnt--;
;;;212        }
;;;213      }
;;;214    
;;;215    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;216    }
00007e  e8bd81f0          POP      {r4-r8,pc}
                  |L1.130|
000082  f9905000          LDRSB    r5,[r0,#0]            ;144
000086  f9906001          LDRSB    r6,[r0,#1]            ;145
00008a  f9907002          LDRSB    r7,[r0,#2]            ;146
00008e  f990c003          LDRSB    r12,[r0,#3]           ;147
000092  410d              ASRS     r5,r5,r1              ;150
000094  410e              ASRS     r6,r6,r1              ;150
000096  b2ed              UXTB     r5,r5                 ;150
000098  ea082606          AND      r6,r8,r6,LSL #8       ;150
00009c  4335              ORRS     r5,r5,r6              ;150
00009e  410f              ASRS     r7,r7,r1              ;150
0000a0  b2fe              UXTB     r6,r7                 ;150
0000a2  ea454506          ORR      r5,r5,r6,LSL #16      ;150
0000a6  fa4cfc01          ASR      r12,r12,r1            ;150
0000aa  ea45650c          ORR      r5,r5,r12,LSL #24     ;150
0000ae  f8425b04          STR      r5,[r2],#4            ;150
0000b2  1d00              ADDS     r0,r0,#4              ;154
0000b4  1e64              SUBS     r4,r4,#1              ;157
                  |L1.182|
0000b6  2c00              CMP      r4,#0                 ;140
0000b8  d1e3              BNE      |L1.130|
0000ba  e005              B        |L1.200|
                  |L1.188|
0000bc  f9104b01          LDRSB    r4,[r0],#1            ;168
0000c0  410c              ASRS     r4,r4,r1              ;169
0000c2  f8024b01          STRB     r4,[r2],#1            ;169
0000c6  1e5b              SUBS     r3,r3,#1              ;172
                  |L1.200|
0000c8  2b00              CMP      r3,#0                 ;164
0000ca  d1f7              BNE      |L1.188|
0000cc  e7d7              B        |L1.126|
;;;217    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\BasicMathFunctions\\arm_shift_q7.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_shift_q7_c_49b5f72d____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___14_arm_shift_q7_c_49b5f72d____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_shift_q7_c_49b5f72d____REVSH|
#line 144
|__asm___14_arm_shift_q7_c_49b5f72d____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_shift_q7_c_49b5f72d____RRX|
#line 300
|__asm___14_arm_shift_q7_c_49b5f72d____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
