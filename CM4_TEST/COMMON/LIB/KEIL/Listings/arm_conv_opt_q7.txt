; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_opt_q7.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_opt_q7.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_conv_opt_q7.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_conv_opt_q7.c]
                          THUMB

                          AREA ||i.arm_conv_opt_q7||, CODE, READONLY, ALIGN=1

                  arm_conv_opt_q7 PROC
;;;78     
;;;79     void arm_conv_opt_q7(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;80       q7_t * pSrcA,
;;;81       uint32_t srcALen,
;;;82       q7_t * pSrcB,
;;;83       uint32_t srcBLen,
;;;84       q7_t * pDst,
;;;85       q15_t * pScratch1,
;;;86       q15_t * pScratch2)
;;;87     {
000004  b085              SUB      sp,sp,#0x14
000006  468a              MOV      r10,r1
000008  e9dd980e          LDRD     r9,r8,[sp,#0x38]
00000c  9c10              LDR      r4,[sp,#0x40]
00000e  461f              MOV      r7,r3
;;;88     
;;;89       q15_t *pScr2, *pScr1;                          /* Intermediate pointers for scratch pointers */
;;;90       q15_t x4;                                      /* Temporary input variable */
;;;91       q7_t *pIn1, *pIn2;                             /* inputA and inputB pointer */
;;;92       uint32_t j, k, blkCnt, tapCnt;                 /* loop counter */
;;;93       q7_t *px;                                      /* Temporary input1 pointer */
;;;94       q15_t *py;                                     /* Temporary input2 pointer */
;;;95       q31_t acc0, acc1, acc2, acc3;                  /* Accumulator */
;;;96       q31_t x1, x2, x3, y1;                          /* Temporary input variables */
;;;97       q7_t *pOut = pDst;                             /* output pointer */
;;;98       q7_t out0, out1, out2, out3;                   /* temporary variables */
;;;99     
;;;100      /* The algorithm implementation is based on the lengths of the inputs. */
;;;101      /* srcB is always made to slide across srcA. */
;;;102      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;103      if(srcALen >= srcBLen)
000010  45ba              CMP      r10,r7
000012  d302              BCC      |L1.26|
;;;104      {
;;;105        /* Initialization of inputA pointer */
;;;106        pIn1 = pSrcA;
000014  4605              MOV      r5,r0
;;;107    
;;;108        /* Initialization of inputB pointer */
;;;109        pIn2 = pSrcB;
000016  4610              MOV      r0,r2
000018  e003              B        |L1.34|
                  |L1.26|
;;;110      }
;;;111      else
;;;112      {
;;;113        /* Initialization of inputA pointer */
;;;114        pIn1 = pSrcB;
00001a  4615              MOV      r5,r2
;;;115    
;;;116        /* Initialization of inputB pointer */
;;;117        pIn2 = pSrcA;
;;;118    
;;;119        /* srcBLen is always considered as shorter or equal to srcALen */
;;;120        j = srcBLen;
00001c  4639              MOV      r1,r7
;;;121        srcBLen = srcALen;
00001e  4657              MOV      r7,r10
;;;122        srcALen = j;
000020  468a              MOV      r10,r1
                  |L1.34|
;;;123      }
;;;124    
;;;125      /* pointer to take end of scratch2 buffer */
;;;126      pScr2 = pScratch2;
000022  4626              MOV      r6,r4
;;;127    
;;;128      /* points to smaller length sequence */
;;;129      px = pIn2 + srcBLen - 1;
000024  4438              ADD      r0,r0,r7
000026  1e40              SUBS     r0,r0,#1
;;;130    
;;;131      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;132      k = srcBLen >> 2u;
000028  08b9              LSRS     r1,r7,#2
00002a  9104              STR      r1,[sp,#0x10]
;;;133    
;;;134      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;135       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;136      while(k > 0u)
00002c  e00e              B        |L1.76|
                  |L1.46|
;;;137      {
;;;138        /* copy second buffer in reversal manner */
;;;139        x4 = (q15_t) * px--;
00002e  1ec0              SUBS     r0,r0,#3
000030  f9902003          LDRSB    r2,[r0,#3]
;;;140        *pScr2++ = x4;
000034  8032              STRH     r2,[r6,#0]
;;;141        x4 = (q15_t) * px--;
000036  f9902002          LDRSB    r2,[r0,#2]
;;;142        *pScr2++ = x4;
00003a  8072              STRH     r2,[r6,#2]
;;;143        x4 = (q15_t) * px--;
00003c  f9902001          LDRSB    r2,[r0,#1]
;;;144        *pScr2++ = x4;
000040  80b2              STRH     r2,[r6,#4]
;;;145        x4 = (q15_t) * px--;
000042  f9102901          LDRSB    r2,[r0],#-1
;;;146        *pScr2++ = x4;
000046  80f2              STRH     r2,[r6,#6]
000048  3608              ADDS     r6,r6,#8
;;;147    
;;;148        /* Decrement the loop counter */
;;;149        k--;
00004a  1e49              SUBS     r1,r1,#1
                  |L1.76|
00004c  2900              CMP      r1,#0                 ;136
00004e  d1ee              BNE      |L1.46|
;;;150      }
;;;151    
;;;152      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;153       ** No loop unrolling is used. */
;;;154      k = srcBLen % 0x4u;
000050  f0070103          AND      r1,r7,#3
000054  9103              STR      r1,[sp,#0xc]
;;;155    
;;;156      while(k > 0u)
000056  e004              B        |L1.98|
                  |L1.88|
;;;157      {
;;;158        /* copy second buffer in reversal manner for remaining samples */
;;;159        x4 = (q15_t) * px--;
000058  f9102901          LDRSB    r2,[r0],#-1
;;;160        *pScr2++ = x4;
00005c  f8262b02          STRH     r2,[r6],#2
;;;161    
;;;162        /* Decrement the loop counter */
;;;163        k--;
000060  1e49              SUBS     r1,r1,#1
                  |L1.98|
000062  2900              CMP      r1,#0                 ;156
000064  d1f8              BNE      |L1.88|
;;;164      }
;;;165    
;;;166      /* Initialze temporary scratch pointer */
;;;167      pScr1 = pScratch1;
;;;168    
;;;169      /* Fill (srcBLen - 1u) zeros in scratch buffer */
;;;170      arm_fill_q15(0, pScr1, (srcBLen - 1u));
000066  1e7a              SUBS     r2,r7,#1
000068  4641              MOV      r1,r8
00006a  2000              MOVS     r0,#0
00006c  f7fffffe          BL       arm_fill_q15
;;;171    
;;;172      /* Update temporary scratch pointer */
;;;173      pScr1 += (srcBLen - 1u);
000070  1e78              SUBS     r0,r7,#1
000072  eb080140          ADD      r1,r8,r0,LSL #1
;;;174    
;;;175      /* Copy (srcALen) samples in scratch buffer */
;;;176      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;177      k = srcALen >> 2u;
000076  ea4f009a          LSR      r0,r10,#2
;;;178    
;;;179      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;180       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;181      while(k > 0u)
00007a  e00e              B        |L1.154|
                  |L1.124|
;;;182      {
;;;183        /* copy second buffer in reversal manner */
;;;184        x4 = (q15_t) * pIn1++;
00007c  f9952000          LDRSB    r2,[r5,#0]
;;;185        *pScr1++ = x4;
000080  800a              STRH     r2,[r1,#0]
;;;186        x4 = (q15_t) * pIn1++;
000082  f9952001          LDRSB    r2,[r5,#1]
;;;187        *pScr1++ = x4;
000086  804a              STRH     r2,[r1,#2]
;;;188        x4 = (q15_t) * pIn1++;
000088  f9952002          LDRSB    r2,[r5,#2]
;;;189        *pScr1++ = x4;
00008c  808a              STRH     r2,[r1,#4]
;;;190        x4 = (q15_t) * pIn1++;
00008e  f9952003          LDRSB    r2,[r5,#3]
000092  1d2d              ADDS     r5,r5,#4
;;;191        *pScr1++ = x4;
000094  80ca              STRH     r2,[r1,#6]
000096  3108              ADDS     r1,r1,#8
;;;192    
;;;193        /* Decrement the loop counter */
;;;194        k--;
000098  1e40              SUBS     r0,r0,#1
                  |L1.154|
00009a  2800              CMP      r0,#0                 ;181
00009c  d1ee              BNE      |L1.124|
;;;195      }
;;;196    
;;;197      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;198       ** No loop unrolling is used. */
;;;199      k = srcALen % 0x4u;
00009e  f00a0003          AND      r0,r10,#3
;;;200    
;;;201      while(k > 0u)
0000a2  e004              B        |L1.174|
                  |L1.164|
;;;202      {
;;;203        /* copy second buffer in reversal manner for remaining samples */
;;;204        x4 = (q15_t) * pIn1++;
0000a4  f9152b01          LDRSB    r2,[r5],#1
;;;205        *pScr1++ = x4;
0000a8  f8212b02          STRH     r2,[r1],#2
;;;206    
;;;207        /* Decrement the loop counter */
;;;208        k--;
0000ac  1e40              SUBS     r0,r0,#1
                  |L1.174|
0000ae  2800              CMP      r0,#0                 ;201
0000b0  d1f8              BNE      |L1.164|
;;;209      }
;;;210    
;;;211    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;212    
;;;213      /* Fill (srcBLen - 1u) zeros at end of scratch buffer */
;;;214      arm_fill_q15(0, pScr1, (srcBLen - 1u));
0000b2  1e7a              SUBS     r2,r7,#1
0000b4  f7fffffe          BL       arm_fill_q15
;;;215    
;;;216      /* Update pointer */
;;;217      pScr1 += (srcBLen - 1u);
;;;218    
;;;219    #else
;;;220    
;;;221      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;222      k = (srcBLen - 1u) >> 2u;
;;;223    
;;;224      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;225       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;226      while(k > 0u)
;;;227      {
;;;228        /* copy second buffer in reversal manner */
;;;229        *pScr1++ = 0;
;;;230        *pScr1++ = 0;
;;;231        *pScr1++ = 0;
;;;232        *pScr1++ = 0;
;;;233    
;;;234        /* Decrement the loop counter */
;;;235        k--;
;;;236      }
;;;237    
;;;238      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;239       ** No loop unrolling is used. */
;;;240      k = (srcBLen - 1u) % 0x4u;
;;;241    
;;;242      while(k > 0u)
;;;243      {
;;;244        /* copy second buffer in reversal manner for remaining samples */
;;;245        *pScr1++ = 0;
;;;246    
;;;247        /* Decrement the loop counter */
;;;248        k--;
;;;249      }
;;;250    
;;;251    #endif
;;;252    
;;;253      /* Temporary pointer for scratch2 */
;;;254      py = pScratch2;
0000b8  9400              STR      r4,[sp,#0]
;;;255    
;;;256      /* Initialization of pIn2 pointer */
;;;257      pIn2 = (q7_t *) py;
;;;258    
;;;259      pScr2 = py;
0000ba  9c00              LDR      r4,[sp,#0]
;;;260    
;;;261      /* Actual convolution process starts here */
;;;262      blkCnt = (srcALen + srcBLen - 1u) >> 2;
0000bc  eb0a0007          ADD      r0,r10,r7
0000c0  1e40              SUBS     r0,r0,#1
0000c2  9002              STR      r0,[sp,#8]
0000c4  0880              LSRS     r0,r0,#2
0000c6  9001              STR      r0,[sp,#4]
;;;263    
;;;264      while(blkCnt > 0)
0000c8  e064              B        |L1.404|
                  |L1.202|
;;;265      {
;;;266        /* Initialze temporary scratch pointer as scratch1 */
;;;267        pScr1 = pScratch1;
0000ca  46c2              MOV      r10,r8
;;;268    
;;;269        /* Clear Accumlators */
;;;270        acc0 = 0;
0000cc  2500              MOVS     r5,#0
;;;271        acc1 = 0;
0000ce  2600              MOVS     r6,#0
;;;272        acc2 = 0;
0000d0  2100              MOVS     r1,#0
;;;273        acc3 = 0;
0000d2  2300              MOVS     r3,#0
;;;274    
;;;275        /* Read two samples from scratch1 buffer */
;;;276        x1 = *__SIMD32(pScr1)++;
0000d4  f85a0b04          LDR      r0,[r10],#4
;;;277    
;;;278        /* Read next two samples from scratch1 buffer */
;;;279        x2 = *__SIMD32(pScr1)++;
0000d8  f85a2b04          LDR      r2,[r10],#4
;;;280    
;;;281        tapCnt = (srcBLen) >> 2u;
0000dc  f8ddb010          LDR      r11,[sp,#0x10]
;;;282    
;;;283        while(tapCnt > 0u)
0000e0  e01f              B        |L1.290|
                  |L1.226|
;;;284        {
;;;285    
;;;286          /* Read four samples from smaller buffer */
;;;287          y1 = _SIMD32_OFFSET(pScr2);
0000e2  f8d4c000          LDR      r12,[r4,#0]
;;;288    
;;;289          /* multiply and accumlate */
;;;290          acc0 = __SMLAD(x1, y1, acc0);
0000e6  fb20550c          SMLAD    r5,r0,r12,r5
;;;291          acc2 = __SMLAD(x2, y1, acc2);
0000ea  fb22110c          SMLAD    r1,r2,r12,r1
;;;292    
;;;293          /* pack input data */
;;;294    #ifndef ARM_MATH_BIG_ENDIAN
;;;295          x3 = __PKHBT(x2, x1, 0);
0000ee  eac20000          PKHBT    r0,r2,r0
;;;296    #else
;;;297          x3 = __PKHBT(x1, x2, 0);
;;;298    #endif
;;;299    
;;;300          /* multiply and accumlate */
;;;301          acc1 = __SMLADX(x3, y1, acc1);
0000f2  fb206e1c          SMLADX   lr,r0,r12,r6
;;;302    
;;;303          /* Read next two samples from scratch1 buffer */
;;;304          x1 = *__SIMD32(pScr1)++;
0000f6  f85a0b04          LDR      r0,[r10],#4
;;;305    
;;;306          /* pack input data */
;;;307    #ifndef ARM_MATH_BIG_ENDIAN
;;;308          x3 = __PKHBT(x1, x2, 0);
0000fa  eac00602          PKHBT    r6,r0,r2
;;;309    #else
;;;310          x3 = __PKHBT(x2, x1, 0);
;;;311    #endif
;;;312    
;;;313          acc3 = __SMLADX(x3, y1, acc3);
0000fe  fb263c1c          SMLADX   r12,r6,r12,r3
;;;314    
;;;315          /* Read four samples from smaller buffer */
;;;316          y1 = _SIMD32_OFFSET(pScr2 + 2u);
000102  6863              LDR      r3,[r4,#4]
;;;317    
;;;318          acc0 = __SMLAD(x2, y1, acc0);
000104  fb225503          SMLAD    r5,r2,r3,r5
;;;319    
;;;320          acc2 = __SMLAD(x1, y1, acc2);
000108  fb201103          SMLAD    r1,r0,r3,r1
;;;321    
;;;322          acc1 = __SMLADX(x3, y1, acc1);
00010c  fb26e613          SMLADX   r6,r6,r3,lr
;;;323    
;;;324          x2 = *__SIMD32(pScr1)++;
000110  f85a2b04          LDR      r2,[r10],#4
;;;325    
;;;326    #ifndef ARM_MATH_BIG_ENDIAN
;;;327          x3 = __PKHBT(x2, x1, 0);
000114  eac20e00          PKHBT    lr,r2,r0
;;;328    #else
;;;329          x3 = __PKHBT(x1, x2, 0);
;;;330    #endif
;;;331    
;;;332          acc3 = __SMLADX(x3, y1, acc3);
000118  fb2ec313          SMLADX   r3,lr,r3,r12
;;;333    
;;;334          pScr2 += 4u;
00011c  3408              ADDS     r4,r4,#8
;;;335    
;;;336    
;;;337          /* Decrement the loop counter */
;;;338          tapCnt--;
00011e  f1ab0b01          SUB      r11,r11,#1
                  |L1.290|
000122  f1bb0f00          CMP      r11,#0                ;283
000126  d1dc              BNE      |L1.226|
;;;339        }
;;;340    
;;;341    
;;;342    
;;;343        /* Update scratch pointer for remaining samples of smaller length sequence */
;;;344        pScr1 -= 4u;
000128  f1aa0a08          SUB      r10,r10,#8
;;;345    
;;;346    
;;;347        /* apply same above for remaining samples of smaller length sequence */
;;;348        tapCnt = (srcBLen) & 3u;
00012c  9a03              LDR      r2,[sp,#0xc]
;;;349    
;;;350        while(tapCnt > 0u)
00012e  e014              B        |L1.346|
                  |L1.304|
;;;351        {
;;;352    
;;;353          /* accumlate the results */
;;;354          acc0 += (*pScr1++ * *pScr2);
000130  f83acb02          LDRH     r12,[r10],#2
000134  f8340b02          LDRH     r0,[r4],#2
000138  fb1c5500          SMLABB   r5,r12,r0,r5
;;;355          acc1 += (*pScr1++ * *pScr2);
00013c  f83acb02          LDRH     r12,[r10],#2
000140  fb1c6600          SMLABB   r6,r12,r0,r6
;;;356          acc2 += (*pScr1++ * *pScr2);
000144  f83acb02          LDRH     r12,[r10],#2
000148  fb1c1100          SMLABB   r1,r12,r0,r1
;;;357          acc3 += (*pScr1++ * *pScr2++);
00014c  f8bac000          LDRH     r12,[r10,#0]
000150  fb1c3300          SMLABB   r3,r12,r0,r3
;;;358    
;;;359          pScr1 -= 3u;
000154  f1aa0a04          SUB      r10,r10,#4
;;;360    
;;;361          /* Decrement the loop counter */
;;;362          tapCnt--;
000158  1e52              SUBS     r2,r2,#1
                  |L1.346|
00015a  2a00              CMP      r2,#0                 ;350
00015c  d1e8              BNE      |L1.304|
;;;363        }
;;;364    
;;;365        blkCnt--;
00015e  9801              LDR      r0,[sp,#4]
000160  1e40              SUBS     r0,r0,#1
000162  9001              STR      r0,[sp,#4]
;;;366    
;;;367        /* Store the result in the accumulator in the destination buffer. */
;;;368        out0 = (q7_t) (__SSAT(acc0 >> 7u, 8));
000164  f32510c7          SSAT     r0,#8,r5,ASR #7
;;;369        out1 = (q7_t) (__SSAT(acc1 >> 7u, 8));
000168  f32612c7          SSAT     r2,#8,r6,ASR #7
;;;370        out2 = (q7_t) (__SSAT(acc2 >> 7u, 8));
00016c  f32111c7          SSAT     r1,#8,r1,ASR #7
;;;371        out3 = (q7_t) (__SSAT(acc3 >> 7u, 8));
000170  f32313c7          SSAT     r3,#8,r3,ASR #7
;;;372    
;;;373        *__SIMD32(pOut)++ = __PACKq7(out0, out1, out2, out3);
000174  f64f74ff          MOV      r4,#0xffff
000178  b2c0              UXTB     r0,r0
00017a  ea042202          AND      r2,r4,r2,LSL #8
00017e  4310              ORRS     r0,r0,r2
000180  b2c9              UXTB     r1,r1
000182  ea404001          ORR      r0,r0,r1,LSL #16
000186  ea406003          ORR      r0,r0,r3,LSL #24
00018a  f8490b04          STR      r0,[r9],#4
;;;374    
;;;375        /* Initialization of inputB pointer */
;;;376        pScr2 = py;
00018e  9c00              LDR      r4,[sp,#0]
;;;377    
;;;378        pScratch1 += 4u;
000190  f1080808          ADD      r8,r8,#8
                  |L1.404|
000194  9801              LDR      r0,[sp,#4]            ;264
000196  2800              CMP      r0,#0                 ;264
000198  d197              BNE      |L1.202|
;;;379    
;;;380      }
;;;381    
;;;382    
;;;383      blkCnt = (srcALen + srcBLen - 1u) & 0x3;
00019a  9802              LDR      r0,[sp,#8]
00019c  f0000303          AND      r3,r0,#3
;;;384    
;;;385      /* Calculate convolution for remaining samples of Bigger length sequence */
;;;386      while(blkCnt > 0)
0001a0  e024              B        |L1.492|
                  |L1.418|
;;;387      {
;;;388        /* Initialze temporary scratch pointer as scratch1 */
;;;389        pScr1 = pScratch1;
0001a2  4640              MOV      r0,r8
;;;390    
;;;391        /* Clear Accumlators */
;;;392        acc0 = 0;
0001a4  2100              MOVS     r1,#0
;;;393    
;;;394        tapCnt = (srcBLen) >> 1u;
0001a6  087a              LSRS     r2,r7,#1
;;;395    
;;;396        while(tapCnt > 0u)
0001a8  e00a              B        |L1.448|
                  |L1.426|
;;;397        {
;;;398          acc0 += (*pScr1++ * *pScr2++);
0001aa  8805              LDRH     r5,[r0,#0]
0001ac  8826              LDRH     r6,[r4,#0]
0001ae  fb151106          SMLABB   r1,r5,r6,r1
;;;399          acc0 += (*pScr1++ * *pScr2++);
0001b2  8845              LDRH     r5,[r0,#2]
0001b4  1d00              ADDS     r0,r0,#4
0001b6  8866              LDRH     r6,[r4,#2]
0001b8  1d24              ADDS     r4,r4,#4
0001ba  fb151106          SMLABB   r1,r5,r6,r1
;;;400    
;;;401          /* Decrement the loop counter */
;;;402          tapCnt--;
0001be  1e52              SUBS     r2,r2,#1
                  |L1.448|
0001c0  2a00              CMP      r2,#0                 ;396
0001c2  d1f2              BNE      |L1.426|
;;;403        }
;;;404    
;;;405        tapCnt = (srcBLen) & 1u;
0001c4  f0070201          AND      r2,r7,#1
;;;406    
;;;407        /* apply same above for remaining samples of smaller length sequence */
;;;408        while(tapCnt > 0u)
0001c8  e006              B        |L1.472|
                  |L1.458|
;;;409        {
;;;410    
;;;411          /* accumlate the results */
;;;412          acc0 += (*pScr1++ * *pScr2++);
0001ca  f8305b02          LDRH     r5,[r0],#2
0001ce  f8346b02          LDRH     r6,[r4],#2
0001d2  fb151106          SMLABB   r1,r5,r6,r1
;;;413    
;;;414          /* Decrement the loop counter */
;;;415          tapCnt--;
0001d6  1e52              SUBS     r2,r2,#1
                  |L1.472|
0001d8  2a00              CMP      r2,#0                 ;408
0001da  d1f6              BNE      |L1.458|
;;;416        }
;;;417    
;;;418        blkCnt--;
0001dc  1e5b              SUBS     r3,r3,#1
;;;419    
;;;420        /* Store the result in the accumulator in the destination buffer. */
;;;421        *pOut++ = (q7_t) (__SSAT(acc0 >> 7u, 8));
0001de  f32110c7          SSAT     r0,#8,r1,ASR #7
0001e2  f8090b01          STRB     r0,[r9],#1
;;;422    
;;;423        /* Initialization of inputB pointer */
;;;424        pScr2 = py;
0001e6  9c00              LDR      r4,[sp,#0]
;;;425    
;;;426        pScratch1 += 1u;
0001e8  f1080802          ADD      r8,r8,#2
                  |L1.492|
0001ec  2b00              CMP      r3,#0                 ;386
0001ee  d1d8              BNE      |L1.418|
;;;427    
;;;428      }
;;;429    
;;;430    }
0001f0  b005              ADD      sp,sp,#0x14
0001f2  e8bd8ff0          POP      {r4-r11,pc}
;;;431    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_conv_opt_q7.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_arm_conv_opt_q7_c_efaa8f5c____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___17_arm_conv_opt_q7_c_efaa8f5c____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_arm_conv_opt_q7_c_efaa8f5c____REVSH|
#line 144
|__asm___17_arm_conv_opt_q7_c_efaa8f5c____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_arm_conv_opt_q7_c_efaa8f5c____RRX|
#line 300
|__asm___17_arm_conv_opt_q7_c_efaa8f5c____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
