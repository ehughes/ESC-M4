; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_interpolate_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_interpolate_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_fir_interpolate_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_fir_interpolate_q15.c]
                          THUMB

                          AREA ||i.arm_fir_interpolate_q15||, CODE, READONLY, ALIGN=1

                  arm_fir_interpolate_q15 PROC
;;;73     
;;;74     void arm_fir_interpolate_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;75       const arm_fir_interpolate_instance_q15 * S,
;;;76       q15_t * pSrc,
;;;77       q15_t * pDst,
;;;78       uint32_t blockSize)
;;;79     {
000004  b089              SUB      sp,sp,#0x24
;;;80       q15_t *pState = S->pState;                     /* State pointer                                            */
000006  6887              LDR      r7,[r0,#8]
;;;81       q15_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer                                      */
000008  6841              LDR      r1,[r0,#4]
00000a  9107              STR      r1,[sp,#0x1c]
;;;82       q15_t *pStateCurnt;                            /* Points to the current sample of the state                */
;;;83       q15_t *ptr1, *ptr2;                            /* Temporary pointers for state and coefficient buffers     */
;;;84       q63_t sum0;                                    /* Accumulators                                             */
;;;85       q15_t x0, c0;                                  /* Temporary variables to hold state and coefficient values */
;;;86       uint32_t i, blkCnt, j, tapCnt;                 /* Loop counters                                            */
;;;87       uint16_t phaseLen = S->phaseLength;            /* Length of each polyphase filter component */
00000c  8841              LDRH     r1,[r0,#2]
00000e  9101              STR      r1,[sp,#4]
;;;88       uint32_t blkCntN2;
;;;89       q63_t acc0, acc1;
;;;90       q15_t x1;
;;;91     
;;;92       /* S->pState buffer contains previous frame (phaseLen - 1) samples */
;;;93       /* pStateCurnt points to the location where the new input data should be written */
;;;94       pStateCurnt = S->pState + ((q31_t) phaseLen - 1);
000010  9901              LDR      r1,[sp,#4]
000012  1e49              SUBS     r1,r1,#1
000014  9108              STR      r1,[sp,#0x20]
000016  eb070141          ADD      r1,r7,r1,LSL #1
00001a  9106              STR      r1,[sp,#0x18]
;;;95     
;;;96       /* Initialise  blkCnt */
;;;97       blkCnt = blockSize / 2;
00001c  0859              LSRS     r1,r3,#1
00001e  9103              STR      r1,[sp,#0xc]
;;;98       blkCntN2 = blockSize - (2 * blkCnt);
000020  9903              LDR      r1,[sp,#0xc]
000022  4249              RSBS     r1,r1,#0
000024  eb030141          ADD      r1,r3,r1,LSL #1
000028  9100              STR      r1,[sp,#0]
00002a  e088              B        |L1.318|
                  |L1.44|
;;;99     
;;;100      /* Samples loop unrolled by 2 */
;;;101      while(blkCnt > 0u)
;;;102      {
;;;103        /* Copy new input sample into the state buffer */
;;;104        *pStateCurnt++ = *pSrc++;
00002c  990a              LDR      r1,[sp,#0x28]
00002e  880b              LDRH     r3,[r1,#0]
000030  9906              LDR      r1,[sp,#0x18]
000032  800b              STRH     r3,[r1,#0]
000034  9b06              LDR      r3,[sp,#0x18]
000036  990a              LDR      r1,[sp,#0x28]
;;;105        *pStateCurnt++ = *pSrc++;
000038  884c              LDRH     r4,[r1,#2]
00003a  1d09              ADDS     r1,r1,#4
00003c  805c              STRH     r4,[r3,#2]
00003e  1d1b              ADDS     r3,r3,#4
000040  9306              STR      r3,[sp,#0x18]
000042  910a              STR      r1,[sp,#0x28]
;;;106    
;;;107        /* Address modifier index of coefficient buffer */
;;;108        j = 1u;
000044  2101              MOVS     r1,#1
000046  9102              STR      r1,[sp,#8]
;;;109    
;;;110        /* Loop over the Interpolation factor. */
;;;111        i = (S->L);
000048  7801              LDRB     r1,[r0,#0]
00004a  9104              STR      r1,[sp,#0x10]
;;;112    
;;;113        while(i > 0u)
00004c  e06d              B        |L1.298|
                  |L1.78|
;;;114        {
;;;115          /* Set accumulator to zero */
;;;116          acc0 = 0;
00004e  2300              MOVS     r3,#0
000050  461c              MOV      r4,r3
;;;117          acc1 = 0;
000052  2500              MOVS     r5,#0
000054  462e              MOV      r6,r5
;;;118    
;;;119          /* Initialize state pointer */
;;;120          ptr1 = pState;
;;;121    
;;;122          /* Initialize coefficient pointer */
;;;123          ptr2 = pCoeffs + (S->L - j);
000056  f8908000          LDRB     r8,[r0,#0]
00005a  9902              LDR      r1,[sp,#8]
00005c  eba80c01          SUB      r12,r8,r1
000060  9907              LDR      r1,[sp,#0x1c]
000062  eb01014c          ADD      r1,r1,r12,LSL #1
;;;124    
;;;125          /* Loop over the polyPhase length. Unroll by a factor of 4.        
;;;126           ** Repeat until we've computed numTaps-(4*S->L) coefficients. */
;;;127          tapCnt = phaseLen >> 2u;
000066  f8ddc004          LDR      r12,[sp,#4]
00006a  ea4f099c          LSR      r9,r12,#2
;;;128    
;;;129          x0 = *(ptr1++);
00006e  f9b7b000          LDRSH    r11,[r7,#0]
000072  f1070c02          ADD      r12,r7,#2
;;;130    
;;;131          while(tapCnt > 0u)
000076  e02b              B        |L1.208|
                  |L1.120|
;;;132          {
;;;133    
;;;134            /* Read the input sample */
;;;135            x1 = *(ptr1++);
000078  f9bca000          LDRSH    r10,[r12,#0]
00007c  f10c0e02          ADD      lr,r12,#2
;;;136    
;;;137            /* Read the coefficient */
;;;138            c0 = *(ptr2);
000080  f9b1c000          LDRSH    r12,[r1,#0]
;;;139    
;;;140            /* Perform the multiply-accumulate */
;;;141            acc0 += (q63_t) x0 *c0;
000084  fbcb340c          SMLAL    r3,r4,r11,r12
;;;142            acc1 += (q63_t) x1 *c0;
000088  fbca560c          SMLAL    r5,r6,r10,r12
;;;143    
;;;144    
;;;145            /* Read the coefficient */
;;;146            c0 = *(ptr2 + S->L);
00008c  f931b018          LDRSH    r11,[r1,r8,LSL #1]
;;;147    
;;;148            /* Read the input sample */
;;;149            x0 = *(ptr1++);
000090  f93ecb02          LDRSH    r12,[lr],#2
;;;150    
;;;151            /* Perform the multiply-accumulate */
;;;152            acc0 += (q63_t) x1 *c0;
000094  fbca340b          SMLAL    r3,r4,r10,r11
;;;153            acc1 += (q63_t) x0 *c0;
000098  fbcc560b          SMLAL    r5,r6,r12,r11
;;;154    
;;;155    
;;;156            /* Read the coefficient */
;;;157            c0 = *(ptr2 + S->L * 2);
00009c  f931b028          LDRSH    r11,[r1,r8,LSL #2]
;;;158    
;;;159            /* Read the input sample */
;;;160            x1 = *(ptr1++);
0000a0  f93eab02          LDRSH    r10,[lr],#2
0000a4  f8cde014          STR      lr,[sp,#0x14]
;;;161    
;;;162            /* Perform the multiply-accumulate */
;;;163            acc0 += (q63_t) x0 *c0;
0000a8  fbcc340b          SMLAL    r3,r4,r12,r11
;;;164            acc1 += (q63_t) x1 *c0;
0000ac  fbca560b          SMLAL    r5,r6,r10,r11
;;;165    
;;;166            /* Read the coefficient */
;;;167            c0 = *(ptr2 + S->L * 3);
0000b0  eb080c48          ADD      r12,r8,r8,LSL #1
0000b4  f931e01c          LDRSH    lr,[r1,r12,LSL #1]
;;;168    
;;;169            /* Read the input sample */
;;;170            x0 = *(ptr1++);
0000b8  f8ddc014          LDR      r12,[sp,#0x14]
0000bc  f93cbb02          LDRSH    r11,[r12],#2
;;;171    
;;;172            /* Perform the multiply-accumulate */
;;;173            acc0 += (q63_t) x1 *c0;
0000c0  fbca340e          SMLAL    r3,r4,r10,lr
;;;174            acc1 += (q63_t) x0 *c0;
0000c4  fbcb560e          SMLAL    r5,r6,r11,lr
;;;175    
;;;176    
;;;177            /* Upsampling is done by stuffing L-1 zeros between each sample.        
;;;178             * So instead of multiplying zeros with coefficients,        
;;;179             * Increment the coefficient pointer by interpolation factor times. */
;;;180            ptr2 += 4 * S->L;
0000c8  eb0101c8          ADD      r1,r1,r8,LSL #3
;;;181    
;;;182            /* Decrement the loop counter */
;;;183            tapCnt--;
0000cc  f1a90901          SUB      r9,r9,#1
                  |L1.208|
0000d0  f1b90f00          CMP      r9,#0                 ;131
0000d4  d1d0              BNE      |L1.120|
;;;184          }
;;;185    
;;;186          /* If the polyPhase length is not a multiple of 4, compute the remaining filter taps */
;;;187          tapCnt = phaseLen % 0x4u;
0000d6  f8dd9004          LDR      r9,[sp,#4]
0000da  f0090903          AND      r9,r9,#3
;;;188    
;;;189          while(tapCnt > 0u)
0000de  e00c              B        |L1.250|
                  |L1.224|
;;;190          {
;;;191    
;;;192            /* Read the input sample */
;;;193            x1 = *(ptr1++);
0000e0  f93cab02          LDRSH    r10,[r12],#2
;;;194    
;;;195            /* Read the coefficient */
;;;196            c0 = *(ptr2);
0000e4  f9b1e000          LDRSH    lr,[r1,#0]
;;;197    
;;;198            /* Perform the multiply-accumulate */
;;;199            acc0 += (q63_t) x0 *c0;
0000e8  fbcb340e          SMLAL    r3,r4,r11,lr
;;;200            acc1 += (q63_t) x1 *c0;
0000ec  fbca560e          SMLAL    r5,r6,r10,lr
;;;201    
;;;202            /* Increment the coefficient pointer by interpolation factor times. */
;;;203            ptr2 += S->L;
0000f0  eb010148          ADD      r1,r1,r8,LSL #1
;;;204    
;;;205            /* update states for next sample processing */
;;;206            x0 = x1;
0000f4  46d3              MOV      r11,r10
;;;207    
;;;208            /* Decrement the loop counter */
;;;209            tapCnt--;
0000f6  f1a90901          SUB      r9,r9,#1
                  |L1.250|
0000fa  f1b90f00          CMP      r9,#0                 ;189
0000fe  d1ef              BNE      |L1.224|
;;;210          }
;;;211    
;;;212          /* The result is in the accumulator, store in the destination buffer. */
;;;213          *pDst = (q15_t) (__SSAT((acc0 >> 15), 16));
000100  0bd9              LSRS     r1,r3,#15
000102  ea414144          ORR      r1,r1,r4,LSL #17
000106  f301010f          SSAT     r1,#16,r1
00010a  8011              STRH     r1,[r2,#0]
;;;214          *(pDst + S->L) = (q15_t) (__SSAT((acc1 >> 15), 16));
00010c  0be9              LSRS     r1,r5,#15
00010e  7803              LDRB     r3,[r0,#0]
000110  ea414146          ORR      r1,r1,r6,LSL #17
000114  f301010f          SSAT     r1,#16,r1
000118  f8221013          STRH     r1,[r2,r3,LSL #1]
;;;215    
;;;216          pDst++;
00011c  1c92              ADDS     r2,r2,#2
;;;217    
;;;218          /* Increment the address modifier index of coefficient buffer */
;;;219          j++;
00011e  9902              LDR      r1,[sp,#8]
000120  1c49              ADDS     r1,r1,#1
000122  9102              STR      r1,[sp,#8]
;;;220    
;;;221          /* Decrement the loop counter */
;;;222          i--;
000124  9904              LDR      r1,[sp,#0x10]
000126  1e49              SUBS     r1,r1,#1
000128  9104              STR      r1,[sp,#0x10]
                  |L1.298|
00012a  9904              LDR      r1,[sp,#0x10]         ;113
00012c  2900              CMP      r1,#0                 ;113
00012e  d18e              BNE      |L1.78|
;;;223        }
;;;224    
;;;225        /* Advance the state pointer by 1        
;;;226         * to process the next group of interpolation factor number samples */
;;;227        pState = pState + 2;
000130  1d3f              ADDS     r7,r7,#4
;;;228    
;;;229        pDst += S->L;
000132  7801              LDRB     r1,[r0,#0]
000134  eb020241          ADD      r2,r2,r1,LSL #1
;;;230    
;;;231        /* Decrement the loop counter */
;;;232        blkCnt--;
000138  9903              LDR      r1,[sp,#0xc]
00013a  1e49              SUBS     r1,r1,#1
00013c  9103              STR      r1,[sp,#0xc]
                  |L1.318|
00013e  9903              LDR      r1,[sp,#0xc]          ;101
000140  2900              CMP      r1,#0                 ;101
000142  f47faf73          BNE      |L1.44|
;;;233      }
;;;234    
;;;235      /* If the blockSize is not a multiple of 2, compute any remaining output samples here.        
;;;236       ** No loop unrolling is used. */
;;;237      blkCnt = blkCntN2;
000146  f8dde000          LDR      lr,[sp,#0]
;;;238    
;;;239      /* Loop over the blockSize. */
;;;240      while(blkCnt > 0u)
00014a  e064              B        |L1.534|
                  |L1.332|
;;;241      {
;;;242        /* Copy new input sample into the state buffer */
;;;243        *pStateCurnt++ = *pSrc++;
00014c  990a              LDR      r1,[sp,#0x28]
00014e  880b              LDRH     r3,[r1,#0]
000150  9906              LDR      r1,[sp,#0x18]
000152  800b              STRH     r3,[r1,#0]
000154  990a              LDR      r1,[sp,#0x28]
000156  1c89              ADDS     r1,r1,#2
000158  910a              STR      r1,[sp,#0x28]
00015a  9906              LDR      r1,[sp,#0x18]
00015c  1c89              ADDS     r1,r1,#2
00015e  9106              STR      r1,[sp,#0x18]
;;;244    
;;;245        /* Address modifier index of coefficient buffer */
;;;246        j = 1u;
000160  f04f0901          MOV      r9,#1
;;;247    
;;;248        /* Loop over the Interpolation factor. */
;;;249        i = S->L;
000164  f8908000          LDRB     r8,[r0,#0]
;;;250        while(i > 0u)
000168  e04f              B        |L1.522|
                  |L1.362|
;;;251        {
;;;252          /* Set accumulator to zero */
;;;253          sum0 = 0;
00016a  2300              MOVS     r3,#0
00016c  461c              MOV      r4,r3
;;;254    
;;;255          /* Initialize state pointer */
;;;256          ptr1 = pState;
00016e  4639              MOV      r1,r7
;;;257    
;;;258          /* Initialize coefficient pointer */
;;;259          ptr2 = pCoeffs + (S->L - j);
000170  7806              LDRB     r6,[r0,#0]
000172  9d07              LDR      r5,[sp,#0x1c]
000174  eba60c09          SUB      r12,r6,r9
000178  eb05054c          ADD      r5,r5,r12,LSL #1
;;;260    
;;;261          /* Loop over the polyPhase length. Unroll by a factor of 4.        
;;;262           ** Repeat until we've computed numTaps-(4*S->L) coefficients. */
;;;263          tapCnt = phaseLen >> 2;
00017c  f8ddc004          LDR      r12,[sp,#4]
000180  ea4f0c9c          LSR      r12,r12,#2
;;;264          while(tapCnt > 0u)
000184  e021              B        |L1.458|
                  |L1.390|
;;;265          {
;;;266    
;;;267            /* Read the coefficient */
;;;268            c0 = *(ptr2);
000186  f9b5a000          LDRSH    r10,[r5,#0]
;;;269    
;;;270            /* Upsampling is done by stuffing L-1 zeros between each sample.        
;;;271             * So instead of multiplying zeros with coefficients,        
;;;272             * Increment the coefficient pointer by interpolation factor times. */
;;;273            ptr2 += S->L;
00018a  eb050546          ADD      r5,r5,r6,LSL #1
;;;274    
;;;275            /* Read the input sample */
;;;276            x0 = *(ptr1++);
00018e  f931bb02          LDRSH    r11,[r1],#2
;;;277    
;;;278            /* Perform the multiply-accumulate */
;;;279            sum0 += (q63_t) x0 *c0;
000192  fbcb340a          SMLAL    r3,r4,r11,r10
;;;280    
;;;281            /* Read the coefficient */
;;;282            c0 = *(ptr2);
000196  f9b5a000          LDRSH    r10,[r5,#0]
;;;283    
;;;284            /* Increment the coefficient pointer by interpolation factor times. */
;;;285            ptr2 += S->L;
00019a  eb050546          ADD      r5,r5,r6,LSL #1
;;;286    
;;;287            /* Read the input sample */
;;;288            x0 = *(ptr1++);
00019e  f931bb02          LDRSH    r11,[r1],#2
;;;289    
;;;290            /* Perform the multiply-accumulate */
;;;291            sum0 += (q63_t) x0 *c0;
0001a2  fbcb340a          SMLAL    r3,r4,r11,r10
;;;292    
;;;293            /* Read the coefficient */
;;;294            c0 = *(ptr2);
0001a6  f9b5a000          LDRSH    r10,[r5,#0]
;;;295    
;;;296            /* Increment the coefficient pointer by interpolation factor times. */
;;;297            ptr2 += S->L;
0001aa  eb050546          ADD      r5,r5,r6,LSL #1
;;;298    
;;;299            /* Read the input sample */
;;;300            x0 = *(ptr1++);
0001ae  f931bb02          LDRSH    r11,[r1],#2
;;;301    
;;;302            /* Perform the multiply-accumulate */
;;;303            sum0 += (q63_t) x0 *c0;
0001b2  fbcb340a          SMLAL    r3,r4,r11,r10
;;;304    
;;;305            /* Read the coefficient */
;;;306            c0 = *(ptr2);
0001b6  f9b5b000          LDRSH    r11,[r5,#0]
;;;307    
;;;308            /* Increment the coefficient pointer by interpolation factor times. */
;;;309            ptr2 += S->L;
0001ba  eb050546          ADD      r5,r5,r6,LSL #1
;;;310    
;;;311            /* Read the input sample */
;;;312            x0 = *(ptr1++);
0001be  f931ab02          LDRSH    r10,[r1],#2
;;;313    
;;;314            /* Perform the multiply-accumulate */
;;;315            sum0 += (q63_t) x0 *c0;
0001c2  fbca340b          SMLAL    r3,r4,r10,r11
;;;316    
;;;317            /* Decrement the loop counter */
;;;318            tapCnt--;
0001c6  f1ac0c01          SUB      r12,r12,#1
                  |L1.458|
0001ca  f1bc0f00          CMP      r12,#0                ;264
0001ce  d1da              BNE      |L1.390|
;;;319          }
;;;320    
;;;321          /* If the polyPhase length is not a multiple of 4, compute the remaining filter taps */
;;;322          tapCnt = phaseLen & 0x3u;
0001d0  f8ddc004          LDR      r12,[sp,#4]
0001d4  f00c0c03          AND      r12,r12,#3
;;;323    
;;;324          while(tapCnt > 0u)
0001d8  e009              B        |L1.494|
                  |L1.474|
;;;325          {
;;;326            /* Read the coefficient */
;;;327            c0 = *(ptr2);
0001da  f9b5b000          LDRSH    r11,[r5,#0]
;;;328    
;;;329            /* Increment the coefficient pointer by interpolation factor times. */
;;;330            ptr2 += S->L;
0001de  eb050546          ADD      r5,r5,r6,LSL #1
;;;331    
;;;332            /* Read the input sample */
;;;333            x0 = *(ptr1++);
0001e2  f931ab02          LDRSH    r10,[r1],#2
;;;334    
;;;335            /* Perform the multiply-accumulate */
;;;336            sum0 += (q63_t) x0 *c0;
0001e6  fbca340b          SMLAL    r3,r4,r10,r11
;;;337    
;;;338            /* Decrement the loop counter */
;;;339            tapCnt--;
0001ea  f1ac0c01          SUB      r12,r12,#1
                  |L1.494|
0001ee  f1bc0f00          CMP      r12,#0                ;324
0001f2  d1f2              BNE      |L1.474|
;;;340          }
;;;341    
;;;342          /* The result is in the accumulator, store in the destination buffer. */
;;;343          *pDst++ = (q15_t) (__SSAT((sum0 >> 15), 16));
0001f4  0bd9              LSRS     r1,r3,#15
0001f6  ea414144          ORR      r1,r1,r4,LSL #17
0001fa  f301010f          SSAT     r1,#16,r1
0001fe  f8221b02          STRH     r1,[r2],#2
;;;344    
;;;345          j++;
000202  f1090901          ADD      r9,r9,#1
;;;346    
;;;347          /* Decrement the loop counter */
;;;348          i--;
000206  f1a80801          SUB      r8,r8,#1
                  |L1.522|
00020a  f1b80f00          CMP      r8,#0                 ;250
00020e  d1ac              BNE      |L1.362|
;;;349        }
;;;350    
;;;351        /* Advance the state pointer by 1        
;;;352         * to process the next group of interpolation factor number samples */
;;;353        pState = pState + 1;
000210  1cbf              ADDS     r7,r7,#2
;;;354    
;;;355        /* Decrement the loop counter */
;;;356        blkCnt--;
000212  f1ae0e01          SUB      lr,lr,#1
                  |L1.534|
000216  ea5f010e          MOVS     r1,lr                 ;240
00021a  d197              BNE      |L1.332|
;;;357      }
;;;358    
;;;359    
;;;360      /* Processing is complete.    
;;;361       ** Now copy the last phaseLen - 1 samples to the satrt of the state buffer.    
;;;362       ** This prepares the state buffer for the next function call. */
;;;363    
;;;364      /* Points to the start of the state buffer */
;;;365      pStateCurnt = S->pState;
00021c  6880              LDR      r0,[r0,#8]
;;;366    
;;;367      i = ((uint32_t) phaseLen - 1u) >> 2u;
00021e  9908              LDR      r1,[sp,#0x20]
000220  0889              LSRS     r1,r1,#2
;;;368    
;;;369      /* copy data */
;;;370      while(i > 0u)
000222  e006              B        |L1.562|
                  |L1.548|
;;;371      {
;;;372    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;373    
;;;374        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
000224  683a              LDR      r2,[r7,#0]
000226  6002              STR      r2,[r0,#0]
;;;375        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
000228  687a              LDR      r2,[r7,#4]
00022a  3708              ADDS     r7,r7,#8
00022c  6042              STR      r2,[r0,#4]
00022e  3008              ADDS     r0,r0,#8
;;;376    
;;;377    #else
;;;378    
;;;379        *pStateCurnt++ = *pState++;
;;;380    	*pStateCurnt++ = *pState++;
;;;381    	*pStateCurnt++ = *pState++;
;;;382    	*pStateCurnt++ = *pState++;
;;;383    	
;;;384    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;385    	
;;;386    	/* Decrement the loop counter */
;;;387        i--;
000230  1e49              SUBS     r1,r1,#1
                  |L1.562|
000232  2900              CMP      r1,#0                 ;370
000234  d1f6              BNE      |L1.548|
;;;388      }
;;;389    
;;;390      i = ((uint32_t) phaseLen - 1u) % 0x04u;
000236  9908              LDR      r1,[sp,#0x20]
000238  f0010103          AND      r1,r1,#3
;;;391    
;;;392      while(i > 0u)
00023c  e004              B        |L1.584|
                  |L1.574|
;;;393      {
;;;394        *pStateCurnt++ = *pState++;
00023e  f8372b02          LDRH     r2,[r7],#2
000242  f8202b02          STRH     r2,[r0],#2
;;;395    
;;;396        /* Decrement the loop counter */
;;;397        i--;
000246  1e49              SUBS     r1,r1,#1
                  |L1.584|
000248  2900              CMP      r1,#0                 ;392
00024a  d1f8              BNE      |L1.574|
;;;398      }
;;;399    }
00024c  b00d              ADD      sp,sp,#0x34
00024e  e8bd8ff0          POP      {r4-r11,pc}
;;;400    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_fir_interpolate_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_fir_interpolate_q15_c_014cfa50____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___25_arm_fir_interpolate_q15_c_014cfa50____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_fir_interpolate_q15_c_014cfa50____REVSH|
#line 144
|__asm___25_arm_fir_interpolate_q15_c_014cfa50____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_fir_interpolate_q15_c_014cfa50____RRX|
#line 300
|__asm___25_arm_fir_interpolate_q15_c_014cfa50____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
