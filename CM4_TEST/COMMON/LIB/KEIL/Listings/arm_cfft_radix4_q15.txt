; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_cfft_radix4_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_cfft_radix4_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_cfft_radix4_q15.crf ..\..\SRC\CMSIS_DSP_4_5\src\TransformFunctions\arm_cfft_radix4_q15.c]
                          THUMB

                          AREA ||i.arm_cfft_radix4_q15||, CODE, READONLY, ALIGN=1

                  arm_cfft_radix4_q15 PROC
;;;90     
;;;91     void arm_cfft_radix4_q15(
000000  b570              PUSH     {r4-r6,lr}
;;;92       const arm_cfft_radix4_instance_q15 * S,
;;;93       q15_t * pSrc)
;;;94     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;95       if(S->ifftFlag == 1u)
000006  78a0              LDRB     r0,[r4,#2]
;;;96       {
;;;97         /*  Complex IFFT radix-4  */
;;;98         arm_radix4_butterfly_inverse_q15(pSrc, S->fftLen, S->pTwiddle,
000008  8821              LDRH     r1,[r4,#0]
00000a  89a3              LDRH     r3,[r4,#0xc]
00000c  6862              LDR      r2,[r4,#4]            ;95
00000e  2801              CMP      r0,#1                 ;95
000010  d00d              BEQ      |L1.46|
;;;99                                          S->twidCoefModifier);
;;;100      }
;;;101      else
;;;102      {
;;;103        /*  Complex FFT radix-4  */
;;;104        arm_radix4_butterfly_q15(pSrc, S->fftLen, S->pTwiddle,
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       arm_radix4_butterfly_q15
                  |L1.24|
;;;105                                 S->twidCoefModifier);
;;;106      }
;;;107    
;;;108      if(S->bitReverseFlag == 1u)
000018  78e0              LDRB     r0,[r4,#3]
00001a  2801              CMP      r0,#1
00001c  d10b              BNE      |L1.54|
;;;109      {
;;;110        /*  Bit Reversal */
;;;111        arm_bitreversal_q15(pSrc, S->fftLen, S->bitRevFactor, S->pBitRevTable);
00001e  89e2              LDRH     r2,[r4,#0xe]
000020  8821              LDRH     r1,[r4,#0]
000022  4628              MOV      r0,r5
000024  68a3              LDR      r3,[r4,#8]
000026  e8bd4070          POP      {r4-r6,lr}
00002a  f7ffbffe          B.W      arm_bitreversal_q15
                  |L1.46|
00002e  4628              MOV      r0,r5                 ;98
000030  f7fffffe          BL       arm_radix4_butterfly_inverse_q15
000034  e7f0              B        |L1.24|
                  |L1.54|
;;;112      }
;;;113    
;;;114    }
000036  bd70              POP      {r4-r6,pc}
;;;115    
                          ENDP


                          AREA ||i.arm_radix4_butterfly_inverse_q15||, CODE, READONLY, ALIGN=1

                  arm_radix4_butterfly_inverse_q15 PROC
;;;1079   
;;;1080   void arm_radix4_butterfly_inverse_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1081     q15_t * pSrc16,
;;;1082     uint32_t fftLen,
;;;1083     q15_t * pCoef16,
;;;1084     uint32_t twidCoefModifier)
;;;1085   {
000004  b087              SUB      sp,sp,#0x1c
;;;1086   
;;;1087   #ifndef ARM_MATH_CM0_FAMILY
;;;1088   
;;;1089     /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;1090   
;;;1091     q31_t R, S, T, U;
;;;1092     q31_t C1, C2, C3, out1, out2;
;;;1093     uint32_t n1, n2, ic, i0, j, k;
;;;1094   
;;;1095     q15_t *ptr1;
;;;1096     q15_t *pSi0;
;;;1097     q15_t *pSi1;
;;;1098     q15_t *pSi2;
;;;1099     q15_t *pSi3;
;;;1100   
;;;1101     q31_t xaya, xbyb, xcyc, xdyd;
;;;1102   
;;;1103     /* Total process is divided into three stages */
;;;1104   
;;;1105     /* process first stage, middle stages, & last stage */
;;;1106   
;;;1107     /*  Initializations for the first stage */
;;;1108     n2 = fftLen;
000006  9808              LDR      r0,[sp,#0x20]
;;;1109     n1 = n2;
;;;1110   
;;;1111     /* n2 = fftLen/4 */
;;;1112     n2 >>= 2u;
000008  0880              LSRS     r0,r0,#2
00000a  9006              STR      r0,[sp,#0x18]
;;;1113   
;;;1114     /* Index for twiddle coefficient */
;;;1115     ic = 0u;
00000c  2500              MOVS     r5,#0
;;;1116   
;;;1117     /* Index for input read and output write */
;;;1118     j = n2;
00000e  4683              MOV      r11,r0
;;;1119     
;;;1120     pSi0 = pSrc16;
000010  9f07              LDR      r7,[sp,#0x1c]
;;;1121     pSi1 = pSi0 + 2 * n2;
000012  eb070480          ADD      r4,r7,r0,LSL #2
;;;1122     pSi2 = pSi1 + 2 * n2;
000016  eb040c80          ADD      r12,r4,r0,LSL #2
;;;1123     pSi3 = pSi2 + 2 * n2;
00001a  eb0c0680          ADD      r6,r12,r0,LSL #2
                  |L2.30|
;;;1124   
;;;1125     /* Input is in 1.15(q15) format */
;;;1126   
;;;1127     /*  start of first stage process */
;;;1128     do
;;;1129     {
;;;1130       /*  Butterfly implementation */
;;;1131   
;;;1132       /*  Reading i0, i0+fftLen/2 inputs */
;;;1133       /* Read ya (real), xa(imag) input */
;;;1134       T = _SIMD32_OFFSET(pSi0);
00001e  f8d78000          LDR      r8,[r7,#0]
;;;1135       T = __SHADD16(T, 0);
000022  2100              MOVS     r1,#0
000024  fa98f821          SHADD16  r8,r8,r1
;;;1136       T = __SHADD16(T, 0);
000028  fa98fa21          SHADD16  r10,r8,r1
;;;1137   
;;;1138       /* Read yc (real), xc(imag) input */
;;;1139       S = _SIMD32_OFFSET(pSi2);
00002c  f8dc8000          LDR      r8,[r12,#0]
;;;1140       S = __SHADD16(S, 0);
000030  fa98f821          SHADD16  r8,r8,r1
;;;1141       S = __SHADD16(S, 0);
000034  fa98f921          SHADD16  r9,r8,r1
;;;1142   
;;;1143       /* R = packed((ya + yc), (xa + xc) ) */
;;;1144       R = __QADD16(T, S);
000038  fa9af819          QADD16   r8,r10,r9
;;;1145   
;;;1146       /* S = packed((ya - yc), (xa - xc) ) */
;;;1147       S = __QSUB16(T, S);
00003c  fadaf919          QSUB16   r9,r10,r9
;;;1148   
;;;1149       /*  Reading i0+fftLen/4 , i0+3fftLen/4 inputs */
;;;1150       /* Read yb (real), xb(imag) input */
;;;1151       T = _SIMD32_OFFSET(pSi1);
000040  f8d4a000          LDR      r10,[r4,#0]
;;;1152       T = __SHADD16(T, 0);
000044  fa9afa21          SHADD16  r10,r10,r1
;;;1153       T = __SHADD16(T, 0);
000048  fa9afa21          SHADD16  r10,r10,r1
;;;1154   
;;;1155       /* Read yd (real), xd(imag) input */
;;;1156       U = _SIMD32_OFFSET(pSi3);
00004c  f8d6e000          LDR      lr,[r6,#0]
;;;1157       U = __SHADD16(U, 0);
000050  fa9efe21          SHADD16  lr,lr,r1
;;;1158       U = __SHADD16(U, 0);
000054  fa9efe21          SHADD16  lr,lr,r1
;;;1159   
;;;1160       /* T = packed((yb + yd), (xb + xd) ) */
;;;1161       T = __QADD16(T, U);
000058  fa9afa1e          QADD16   r10,r10,lr
;;;1162   
;;;1163       /*  writing the butterfly processed i0 sample */
;;;1164       /* xa' = xa + xb + xc + xd */
;;;1165       /* ya' = ya + yb + yc + yd */
;;;1166       _SIMD32_OFFSET(pSi0) = __SHADD16(R, T);
00005c  fa98fe2a          SHADD16  lr,r8,r10
000060  f8c7e000          STR      lr,[r7,#0]
;;;1167       pSi0 += 2;
000064  1d3f              ADDS     r7,r7,#4
;;;1168   
;;;1169       /* R = packed((ya + yc) - (yb + yd), (xa + xc)- (xb + xd)) */
;;;1170       R = __QSUB16(R, T);
000066  fad8f81a          QSUB16   r8,r8,r10
;;;1171   
;;;1172       /* co2 & si2 are read from SIMD Coefficient pointer */
;;;1173       C2 = _SIMD32_OFFSET(pCoef16 + (4u * ic));
00006a  eb020ac5          ADD      r10,r2,r5,LSL #3
00006e  f8daa000          LDR      r10,[r10,#0]
;;;1174   
;;;1175   #ifndef ARM_MATH_BIG_ENDIAN
;;;1176   
;;;1177       /* xc' = (xa-xb+xc-xd)* co2 + (ya-yb+yc-yd)* (si2) */
;;;1178       out1 = __SMUSD(C2, R) >> 16u;
000072  fb4afe08          SMUSD    lr,r10,r8
000076  ea4f4e1e          LSR      lr,lr,#16
;;;1179       /* yc' = (ya-yb+yc-yd)* co2 - (xa-xb+xc-xd)* (si2) */
;;;1180       out2 = __SMUADX(C2, R);
00007a  fb2afa18          SMUADX   r10,r10,r8
;;;1181   
;;;1182   #else
;;;1183   
;;;1184       /* xc' = (ya-yb+yc-yd)* co2 - (xa-xb+xc-xd)* (si2) */
;;;1185       out1 = __SMUADX(C2, R) >> 16u;
;;;1186       /* yc' = (xa-xb+xc-xd)* co2 + (ya-yb+yc-yd)* (si2) */
;;;1187       out2 = __SMUSD(__QSUB16(0, C2), R);
;;;1188   
;;;1189   #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;1190   
;;;1191       /*  Reading i0+fftLen/4 */
;;;1192       /* T = packed(yb, xb) */
;;;1193       T = _SIMD32_OFFSET(pSi1);
00007e  f8d48000          LDR      r8,[r4,#0]
;;;1194       T = __SHADD16(T, 0);
000082  fa98f821          SHADD16  r8,r8,r1
;;;1195       T = __SHADD16(T, 0);
000086  fa98f821          SHADD16  r8,r8,r1
;;;1196   
;;;1197       /* writing the butterfly processed i0 + fftLen/4 sample */
;;;1198       /* writing output(xc', yc') in little endian format */
;;;1199       _SIMD32_OFFSET(pSi1) =
00008a  eace0a0a          PKHBT    r10,lr,r10
00008e  f8c4a000          STR      r10,[r4,#0]
;;;1200         (q31_t) ((out2) & 0xFFFF0000) | (out1 & 0x0000FFFF);
;;;1201       pSi1 += 2;
000092  1d24              ADDS     r4,r4,#4
;;;1202   
;;;1203       /*  Butterfly calculations */
;;;1204       /* U = packed(yd, xd) */
;;;1205       U = _SIMD32_OFFSET(pSi3);
000094  f8d6a000          LDR      r10,[r6,#0]
;;;1206       U = __SHADD16(U, 0);
000098  fa9afa21          SHADD16  r10,r10,r1
;;;1207       U = __SHADD16(U, 0);
00009c  fa9afa21          SHADD16  r10,r10,r1
;;;1208   
;;;1209       /* T = packed(yb-yd, xb-xd) */
;;;1210       T = __QSUB16(T, U);
0000a0  fad8fa1a          QSUB16   r10,r8,r10
;;;1211   
;;;1212   #ifndef ARM_MATH_BIG_ENDIAN
;;;1213   
;;;1214       /* R = packed((ya-yc) + (xb- xd) , (xa-xc) - (yb-yd)) */
;;;1215       R = __QSAX(S, T);
0000a4  fae9f81a          QSAX     r8,r9,r10
;;;1216       /* S = packed((ya-yc) + (xb- xd),  (xa-xc) - (yb-yd)) */
;;;1217       S = __QASX(S, T);
0000a8  faa9f91a          QASX     r9,r9,r10
;;;1218   
;;;1219   #else
;;;1220   
;;;1221       /* R = packed((ya-yc) + (xb- xd) , (xa-xc) - (yb-yd)) */
;;;1222       R = __QASX(S, T);
;;;1223       /* S = packed((ya-yc) - (xb- xd),  (xa-xc) + (yb-yd)) */
;;;1224       S = __QSAX(S, T);
;;;1225   
;;;1226   #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;1227   
;;;1228       /* co1 & si1 are read from SIMD Coefficient pointer */
;;;1229       C1 = _SIMD32_OFFSET(pCoef16 + (2u * ic));
0000ac  eb020a85          ADD      r10,r2,r5,LSL #2
0000b0  f8daa000          LDR      r10,[r10,#0]
;;;1230       /*  Butterfly process for the i0+fftLen/2 sample */
;;;1231   
;;;1232   #ifndef ARM_MATH_BIG_ENDIAN
;;;1233   
;;;1234       /* xb' = (xa+yb-xc-yd)* co1 + (ya-xb-yc+xd)* (si1) */
;;;1235       out1 = __SMUSD(C1, S) >> 16u;
0000b4  fb4afe09          SMUSD    lr,r10,r9
0000b8  ea4f4e1e          LSR      lr,lr,#16
;;;1236       /* yb' = (ya-xb-yc+xd)* co1 - (xa+yb-xc-yd)* (si1) */
;;;1237       out2 = __SMUADX(C1, S);
0000bc  fb2af919          SMUADX   r9,r10,r9
;;;1238   
;;;1239   #else
;;;1240   
;;;1241       /* xb' = (ya-xb-yc+xd)* co1 - (xa+yb-xc-yd)* (si1) */
;;;1242       out1 = __SMUADX(C1, S) >> 16u;
;;;1243       /* yb' = (xa+yb-xc-yd)* co1 + (ya-xb-yc+xd)* (si1) */
;;;1244       out2 = __SMUSD(__QSUB16(0, C1), S);
;;;1245   
;;;1246   #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;1247   
;;;1248       /* writing output(xb', yb') in little endian format */
;;;1249       _SIMD32_OFFSET(pSi2) =
0000c0  eace0909          PKHBT    r9,lr,r9
0000c4  f8cc9000          STR      r9,[r12,#0]
;;;1250         ((out2) & 0xFFFF0000) | ((out1) & 0x0000FFFF);
;;;1251       pSi2 += 2;
0000c8  f10c0c04          ADD      r12,r12,#4
;;;1252   
;;;1253   
;;;1254       /* co3 & si3 are read from SIMD Coefficient pointer */
;;;1255       C3 = _SIMD32_OFFSET(pCoef16 + (6u * ic));
0000cc  eb050945          ADD      r9,r5,r5,LSL #1
0000d0  eb020989          ADD      r9,r2,r9,LSL #2
0000d4  f8d99000          LDR      r9,[r9,#0]
;;;1256       /*  Butterfly process for the i0+3fftLen/4 sample */
;;;1257   
;;;1258   #ifndef ARM_MATH_BIG_ENDIAN
;;;1259   
;;;1260       /* xd' = (xa-yb-xc+yd)* co3 + (ya+xb-yc-xd)* (si3) */
;;;1261       out1 = __SMUSD(C3, R) >> 16u;
0000d8  fb49fa08          SMUSD    r10,r9,r8
0000dc  ea4f4a1a          LSR      r10,r10,#16
;;;1262       /* yd' = (ya+xb-yc-xd)* co3 - (xa-yb-xc+yd)* (si3) */
;;;1263       out2 = __SMUADX(C3, R);
0000e0  fb29f818          SMUADX   r8,r9,r8
;;;1264   
;;;1265   #else
;;;1266   
;;;1267       /* xd' = (ya+xb-yc-xd)* co3 - (xa-yb-xc+yd)* (si3) */
;;;1268       out1 = __SMUADX(C3, R) >> 16u;
;;;1269       /* yd' = (xa-yb-xc+yd)* co3 + (ya+xb-yc-xd)* (si3) */
;;;1270       out2 = __SMUSD(__QSUB16(0, C3), R);
;;;1271   
;;;1272   #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;1273   
;;;1274       /* writing output(xd', yd') in little endian format */
;;;1275       _SIMD32_OFFSET(pSi3) =
0000e4  eaca0808          PKHBT    r8,r10,r8
0000e8  f8c68000          STR      r8,[r6,#0]
;;;1276         ((out2) & 0xFFFF0000) | (out1 & 0x0000FFFF);
;;;1277       pSi3 += 2;
0000ec  1d36              ADDS     r6,r6,#4
;;;1278   
;;;1279       /*  Twiddle coefficients index modifier */
;;;1280       ic = ic + twidCoefModifier;
0000ee  441d              ADD      r5,r5,r3
;;;1281   
;;;1282     } while(--j);
0000f0  f1bb0b01          SUBS     r11,r11,#1
0000f4  d193              BNE      |L2.30|
;;;1283     /* data is in 4.11(q11) format */
;;;1284   
;;;1285     /* end of first stage process */
;;;1286   
;;;1287   
;;;1288     /* start of middle stage process */
;;;1289   
;;;1290     /*  Twiddle coefficients index modifier */
;;;1291     twidCoefModifier <<= 2u;
0000f6  0099              LSLS     r1,r3,#2
0000f8  910a              STR      r1,[sp,#0x28]
;;;1292   
;;;1293     /*  Calculation of Middle stage */
;;;1294     for (k = fftLen / 4u; k > 4u; k >>= 2u)
0000fa  9906              LDR      r1,[sp,#0x18]
0000fc  9100              STR      r1,[sp,#0]
0000fe  e08b              B        |L2.536|
                  |L2.256|
;;;1295     {
;;;1296       /*  Initializations for the middle stage */
;;;1297       n1 = n2;
000100  4604              MOV      r4,r0
;;;1298       n2 >>= 2u;
000102  0880              LSRS     r0,r0,#2
;;;1299       ic = 0u;
000104  f04f0c00          MOV      r12,#0
;;;1300   
;;;1301       for (j = 0u; j <= (n2 - 1u); j++)
000108  2700              MOVS     r7,#0
00010a  1e41              SUBS     r1,r0,#1
00010c  9105              STR      r1,[sp,#0x14]
00010e  e07a              B        |L2.518|
                  |L2.272|
;;;1302       {
;;;1303         /*  index calculation for the coefficients */
;;;1304         C1 = _SIMD32_OFFSET(pCoef16 + (2u * ic));
000110  eb02018c          ADD      r1,r2,r12,LSL #2
000114  6809              LDR      r1,[r1,#0]
000116  9103              STR      r1,[sp,#0xc]
;;;1305         C2 = _SIMD32_OFFSET(pCoef16 + (4u * ic));
000118  eb0201cc          ADD      r1,r2,r12,LSL #3
00011c  6809              LDR      r1,[r1,#0]
00011e  9102              STR      r1,[sp,#8]
;;;1306         C3 = _SIMD32_OFFSET(pCoef16 + (6u * ic));
000120  eb0c014c          ADD      r1,r12,r12,LSL #1
000124  eb020181          ADD      r1,r2,r1,LSL #2
000128  6809              LDR      r1,[r1,#0]
00012a  9101              STR      r1,[sp,#4]
;;;1307   
;;;1308         /*  Twiddle coefficients index modifier */
;;;1309         ic = ic + twidCoefModifier;
00012c  990a              LDR      r1,[sp,#0x28]
00012e  448c              ADD      r12,r12,r1
;;;1310         
;;;1311         pSi0 = pSrc16 + 2 * j;
000130  9907              LDR      r1,[sp,#0x1c]
000132  eb010587          ADD      r5,r1,r7,LSL #2
;;;1312         pSi1 = pSi0 + 2 * n2;
000136  eb050180          ADD      r1,r5,r0,LSL #2
;;;1313         pSi2 = pSi1 + 2 * n2;
00013a  eb010680          ADD      r6,r1,r0,LSL #2
;;;1314         pSi3 = pSi2 + 2 * n2;
00013e  eb060380          ADD      r3,r6,r0,LSL #2
;;;1315   
;;;1316         /*  Butterfly implementation */
;;;1317         for (i0 = j; i0 < fftLen; i0 += n1)
000142  46b8              MOV      r8,r7
000144  e05a              B        |L2.508|
                  |L2.326|
;;;1318         {
;;;1319           /*  Reading i0, i0+fftLen/2 inputs */
;;;1320           /* Read ya (real), xa(imag) input */
;;;1321           T = _SIMD32_OFFSET(pSi0);
000146  f8d5b000          LDR      r11,[r5,#0]
;;;1322   
;;;1323           /* Read yc (real), xc(imag) input */
;;;1324           S = _SIMD32_OFFSET(pSi2);
00014a  f8d6a000          LDR      r10,[r6,#0]
;;;1325   
;;;1326           /* R = packed( (ya + yc), (xa + xc)) */
;;;1327           R = __QADD16(T, S);
00014e  fa9bf91a          QADD16   r9,r11,r10
;;;1328   
;;;1329           /* S = packed((ya - yc), (xa - xc)) */
;;;1330           S = __QSUB16(T, S);
000152  fadbfb1a          QSUB16   r11,r11,r10
000156  f8cdb010          STR      r11,[sp,#0x10]
;;;1331   
;;;1332           /*  Reading i0+fftLen/4 , i0+3fftLen/4 inputs */
;;;1333           /* Read yb (real), xb(imag) input */
;;;1334           T = _SIMD32_OFFSET(pSi1);
00015a  f8d1a000          LDR      r10,[r1,#0]
;;;1335   
;;;1336           /* Read yd (real), xd(imag) input */
;;;1337           U = _SIMD32_OFFSET(pSi3);
00015e  f8d3b000          LDR      r11,[r3,#0]
;;;1338   
;;;1339           /* T = packed( (yb + yd), (xb + xd)) */
;;;1340           T = __QADD16(T, U);
000162  fa9afa1b          QADD16   r10,r10,r11
;;;1341   
;;;1342           /*  writing the butterfly processed i0 sample */
;;;1343   
;;;1344           /* xa' = xa + xb + xc + xd */
;;;1345           /* ya' = ya + yb + yc + yd */
;;;1346           out1 = __SHADD16(R, T);
000166  fa99fb2a          SHADD16  r11,r9,r10
;;;1347           out1 = __SHADD16(out1, 0);
00016a  f04f0e00          MOV      lr,#0
00016e  fa9bfb2e          SHADD16  r11,r11,lr
;;;1348           _SIMD32_OFFSET(pSi0) = out1;
000172  f8c5b000          STR      r11,[r5,#0]
;;;1349           pSi0 += 2 * n1;
000176  eb050584          ADD      r5,r5,r4,LSL #2
;;;1350   
;;;1351           /* R = packed( (ya + yc) - (yb + yd), (xa + xc) - (xb + xd)) */
;;;1352           R = __SHSUB16(R, T);
00017a  fad9f92a          SHSUB16  r9,r9,r10
;;;1353   
;;;1354   #ifndef ARM_MATH_BIG_ENDIAN
;;;1355   
;;;1356           /* (ya-yb+yc-yd)* (si2) + (xa-xb+xc-xd)* co2 */
;;;1357           out1 = __SMUSD(C2, R) >> 16u;
00017e  f8dda008          LDR      r10,[sp,#8]
000182  fb4afa09          SMUSD    r10,r10,r9
000186  ea4f4a1a          LSR      r10,r10,#16
;;;1358   
;;;1359           /* (ya-yb+yc-yd)* co2 - (xa-xb+xc-xd)* (si2) */
;;;1360           out2 = __SMUADX(C2, R);
00018a  f8ddb008          LDR      r11,[sp,#8]
00018e  fb2bfb19          SMUADX   r11,r11,r9
;;;1361   
;;;1362   #else
;;;1363   
;;;1364           /* (ya-yb+yc-yd)* co2 - (xa-xb+xc-xd)* (si2) */
;;;1365           out1 = __SMUADX(R, C2) >> 16u;
;;;1366   
;;;1367           /* (ya-yb+yc-yd)* (si2) + (xa-xb+xc-xd)* co2 */
;;;1368           out2 = __SMUSD(__QSUB16(0, C2), R);
;;;1369   
;;;1370   #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;1371   
;;;1372           /*  Reading i0+3fftLen/4 */
;;;1373           /* Read yb (real), xb(imag) input */
;;;1374           T = _SIMD32_OFFSET(pSi1);
000192  f8d19000          LDR      r9,[r1,#0]
;;;1375   
;;;1376           /*  writing the butterfly processed i0 + fftLen/4 sample */
;;;1377           /* xc' = (xa-xb+xc-xd)* co2 + (ya-yb+yc-yd)* (si2) */
;;;1378           /* yc' = (ya-yb+yc-yd)* co2 - (xa-xb+xc-xd)* (si2) */
;;;1379           _SIMD32_OFFSET(pSi1) =
000196  eaca0a0b          PKHBT    r10,r10,r11
00019a  f8c1a000          STR      r10,[r1,#0]
;;;1380             ((out2) & 0xFFFF0000) | (out1 & 0x0000FFFF);
;;;1381           pSi1 += 2 * n1;
00019e  eb010184          ADD      r1,r1,r4,LSL #2
;;;1382   
;;;1383           /*  Butterfly calculations */
;;;1384   
;;;1385           /* Read yd (real), xd(imag) input */
;;;1386           U = _SIMD32_OFFSET(pSi3);
0001a2  f8d3a000          LDR      r10,[r3,#0]
;;;1387   
;;;1388           /* T = packed(yb-yd, xb-xd) */
;;;1389           T = __QSUB16(T, U);
0001a6  fad9fa1a          QSUB16   r10,r9,r10
;;;1390   
;;;1391   #ifndef ARM_MATH_BIG_ENDIAN
;;;1392   
;;;1393           /* R = packed((ya-yc) + (xb- xd) , (xa-xc) - (yb-yd)) */
;;;1394           R = __SHSAX(S, T);
0001aa  f8ddb010          LDR      r11,[sp,#0x10]
0001ae  faebf92a          SHSAX    r9,r11,r10
;;;1395   
;;;1396           /* S = packed((ya-yc) - (xb- xd),  (xa-xc) + (yb-yd)) */
;;;1397           S = __SHASX(S, T);
0001b2  f8ddb010          LDR      r11,[sp,#0x10]
0001b6  faabfa2a          SHASX    r10,r11,r10
;;;1398   
;;;1399   
;;;1400           /*  Butterfly process for the i0+fftLen/2 sample */
;;;1401           out1 = __SMUSD(C1, S) >> 16u;
0001ba  f8ddb00c          LDR      r11,[sp,#0xc]
0001be  fb4bfb0a          SMUSD    r11,r11,r10
0001c2  ea4f4b1b          LSR      r11,r11,#16
;;;1402           out2 = __SMUADX(C1, S);
0001c6  f8dde00c          LDR      lr,[sp,#0xc]
0001ca  fb2efa1a          SMUADX   r10,lr,r10
;;;1403   
;;;1404   #else
;;;1405   
;;;1406           /* R = packed((ya-yc) + (xb- xd) , (xa-xc) - (yb-yd)) */
;;;1407           R = __SHASX(S, T);
;;;1408   
;;;1409           /* S = packed((ya-yc) - (xb- xd),  (xa-xc) + (yb-yd)) */
;;;1410           S = __SHSAX(S, T);
;;;1411   
;;;1412   
;;;1413           /*  Butterfly process for the i0+fftLen/2 sample */
;;;1414           out1 = __SMUADX(S, C1) >> 16u;
;;;1415           out2 = __SMUSD(__QSUB16(0, C1), S);
;;;1416   
;;;1417   #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;1418   
;;;1419           /* xb' = (xa+yb-xc-yd)* co1 + (ya-xb-yc+xd)* (si1) */
;;;1420           /* yb' = (ya-xb-yc+xd)* co1 - (xa+yb-xc-yd)* (si1) */
;;;1421           _SIMD32_OFFSET(pSi2) =
0001ce  eacb0a0a          PKHBT    r10,r11,r10
0001d2  f8c6a000          STR      r10,[r6,#0]
;;;1422             ((out2) & 0xFFFF0000) | (out1 & 0x0000FFFF);
;;;1423           pSi2 += 2 * n1;
0001d6  eb060684          ADD      r6,r6,r4,LSL #2
;;;1424   
;;;1425           /*  Butterfly process for the i0+3fftLen/4 sample */
;;;1426   
;;;1427   #ifndef ARM_MATH_BIG_ENDIAN
;;;1428   
;;;1429           out1 = __SMUSD(C3, R) >> 16u;
0001da  f8dda004          LDR      r10,[sp,#4]
0001de  fb4afa09          SMUSD    r10,r10,r9
0001e2  ea4f4a1a          LSR      r10,r10,#16
;;;1430           out2 = __SMUADX(C3, R);
0001e6  f8ddb004          LDR      r11,[sp,#4]
0001ea  fb2bf919          SMUADX   r9,r11,r9
;;;1431   
;;;1432   #else
;;;1433   
;;;1434           out1 = __SMUADX(C3, R) >> 16u;
;;;1435           out2 = __SMUSD(__QSUB16(0, C3), R);
;;;1436   
;;;1437   #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;1438   
;;;1439           /* xd' = (xa-yb-xc+yd)* co3 + (ya+xb-yc-xd)* (si3) */
;;;1440           /* yd' = (ya+xb-yc-xd)* co3 - (xa-yb-xc+yd)* (si3) */
;;;1441           _SIMD32_OFFSET(pSi3) =
0001ee  eaca0909          PKHBT    r9,r10,r9
0001f2  f8c39000          STR      r9,[r3,#0]
;;;1442             ((out2) & 0xFFFF0000) | (out1 & 0x0000FFFF);
;;;1443           pSi3 += 2 * n1;
0001f6  eb030384          ADD      r3,r3,r4,LSL #2
0001fa  44a0              ADD      r8,r8,r4              ;1317
                  |L2.508|
0001fc  f8dd9020          LDR      r9,[sp,#0x20]         ;1317
000200  45c8              CMP      r8,r9                 ;1317
000202  d3a0              BCC      |L2.326|
000204  1c7f              ADDS     r7,r7,#1              ;1301
                  |L2.518|
000206  9905              LDR      r1,[sp,#0x14]         ;1301
000208  428f              CMP      r7,r1                 ;1301
00020a  d981              BLS      |L2.272|
;;;1444         }
;;;1445       }
;;;1446       /*  Twiddle coefficients index modifier */
;;;1447       twidCoefModifier <<= 2u;
00020c  990a              LDR      r1,[sp,#0x28]
00020e  0089              LSLS     r1,r1,#2
000210  910a              STR      r1,[sp,#0x28]
000212  9900              LDR      r1,[sp,#0]            ;1294
000214  0889              LSRS     r1,r1,#2              ;1294
000216  9100              STR      r1,[sp,#0]            ;1294
                  |L2.536|
000218  9900              LDR      r1,[sp,#0]            ;1294
00021a  2904              CMP      r1,#4                 ;1294
00021c  f63faf70          BHI      |L2.256|
;;;1448     }
;;;1449     /* end of middle stage process */
;;;1450   
;;;1451     /* data is in 10.6(q6) format for the 1024 point */
;;;1452     /* data is in 8.8(q8) format for the 256 point */
;;;1453     /* data is in 6.10(q10) format for the 64 point */
;;;1454     /* data is in 4.12(q12) format for the 16 point */
;;;1455   
;;;1456     /*  Initializations for the last stage */
;;;1457     j = fftLen >> 2;
000220  9e06              LDR      r6,[sp,#0x18]
;;;1458   
;;;1459     ptr1 = &pSrc16[0];
000222  9a07              LDR      r2,[sp,#0x1c]
                  |L2.548|
;;;1460   
;;;1461     /* start of last stage process */
;;;1462   
;;;1463     /*  Butterfly implementation */
;;;1464     do
;;;1465     {
;;;1466       /* Read xa (real), ya(imag) input */
;;;1467       xaya = *__SIMD32(ptr1)++;
000224  6813              LDR      r3,[r2,#0]
;;;1468   
;;;1469       /* Read xb (real), yb(imag) input */
;;;1470       xbyb = *__SIMD32(ptr1)++;
000226  6850              LDR      r0,[r2,#4]
;;;1471   
;;;1472       /* Read xc (real), yc(imag) input */
;;;1473       xcyc = *__SIMD32(ptr1)++;
000228  6894              LDR      r4,[r2,#8]
;;;1474   
;;;1475       /* Read xd (real), yd(imag) input */
;;;1476       xdyd = *__SIMD32(ptr1)++;
00022a  68d1              LDR      r1,[r2,#0xc]
;;;1477   
;;;1478       /* R = packed((ya + yc), (xa + xc)) */
;;;1479       R = __QADD16(xaya, xcyc);
00022c  fa93f514          QADD16   r5,r3,r4
;;;1480   
;;;1481       /* T = packed((yb + yd), (xb + xd)) */
;;;1482       T = __QADD16(xbyb, xdyd);
000230  fa90f711          QADD16   r7,r0,r1
;;;1483   
;;;1484       /* pointer updation for writing */
;;;1485       ptr1 = ptr1 - 8u;
;;;1486   
;;;1487   
;;;1488       /* xa' = xa + xb + xc + xd */
;;;1489       /* ya' = ya + yb + yc + yd */
;;;1490       *__SIMD32(ptr1)++ = __SHADD16(R, T);
000234  fa95f727          SHADD16  r7,r5,r7
000238  6017              STR      r7,[r2,#0]
;;;1491   
;;;1492       /* T = packed((yb + yd), (xb + xd)) */
;;;1493       T = __QADD16(xbyb, xdyd);
00023a  fa90f711          QADD16   r7,r0,r1
;;;1494   
;;;1495       /* xc' = (xa-xb+xc-xd) */
;;;1496       /* yc' = (ya-yb+yc-yd) */
;;;1497       *__SIMD32(ptr1)++ = __SHSUB16(R, T);
00023e  fad5f527          SHSUB16  r5,r5,r7
000242  6055              STR      r5,[r2,#4]
;;;1498   
;;;1499       /* S = packed((ya - yc), (xa - xc)) */
;;;1500       S = __QSUB16(xaya, xcyc);
000244  fad3f314          QSUB16   r3,r3,r4
;;;1501   
;;;1502       /* Read yd (real), xd(imag) input */
;;;1503       /* T = packed( (yb - yd), (xb - xd))  */
;;;1504       U = __QSUB16(xbyb, xdyd);
000248  fad0f011          QSUB16   r0,r0,r1
;;;1505   
;;;1506   #ifndef ARM_MATH_BIG_ENDIAN
;;;1507   
;;;1508       /* xb' = (xa+yb-xc-yd) */
;;;1509       /* yb' = (ya-xb-yc+xd) */
;;;1510       *__SIMD32(ptr1)++ = __SHASX(S, U);
00024c  faa3f120          SHASX    r1,r3,r0
000250  6091              STR      r1,[r2,#8]
;;;1511   
;;;1512   
;;;1513       /* xd' = (xa-yb-xc+yd) */
;;;1514       /* yd' = (ya+xb-yc-xd) */
;;;1515       *__SIMD32(ptr1)++ = __SHSAX(S, U);
000252  fae3f020          SHSAX    r0,r3,r0
000256  60d0              STR      r0,[r2,#0xc]
000258  3210              ADDS     r2,r2,#0x10
;;;1516   
;;;1517   #else
;;;1518   
;;;1519       /* xb' = (xa+yb-xc-yd) */
;;;1520       /* yb' = (ya-xb-yc+xd) */
;;;1521       *__SIMD32(ptr1)++ = __SHSAX(S, U);
;;;1522   
;;;1523   
;;;1524       /* xd' = (xa-yb-xc+yd) */
;;;1525       /* yd' = (ya+xb-yc-xd) */
;;;1526       *__SIMD32(ptr1)++ = __SHASX(S, U);
;;;1527   
;;;1528   
;;;1529   #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;1530   
;;;1531     } while(--j);
00025a  1e76              SUBS     r6,r6,#1
00025c  d1e2              BNE      |L2.548|
;;;1532   
;;;1533     /* end of last stage  process */
;;;1534   
;;;1535     /* output is in 11.5(q5) format for the 1024 point */
;;;1536     /* output is in 9.7(q7) format for the 256 point   */
;;;1537     /* output is in 7.9(q9) format for the 64 point  */
;;;1538     /* output is in 5.11(q11) format for the 16 point  */
;;;1539   
;;;1540   
;;;1541   #else
;;;1542   
;;;1543     /* Run the below code for Cortex-M0 */
;;;1544   
;;;1545     q15_t R0, R1, S0, S1, T0, T1, U0, U1;
;;;1546     q15_t Co1, Si1, Co2, Si2, Co3, Si3, out1, out2;
;;;1547     uint32_t n1, n2, ic, i0, i1, i2, i3, j, k;
;;;1548   
;;;1549     /* Total process is divided into three stages */
;;;1550   
;;;1551     /* process first stage, middle stages, & last stage */
;;;1552   
;;;1553     /*  Initializations for the first stage */
;;;1554     n2 = fftLen;
;;;1555     n1 = n2;
;;;1556   
;;;1557     /* n2 = fftLen/4 */
;;;1558     n2 >>= 2u;
;;;1559   
;;;1560     /* Index for twiddle coefficient */
;;;1561     ic = 0u;
;;;1562   
;;;1563     /* Index for input read and output write */
;;;1564     i0 = 0u;
;;;1565   
;;;1566     j = n2;
;;;1567   
;;;1568     /* Input is in 1.15(q15) format */
;;;1569   
;;;1570     /*  Start of first stage process */
;;;1571     do
;;;1572     {
;;;1573       /*  Butterfly implementation */
;;;1574   
;;;1575       /*  index calculation for the input as, */
;;;1576       /*  pSrc16[i0 + 0], pSrc16[i0 + fftLen/4], pSrc16[i0 + fftLen/2], pSrc16[i0 + 3fftLen/4] */
;;;1577       i1 = i0 + n2;
;;;1578       i2 = i1 + n2;
;;;1579       i3 = i2 + n2;
;;;1580   
;;;1581       /*  Reading i0, i0+fftLen/2 inputs */
;;;1582       /* input is down scale by 4 to avoid overflow */
;;;1583       /* Read ya (real), xa(imag) input */
;;;1584       T0 = pSrc16[i0 * 2u] >> 2u;
;;;1585       T1 = pSrc16[(i0 * 2u) + 1u] >> 2u;
;;;1586       /* input is down scale by 4 to avoid overflow */
;;;1587       /* Read yc (real), xc(imag) input */
;;;1588       S0 = pSrc16[i2 * 2u] >> 2u;
;;;1589       S1 = pSrc16[(i2 * 2u) + 1u] >> 2u;
;;;1590   
;;;1591       /* R0 = (ya + yc), R1 = (xa + xc) */
;;;1592       R0 = __SSAT(T0 + S0, 16u);
;;;1593       R1 = __SSAT(T1 + S1, 16u);
;;;1594       /* S0 = (ya - yc), S1 = (xa - xc) */
;;;1595       S0 = __SSAT(T0 - S0, 16u);
;;;1596       S1 = __SSAT(T1 - S1, 16u);
;;;1597   
;;;1598       /*  Reading i0+fftLen/4 , i0+3fftLen/4 inputs */
;;;1599       /* input is down scale by 4 to avoid overflow */
;;;1600       /* Read yb (real), xb(imag) input */
;;;1601       T0 = pSrc16[i1 * 2u] >> 2u;
;;;1602       T1 = pSrc16[(i1 * 2u) + 1u] >> 2u;
;;;1603       /* Read yd (real), xd(imag) input */
;;;1604       /* input is down scale by 4 to avoid overflow */
;;;1605       U0 = pSrc16[i3 * 2u] >> 2u;
;;;1606       U1 = pSrc16[(i3 * 2u) + 1u] >> 2u;
;;;1607   
;;;1608       /* T0 = (yb + yd), T1 = (xb + xd) */
;;;1609       T0 = __SSAT(T0 + U0, 16u);
;;;1610       T1 = __SSAT(T1 + U1, 16u);
;;;1611   
;;;1612       /*  writing the butterfly processed i0 sample */
;;;1613       /* xa' = xa + xb + xc + xd */
;;;1614       /* ya' = ya + yb + yc + yd */
;;;1615       pSrc16[i0 * 2u] = (R0 >> 1u) + (T0 >> 1u);
;;;1616       pSrc16[(i0 * 2u) + 1u] = (R1 >> 1u) + (T1 >> 1u);
;;;1617   
;;;1618       /* R0 = (ya + yc) - (yb + yd), R1 = (xa + xc)- (xb + xd) */
;;;1619       R0 = __SSAT(R0 - T0, 16u);
;;;1620       R1 = __SSAT(R1 - T1, 16u);
;;;1621       /* co2 & si2 are read from Coefficient pointer */
;;;1622       Co2 = pCoef16[2u * ic * 2u];
;;;1623       Si2 = pCoef16[(2u * ic * 2u) + 1u];
;;;1624       /* xc' = (xa-xb+xc-xd)* co2 - (ya-yb+yc-yd)* (si2) */
;;;1625       out1 = (q15_t) ((Co2 * R0 - Si2 * R1) >> 16u);
;;;1626       /* yc' = (ya-yb+yc-yd)* co2 + (xa-xb+xc-xd)* (si2) */
;;;1627       out2 = (q15_t) ((Si2 * R0 + Co2 * R1) >> 16u);
;;;1628   
;;;1629       /*  Reading i0+fftLen/4 */
;;;1630       /* input is down scale by 4 to avoid overflow */
;;;1631       /* T0 = yb, T1 = xb */
;;;1632       T0 = pSrc16[i1 * 2u] >> 2u;
;;;1633       T1 = pSrc16[(i1 * 2u) + 1u] >> 2u;
;;;1634   
;;;1635       /* writing the butterfly processed i0 + fftLen/4 sample */
;;;1636       /* writing output(xc', yc') in little endian format */
;;;1637       pSrc16[i1 * 2u] = out1;
;;;1638       pSrc16[(i1 * 2u) + 1u] = out2;
;;;1639   
;;;1640       /*  Butterfly calculations */
;;;1641       /* input is down scale by 4 to avoid overflow */
;;;1642       /* U0 = yd, U1 = xd) */
;;;1643       U0 = pSrc16[i3 * 2u] >> 2u;
;;;1644       U1 = pSrc16[(i3 * 2u) + 1u] >> 2u;
;;;1645   
;;;1646       /* T0 = yb-yd, T1 = xb-xd) */
;;;1647       T0 = __SSAT(T0 - U0, 16u);
;;;1648       T1 = __SSAT(T1 - U1, 16u);
;;;1649       /* R0 = (ya-yc) - (xb- xd) , R1 = (xa-xc) + (yb-yd) */
;;;1650       R0 = (q15_t) __SSAT((q31_t) (S0 + T1), 16);
;;;1651       R1 = (q15_t) __SSAT((q31_t) (S1 - T0), 16);
;;;1652       /* S = (ya-yc) + (xb- xd), S1 = (xa-xc) - (yb-yd) */
;;;1653       S0 = (q15_t) __SSAT((q31_t) (S0 - T1), 16);
;;;1654       S1 = (q15_t) __SSAT((q31_t) (S1 + T0), 16);
;;;1655   
;;;1656       /* co1 & si1 are read from Coefficient pointer */
;;;1657       Co1 = pCoef16[ic * 2u];
;;;1658       Si1 = pCoef16[(ic * 2u) + 1u];
;;;1659       /*  Butterfly process for the i0+fftLen/2 sample */
;;;1660       /* xb' = (xa-yb-xc+yd)* co1 - (ya+xb-yc-xd)* (si1) */
;;;1661       out1 = (q15_t) ((Co1 * S0 - Si1 * S1) >> 16u);
;;;1662       /* yb' = (ya+xb-yc-xd)* co1 + (xa-yb-xc+yd)* (si1) */
;;;1663       out2 = (q15_t) ((Si1 * S0 + Co1 * S1) >> 16u);
;;;1664       /* writing output(xb', yb') in little endian format */
;;;1665       pSrc16[i2 * 2u] = out1;
;;;1666       pSrc16[(i2 * 2u) + 1u] = out2;
;;;1667   
;;;1668       /* Co3 & si3 are read from Coefficient pointer */
;;;1669       Co3 = pCoef16[3u * ic * 2u];
;;;1670       Si3 = pCoef16[(3u * ic * 2u) + 1u];
;;;1671       /*  Butterfly process for the i0+3fftLen/4 sample */
;;;1672       /* xd' = (xa+yb-xc-yd)* Co3 - (ya-xb-yc+xd)* (si3) */
;;;1673       out1 = (q15_t) ((Co3 * R0 - Si3 * R1) >> 16u);
;;;1674       /* yd' = (ya-xb-yc+xd)* Co3 + (xa+yb-xc-yd)* (si3) */
;;;1675       out2 = (q15_t) ((Si3 * R0 + Co3 * R1) >> 16u);
;;;1676       /* writing output(xd', yd') in little endian format */
;;;1677       pSrc16[i3 * 2u] = out1;
;;;1678       pSrc16[(i3 * 2u) + 1u] = out2;
;;;1679   
;;;1680       /*  Twiddle coefficients index modifier */
;;;1681       ic = ic + twidCoefModifier;
;;;1682   
;;;1683       /*  Updating input index */
;;;1684       i0 = i0 + 1u;
;;;1685   
;;;1686     } while(--j);
;;;1687   
;;;1688     /*  End of first stage process */
;;;1689   
;;;1690     /* data is in 4.11(q11) format */
;;;1691   
;;;1692   
;;;1693     /*  Start of Middle stage process */
;;;1694   
;;;1695     /*  Twiddle coefficients index modifier */
;;;1696     twidCoefModifier <<= 2u;
;;;1697   
;;;1698     /*  Calculation of Middle stage */
;;;1699     for (k = fftLen / 4u; k > 4u; k >>= 2u)
;;;1700     {
;;;1701       /*  Initializations for the middle stage */
;;;1702       n1 = n2;
;;;1703       n2 >>= 2u;
;;;1704       ic = 0u;
;;;1705   
;;;1706       for (j = 0u; j <= (n2 - 1u); j++)
;;;1707       {
;;;1708         /*  index calculation for the coefficients */
;;;1709         Co1 = pCoef16[ic * 2u];
;;;1710         Si1 = pCoef16[(ic * 2u) + 1u];
;;;1711         Co2 = pCoef16[2u * ic * 2u];
;;;1712         Si2 = pCoef16[2u * ic * 2u + 1u];
;;;1713         Co3 = pCoef16[3u * ic * 2u];
;;;1714         Si3 = pCoef16[(3u * ic * 2u) + 1u];
;;;1715   
;;;1716         /*  Twiddle coefficients index modifier */
;;;1717         ic = ic + twidCoefModifier;
;;;1718   
;;;1719         /*  Butterfly implementation */
;;;1720         for (i0 = j; i0 < fftLen; i0 += n1)
;;;1721         {
;;;1722           /*  index calculation for the input as, */
;;;1723           /*  pSrc16[i0 + 0], pSrc16[i0 + fftLen/4], pSrc16[i0 + fftLen/2], pSrc16[i0 + 3fftLen/4] */
;;;1724           i1 = i0 + n2;
;;;1725           i2 = i1 + n2;
;;;1726           i3 = i2 + n2;
;;;1727   
;;;1728           /*  Reading i0, i0+fftLen/2 inputs */
;;;1729           /* Read ya (real), xa(imag) input */
;;;1730           T0 = pSrc16[i0 * 2u];
;;;1731           T1 = pSrc16[(i0 * 2u) + 1u];
;;;1732   
;;;1733           /* Read yc (real), xc(imag) input */
;;;1734           S0 = pSrc16[i2 * 2u];
;;;1735           S1 = pSrc16[(i2 * 2u) + 1u];
;;;1736   
;;;1737   
;;;1738           /* R0 = (ya + yc), R1 = (xa + xc) */
;;;1739           R0 = __SSAT(T0 + S0, 16u);
;;;1740           R1 = __SSAT(T1 + S1, 16u);
;;;1741           /* S0 = (ya - yc), S1 = (xa - xc) */
;;;1742           S0 = __SSAT(T0 - S0, 16u);
;;;1743           S1 = __SSAT(T1 - S1, 16u);
;;;1744   
;;;1745           /*  Reading i0+fftLen/4 , i0+3fftLen/4 inputs */
;;;1746           /* Read yb (real), xb(imag) input */
;;;1747           T0 = pSrc16[i1 * 2u];
;;;1748           T1 = pSrc16[(i1 * 2u) + 1u];
;;;1749   
;;;1750           /* Read yd (real), xd(imag) input */
;;;1751           U0 = pSrc16[i3 * 2u];
;;;1752           U1 = pSrc16[(i3 * 2u) + 1u];
;;;1753   
;;;1754           /* T0 = (yb + yd), T1 = (xb + xd) */
;;;1755           T0 = __SSAT(T0 + U0, 16u);
;;;1756           T1 = __SSAT(T1 + U1, 16u);
;;;1757   
;;;1758           /*  writing the butterfly processed i0 sample */
;;;1759           /* xa' = xa + xb + xc + xd */
;;;1760           /* ya' = ya + yb + yc + yd */
;;;1761           pSrc16[i0 * 2u] = ((R0 >> 1u) + (T0 >> 1u)) >> 1u;
;;;1762           pSrc16[(i0 * 2u) + 1u] = ((R1 >> 1u) + (T1 >> 1u)) >> 1u;
;;;1763   
;;;1764           /* R0 = (ya + yc) - (yb + yd), R1 = (xa + xc) - (xb + xd) */
;;;1765           R0 = (R0 >> 1u) - (T0 >> 1u);
;;;1766           R1 = (R1 >> 1u) - (T1 >> 1u);
;;;1767   
;;;1768           /* (ya-yb+yc-yd)* (si2) - (xa-xb+xc-xd)* co2 */
;;;1769           out1 = (q15_t) ((Co2 * R0 - Si2 * R1) >> 16);
;;;1770           /* (ya-yb+yc-yd)* co2 + (xa-xb+xc-xd)* (si2) */
;;;1771           out2 = (q15_t) ((Si2 * R0 + Co2 * R1) >> 16);
;;;1772   
;;;1773           /*  Reading i0+3fftLen/4 */
;;;1774           /* Read yb (real), xb(imag) input */
;;;1775           T0 = pSrc16[i1 * 2u];
;;;1776           T1 = pSrc16[(i1 * 2u) + 1u];
;;;1777   
;;;1778           /*  writing the butterfly processed i0 + fftLen/4 sample */
;;;1779           /* xc' = (xa-xb+xc-xd)* co2 - (ya-yb+yc-yd)* (si2) */
;;;1780           /* yc' = (ya-yb+yc-yd)* co2 + (xa-xb+xc-xd)* (si2) */
;;;1781           pSrc16[i1 * 2u] = out1;
;;;1782           pSrc16[(i1 * 2u) + 1u] = out2;
;;;1783   
;;;1784           /*  Butterfly calculations */
;;;1785           /* Read yd (real), xd(imag) input */
;;;1786           U0 = pSrc16[i3 * 2u];
;;;1787           U1 = pSrc16[(i3 * 2u) + 1u];
;;;1788   
;;;1789           /* T0 = yb-yd, T1 = xb-xd) */
;;;1790           T0 = __SSAT(T0 - U0, 16u);
;;;1791           T1 = __SSAT(T1 - U1, 16u);
;;;1792   
;;;1793           /* R0 = (ya-yc) - (xb- xd) , R1 = (xa-xc) + (yb-yd) */
;;;1794           R0 = (S0 >> 1u) + (T1 >> 1u);
;;;1795           R1 = (S1 >> 1u) - (T0 >> 1u);
;;;1796   
;;;1797           /* S1 = (ya-yc) + (xb- xd), S1 = (xa-xc) - (yb-yd) */
;;;1798           S0 = (S0 >> 1u) - (T1 >> 1u);
;;;1799           S1 = (S1 >> 1u) + (T0 >> 1u);
;;;1800   
;;;1801           /*  Butterfly process for the i0+fftLen/2 sample */
;;;1802           out1 = (q15_t) ((Co1 * S0 - Si1 * S1) >> 16u);
;;;1803           out2 = (q15_t) ((Si1 * S0 + Co1 * S1) >> 16u);
;;;1804           /* xb' = (xa-yb-xc+yd)* co1 - (ya+xb-yc-xd)* (si1) */
;;;1805           /* yb' = (ya+xb-yc-xd)* co1 + (xa-yb-xc+yd)* (si1) */
;;;1806           pSrc16[i2 * 2u] = out1;
;;;1807           pSrc16[(i2 * 2u) + 1u] = out2;
;;;1808   
;;;1809           /*  Butterfly process for the i0+3fftLen/4 sample */
;;;1810           out1 = (q15_t) ((Co3 * R0 - Si3 * R1) >> 16u);
;;;1811   
;;;1812           out2 = (q15_t) ((Si3 * R0 + Co3 * R1) >> 16u);
;;;1813           /* xd' = (xa+yb-xc-yd)* Co3 - (ya-xb-yc+xd)* (si3) */
;;;1814           /* yd' = (ya-xb-yc+xd)* Co3 + (xa+yb-xc-yd)* (si3) */
;;;1815           pSrc16[i3 * 2u] = out1;
;;;1816           pSrc16[(i3 * 2u) + 1u] = out2;
;;;1817   
;;;1818   
;;;1819         }
;;;1820       }
;;;1821       /*  Twiddle coefficients index modifier */
;;;1822       twidCoefModifier <<= 2u;
;;;1823     }
;;;1824     /*  End of Middle stages process */
;;;1825   
;;;1826   
;;;1827     /* data is in 10.6(q6) format for the 1024 point */
;;;1828     /* data is in 8.8(q8) format for the 256 point   */
;;;1829     /* data is in 6.10(q10) format for the 64 point  */
;;;1830     /* data is in 4.12(q12) format for the 16 point  */
;;;1831   
;;;1832     /* start of last stage process */
;;;1833   
;;;1834   
;;;1835     /*  Initializations for the last stage */
;;;1836     n1 = n2;
;;;1837     n2 >>= 2u;
;;;1838   
;;;1839     /*  Butterfly implementation */
;;;1840     for (i0 = 0u; i0 <= (fftLen - n1); i0 += n1)
;;;1841     {
;;;1842       /*  index calculation for the input as, */
;;;1843       /*  pSrc16[i0 + 0], pSrc16[i0 + fftLen/4], pSrc16[i0 + fftLen/2], pSrc16[i0 + 3fftLen/4] */
;;;1844       i1 = i0 + n2;
;;;1845       i2 = i1 + n2;
;;;1846       i3 = i2 + n2;
;;;1847   
;;;1848       /*  Reading i0, i0+fftLen/2 inputs */
;;;1849       /* Read ya (real), xa(imag) input */
;;;1850       T0 = pSrc16[i0 * 2u];
;;;1851       T1 = pSrc16[(i0 * 2u) + 1u];
;;;1852       /* Read yc (real), xc(imag) input */
;;;1853       S0 = pSrc16[i2 * 2u];
;;;1854       S1 = pSrc16[(i2 * 2u) + 1u];
;;;1855   
;;;1856       /* R0 = (ya + yc), R1 = (xa + xc) */
;;;1857       R0 = __SSAT(T0 + S0, 16u);
;;;1858       R1 = __SSAT(T1 + S1, 16u);
;;;1859       /* S0 = (ya - yc), S1 = (xa - xc) */
;;;1860       S0 = __SSAT(T0 - S0, 16u);
;;;1861       S1 = __SSAT(T1 - S1, 16u);
;;;1862   
;;;1863       /*  Reading i0+fftLen/4 , i0+3fftLen/4 inputs */
;;;1864       /* Read yb (real), xb(imag) input */
;;;1865       T0 = pSrc16[i1 * 2u];
;;;1866       T1 = pSrc16[(i1 * 2u) + 1u];
;;;1867       /* Read yd (real), xd(imag) input */
;;;1868       U0 = pSrc16[i3 * 2u];
;;;1869       U1 = pSrc16[(i3 * 2u) + 1u];
;;;1870   
;;;1871       /* T0 = (yb + yd), T1 = (xb + xd) */
;;;1872       T0 = __SSAT(T0 + U0, 16u);
;;;1873       T1 = __SSAT(T1 + U1, 16u);
;;;1874   
;;;1875       /*  writing the butterfly processed i0 sample */
;;;1876       /* xa' = xa + xb + xc + xd */
;;;1877       /* ya' = ya + yb + yc + yd */
;;;1878       pSrc16[i0 * 2u] = (R0 >> 1u) + (T0 >> 1u);
;;;1879       pSrc16[(i0 * 2u) + 1u] = (R1 >> 1u) + (T1 >> 1u);
;;;1880   
;;;1881       /* R0 = (ya + yc) - (yb + yd), R1 = (xa + xc) - (xb + xd) */
;;;1882       R0 = (R0 >> 1u) - (T0 >> 1u);
;;;1883       R1 = (R1 >> 1u) - (T1 >> 1u);
;;;1884   
;;;1885       /* Read yb (real), xb(imag) input */
;;;1886       T0 = pSrc16[i1 * 2u];
;;;1887       T1 = pSrc16[(i1 * 2u) + 1u];
;;;1888   
;;;1889       /*  writing the butterfly processed i0 + fftLen/4 sample */
;;;1890       /* xc' = (xa-xb+xc-xd) */
;;;1891       /* yc' = (ya-yb+yc-yd) */
;;;1892       pSrc16[i1 * 2u] = R0;
;;;1893       pSrc16[(i1 * 2u) + 1u] = R1;
;;;1894   
;;;1895       /* Read yd (real), xd(imag) input */
;;;1896       U0 = pSrc16[i3 * 2u];
;;;1897       U1 = pSrc16[(i3 * 2u) + 1u];
;;;1898       /* T0 = (yb - yd), T1 = (xb - xd) */
;;;1899       T0 = __SSAT(T0 - U0, 16u);
;;;1900       T1 = __SSAT(T1 - U1, 16u);
;;;1901   
;;;1902       /*  writing the butterfly processed i0 + fftLen/2 sample */
;;;1903       /* xb' = (xa-yb-xc+yd) */
;;;1904       /* yb' = (ya+xb-yc-xd) */
;;;1905       pSrc16[i2 * 2u] = (S0 >> 1u) - (T1 >> 1u);
;;;1906       pSrc16[(i2 * 2u) + 1u] = (S1 >> 1u) + (T0 >> 1u);
;;;1907   
;;;1908   
;;;1909       /*  writing the butterfly processed i0 + 3fftLen/4 sample */
;;;1910       /* xd' = (xa+yb-xc-yd) */
;;;1911       /* yd' = (ya-xb-yc+xd) */
;;;1912       pSrc16[i3 * 2u] = (S0 >> 1u) + (T1 >> 1u);
;;;1913       pSrc16[(i3 * 2u) + 1u] = (S1 >> 1u) - (T0 >> 1u);
;;;1914     }
;;;1915     /* end of last stage  process */
;;;1916   
;;;1917     /* output is in 11.5(q5) format for the 1024 point */
;;;1918     /* output is in 9.7(q7) format for the 256 point   */
;;;1919     /* output is in 7.9(q9) format for the 64 point  */
;;;1920     /* output is in 5.11(q11) format for the 16 point  */
;;;1921   
;;;1922   #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;1923   
;;;1924   }
00025e  b00b              ADD      sp,sp,#0x2c
000260  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP


                          AREA ||i.arm_radix4_butterfly_q15||, CODE, READONLY, ALIGN=1

                  arm_radix4_butterfly_q15 PROC
;;;162    
;;;163    void arm_radix4_butterfly_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;164      q15_t * pSrc16,
;;;165      uint32_t fftLen,
;;;166      q15_t * pCoef16,
;;;167      uint32_t twidCoefModifier)
;;;168    {
000004  b087              SUB      sp,sp,#0x1c
;;;169    
;;;170    #ifndef ARM_MATH_CM0_FAMILY
;;;171    
;;;172      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;173    
;;;174      q31_t R, S, T, U;
;;;175      q31_t C1, C2, C3, out1, out2;
;;;176      uint32_t n1, n2, ic, i0, j, k;
;;;177    
;;;178      q15_t *ptr1;
;;;179      q15_t *pSi0;
;;;180      q15_t *pSi1;
;;;181      q15_t *pSi2;
;;;182      q15_t *pSi3;
;;;183    
;;;184      q31_t xaya, xbyb, xcyc, xdyd;
;;;185    
;;;186      /* Total process is divided into three stages */
;;;187    
;;;188      /* process first stage, middle stages, & last stage */
;;;189    
;;;190      /*  Initializations for the first stage */
;;;191      n2 = fftLen;
000006  9808              LDR      r0,[sp,#0x20]
;;;192      n1 = n2;
;;;193    
;;;194      /* n2 = fftLen/4 */
;;;195      n2 >>= 2u;
000008  0880              LSRS     r0,r0,#2
00000a  9006              STR      r0,[sp,#0x18]
;;;196    
;;;197      /* Index for twiddle coefficient */
;;;198      ic = 0u;
00000c  2500              MOVS     r5,#0
;;;199    
;;;200      /* Index for input read and output write */
;;;201      j = n2;
00000e  4683              MOV      r11,r0
;;;202      
;;;203      pSi0 = pSrc16;
000010  9f07              LDR      r7,[sp,#0x1c]
;;;204      pSi1 = pSi0 + 2 * n2;
000012  eb070480          ADD      r4,r7,r0,LSL #2
;;;205      pSi2 = pSi1 + 2 * n2;
000016  eb040c80          ADD      r12,r4,r0,LSL #2
;;;206      pSi3 = pSi2 + 2 * n2;
00001a  eb0c0680          ADD      r6,r12,r0,LSL #2
                  |L3.30|
;;;207    
;;;208      /* Input is in 1.15(q15) format */
;;;209    
;;;210      /*  start of first stage process */
;;;211      do
;;;212      {
;;;213        /*  Butterfly implementation */
;;;214    
;;;215        /*  Reading i0, i0+fftLen/2 inputs */
;;;216        /* Read ya (real), xa(imag) input */
;;;217        T = _SIMD32_OFFSET(pSi0);
00001e  f8d78000          LDR      r8,[r7,#0]
;;;218        T = __SHADD16(T, 0); // this is just a SIMD arithmetic shift right by 1
000022  2100              MOVS     r1,#0
000024  fa98f821          SHADD16  r8,r8,r1
;;;219        T = __SHADD16(T, 0); // it turns out doing this twice is 2 cycles, the alternative takes 3 cycles
000028  fa98fa21          SHADD16  r10,r8,r1
;;;220        //in = ((int16_t) (T & 0xFFFF)) >> 2;       // alternative code that takes 3 cycles
;;;221        //T = ((T >> 2) & 0xFFFF0000) | (in & 0xFFFF);
;;;222    
;;;223        /* Read yc (real), xc(imag) input */
;;;224        S = _SIMD32_OFFSET(pSi2);
00002c  f8dc8000          LDR      r8,[r12,#0]
;;;225        S = __SHADD16(S, 0);
000030  fa98f821          SHADD16  r8,r8,r1
;;;226        S = __SHADD16(S, 0);
000034  fa98f921          SHADD16  r9,r8,r1
;;;227    
;;;228        /* R = packed((ya + yc), (xa + xc) ) */
;;;229        R = __QADD16(T, S);
000038  fa9af819          QADD16   r8,r10,r9
;;;230    
;;;231        /* S = packed((ya - yc), (xa - xc) ) */
;;;232        S = __QSUB16(T, S);
00003c  fadaf919          QSUB16   r9,r10,r9
;;;233    
;;;234        /*  Reading i0+fftLen/4 , i0+3fftLen/4 inputs */
;;;235        /* Read yb (real), xb(imag) input */
;;;236        T = _SIMD32_OFFSET(pSi1);
000040  f8d4a000          LDR      r10,[r4,#0]
;;;237        T = __SHADD16(T, 0);
000044  fa9afa21          SHADD16  r10,r10,r1
;;;238        T = __SHADD16(T, 0);
000048  fa9afa21          SHADD16  r10,r10,r1
;;;239    
;;;240        /* Read yd (real), xd(imag) input */
;;;241        U = _SIMD32_OFFSET(pSi3);
00004c  f8d6e000          LDR      lr,[r6,#0]
;;;242        U = __SHADD16(U, 0);
000050  fa9efe21          SHADD16  lr,lr,r1
;;;243        U = __SHADD16(U, 0);
000054  fa9efe21          SHADD16  lr,lr,r1
;;;244    
;;;245        /* T = packed((yb + yd), (xb + xd) ) */
;;;246        T = __QADD16(T, U);
000058  fa9afa1e          QADD16   r10,r10,lr
;;;247    
;;;248        /*  writing the butterfly processed i0 sample */
;;;249        /* xa' = xa + xb + xc + xd */
;;;250        /* ya' = ya + yb + yc + yd */
;;;251        _SIMD32_OFFSET(pSi0) = __SHADD16(R, T);
00005c  fa98fe2a          SHADD16  lr,r8,r10
000060  f8c7e000          STR      lr,[r7,#0]
;;;252        pSi0 += 2;
000064  1d3f              ADDS     r7,r7,#4
;;;253    
;;;254        /* R = packed((ya + yc) - (yb + yd), (xa + xc)- (xb + xd)) */
;;;255        R = __QSUB16(R, T);
000066  fad8f81a          QSUB16   r8,r8,r10
;;;256    
;;;257        /* co2 & si2 are read from SIMD Coefficient pointer */
;;;258        C2 = _SIMD32_OFFSET(pCoef16 + (4u * ic));
00006a  eb020ac5          ADD      r10,r2,r5,LSL #3
00006e  f8daa000          LDR      r10,[r10,#0]
;;;259    
;;;260    #ifndef ARM_MATH_BIG_ENDIAN
;;;261    
;;;262        /* xc' = (xa-xb+xc-xd)* co2 + (ya-yb+yc-yd)* (si2) */
;;;263        out1 = __SMUAD(C2, R) >> 16u;
000072  fb2afe08          SMUAD    lr,r10,r8
000076  ea4f4e1e          LSR      lr,lr,#16
;;;264        /* yc' = (ya-yb+yc-yd)* co2 - (xa-xb+xc-xd)* (si2) */
;;;265        out2 = __SMUSDX(C2, R);
00007a  fb4afa18          SMUSDX   r10,r10,r8
;;;266    
;;;267    #else
;;;268    
;;;269        /* xc' = (ya-yb+yc-yd)* co2 - (xa-xb+xc-xd)* (si2) */
;;;270        out1 = __SMUSDX(R, C2) >> 16u;
;;;271        /* yc' = (xa-xb+xc-xd)* co2 + (ya-yb+yc-yd)* (si2) */
;;;272        out2 = __SMUAD(C2, R);
;;;273    
;;;274    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;275    
;;;276        /*  Reading i0+fftLen/4 */
;;;277        /* T = packed(yb, xb) */
;;;278        T = _SIMD32_OFFSET(pSi1);
00007e  f8d48000          LDR      r8,[r4,#0]
;;;279        T = __SHADD16(T, 0);
000082  fa98f821          SHADD16  r8,r8,r1
;;;280        T = __SHADD16(T, 0);
000086  fa98f821          SHADD16  r8,r8,r1
;;;281    
;;;282        /* writing the butterfly processed i0 + fftLen/4 sample */
;;;283        /* writing output(xc', yc') in little endian format */
;;;284        _SIMD32_OFFSET(pSi1) =
00008a  eace0a0a          PKHBT    r10,lr,r10
00008e  f8c4a000          STR      r10,[r4,#0]
;;;285          (q31_t) ((out2) & 0xFFFF0000) | (out1 & 0x0000FFFF);
;;;286        pSi1 += 2;
000092  1d24              ADDS     r4,r4,#4
;;;287    
;;;288        /*  Butterfly calculations */
;;;289        /* U = packed(yd, xd) */
;;;290        U = _SIMD32_OFFSET(pSi3);
000094  f8d6a000          LDR      r10,[r6,#0]
;;;291        U = __SHADD16(U, 0);
000098  fa9afa21          SHADD16  r10,r10,r1
;;;292        U = __SHADD16(U, 0);
00009c  fa9afa21          SHADD16  r10,r10,r1
;;;293    
;;;294        /* T = packed(yb-yd, xb-xd) */
;;;295        T = __QSUB16(T, U);
0000a0  fad8fa1a          QSUB16   r10,r8,r10
;;;296    
;;;297    #ifndef ARM_MATH_BIG_ENDIAN
;;;298    
;;;299        /* R = packed((ya-yc) + (xb- xd) , (xa-xc) - (yb-yd)) */
;;;300        R = __QASX(S, T);
0000a4  faa9f81a          QASX     r8,r9,r10
;;;301        /* S = packed((ya-yc) - (xb- xd),  (xa-xc) + (yb-yd)) */
;;;302        S = __QSAX(S, T);
0000a8  fae9f91a          QSAX     r9,r9,r10
;;;303    
;;;304    #else
;;;305    
;;;306        /* R = packed((ya-yc) + (xb- xd) , (xa-xc) - (yb-yd)) */
;;;307        R = __QSAX(S, T);
;;;308        /* S = packed((ya-yc) - (xb- xd),  (xa-xc) + (yb-yd)) */
;;;309        S = __QASX(S, T);
;;;310    
;;;311    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;312    
;;;313        /* co1 & si1 are read from SIMD Coefficient pointer */
;;;314        C1 = _SIMD32_OFFSET(pCoef16 + (2u * ic));
0000ac  eb020a85          ADD      r10,r2,r5,LSL #2
0000b0  f8daa000          LDR      r10,[r10,#0]
;;;315        /*  Butterfly process for the i0+fftLen/2 sample */
;;;316    
;;;317    #ifndef ARM_MATH_BIG_ENDIAN
;;;318    
;;;319        /* xb' = (xa+yb-xc-yd)* co1 + (ya-xb-yc+xd)* (si1) */
;;;320        out1 = __SMUAD(C1, S) >> 16u;
0000b4  fb2afe09          SMUAD    lr,r10,r9
0000b8  ea4f4e1e          LSR      lr,lr,#16
;;;321        /* yb' = (ya-xb-yc+xd)* co1 - (xa+yb-xc-yd)* (si1) */
;;;322        out2 = __SMUSDX(C1, S);
0000bc  fb4af919          SMUSDX   r9,r10,r9
;;;323    
;;;324    #else
;;;325    
;;;326        /* xb' = (ya-xb-yc+xd)* co1 - (xa+yb-xc-yd)* (si1) */
;;;327        out1 = __SMUSDX(S, C1) >> 16u;
;;;328        /* yb' = (xa+yb-xc-yd)* co1 + (ya-xb-yc+xd)* (si1) */
;;;329        out2 = __SMUAD(C1, S);
;;;330    
;;;331    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;332    
;;;333        /* writing output(xb', yb') in little endian format */
;;;334        _SIMD32_OFFSET(pSi2) =
0000c0  eace0909          PKHBT    r9,lr,r9
0000c4  f8cc9000          STR      r9,[r12,#0]
;;;335          ((out2) & 0xFFFF0000) | ((out1) & 0x0000FFFF);
;;;336        pSi2 += 2;
0000c8  f10c0c04          ADD      r12,r12,#4
;;;337    
;;;338    
;;;339        /* co3 & si3 are read from SIMD Coefficient pointer */
;;;340        C3 = _SIMD32_OFFSET(pCoef16 + (6u * ic));
0000cc  eb050945          ADD      r9,r5,r5,LSL #1
0000d0  eb020989          ADD      r9,r2,r9,LSL #2
0000d4  f8d99000          LDR      r9,[r9,#0]
;;;341        /*  Butterfly process for the i0+3fftLen/4 sample */
;;;342    
;;;343    #ifndef ARM_MATH_BIG_ENDIAN
;;;344    
;;;345        /* xd' = (xa-yb-xc+yd)* co3 + (ya+xb-yc-xd)* (si3) */
;;;346        out1 = __SMUAD(C3, R) >> 16u;
0000d8  fb29fa08          SMUAD    r10,r9,r8
0000dc  ea4f4a1a          LSR      r10,r10,#16
;;;347        /* yd' = (ya+xb-yc-xd)* co3 - (xa-yb-xc+yd)* (si3) */
;;;348        out2 = __SMUSDX(C3, R);
0000e0  fb49f818          SMUSDX   r8,r9,r8
;;;349    
;;;350    #else
;;;351    
;;;352        /* xd' = (ya+xb-yc-xd)* co3 - (xa-yb-xc+yd)* (si3) */
;;;353        out1 = __SMUSDX(R, C3) >> 16u;
;;;354        /* yd' = (xa-yb-xc+yd)* co3 + (ya+xb-yc-xd)* (si3) */
;;;355        out2 = __SMUAD(C3, R);
;;;356    
;;;357    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;358    
;;;359        /* writing output(xd', yd') in little endian format */
;;;360        _SIMD32_OFFSET(pSi3) =
0000e4  eaca0808          PKHBT    r8,r10,r8
0000e8  f8c68000          STR      r8,[r6,#0]
;;;361          ((out2) & 0xFFFF0000) | (out1 & 0x0000FFFF);
;;;362        pSi3 += 2;
0000ec  1d36              ADDS     r6,r6,#4
;;;363    
;;;364        /*  Twiddle coefficients index modifier */
;;;365        ic = ic + twidCoefModifier;
0000ee  441d              ADD      r5,r5,r3
;;;366    
;;;367      } while(--j);
0000f0  f1bb0b01          SUBS     r11,r11,#1
0000f4  d193              BNE      |L3.30|
;;;368      /* data is in 4.11(q11) format */
;;;369    
;;;370      /* end of first stage process */
;;;371    
;;;372    
;;;373      /* start of middle stage process */
;;;374    
;;;375      /*  Twiddle coefficients index modifier */
;;;376      twidCoefModifier <<= 2u;
0000f6  0099              LSLS     r1,r3,#2
0000f8  910a              STR      r1,[sp,#0x28]
;;;377    
;;;378      /*  Calculation of Middle stage */
;;;379      for (k = fftLen / 4u; k > 4u; k >>= 2u)
0000fa  9906              LDR      r1,[sp,#0x18]
0000fc  9100              STR      r1,[sp,#0]
0000fe  e08b              B        |L3.536|
                  |L3.256|
;;;380      {
;;;381        /*  Initializations for the middle stage */
;;;382        n1 = n2;
000100  4604              MOV      r4,r0
;;;383        n2 >>= 2u;
000102  0880              LSRS     r0,r0,#2
;;;384        ic = 0u;
000104  f04f0c00          MOV      r12,#0
;;;385    
;;;386        for (j = 0u; j <= (n2 - 1u); j++)
000108  2700              MOVS     r7,#0
00010a  1e41              SUBS     r1,r0,#1
00010c  9105              STR      r1,[sp,#0x14]
00010e  e07a              B        |L3.518|
                  |L3.272|
;;;387        {
;;;388          /*  index calculation for the coefficients */
;;;389          C1 = _SIMD32_OFFSET(pCoef16 + (2u * ic));
000110  eb02018c          ADD      r1,r2,r12,LSL #2
000114  6809              LDR      r1,[r1,#0]
000116  9103              STR      r1,[sp,#0xc]
;;;390          C2 = _SIMD32_OFFSET(pCoef16 + (4u * ic));
000118  eb0201cc          ADD      r1,r2,r12,LSL #3
00011c  6809              LDR      r1,[r1,#0]
00011e  9102              STR      r1,[sp,#8]
;;;391          C3 = _SIMD32_OFFSET(pCoef16 + (6u * ic));
000120  eb0c014c          ADD      r1,r12,r12,LSL #1
000124  eb020181          ADD      r1,r2,r1,LSL #2
000128  6809              LDR      r1,[r1,#0]
00012a  9101              STR      r1,[sp,#4]
;;;392    
;;;393          /*  Twiddle coefficients index modifier */
;;;394          ic = ic + twidCoefModifier;
00012c  990a              LDR      r1,[sp,#0x28]
00012e  448c              ADD      r12,r12,r1
;;;395          
;;;396          pSi0 = pSrc16 + 2 * j;
000130  9907              LDR      r1,[sp,#0x1c]
000132  eb010587          ADD      r5,r1,r7,LSL #2
;;;397          pSi1 = pSi0 + 2 * n2;
000136  eb050180          ADD      r1,r5,r0,LSL #2
;;;398          pSi2 = pSi1 + 2 * n2;
00013a  eb010680          ADD      r6,r1,r0,LSL #2
;;;399          pSi3 = pSi2 + 2 * n2;
00013e  eb060380          ADD      r3,r6,r0,LSL #2
;;;400    
;;;401          /*  Butterfly implementation */
;;;402          for (i0 = j; i0 < fftLen; i0 += n1)
000142  46b8              MOV      r8,r7
000144  e05a              B        |L3.508|
                  |L3.326|
;;;403          {
;;;404            /*  Reading i0, i0+fftLen/2 inputs */
;;;405            /* Read ya (real), xa(imag) input */
;;;406            T = _SIMD32_OFFSET(pSi0);
000146  f8d5b000          LDR      r11,[r5,#0]
;;;407    
;;;408            /* Read yc (real), xc(imag) input */
;;;409            S = _SIMD32_OFFSET(pSi2);
00014a  f8d6a000          LDR      r10,[r6,#0]
;;;410    
;;;411            /* R = packed( (ya + yc), (xa + xc)) */
;;;412            R = __QADD16(T, S);
00014e  fa9bf91a          QADD16   r9,r11,r10
;;;413    
;;;414            /* S = packed((ya - yc), (xa - xc)) */
;;;415            S = __QSUB16(T, S);
000152  fadbfb1a          QSUB16   r11,r11,r10
000156  f8cdb010          STR      r11,[sp,#0x10]
;;;416    
;;;417            /*  Reading i0+fftLen/4 , i0+3fftLen/4 inputs */
;;;418            /* Read yb (real), xb(imag) input */
;;;419            T = _SIMD32_OFFSET(pSi1);
00015a  f8d1a000          LDR      r10,[r1,#0]
;;;420    
;;;421            /* Read yd (real), xd(imag) input */
;;;422            U = _SIMD32_OFFSET(pSi3);
00015e  f8d3b000          LDR      r11,[r3,#0]
;;;423    
;;;424            /* T = packed( (yb + yd), (xb + xd)) */
;;;425            T = __QADD16(T, U);
000162  fa9afa1b          QADD16   r10,r10,r11
;;;426    
;;;427            /*  writing the butterfly processed i0 sample */
;;;428    
;;;429            /* xa' = xa + xb + xc + xd */
;;;430            /* ya' = ya + yb + yc + yd */
;;;431            out1 = __SHADD16(R, T);
000166  fa99fb2a          SHADD16  r11,r9,r10
;;;432            out1 = __SHADD16(out1, 0);
00016a  f04f0e00          MOV      lr,#0
00016e  fa9bfb2e          SHADD16  r11,r11,lr
;;;433            _SIMD32_OFFSET(pSi0) = out1;
000172  f8c5b000          STR      r11,[r5,#0]
;;;434            pSi0 += 2 * n1;
000176  eb050584          ADD      r5,r5,r4,LSL #2
;;;435    
;;;436            /* R = packed( (ya + yc) - (yb + yd), (xa + xc) - (xb + xd)) */
;;;437            R = __SHSUB16(R, T);
00017a  fad9f92a          SHSUB16  r9,r9,r10
;;;438    
;;;439    #ifndef ARM_MATH_BIG_ENDIAN
;;;440    
;;;441            /* (ya-yb+yc-yd)* (si2) + (xa-xb+xc-xd)* co2 */
;;;442            out1 = __SMUAD(C2, R) >> 16u;
00017e  f8dda008          LDR      r10,[sp,#8]
000182  fb2afa09          SMUAD    r10,r10,r9
000186  ea4f4a1a          LSR      r10,r10,#16
;;;443    
;;;444            /* (ya-yb+yc-yd)* co2 - (xa-xb+xc-xd)* (si2) */
;;;445            out2 = __SMUSDX(C2, R);
00018a  f8ddb008          LDR      r11,[sp,#8]
00018e  fb4bfb19          SMUSDX   r11,r11,r9
;;;446    
;;;447    #else
;;;448    
;;;449            /* (ya-yb+yc-yd)* co2 - (xa-xb+xc-xd)* (si2) */
;;;450            out1 = __SMUSDX(R, C2) >> 16u;
;;;451    
;;;452            /* (ya-yb+yc-yd)* (si2) + (xa-xb+xc-xd)* co2 */
;;;453            out2 = __SMUAD(C2, R);
;;;454    
;;;455    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;456    
;;;457            /*  Reading i0+3fftLen/4 */
;;;458            /* Read yb (real), xb(imag) input */
;;;459            T = _SIMD32_OFFSET(pSi1);
000192  f8d19000          LDR      r9,[r1,#0]
;;;460    
;;;461            /*  writing the butterfly processed i0 + fftLen/4 sample */
;;;462            /* xc' = (xa-xb+xc-xd)* co2 + (ya-yb+yc-yd)* (si2) */
;;;463            /* yc' = (ya-yb+yc-yd)* co2 - (xa-xb+xc-xd)* (si2) */
;;;464            _SIMD32_OFFSET(pSi1) =
000196  eaca0a0b          PKHBT    r10,r10,r11
00019a  f8c1a000          STR      r10,[r1,#0]
;;;465              ((out2) & 0xFFFF0000) | (out1 & 0x0000FFFF);
;;;466            pSi1 += 2 * n1;
00019e  eb010184          ADD      r1,r1,r4,LSL #2
;;;467    
;;;468            /*  Butterfly calculations */
;;;469    
;;;470            /* Read yd (real), xd(imag) input */
;;;471            U = _SIMD32_OFFSET(pSi3);
0001a2  f8d3a000          LDR      r10,[r3,#0]
;;;472    
;;;473            /* T = packed(yb-yd, xb-xd) */
;;;474            T = __QSUB16(T, U);
0001a6  fad9fa1a          QSUB16   r10,r9,r10
;;;475    
;;;476    #ifndef ARM_MATH_BIG_ENDIAN
;;;477    
;;;478            /* R = packed((ya-yc) + (xb- xd) , (xa-xc) - (yb-yd)) */
;;;479            R = __SHASX(S, T);
0001aa  f8ddb010          LDR      r11,[sp,#0x10]
0001ae  faabf92a          SHASX    r9,r11,r10
;;;480    
;;;481            /* S = packed((ya-yc) - (xb- xd),  (xa-xc) + (yb-yd)) */
;;;482            S = __SHSAX(S, T);
0001b2  f8ddb010          LDR      r11,[sp,#0x10]
0001b6  faebfa2a          SHSAX    r10,r11,r10
;;;483    
;;;484    
;;;485            /*  Butterfly process for the i0+fftLen/2 sample */
;;;486            out1 = __SMUAD(C1, S) >> 16u;
0001ba  f8ddb00c          LDR      r11,[sp,#0xc]
0001be  fb2bfb0a          SMUAD    r11,r11,r10
0001c2  ea4f4b1b          LSR      r11,r11,#16
;;;487            out2 = __SMUSDX(C1, S);
0001c6  f8dde00c          LDR      lr,[sp,#0xc]
0001ca  fb4efa1a          SMUSDX   r10,lr,r10
;;;488    
;;;489    #else
;;;490    
;;;491            /* R = packed((ya-yc) + (xb- xd) , (xa-xc) - (yb-yd)) */
;;;492            R = __SHSAX(S, T);
;;;493    
;;;494            /* S = packed((ya-yc) - (xb- xd),  (xa-xc) + (yb-yd)) */
;;;495            S = __SHASX(S, T);
;;;496    
;;;497    
;;;498            /*  Butterfly process for the i0+fftLen/2 sample */
;;;499            out1 = __SMUSDX(S, C1) >> 16u;
;;;500            out2 = __SMUAD(C1, S);
;;;501    
;;;502    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;503    
;;;504            /* xb' = (xa+yb-xc-yd)* co1 + (ya-xb-yc+xd)* (si1) */
;;;505            /* yb' = (ya-xb-yc+xd)* co1 - (xa+yb-xc-yd)* (si1) */
;;;506            _SIMD32_OFFSET(pSi2) =
0001ce  eacb0a0a          PKHBT    r10,r11,r10
0001d2  f8c6a000          STR      r10,[r6,#0]
;;;507              ((out2) & 0xFFFF0000) | (out1 & 0x0000FFFF);
;;;508            pSi2 += 2 * n1;
0001d6  eb060684          ADD      r6,r6,r4,LSL #2
;;;509    
;;;510            /*  Butterfly process for the i0+3fftLen/4 sample */
;;;511    
;;;512    #ifndef ARM_MATH_BIG_ENDIAN
;;;513    
;;;514            out1 = __SMUAD(C3, R) >> 16u;
0001da  f8dda004          LDR      r10,[sp,#4]
0001de  fb2afa09          SMUAD    r10,r10,r9
0001e2  ea4f4a1a          LSR      r10,r10,#16
;;;515            out2 = __SMUSDX(C3, R);
0001e6  f8ddb004          LDR      r11,[sp,#4]
0001ea  fb4bf919          SMUSDX   r9,r11,r9
;;;516    
;;;517    #else
;;;518    
;;;519            out1 = __SMUSDX(R, C3) >> 16u;
;;;520            out2 = __SMUAD(C3, R);
;;;521    
;;;522    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;523    
;;;524            /* xd' = (xa-yb-xc+yd)* co3 + (ya+xb-yc-xd)* (si3) */
;;;525            /* yd' = (ya+xb-yc-xd)* co3 - (xa-yb-xc+yd)* (si3) */
;;;526            _SIMD32_OFFSET(pSi3) =
0001ee  eaca0909          PKHBT    r9,r10,r9
0001f2  f8c39000          STR      r9,[r3,#0]
;;;527              ((out2) & 0xFFFF0000) | (out1 & 0x0000FFFF);
;;;528            pSi3 += 2 * n1;
0001f6  eb030384          ADD      r3,r3,r4,LSL #2
0001fa  44a0              ADD      r8,r8,r4              ;402
                  |L3.508|
0001fc  f8dd9020          LDR      r9,[sp,#0x20]         ;402
000200  45c8              CMP      r8,r9                 ;402
000202  d3a0              BCC      |L3.326|
000204  1c7f              ADDS     r7,r7,#1              ;386
                  |L3.518|
000206  9905              LDR      r1,[sp,#0x14]         ;386
000208  428f              CMP      r7,r1                 ;386
00020a  d981              BLS      |L3.272|
;;;529          }
;;;530        }
;;;531        /*  Twiddle coefficients index modifier */
;;;532        twidCoefModifier <<= 2u;
00020c  990a              LDR      r1,[sp,#0x28]
00020e  0089              LSLS     r1,r1,#2
000210  910a              STR      r1,[sp,#0x28]
000212  9900              LDR      r1,[sp,#0]            ;379
000214  0889              LSRS     r1,r1,#2              ;379
000216  9100              STR      r1,[sp,#0]            ;379
                  |L3.536|
000218  9900              LDR      r1,[sp,#0]            ;379
00021a  2904              CMP      r1,#4                 ;379
00021c  f63faf70          BHI      |L3.256|
;;;533      }
;;;534      /* end of middle stage process */
;;;535    
;;;536    
;;;537      /* data is in 10.6(q6) format for the 1024 point */
;;;538      /* data is in 8.8(q8) format for the 256 point */
;;;539      /* data is in 6.10(q10) format for the 64 point */
;;;540      /* data is in 4.12(q12) format for the 16 point */
;;;541    
;;;542      /*  Initializations for the last stage */
;;;543      j = fftLen >> 2;
000220  9e06              LDR      r6,[sp,#0x18]
;;;544    
;;;545      ptr1 = &pSrc16[0];
000222  9a07              LDR      r2,[sp,#0x1c]
                  |L3.548|
;;;546    
;;;547      /* start of last stage process */
;;;548    
;;;549      /*  Butterfly implementation */
;;;550      do
;;;551      {
;;;552        /* Read xa (real), ya(imag) input */
;;;553        xaya = *__SIMD32(ptr1)++;
000224  6813              LDR      r3,[r2,#0]
;;;554    
;;;555        /* Read xb (real), yb(imag) input */
;;;556        xbyb = *__SIMD32(ptr1)++;
000226  6850              LDR      r0,[r2,#4]
;;;557    
;;;558        /* Read xc (real), yc(imag) input */
;;;559        xcyc = *__SIMD32(ptr1)++;
000228  6894              LDR      r4,[r2,#8]
;;;560    
;;;561        /* Read xd (real), yd(imag) input */
;;;562        xdyd = *__SIMD32(ptr1)++;
00022a  68d1              LDR      r1,[r2,#0xc]
;;;563    
;;;564        /* R = packed((ya + yc), (xa + xc)) */
;;;565        R = __QADD16(xaya, xcyc);
00022c  fa93f514          QADD16   r5,r3,r4
;;;566    
;;;567        /* T = packed((yb + yd), (xb + xd)) */
;;;568        T = __QADD16(xbyb, xdyd);
000230  fa90f711          QADD16   r7,r0,r1
;;;569    
;;;570        /* pointer updation for writing */
;;;571        ptr1 = ptr1 - 8u;
;;;572    
;;;573    
;;;574        /* xa' = xa + xb + xc + xd */
;;;575        /* ya' = ya + yb + yc + yd */
;;;576        *__SIMD32(ptr1)++ = __SHADD16(R, T);
000234  fa95f727          SHADD16  r7,r5,r7
000238  6017              STR      r7,[r2,#0]
;;;577    
;;;578        /* T = packed((yb + yd), (xb + xd)) */
;;;579        T = __QADD16(xbyb, xdyd);
00023a  fa90f711          QADD16   r7,r0,r1
;;;580    
;;;581        /* xc' = (xa-xb+xc-xd) */
;;;582        /* yc' = (ya-yb+yc-yd) */
;;;583        *__SIMD32(ptr1)++ = __SHSUB16(R, T);
00023e  fad5f527          SHSUB16  r5,r5,r7
000242  6055              STR      r5,[r2,#4]
;;;584    
;;;585        /* S = packed((ya - yc), (xa - xc)) */
;;;586        S = __QSUB16(xaya, xcyc);
000244  fad3f314          QSUB16   r3,r3,r4
;;;587    
;;;588        /* Read yd (real), xd(imag) input */
;;;589        /* T = packed( (yb - yd), (xb - xd))  */
;;;590        U = __QSUB16(xbyb, xdyd);
000248  fad0f011          QSUB16   r0,r0,r1
;;;591    
;;;592    #ifndef ARM_MATH_BIG_ENDIAN
;;;593    
;;;594        /* xb' = (xa+yb-xc-yd) */
;;;595        /* yb' = (ya-xb-yc+xd) */
;;;596        *__SIMD32(ptr1)++ = __SHSAX(S, U);
00024c  fae3f120          SHSAX    r1,r3,r0
000250  6091              STR      r1,[r2,#8]
;;;597    
;;;598    
;;;599        /* xd' = (xa-yb-xc+yd) */
;;;600        /* yd' = (ya+xb-yc-xd) */
;;;601        *__SIMD32(ptr1)++ = __SHASX(S, U);
000252  faa3f020          SHASX    r0,r3,r0
000256  60d0              STR      r0,[r2,#0xc]
000258  3210              ADDS     r2,r2,#0x10
;;;602    
;;;603    #else
;;;604    
;;;605        /* xb' = (xa+yb-xc-yd) */
;;;606        /* yb' = (ya-xb-yc+xd) */
;;;607        *__SIMD32(ptr1)++ = __SHASX(S, U);
;;;608    
;;;609    
;;;610        /* xd' = (xa-yb-xc+yd) */
;;;611        /* yd' = (ya+xb-yc-xd) */
;;;612        *__SIMD32(ptr1)++ = __SHSAX(S, U);
;;;613    
;;;614    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;615    
;;;616      } while(--j);
00025a  1e76              SUBS     r6,r6,#1
00025c  d1e2              BNE      |L3.548|
;;;617    
;;;618      /* end of last stage process */
;;;619    
;;;620      /* output is in 11.5(q5) format for the 1024 point */
;;;621      /* output is in 9.7(q7) format for the 256 point   */
;;;622      /* output is in 7.9(q9) format for the 64 point  */
;;;623      /* output is in 5.11(q11) format for the 16 point  */
;;;624    
;;;625    
;;;626    #else
;;;627    
;;;628      /* Run the below code for Cortex-M0 */
;;;629    
;;;630      q15_t R0, R1, S0, S1, T0, T1, U0, U1;
;;;631      q15_t Co1, Si1, Co2, Si2, Co3, Si3, out1, out2;
;;;632      uint32_t n1, n2, ic, i0, i1, i2, i3, j, k;
;;;633    
;;;634      /* Total process is divided into three stages */
;;;635    
;;;636      /* process first stage, middle stages, & last stage */
;;;637    
;;;638      /*  Initializations for the first stage */
;;;639      n2 = fftLen;
;;;640      n1 = n2;
;;;641    
;;;642      /* n2 = fftLen/4 */
;;;643      n2 >>= 2u;
;;;644    
;;;645      /* Index for twiddle coefficient */
;;;646      ic = 0u;
;;;647    
;;;648      /* Index for input read and output write */
;;;649      i0 = 0u;
;;;650      j = n2;
;;;651    
;;;652      /* Input is in 1.15(q15) format */
;;;653    
;;;654      /*  start of first stage process */
;;;655      do
;;;656      {
;;;657        /*  Butterfly implementation */
;;;658    
;;;659        /*  index calculation for the input as, */
;;;660        /*  pSrc16[i0 + 0], pSrc16[i0 + fftLen/4], pSrc16[i0 + fftLen/2], pSrc16[i0 + 3fftLen/4] */
;;;661        i1 = i0 + n2;
;;;662        i2 = i1 + n2;
;;;663        i3 = i2 + n2;
;;;664    
;;;665        /*  Reading i0, i0+fftLen/2 inputs */
;;;666    
;;;667        /* input is down scale by 4 to avoid overflow */
;;;668        /* Read ya (real), xa(imag) input */
;;;669        T0 = pSrc16[i0 * 2u] >> 2u;
;;;670        T1 = pSrc16[(i0 * 2u) + 1u] >> 2u;
;;;671    
;;;672        /* input is down scale by 4 to avoid overflow */
;;;673        /* Read yc (real), xc(imag) input */
;;;674        S0 = pSrc16[i2 * 2u] >> 2u;
;;;675        S1 = pSrc16[(i2 * 2u) + 1u] >> 2u;
;;;676    
;;;677        /* R0 = (ya + yc) */
;;;678        R0 = __SSAT(T0 + S0, 16u);
;;;679        /* R1 = (xa + xc) */
;;;680        R1 = __SSAT(T1 + S1, 16u);
;;;681    
;;;682        /* S0 = (ya - yc) */
;;;683        S0 = __SSAT(T0 - S0, 16);
;;;684        /* S1 = (xa - xc) */
;;;685        S1 = __SSAT(T1 - S1, 16);
;;;686    
;;;687        /*  Reading i0+fftLen/4 , i0+3fftLen/4 inputs */
;;;688        /* input is down scale by 4 to avoid overflow */
;;;689        /* Read yb (real), xb(imag) input */
;;;690        T0 = pSrc16[i1 * 2u] >> 2u;
;;;691        T1 = pSrc16[(i1 * 2u) + 1u] >> 2u;
;;;692    
;;;693        /* input is down scale by 4 to avoid overflow */
;;;694        /* Read yd (real), xd(imag) input */
;;;695        U0 = pSrc16[i3 * 2u] >> 2u;
;;;696        U1 = pSrc16[(i3 * 2u) + 1] >> 2u;
;;;697    
;;;698        /* T0 = (yb + yd) */
;;;699        T0 = __SSAT(T0 + U0, 16u);
;;;700        /* T1 = (xb + xd) */
;;;701        T1 = __SSAT(T1 + U1, 16u);
;;;702    
;;;703        /*  writing the butterfly processed i0 sample */
;;;704        /* ya' = ya + yb + yc + yd */
;;;705        /* xa' = xa + xb + xc + xd */
;;;706        pSrc16[i0 * 2u] = (R0 >> 1u) + (T0 >> 1u);
;;;707        pSrc16[(i0 * 2u) + 1u] = (R1 >> 1u) + (T1 >> 1u);
;;;708    
;;;709        /* R0 = (ya + yc) - (yb + yd) */
;;;710        /* R1 = (xa + xc) - (xb + xd) */
;;;711        R0 = __SSAT(R0 - T0, 16u);
;;;712        R1 = __SSAT(R1 - T1, 16u);
;;;713    
;;;714        /* co2 & si2 are read from Coefficient pointer */
;;;715        Co2 = pCoef16[2u * ic * 2u];
;;;716        Si2 = pCoef16[(2u * ic * 2u) + 1];
;;;717    
;;;718        /* xc' = (xa-xb+xc-xd)* co2 + (ya-yb+yc-yd)* (si2) */
;;;719        out1 = (q15_t) ((Co2 * R0 + Si2 * R1) >> 16u);
;;;720        /* yc' = (ya-yb+yc-yd)* co2 - (xa-xb+xc-xd)* (si2) */
;;;721        out2 = (q15_t) ((-Si2 * R0 + Co2 * R1) >> 16u);
;;;722    
;;;723        /*  Reading i0+fftLen/4 */
;;;724        /* input is down scale by 4 to avoid overflow */
;;;725        /* T0 = yb, T1 =  xb */
;;;726        T0 = pSrc16[i1 * 2u] >> 2;
;;;727        T1 = pSrc16[(i1 * 2u) + 1] >> 2;
;;;728    
;;;729        /* writing the butterfly processed i0 + fftLen/4 sample */
;;;730        /* writing output(xc', yc') in little endian format */
;;;731        pSrc16[i1 * 2u] = out1;
;;;732        pSrc16[(i1 * 2u) + 1] = out2;
;;;733    
;;;734        /*  Butterfly calculations */
;;;735        /* input is down scale by 4 to avoid overflow */
;;;736        /* U0 = yd, U1 = xd */
;;;737        U0 = pSrc16[i3 * 2u] >> 2;
;;;738        U1 = pSrc16[(i3 * 2u) + 1] >> 2;
;;;739        /* T0 = yb-yd */
;;;740        T0 = __SSAT(T0 - U0, 16);
;;;741        /* T1 = xb-xd */
;;;742        T1 = __SSAT(T1 - U1, 16);
;;;743    
;;;744        /* R1 = (ya-yc) + (xb- xd),  R0 = (xa-xc) - (yb-yd)) */
;;;745        R0 = (q15_t) __SSAT((q31_t) (S0 - T1), 16);
;;;746        R1 = (q15_t) __SSAT((q31_t) (S1 + T0), 16);
;;;747    
;;;748        /* S1 = (ya-yc) - (xb- xd), S0 = (xa-xc) + (yb-yd)) */
;;;749        S0 = (q15_t) __SSAT(((q31_t) S0 + T1), 16u);
;;;750        S1 = (q15_t) __SSAT(((q31_t) S1 - T0), 16u);
;;;751    
;;;752        /* co1 & si1 are read from Coefficient pointer */
;;;753        Co1 = pCoef16[ic * 2u];
;;;754        Si1 = pCoef16[(ic * 2u) + 1];
;;;755        /*  Butterfly process for the i0+fftLen/2 sample */
;;;756        /* xb' = (xa+yb-xc-yd)* co1 + (ya-xb-yc+xd)* (si1) */
;;;757        out1 = (q15_t) ((Si1 * S1 + Co1 * S0) >> 16);
;;;758        /* yb' = (ya-xb-yc+xd)* co1 - (xa+yb-xc-yd)* (si1) */
;;;759        out2 = (q15_t) ((-Si1 * S0 + Co1 * S1) >> 16);
;;;760    
;;;761        /* writing output(xb', yb') in little endian format */
;;;762        pSrc16[i2 * 2u] = out1;
;;;763        pSrc16[(i2 * 2u) + 1] = out2;
;;;764    
;;;765        /* Co3 & si3 are read from Coefficient pointer */
;;;766        Co3 = pCoef16[3u * (ic * 2u)];
;;;767        Si3 = pCoef16[(3u * (ic * 2u)) + 1];
;;;768        /*  Butterfly process for the i0+3fftLen/4 sample */
;;;769        /* xd' = (xa-yb-xc+yd)* Co3 + (ya+xb-yc-xd)* (si3) */
;;;770        out1 = (q15_t) ((Si3 * R1 + Co3 * R0) >> 16u);
;;;771        /* yd' = (ya+xb-yc-xd)* Co3 - (xa-yb-xc+yd)* (si3) */
;;;772        out2 = (q15_t) ((-Si3 * R0 + Co3 * R1) >> 16u);
;;;773        /* writing output(xd', yd') in little endian format */
;;;774        pSrc16[i3 * 2u] = out1;
;;;775        pSrc16[(i3 * 2u) + 1] = out2;
;;;776    
;;;777        /*  Twiddle coefficients index modifier */
;;;778        ic = ic + twidCoefModifier;
;;;779    
;;;780        /*  Updating input index */
;;;781        i0 = i0 + 1u;
;;;782    
;;;783      } while(--j);
;;;784      /* data is in 4.11(q11) format */
;;;785    
;;;786      /* end of first stage process */
;;;787    
;;;788    
;;;789      /* start of middle stage process */
;;;790    
;;;791      /*  Twiddle coefficients index modifier */
;;;792      twidCoefModifier <<= 2u;
;;;793    
;;;794      /*  Calculation of Middle stage */
;;;795      for (k = fftLen / 4u; k > 4u; k >>= 2u)
;;;796      {
;;;797        /*  Initializations for the middle stage */
;;;798        n1 = n2;
;;;799        n2 >>= 2u;
;;;800        ic = 0u;
;;;801    
;;;802        for (j = 0u; j <= (n2 - 1u); j++)
;;;803        {
;;;804          /*  index calculation for the coefficients */
;;;805          Co1 = pCoef16[ic * 2u];
;;;806          Si1 = pCoef16[(ic * 2u) + 1u];
;;;807          Co2 = pCoef16[2u * (ic * 2u)];
;;;808          Si2 = pCoef16[(2u * (ic * 2u)) + 1u];
;;;809          Co3 = pCoef16[3u * (ic * 2u)];
;;;810          Si3 = pCoef16[(3u * (ic * 2u)) + 1u];
;;;811    
;;;812          /*  Twiddle coefficients index modifier */
;;;813          ic = ic + twidCoefModifier;
;;;814    
;;;815          /*  Butterfly implementation */
;;;816          for (i0 = j; i0 < fftLen; i0 += n1)
;;;817          {
;;;818            /*  index calculation for the input as, */
;;;819            /*  pSrc16[i0 + 0], pSrc16[i0 + fftLen/4], pSrc16[i0 + fftLen/2], pSrc16[i0 + 3fftLen/4] */
;;;820            i1 = i0 + n2;
;;;821            i2 = i1 + n2;
;;;822            i3 = i2 + n2;
;;;823    
;;;824            /*  Reading i0, i0+fftLen/2 inputs */
;;;825            /* Read ya (real), xa(imag) input */
;;;826            T0 = pSrc16[i0 * 2u];
;;;827            T1 = pSrc16[(i0 * 2u) + 1u];
;;;828    
;;;829            /* Read yc (real), xc(imag) input */
;;;830            S0 = pSrc16[i2 * 2u];
;;;831            S1 = pSrc16[(i2 * 2u) + 1u];
;;;832    
;;;833            /* R0 = (ya + yc), R1 = (xa + xc) */
;;;834            R0 = __SSAT(T0 + S0, 16);
;;;835            R1 = __SSAT(T1 + S1, 16);
;;;836    
;;;837            /* S0 = (ya - yc), S1 =(xa - xc) */
;;;838            S0 = __SSAT(T0 - S0, 16);
;;;839            S1 = __SSAT(T1 - S1, 16);
;;;840    
;;;841            /*  Reading i0+fftLen/4 , i0+3fftLen/4 inputs */
;;;842            /* Read yb (real), xb(imag) input */
;;;843            T0 = pSrc16[i1 * 2u];
;;;844            T1 = pSrc16[(i1 * 2u) + 1u];
;;;845    
;;;846            /* Read yd (real), xd(imag) input */
;;;847            U0 = pSrc16[i3 * 2u];
;;;848            U1 = pSrc16[(i3 * 2u) + 1u];
;;;849    
;;;850    
;;;851            /* T0 = (yb + yd), T1 = (xb + xd) */
;;;852            T0 = __SSAT(T0 + U0, 16);
;;;853            T1 = __SSAT(T1 + U1, 16);
;;;854    
;;;855            /*  writing the butterfly processed i0 sample */
;;;856    
;;;857            /* xa' = xa + xb + xc + xd */
;;;858            /* ya' = ya + yb + yc + yd */
;;;859            out1 = ((R0 >> 1u) + (T0 >> 1u)) >> 1u;
;;;860            out2 = ((R1 >> 1u) + (T1 >> 1u)) >> 1u;
;;;861    
;;;862            pSrc16[i0 * 2u] = out1;
;;;863            pSrc16[(2u * i0) + 1u] = out2;
;;;864    
;;;865            /* R0 = (ya + yc) - (yb + yd), R1 = (xa + xc) - (xb + xd) */
;;;866            R0 = (R0 >> 1u) - (T0 >> 1u);
;;;867            R1 = (R1 >> 1u) - (T1 >> 1u);
;;;868    
;;;869            /* (ya-yb+yc-yd)* (si2) + (xa-xb+xc-xd)* co2 */
;;;870            out1 = (q15_t) ((Co2 * R0 + Si2 * R1) >> 16u);
;;;871    
;;;872            /* (ya-yb+yc-yd)* co2 - (xa-xb+xc-xd)* (si2) */
;;;873            out2 = (q15_t) ((-Si2 * R0 + Co2 * R1) >> 16u);
;;;874    
;;;875            /*  Reading i0+3fftLen/4 */
;;;876            /* Read yb (real), xb(imag) input */
;;;877            T0 = pSrc16[i1 * 2u];
;;;878            T1 = pSrc16[(i1 * 2u) + 1u];
;;;879    
;;;880            /*  writing the butterfly processed i0 + fftLen/4 sample */
;;;881            /* xc' = (xa-xb+xc-xd)* co2 + (ya-yb+yc-yd)* (si2) */
;;;882            /* yc' = (ya-yb+yc-yd)* co2 - (xa-xb+xc-xd)* (si2) */
;;;883            pSrc16[i1 * 2u] = out1;
;;;884            pSrc16[(i1 * 2u) + 1u] = out2;
;;;885    
;;;886            /*  Butterfly calculations */
;;;887    
;;;888            /* Read yd (real), xd(imag) input */
;;;889            U0 = pSrc16[i3 * 2u];
;;;890            U1 = pSrc16[(i3 * 2u) + 1u];
;;;891    
;;;892            /* T0 = yb-yd, T1 = xb-xd */
;;;893            T0 = __SSAT(T0 - U0, 16);
;;;894            T1 = __SSAT(T1 - U1, 16);
;;;895    
;;;896            /* R0 = (ya-yc) + (xb- xd), R1 = (xa-xc) - (yb-yd)) */
;;;897            R0 = (S0 >> 1u) - (T1 >> 1u);
;;;898            R1 = (S1 >> 1u) + (T0 >> 1u);
;;;899    
;;;900            /* S0 = (ya-yc) - (xb- xd), S1 = (xa-xc) + (yb-yd)) */
;;;901            S0 = (S0 >> 1u) + (T1 >> 1u);
;;;902            S1 = (S1 >> 1u) - (T0 >> 1u);
;;;903    
;;;904            /*  Butterfly process for the i0+fftLen/2 sample */
;;;905            out1 = (q15_t) ((Co1 * S0 + Si1 * S1) >> 16u);
;;;906    
;;;907            out2 = (q15_t) ((-Si1 * S0 + Co1 * S1) >> 16u);
;;;908    
;;;909            /* xb' = (xa+yb-xc-yd)* co1 + (ya-xb-yc+xd)* (si1) */
;;;910            /* yb' = (ya-xb-yc+xd)* co1 - (xa+yb-xc-yd)* (si1) */
;;;911            pSrc16[i2 * 2u] = out1;
;;;912            pSrc16[(i2 * 2u) + 1u] = out2;
;;;913    
;;;914            /*  Butterfly process for the i0+3fftLen/4 sample */
;;;915            out1 = (q15_t) ((Si3 * R1 + Co3 * R0) >> 16u);
;;;916    
;;;917            out2 = (q15_t) ((-Si3 * R0 + Co3 * R1) >> 16u);
;;;918            /* xd' = (xa-yb-xc+yd)* Co3 + (ya+xb-yc-xd)* (si3) */
;;;919            /* yd' = (ya+xb-yc-xd)* Co3 - (xa-yb-xc+yd)* (si3) */
;;;920            pSrc16[i3 * 2u] = out1;
;;;921            pSrc16[(i3 * 2u) + 1u] = out2;
;;;922          }
;;;923        }
;;;924        /*  Twiddle coefficients index modifier */
;;;925        twidCoefModifier <<= 2u;
;;;926      }
;;;927      /* end of middle stage process */
;;;928    
;;;929    
;;;930      /* data is in 10.6(q6) format for the 1024 point */
;;;931      /* data is in 8.8(q8) format for the 256 point */
;;;932      /* data is in 6.10(q10) format for the 64 point */
;;;933      /* data is in 4.12(q12) format for the 16 point */
;;;934    
;;;935      /*  Initializations for the last stage */
;;;936      n1 = n2;
;;;937      n2 >>= 2u;
;;;938    
;;;939      /* start of last stage process */
;;;940    
;;;941      /*  Butterfly implementation */
;;;942      for (i0 = 0u; i0 <= (fftLen - n1); i0 += n1)
;;;943      {
;;;944        /*  index calculation for the input as, */
;;;945        /*  pSrc16[i0 + 0], pSrc16[i0 + fftLen/4], pSrc16[i0 + fftLen/2], pSrc16[i0 + 3fftLen/4] */
;;;946        i1 = i0 + n2;
;;;947        i2 = i1 + n2;
;;;948        i3 = i2 + n2;
;;;949    
;;;950        /*  Reading i0, i0+fftLen/2 inputs */
;;;951        /* Read ya (real), xa(imag) input */
;;;952        T0 = pSrc16[i0 * 2u];
;;;953        T1 = pSrc16[(i0 * 2u) + 1u];
;;;954    
;;;955        /* Read yc (real), xc(imag) input */
;;;956        S0 = pSrc16[i2 * 2u];
;;;957        S1 = pSrc16[(i2 * 2u) + 1u];
;;;958    
;;;959        /* R0 = (ya + yc), R1 = (xa + xc) */
;;;960        R0 = __SSAT(T0 + S0, 16u);
;;;961        R1 = __SSAT(T1 + S1, 16u);
;;;962    
;;;963        /* S0 = (ya - yc), S1 = (xa - xc) */
;;;964        S0 = __SSAT(T0 - S0, 16u);
;;;965        S1 = __SSAT(T1 - S1, 16u);
;;;966    
;;;967        /*  Reading i0+fftLen/4 , i0+3fftLen/4 inputs */
;;;968        /* Read yb (real), xb(imag) input */
;;;969        T0 = pSrc16[i1 * 2u];
;;;970        T1 = pSrc16[(i1 * 2u) + 1u];
;;;971        /* Read yd (real), xd(imag) input */
;;;972        U0 = pSrc16[i3 * 2u];
;;;973        U1 = pSrc16[(i3 * 2u) + 1u];
;;;974    
;;;975        /* T0 = (yb + yd), T1 = (xb + xd)) */
;;;976        T0 = __SSAT(T0 + U0, 16u);
;;;977        T1 = __SSAT(T1 + U1, 16u);
;;;978    
;;;979        /*  writing the butterfly processed i0 sample */
;;;980        /* xa' = xa + xb + xc + xd */
;;;981        /* ya' = ya + yb + yc + yd */
;;;982        pSrc16[i0 * 2u] = (R0 >> 1u) + (T0 >> 1u);
;;;983        pSrc16[(i0 * 2u) + 1u] = (R1 >> 1u) + (T1 >> 1u);
;;;984    
;;;985        /* R0 = (ya + yc) - (yb + yd), R1 = (xa + xc) - (xb + xd) */
;;;986        R0 = (R0 >> 1u) - (T0 >> 1u);
;;;987        R1 = (R1 >> 1u) - (T1 >> 1u);
;;;988        /* Read yb (real), xb(imag) input */
;;;989        T0 = pSrc16[i1 * 2u];
;;;990        T1 = pSrc16[(i1 * 2u) + 1u];
;;;991    
;;;992        /*  writing the butterfly processed i0 + fftLen/4 sample */
;;;993        /* xc' = (xa-xb+xc-xd) */
;;;994        /* yc' = (ya-yb+yc-yd) */
;;;995        pSrc16[i1 * 2u] = R0;
;;;996        pSrc16[(i1 * 2u) + 1u] = R1;
;;;997    
;;;998        /* Read yd (real), xd(imag) input */
;;;999        U0 = pSrc16[i3 * 2u];
;;;1000       U1 = pSrc16[(i3 * 2u) + 1u];
;;;1001       /* T0 = (yb - yd), T1 = (xb - xd)  */
;;;1002       T0 = __SSAT(T0 - U0, 16u);
;;;1003       T1 = __SSAT(T1 - U1, 16u);
;;;1004   
;;;1005       /*  writing the butterfly processed i0 + fftLen/2 sample */
;;;1006       /* xb' = (xa+yb-xc-yd) */
;;;1007       /* yb' = (ya-xb-yc+xd) */
;;;1008       pSrc16[i2 * 2u] = (S0 >> 1u) + (T1 >> 1u);
;;;1009       pSrc16[(i2 * 2u) + 1u] = (S1 >> 1u) - (T0 >> 1u);
;;;1010   
;;;1011       /*  writing the butterfly processed i0 + 3fftLen/4 sample */
;;;1012       /* xd' = (xa-yb-xc+yd) */
;;;1013       /* yd' = (ya+xb-yc-xd) */
;;;1014       pSrc16[i3 * 2u] = (S0 >> 1u) - (T1 >> 1u);
;;;1015       pSrc16[(i3 * 2u) + 1u] = (S1 >> 1u) + (T0 >> 1u);
;;;1016   
;;;1017     }
;;;1018   
;;;1019     /* end of last stage process */
;;;1020   
;;;1021     /* output is in 11.5(q5) format for the 1024 point */
;;;1022     /* output is in 9.7(q7) format for the 256 point   */
;;;1023     /* output is in 7.9(q9) format for the 64 point  */
;;;1024     /* output is in 5.11(q11) format for the 16 point  */
;;;1025   
;;;1026   #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;1027   
;;;1028   }
00025e  b00b              ADD      sp,sp,#0x2c
000260  e8bd8ff0          POP      {r4-r11,pc}
;;;1029   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\TransformFunctions\\arm_cfft_radix4_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_cfft_radix4_q15_c_de3a22b0____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___21_arm_cfft_radix4_q15_c_de3a22b0____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_cfft_radix4_q15_c_de3a22b0____REVSH|
#line 144
|__asm___21_arm_cfft_radix4_q15_c_de3a22b0____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_cfft_radix4_q15_c_de3a22b0____RRX|
#line 300
|__asm___21_arm_cfft_radix4_q15_c_de3a22b0____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
