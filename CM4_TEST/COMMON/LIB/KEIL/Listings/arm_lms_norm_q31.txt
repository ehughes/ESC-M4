; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_lms_norm_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_lms_norm_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_lms_norm_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_lms_norm_q31.c]
                          THUMB

                          AREA ||i.arm_lms_norm_q31||, CODE, READONLY, ALIGN=1

                  arm_lms_norm_q31 PROC
;;;79     
;;;80     void arm_lms_norm_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;81       arm_lms_norm_instance_q31 * S,
;;;82       q31_t * pSrc,
;;;83       q31_t * pRef,
;;;84       q31_t * pOut,
;;;85       q31_t * pErr,
;;;86       uint32_t blockSize)
;;;87     {
000004  b08b              SUB      sp,sp,#0x2c
000006  4681              MOV      r9,r0
000008  9a19              LDR      r2,[sp,#0x64]
00000a  468b              MOV      r11,r1
;;;88       q31_t *pState = S->pState;                     /* State pointer */
00000c  f8d96004          LDR      r6,[r9,#4]
;;;89       q31_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
000010  f8d90008          LDR      r0,[r9,#8]
000014  9006              STR      r0,[sp,#0x18]
;;;90       q31_t *pStateCurnt;                            /* Points to the current sample of the state */
;;;91       q31_t *px, *pb;                                /* Temporary pointers for state and coefficient buffers */
;;;92       q31_t mu = S->mu;                              /* Adaptive factor */
000016  f8d9000c          LDR      r0,[r9,#0xc]
00001a  9004              STR      r0,[sp,#0x10]
;;;93       uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
00001c  f8b91000          LDRH     r1,[r9,#0]
000020  9103              STR      r1,[sp,#0xc]
;;;94       uint32_t tapCnt, blkCnt;                       /* Loop counters */
;;;95       q63_t energy;                                  /* Energy of the input */
;;;96       q63_t acc;                                     /* Accumulator */
;;;97       q31_t e = 0, d = 0;                            /* error, reference data sample */
;;;98       q31_t w = 0, in;                               /* weight factor and state */
;;;99       q31_t x0;                                      /* temporary variable to hold input sample */
;;;100    //  uint32_t shift = 32u - ((uint32_t) S->postShift + 1u);        /* Shift to be applied to the output */      
;;;101      q31_t errorXmu, oneByEnergy;                   /* Temporary variables to store error and mu product and reciprocal of energy */
;;;102      q31_t postShift;                               /* Post shift to be applied to weight after reciprocal calculation */
;;;103      q31_t coef;                                    /* Temporary variable for coef */
;;;104      q31_t acc_l, acc_h;                            /*  temporary input */
;;;105      uint32_t uShift = ((uint32_t) S->postShift + 1u);
000022  f8990010          LDRB     r0,[r9,#0x10]
000026  1c40              ADDS     r0,r0,#1
000028  9001              STR      r0,[sp,#4]
;;;106      uint32_t lShift = 32u - uShift;                /*  Shift to be applied to the output */
00002a  9801              LDR      r0,[sp,#4]
00002c  f1c00020          RSB      r0,r0,#0x20
000030  9000              STR      r0,[sp,#0]
;;;107    
;;;108      energy = S->energy;
000032  f8d95018          LDR      r5,[r9,#0x18]
;;;109      x0 = S->x0;
000036  f8d9001c          LDR      r0,[r9,#0x1c]
;;;110    
;;;111      /* S->pState points to buffer which contains previous frame (numTaps - 1) samples */
;;;112      /* pStateCurnt points to the location where the new input data should be written */
;;;113      pStateCurnt = &(S->pState[(numTaps - 1u)]);
00003a  9903              LDR      r1,[sp,#0xc]
00003c  1e49              SUBS     r1,r1,#1
00003e  910a              STR      r1,[sp,#0x28]
000040  eb060181          ADD      r1,r6,r1,LSL #2
000044  9105              STR      r1,[sp,#0x14]
;;;114    
;;;115      /* Loop over blockSize number of values */
;;;116      blkCnt = blockSize;
000046  9202              STR      r2,[sp,#8]
000048  e107              B        |L1.602|
                  |L1.74|
;;;117    
;;;118    
;;;119    #ifndef ARM_MATH_CM0_FAMILY
;;;120    
;;;121      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;122    
;;;123      while(blkCnt > 0u)
;;;124      {
;;;125    
;;;126        /* Copy the new input sample into the state buffer */
;;;127        *pStateCurnt++ = *pSrc;
00004a  9905              LDR      r1,[sp,#0x14]
00004c  f8db2000          LDR      r2,[r11,#0]
000050  600a              STR      r2,[r1,#0]
000052  9905              LDR      r1,[sp,#0x14]
000054  1d09              ADDS     r1,r1,#4
000056  9105              STR      r1,[sp,#0x14]
;;;128    
;;;129        /* Initialize pState pointer */
;;;130        px = pState;
000058  4632              MOV      r2,r6
;;;131    
;;;132        /* Initialize coeff pointer */
;;;133        pb = (pCoeffs);
00005a  9b06              LDR      r3,[sp,#0x18]
;;;134    
;;;135        /* Read the sample from input buffer */
;;;136        in = *pSrc++;
00005c  f85b1b04          LDR      r1,[r11],#4
;;;137    
;;;138        /* Update the energy calculation */
;;;139        energy = (q31_t) ((((q63_t) energy << 32) -
000060  fb804000          SMULL    r4,r0,r0,r0
000064  1924              ADDS     r4,r4,r4
000066  4140              ADCS     r0,r0,r0
000068  f04f0c00          MOV      r12,#0
00006c  ebbc0404          SUBS     r4,r12,r4
000070  eb650500          SBC      r5,r5,r0
;;;140                           (((q63_t) x0 * x0) << 1)) >> 32);
;;;141        energy = (q31_t) (((((q63_t) in * in) << 1) + (energy << 32)) >> 32);
000074  fb811001          SMULL    r1,r0,r1,r1
000078  1849              ADDS     r1,r1,r1
00007a  4140              ADCS     r0,r0,r0
00007c  eb11010c          ADDS     r1,r1,r12
000080  4145              ADCS     r5,r5,r0
;;;142    
;;;143        /* Set the accumulator to zero */
;;;144        acc = 0;
000082  2000              MOVS     r0,#0
000084  4601              MOV      r1,r0
;;;145    
;;;146        /* Loop unrolling.  Process 4 taps at a time. */
;;;147        tapCnt = numTaps >> 2;
000086  9c03              LDR      r4,[sp,#0xc]
000088  08a4              LSRS     r4,r4,#2
00008a  9409              STR      r4,[sp,#0x24]
;;;148    
;;;149        while(tapCnt > 0u)
00008c  e021              B        |L1.210|
                  |L1.142|
;;;150        {
;;;151          /* Perform the multiply-accumulate */
;;;152          acc += ((q63_t) (*px++)) * (*pb++);
00008e  6817              LDR      r7,[r2,#0]
000090  f8538b04          LDR      r8,[r3],#4
000094  fb878708          SMULL    r8,r7,r7,r8
000098  eb180000          ADDS     r0,r8,r0
00009c  4179              ADCS     r1,r1,r7
;;;153          acc += ((q63_t) (*px++)) * (*pb++);
00009e  6857              LDR      r7,[r2,#4]
0000a0  f8538b04          LDR      r8,[r3],#4
0000a4  fb878708          SMULL    r8,r7,r7,r8
0000a8  eb180000          ADDS     r0,r8,r0
0000ac  4179              ADCS     r1,r1,r7
;;;154          acc += ((q63_t) (*px++)) * (*pb++);
0000ae  6897              LDR      r7,[r2,#8]
0000b0  f8538b04          LDR      r8,[r3],#4
0000b4  fb878708          SMULL    r8,r7,r7,r8
0000b8  eb180000          ADDS     r0,r8,r0
0000bc  4179              ADCS     r1,r1,r7
;;;155          acc += ((q63_t) (*px++)) * (*pb++);
0000be  68d7              LDR      r7,[r2,#0xc]
0000c0  f8538b04          LDR      r8,[r3],#4
0000c4  3210              ADDS     r2,r2,#0x10
0000c6  fb878708          SMULL    r8,r7,r7,r8
0000ca  eb180000          ADDS     r0,r8,r0
0000ce  4179              ADCS     r1,r1,r7
;;;156    
;;;157          /* Decrement the loop counter */
;;;158          tapCnt--;
0000d0  1e64              SUBS     r4,r4,#1
                  |L1.210|
0000d2  2c00              CMP      r4,#0                 ;149
0000d4  d1db              BNE      |L1.142|
;;;159        }
;;;160    
;;;161        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;162        tapCnt = numTaps % 0x4u;
0000d6  9c03              LDR      r4,[sp,#0xc]
0000d8  f0040403          AND      r4,r4,#3
0000dc  9408              STR      r4,[sp,#0x20]
;;;163    
;;;164        while(tapCnt > 0u)
0000de  e008              B        |L1.242|
                  |L1.224|
;;;165        {
;;;166          /* Perform the multiply-accumulate */
;;;167          acc += ((q63_t) (*px++)) * (*pb++);
0000e0  ca80              LDM      r2!,{r7}
0000e2  f8538b04          LDR      r8,[r3],#4
0000e6  fb878708          SMULL    r8,r7,r7,r8
0000ea  eb180000          ADDS     r0,r8,r0
0000ee  4179              ADCS     r1,r1,r7
;;;168    
;;;169          /* Decrement the loop counter */
;;;170          tapCnt--;
0000f0  1e64              SUBS     r4,r4,#1
                  |L1.242|
0000f2  2c00              CMP      r4,#0                 ;164
0000f4  d1f4              BNE      |L1.224|
;;;171        }
;;;172    
;;;173        /* Converting the result to 1.31 format */
;;;174        /* Calc lower part of acc */
;;;175        acc_l = acc & 0xffffffff;
;;;176    
;;;177        /* Calc upper part of acc */
;;;178        acc_h = (acc >> 32) & 0xffffffff;
;;;179    
;;;180        acc = (uint32_t) acc_l >> lShift | acc_h << uShift;
0000f6  9a00              LDR      r2,[sp,#0]
0000f8  40d0              LSRS     r0,r0,r2
0000fa  9a01              LDR      r2,[sp,#4]
0000fc  4091              LSLS     r1,r1,r2
0000fe  4308              ORRS     r0,r0,r1
;;;181    
;;;182        /* Store the result from accumulator into the destination buffer. */
;;;183        *pOut++ = (q31_t) acc;
000100  990e              LDR      r1,[sp,#0x38]
000102  6008              STR      r0,[r1,#0]
000104  990e              LDR      r1,[sp,#0x38]
000106  1d09              ADDS     r1,r1,#4
000108  910e              STR      r1,[sp,#0x38]
;;;184    
;;;185        /* Compute and store error */
;;;186        d = *pRef++;
00010a  990d              LDR      r1,[sp,#0x34]
00010c  9a0d              LDR      r2,[sp,#0x34]
00010e  6809              LDR      r1,[r1,#0]
000110  1d12              ADDS     r2,r2,#4
000112  920d              STR      r2,[sp,#0x34]
;;;187        e = d - (q31_t) acc;
000114  eba10a00          SUB      r10,r1,r0
;;;188        *pErr++ = e;
000118  9818              LDR      r0,[sp,#0x60]
00011a  f8c0a000          STR      r10,[r0,#0]
00011e  9818              LDR      r0,[sp,#0x60]
000120  1d00              ADDS     r0,r0,#4
000122  9018              STR      r0,[sp,#0x60]
;;;189    
;;;190        /* Calculates the reciprocal of energy */
;;;191        postShift = arm_recip_q31(energy + DELTA_Q31,
000124  f44f7080          MOV      r0,#0x100
000128  182f              ADDS     r7,r5,r0
00012a  f8d90014          LDR      r0,[r9,#0x14]
00012e  2f00              CMP      r7,#0
000130  dd04              BLE      |L1.316|
000132  fab7f887          CLZ      r8,r7
000136  f1a80801          SUB      r8,r8,#1
00013a  e004              B        |L1.326|
                  |L1.316|
00013c  4279              RSBS     r1,r7,#0
00013e  fab1f881          CLZ      r8,r1
000142  f1a80801          SUB      r8,r8,#1
                  |L1.326|
000146  fa07f708          LSL      r7,r7,r8
00014a  1639              ASRS     r1,r7,#24
00014c  f001013f          AND      r1,r1,#0x3f
000150  f8500021          LDR      r0,[r0,r1,LSL #2]
000154  2400              MOVS     r4,#0
000156  17f9              ASRS     r1,r7,#31
000158  9107              STR      r1,[sp,#0x1c]
                  |L1.346|
00015a  fba73c00          UMULL    r3,r12,r7,r0
00015e  9907              LDR      r1,[sp,#0x1c]
000160  2200              MOVS     r2,#0
000162  fb01c100          MLA      r1,r1,r0,r12
000166  fb071102          MLA      r1,r7,r2,r1
00016a  004a              LSLS     r2,r1,#1
00016c  ea4271d3          ORR      r1,r2,r3,LSR #31
000170  f06f4200          MVN      r2,#0x80000000
000174  1a51              SUBS     r1,r2,r1
000176  fba01001          UMULL    r1,r0,r0,r1
00017a  0f89              LSRS     r1,r1,#30
00017c  ea410180          ORR      r1,r1,r0,LSL #2
000180  1782              ASRS     r2,r0,#30
000182  4608              MOV      r0,r1
000184  4611              MOV      r1,r2
000186  f7fffffe          BL       clip_q63_to_q31
00018a  1c64              ADDS     r4,r4,#1
00018c  2c02              CMP      r4,#2
00018e  d3e4              BCC      |L1.346|
000190  f1080801          ADD      r8,r8,#1
;;;192                                  &oneByEnergy, &S->recipTable[0]);
;;;193    
;;;194        /* Calculation of product of (e * mu) */
;;;195        errorXmu = (q31_t) (((q63_t) e * mu) >> 31);
000194  9904              LDR      r1,[sp,#0x10]
000196  fb8a1201          SMULL    r1,r2,r10,r1
00019a  0fc9              LSRS     r1,r1,#31
00019c  ea410142          ORR      r1,r1,r2,LSL #1
;;;196    
;;;197        /* Weighting factor for the normalized version */
;;;198        w = clip_q63_to_q31(((q63_t) errorXmu * oneByEnergy) >> (31 - postShift));
0001a0  fb810100          SMULL    r0,r1,r1,r0
0001a4  f1c8021f          RSB      r2,r8,#0x1f
0001a8  f7fffffe          BL       __aeabi_lasr
0001ac  f7fffffe          BL       clip_q63_to_q31
0001b0  4680              MOV      r8,r0
;;;199    
;;;200        /* Initialize pState pointer */
;;;201        px = pState;
0001b2  4637              MOV      r7,r6
;;;202    
;;;203        /* Initialize coeff pointer */
;;;204        pb = (pCoeffs);
0001b4  9c06              LDR      r4,[sp,#0x18]
;;;205    
;;;206        /* Loop unrolling.  Process 4 taps at a time. */
;;;207        tapCnt = numTaps >> 2;
0001b6  f8dda024          LDR      r10,[sp,#0x24]
;;;208    
;;;209        /* Update filter coefficients */
;;;210        while(tapCnt > 0u)
0001ba  e033              B        |L1.548|
                  |L1.444|
;;;211        {
;;;212          /* Perform the multiply-accumulate */
;;;213    
;;;214          /* coef is in 2.30 format */
;;;215          coef = (q31_t) (((q63_t) w * (*px++)) >> (32));
0001bc  6838              LDR      r0,[r7,#0]
0001be  fb58f100          SMMUL    r1,r8,r0
;;;216          /* get coef in 1.31 format by left shifting */
;;;217          *pb = clip_q63_to_q31((q63_t) * pb + (coef << 1u));
0001c2  6820              LDR      r0,[r4,#0]
0001c4  0049              LSLS     r1,r1,#1
0001c6  17c2              ASRS     r2,r0,#31
0001c8  1840              ADDS     r0,r0,r1
0001ca  eb4271e1          ADC      r1,r2,r1,ASR #31
0001ce  f7fffffe          BL       clip_q63_to_q31
0001d2  6020              STR      r0,[r4,#0]
;;;218          /* update coefficient buffer to next coefficient */
;;;219          pb++;
;;;220    
;;;221          coef = (q31_t) (((q63_t) w * (*px++)) >> (32));
0001d4  6878              LDR      r0,[r7,#4]
0001d6  fb58f200          SMMUL    r2,r8,r0
;;;222          *pb = clip_q63_to_q31((q63_t) * pb + (coef << 1u));
0001da  6860              LDR      r0,[r4,#4]
0001dc  0052              LSLS     r2,r2,#1
0001de  17c1              ASRS     r1,r0,#31
0001e0  1880              ADDS     r0,r0,r2
0001e2  eb4171e2          ADC      r1,r1,r2,ASR #31
0001e6  f7fffffe          BL       clip_q63_to_q31
0001ea  6060              STR      r0,[r4,#4]
;;;223          pb++;
;;;224    
;;;225          coef = (q31_t) (((q63_t) w * (*px++)) >> (32));
0001ec  68b8              LDR      r0,[r7,#8]
0001ee  fb58f200          SMMUL    r2,r8,r0
;;;226          *pb = clip_q63_to_q31((q63_t) * pb + (coef << 1u));
0001f2  68a0              LDR      r0,[r4,#8]
0001f4  0052              LSLS     r2,r2,#1
0001f6  17c1              ASRS     r1,r0,#31
0001f8  1880              ADDS     r0,r0,r2
0001fa  eb4171e2          ADC      r1,r1,r2,ASR #31
0001fe  f7fffffe          BL       clip_q63_to_q31
000202  60a0              STR      r0,[r4,#8]
;;;227          pb++;
;;;228    
;;;229          coef = (q31_t) (((q63_t) w * (*px++)) >> (32));
000204  68f8              LDR      r0,[r7,#0xc]
000206  3710              ADDS     r7,r7,#0x10
000208  fb58f100          SMMUL    r1,r8,r0
;;;230          *pb = clip_q63_to_q31((q63_t) * pb + (coef << 1u));
00020c  68e0              LDR      r0,[r4,#0xc]
00020e  0049              LSLS     r1,r1,#1
000210  17c2              ASRS     r2,r0,#31
000212  1840              ADDS     r0,r0,r1
000214  eb4271e1          ADC      r1,r2,r1,ASR #31
000218  f7fffffe          BL       clip_q63_to_q31
00021c  60e0              STR      r0,[r4,#0xc]
00021e  3410              ADDS     r4,r4,#0x10
;;;231          pb++;
;;;232    
;;;233          /* Decrement the loop counter */
;;;234          tapCnt--;
000220  f1aa0a01          SUB      r10,r10,#1
                  |L1.548|
000224  f1ba0f00          CMP      r10,#0                ;210
000228  d1c8              BNE      |L1.444|
;;;235        }
;;;236    
;;;237        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;238        tapCnt = numTaps % 0x4u;
00022a  f8dda020          LDR      r10,[sp,#0x20]
;;;239    
;;;240        while(tapCnt > 0u)
00022e  e00d              B        |L1.588|
                  |L1.560|
;;;241        {
;;;242          /* Perform the multiply-accumulate */
;;;243          coef = (q31_t) (((q63_t) w * (*px++)) >> (32));
000230  cf01              LDM      r7!,{r0}
000232  fb58f100          SMMUL    r1,r8,r0
;;;244          *pb = clip_q63_to_q31((q63_t) * pb + (coef << 1u));
000236  6820              LDR      r0,[r4,#0]
000238  0049              LSLS     r1,r1,#1
00023a  17c2              ASRS     r2,r0,#31
00023c  1840              ADDS     r0,r0,r1
00023e  eb4271e1          ADC      r1,r2,r1,ASR #31
000242  f7fffffe          BL       clip_q63_to_q31
000246  c401              STM      r4!,{r0}
;;;245          pb++;
;;;246    
;;;247          /* Decrement the loop counter */
;;;248          tapCnt--;
000248  f1aa0a01          SUB      r10,r10,#1
                  |L1.588|
00024c  f1ba0f00          CMP      r10,#0                ;240
000250  d1ee              BNE      |L1.560|
;;;249        }
;;;250    
;;;251        /* Read the sample from state buffer */
;;;252        x0 = *pState;
000252  ce01              LDM      r6!,{r0}
;;;253    
;;;254        /* Advance state pointer by 1 for the next sample */
;;;255        pState = pState + 1;
;;;256    
;;;257        /* Decrement the loop counter */
;;;258        blkCnt--;
000254  9902              LDR      r1,[sp,#8]
000256  1e49              SUBS     r1,r1,#1
000258  9102              STR      r1,[sp,#8]
                  |L1.602|
00025a  9902              LDR      r1,[sp,#8]            ;123
00025c  2900              CMP      r1,#0                 ;123
00025e  f47faef4          BNE      |L1.74|
;;;259      }
;;;260    
;;;261      /* Save energy and x0 values for the next frame */
;;;262      S->energy = (q31_t) energy;
000262  f8c95018          STR      r5,[r9,#0x18]
;;;263      S->x0 = x0;
000266  f8c9001c          STR      r0,[r9,#0x1c]
;;;264    
;;;265      /* Processing is complete. Now copy the last numTaps - 1 samples to the    
;;;266         satrt of the state buffer. This prepares the state buffer for the    
;;;267         next function call. */
;;;268    
;;;269      /* Points to the start of the pState buffer */
;;;270      pStateCurnt = S->pState;
00026a  f8d90004          LDR      r0,[r9,#4]
;;;271    
;;;272      /* Loop unrolling for (numTaps - 1u) samples copy */
;;;273      tapCnt = (numTaps - 1u) >> 2u;
00026e  990a              LDR      r1,[sp,#0x28]
000270  0889              LSRS     r1,r1,#2
;;;274    
;;;275      /* copy data */
;;;276      while(tapCnt > 0u)
000272  e00a              B        |L1.650|
                  |L1.628|
;;;277      {
;;;278        *pStateCurnt++ = *pState++;
000274  6832              LDR      r2,[r6,#0]
000276  6002              STR      r2,[r0,#0]
;;;279        *pStateCurnt++ = *pState++;
000278  6872              LDR      r2,[r6,#4]
00027a  6042              STR      r2,[r0,#4]
;;;280        *pStateCurnt++ = *pState++;
00027c  68b2              LDR      r2,[r6,#8]
00027e  6082              STR      r2,[r0,#8]
;;;281        *pStateCurnt++ = *pState++;
000280  68f2              LDR      r2,[r6,#0xc]
000282  3610              ADDS     r6,r6,#0x10
000284  60c2              STR      r2,[r0,#0xc]
000286  3010              ADDS     r0,r0,#0x10
;;;282    
;;;283        /* Decrement the loop counter */
;;;284        tapCnt--;
000288  1e49              SUBS     r1,r1,#1
                  |L1.650|
00028a  2900              CMP      r1,#0                 ;276
00028c  d1f2              BNE      |L1.628|
;;;285      }
;;;286    
;;;287      /* Calculate remaining number of copies */
;;;288      tapCnt = (numTaps - 1u) % 0x4u;
00028e  990a              LDR      r1,[sp,#0x28]
000290  f0010103          AND      r1,r1,#3
;;;289    
;;;290      /* Copy the remaining q31_t data */
;;;291      while(tapCnt > 0u)
000294  e002              B        |L1.668|
                  |L1.662|
;;;292      {
;;;293        *pStateCurnt++ = *pState++;
000296  ce04              LDM      r6!,{r2}
000298  c004              STM      r0!,{r2}
;;;294    
;;;295        /* Decrement the loop counter */
;;;296        tapCnt--;
00029a  1e49              SUBS     r1,r1,#1
                  |L1.668|
00029c  2900              CMP      r1,#0                 ;291
00029e  d1fa              BNE      |L1.662|
;;;297      }
;;;298    
;;;299    #else
;;;300    
;;;301      /* Run the below code for Cortex-M0 */
;;;302    
;;;303      while(blkCnt > 0u)
;;;304      {
;;;305    
;;;306        /* Copy the new input sample into the state buffer */
;;;307        *pStateCurnt++ = *pSrc;
;;;308    
;;;309        /* Initialize pState pointer */
;;;310        px = pState;
;;;311    
;;;312        /* Initialize pCoeffs pointer */
;;;313        pb = pCoeffs;
;;;314    
;;;315        /* Read the sample from input buffer */
;;;316        in = *pSrc++;
;;;317    
;;;318        /* Update the energy calculation */
;;;319        energy =
;;;320          (q31_t) ((((q63_t) energy << 32) - (((q63_t) x0 * x0) << 1)) >> 32);
;;;321        energy = (q31_t) (((((q63_t) in * in) << 1) + (energy << 32)) >> 32);
;;;322    
;;;323        /* Set the accumulator to zero */
;;;324        acc = 0;
;;;325    
;;;326        /* Loop over numTaps number of values */
;;;327        tapCnt = numTaps;
;;;328    
;;;329        while(tapCnt > 0u)
;;;330        {
;;;331          /* Perform the multiply-accumulate */
;;;332          acc += ((q63_t) (*px++)) * (*pb++);
;;;333    
;;;334          /* Decrement the loop counter */
;;;335          tapCnt--;
;;;336        }
;;;337    
;;;338        /* Converting the result to 1.31 format */
;;;339        /* Converting the result to 1.31 format */
;;;340        /* Calc lower part of acc */
;;;341        acc_l = acc & 0xffffffff;
;;;342    
;;;343        /* Calc upper part of acc */
;;;344        acc_h = (acc >> 32) & 0xffffffff;
;;;345    
;;;346        acc = (uint32_t) acc_l >> lShift | acc_h << uShift;
;;;347    
;;;348    
;;;349        //acc = (q31_t) (acc >> shift); 
;;;350    
;;;351        /* Store the result from accumulator into the destination buffer. */
;;;352        *pOut++ = (q31_t) acc;
;;;353    
;;;354        /* Compute and store error */
;;;355        d = *pRef++;
;;;356        e = d - (q31_t) acc;
;;;357        *pErr++ = e;
;;;358    
;;;359        /* Calculates the reciprocal of energy */
;;;360        postShift =
;;;361          arm_recip_q31(energy + DELTA_Q31, &oneByEnergy, &S->recipTable[0]);
;;;362    
;;;363        /* Calculation of product of (e * mu) */
;;;364        errorXmu = (q31_t) (((q63_t) e * mu) >> 31);
;;;365    
;;;366        /* Weighting factor for the normalized version */
;;;367        w = clip_q63_to_q31(((q63_t) errorXmu * oneByEnergy) >> (31 - postShift));
;;;368    
;;;369        /* Initialize pState pointer */
;;;370        px = pState;
;;;371    
;;;372        /* Initialize coeff pointer */
;;;373        pb = (pCoeffs);
;;;374    
;;;375        /* Loop over numTaps number of values */
;;;376        tapCnt = numTaps;
;;;377    
;;;378        while(tapCnt > 0u)
;;;379        {
;;;380          /* Perform the multiply-accumulate */
;;;381          /* coef is in 2.30 format */
;;;382          coef = (q31_t) (((q63_t) w * (*px++)) >> (32));
;;;383          /* get coef in 1.31 format by left shifting */
;;;384          *pb = clip_q63_to_q31((q63_t) * pb + (coef << 1u));
;;;385          /* update coefficient buffer to next coefficient */
;;;386          pb++;
;;;387    
;;;388          /* Decrement the loop counter */
;;;389          tapCnt--;
;;;390        }
;;;391    
;;;392        /* Read the sample from state buffer */
;;;393        x0 = *pState;
;;;394    
;;;395        /* Advance state pointer by 1 for the next sample */
;;;396        pState = pState + 1;
;;;397    
;;;398        /* Decrement the loop counter */
;;;399        blkCnt--;
;;;400      }
;;;401    
;;;402      /* Save energy and x0 values for the next frame */
;;;403      S->energy = (q31_t) energy;
;;;404      S->x0 = x0;
;;;405    
;;;406      /* Processing is complete. Now copy the last numTaps - 1 samples to the     
;;;407         start of the state buffer. This prepares the state buffer for the        
;;;408         next function call. */
;;;409    
;;;410      /* Points to the start of the pState buffer */
;;;411      pStateCurnt = S->pState;
;;;412    
;;;413      /* Loop for (numTaps - 1u) samples copy */
;;;414      tapCnt = (numTaps - 1u);
;;;415    
;;;416      /* Copy the remaining q31_t data */
;;;417      while(tapCnt > 0u)
;;;418      {
;;;419        *pStateCurnt++ = *pState++;
;;;420    
;;;421        /* Decrement the loop counter */
;;;422        tapCnt--;
;;;423      }
;;;424    
;;;425    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;426    
;;;427    }
0002a0  b00f              ADD      sp,sp,#0x3c
0002a2  e8bd8ff0          POP      {r4-r11,pc}
;;;428    
                          ENDP


                          AREA ||i.clip_q63_to_q31||, CODE, READONLY, ALIGN=1

                  clip_q63_to_q31 PROC
;;;458       */
;;;459      static __INLINE q31_t clip_q63_to_q31(
000000  17ca              ASRS     r2,r1,#31
;;;460      q63_t x)
;;;461      {
;;;462        return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
000002  ebb17fe0          CMP      r1,r0,ASR #31
000006  d002              BEQ      |L2.14|
;;;463          ((0x7FFFFFFF ^ ((q31_t) (x >> 63)))) : (q31_t) x;
000008  f06f4000          MVN      r0,#0x80000000
00000c  4050              EORS     r0,r0,r2
                  |L2.14|
;;;464      }
00000e  4770              BX       lr
;;;465    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_lms_norm_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_lms_norm_q31_c_3a2782e8____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___18_arm_lms_norm_q31_c_3a2782e8____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_lms_norm_q31_c_3a2782e8____REVSH|
#line 144
|__asm___18_arm_lms_norm_q31_c_3a2782e8____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_lms_norm_q31_c_3a2782e8____RRX|
#line 300
|__asm___18_arm_lms_norm_q31_c_3a2782e8____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
