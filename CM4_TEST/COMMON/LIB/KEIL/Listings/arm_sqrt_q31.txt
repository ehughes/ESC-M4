; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_sqrt_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_sqrt_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_sqrt_q31.crf ..\..\SRC\CMSIS_DSP_4_5\src\FastMathFunctions\arm_sqrt_q31.c]
                          THUMB

                          AREA ||i.arm_sqrt_q31||, CODE, READONLY, ALIGN=2

                  arm_sqrt_q31 PROC
;;;60     
;;;61     arm_status arm_sqrt_q31(
000000  b5f8              PUSH     {r3-r7,lr}
;;;62       q31_t in,
;;;63       q31_t * pOut)
;;;64     {
;;;65       q31_t number, temp1, bits_val1, var1, signBits1, half;
;;;66       float32_t temp_float1;
;;;67       union
;;;68       {
;;;69           q31_t fracval;
;;;70           float32_t floatval;
;;;71       } tempconv;
;;;72     
;;;73       number = in;
;;;74     
;;;75       /* If the input is a positive number then compute the signBits. */
;;;76       if(number > 0)
000002  2800              CMP      r0,#0
000004  dd76              BLE      |L1.244|
;;;77       {
;;;78         signBits1 = __CLZ(number) - 1;
000006  fab0f280          CLZ      r2,r0
00000a  1e52              SUBS     r2,r2,#1
;;;79     
;;;80         /* Shift by the number of signBits1 */
;;;81         if((signBits1 % 2) == 0)
00000c  07d3              LSLS     r3,r2,#31
00000e  2b00              CMP      r3,#0
000010  d072              BEQ      |L1.248|
;;;82         {
;;;83           number = number << signBits1;
;;;84         }
;;;85         else
;;;86         {
;;;87           number = number << (signBits1 - 1);
000012  f1a20301          SUB      r3,r2,#1
000016  fa00f003          LSL      r0,r0,r3
                  |L1.26|
;;;88         }
;;;89     
;;;90         /* Calculate half value of the number */
;;;91         half = number >> 1;
00001a  ea4f0460          ASR      r4,r0,#1
;;;92         /* Store the number for later use */
;;;93         temp1 = number;
;;;94     
;;;95         /*Convert to float */
;;;96         temp_float1 = number * 4.6566128731e-010f;
00001e  ee000a10          VMOV     s0,r0
000022  eeb80ac0          VCVT.F32.S32 s0,s0
000026  eddf0a3f          VLDR     s1,|L1.292|
00002a  ee200a20          VMUL.F32 s0,s0,s1
;;;97         /*Store as integer */
;;;98         tempconv.floatval = temp_float1;
00002e  ed8d0a00          VSTR     s0,[sp,#0]
;;;99         bits_val1 = tempconv.fracval;
000032  9b00              LDR      r3,[sp,#0]
;;;100        /* Subtract the shifted value from the magic number to give intial guess */
;;;101        bits_val1 = 0x5f3759df - (bits_val1 >> 1);  /* gives initial guess */
000034  4d3c              LDR      r5,|L1.296|
000036  eba50363          SUB      r3,r5,r3,ASR #1
;;;102        /* Store as float */
;;;103        tempconv.fracval = bits_val1;
00003a  9300              STR      r3,[sp,#0]
;;;104        temp_float1 = tempconv.floatval;
00003c  ed9d0a00          VLDR     s0,[sp,#0]
;;;105        /* Convert to integer format */
;;;106        var1 = (q31_t) (temp_float1 * 1073741824);
000040  eddf0a3a          VLDR     s1,|L1.300|
000044  ee200a20          VMUL.F32 s0,s0,s1
000048  eebd0ac0          VCVT.S32.F32 s0,s0
00004c  ee103a10          VMOV     r3,s0
;;;107    
;;;108        /* 1st iteration */
;;;109        var1 = ((q31_t) ((q63_t) var1 * (0x30000000 -
000050  fb836503          SMULL    r6,r5,r3,r3
000054  ea4f0745          LSL      r7,r5,#1
000058  ea4775d6          ORR      r5,r7,r6,LSR #31
00005c  fb855604          SMULL    r5,r6,r5,r4
000060  ea4f75d5          LSR      r5,r5,#31
000064  ea450546          ORR      r5,r5,r6,LSL #1
000068  f1c55540          RSB      r5,r5,#0x30000000
00006c  fb833505          SMULL    r3,r5,r3,r5
000070  ea4f73d3          LSR      r3,r3,#31
000074  ea430345          ORR      r3,r3,r5,LSL #1
000078  ea4f0383          LSL      r3,r3,#2
;;;110                                         ((q31_t)
;;;111                                          ((((q31_t)
;;;112                                             (((q63_t) var1 * var1) >> 31)) *
;;;113                                            (q63_t) half) >> 31))) >> 31)) << 2;
;;;114        /* 2nd iteration */
;;;115        var1 = ((q31_t) ((q63_t) var1 * (0x30000000 -
00007c  fb835603          SMULL    r5,r6,r3,r3
000080  ea4f75d5          LSR      r5,r5,#31
000084  ea450546          ORR      r5,r5,r6,LSL #1
000088  fb856504          SMULL    r6,r5,r5,r4
00008c  ea4f0745          LSL      r7,r5,#1
000090  ea4775d6          ORR      r5,r7,r6,LSR #31
000094  f1c55540          RSB      r5,r5,#0x30000000
000098  fb835305          SMULL    r5,r3,r3,r5
00009c  ea4f0643          LSL      r6,r3,#1
0000a0  ea4673d5          ORR      r3,r6,r5,LSR #31
0000a4  ea4f0383          LSL      r3,r3,#2
;;;116                                         ((q31_t)
;;;117                                          ((((q31_t)
;;;118                                             (((q63_t) var1 * var1) >> 31)) *
;;;119                                            (q63_t) half) >> 31))) >> 31)) << 2;
;;;120        /* 3rd iteration */
;;;121        var1 = ((q31_t) ((q63_t) var1 * (0x30000000 -
0000a8  fb835603          SMULL    r5,r6,r3,r3
0000ac  ea4f75d5          LSR      r5,r5,#31
0000b0  ea450546          ORR      r5,r5,r6,LSL #1
0000b4  fb854504          SMULL    r4,r5,r5,r4
0000b8  ea4f74d4          LSR      r4,r4,#31
0000bc  ea440445          ORR      r4,r4,r5,LSL #1
0000c0  f1c45440          RSB      r4,r4,#0x30000000
0000c4  fb834304          SMULL    r4,r3,r3,r4
0000c8  ea4f0543          LSL      r5,r3,#1
0000cc  ea4573d4          ORR      r3,r5,r4,LSR #31
0000d0  ea4f0383          LSL      r3,r3,#2
;;;122                                         ((q31_t)
;;;123                                          ((((q31_t)
;;;124                                             (((q63_t) var1 * var1) >> 31)) *
;;;125                                            (q63_t) half) >> 31))) >> 31)) << 2;
;;;126    
;;;127        /* Multiply the inverse square root with the original value */
;;;128        var1 = ((q31_t) (((q63_t) temp1 * var1) >> 31)) << 1;
0000d4  fb800303          SMULL    r0,r3,r0,r3
0000d8  ea4f70d0          LSR      r0,r0,#31
0000dc  ea400043          ORR      r0,r0,r3,LSL #1
0000e0  ea4f0040          LSL      r0,r0,#1
;;;129    
;;;130        /* Shift the output down accordingly */
;;;131        if((signBits1 % 2) == 0)
0000e4  d10b              BNE      |L1.254|
;;;132        {
;;;133          var1 = var1 >> (signBits1 / 2);
0000e6  eb0272d2          ADD      r2,r2,r2,LSR #31
0000ea  ea4f0262          ASR      r2,r2,#1
0000ee  fa40f002          ASR      r0,r0,r2
0000f2  e00c              B        |L1.270|
                  |L1.244|
0000f4  e00f              B        |L1.278|
0000f6  e7ff              B        |L1.248|
                  |L1.248|
0000f8  fa00f002          LSL      r0,r0,r2              ;83
0000fc  e78d              B        |L1.26|
                  |L1.254|
;;;134        }
;;;135        else
;;;136        {
;;;137          var1 = var1 >> ((signBits1 - 1) / 2);
0000fe  f1a20201          SUB      r2,r2,#1
000102  eb0272d2          ADD      r2,r2,r2,LSR #31
000106  ea4f0262          ASR      r2,r2,#1
00010a  fa40f002          ASR      r0,r0,r2
                  |L1.270|
;;;138        }
;;;139        *pOut = var1;
00010e  6008              STR      r0,[r1,#0]
;;;140    
;;;141        return (ARM_MATH_SUCCESS);
000110  f04f0000          MOV      r0,#0
;;;142      }
;;;143      /* If the number is a negative number then store zero as its square root value */
;;;144      else
;;;145      {
;;;146        *pOut = 0;
;;;147        return (ARM_MATH_ARGUMENT_ERROR);
;;;148      }
;;;149    }
000114  bdf8              POP      {r3-r7,pc}
                  |L1.278|
000116  f04f0000          MOV      r0,#0                 ;146
00011a  6008              STR      r0,[r1,#0]            ;146
00011c  f04f30ff          MOV      r0,#0xffffffff        ;147
000120  bdf8              POP      {r3-r7,pc}
;;;150    
                          ENDP

000122  0000              DCW      0x0000
                  |L1.292|
000124  30000000          DCFS     0x30000000 ; 4.6566128730773926e-10
                  |L1.296|
                          DCD      0x5f3759df
                  |L1.300|
00012c  4e800000          DCFS     0x4e800000 ; 1073741824

;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FastMathFunctions\\arm_sqrt_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_sqrt_q31_c_a60ed3ed____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___14_arm_sqrt_q31_c_a60ed3ed____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_sqrt_q31_c_a60ed3ed____REVSH|
#line 144
|__asm___14_arm_sqrt_q31_c_a60ed3ed____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_sqrt_q31_c_a60ed3ed____RRX|
#line 300
|__asm___14_arm_sqrt_q31_c_a60ed3ed____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
