; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_interpolate_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_interpolate_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931 -I..\..\SRC\CMSIS_DSP_4_5\inc -IC:\Users\emh203\Documents\GitHub\ESC-M4\CM4_TEST\COMMON\LIB\KEIL\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=521 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 --omf_browse=.\objects\arm_fir_interpolate_f32.crf ..\..\SRC\CMSIS_DSP_4_5\src\FilteringFunctions\arm_fir_interpolate_f32.c]
                          THUMB

                          AREA ||i.arm_fir_interpolate_f32||, CODE, READONLY, ALIGN=2

                  arm_fir_interpolate_f32 PROC
;;;147    
;;;148    void arm_fir_interpolate_f32(
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;149      const arm_fir_interpolate_instance_f32 * S,
;;;150      float32_t * pSrc,
;;;151      float32_t * pDst,
;;;152      uint32_t blockSize)
;;;153    {
;;;154      float32_t *pState = S->pState;                 /* State pointer */
000004  6884              LDR      r4,[r0,#8]
;;;155      float32_t *pCoeffs = S->pCoeffs;               /* Coefficient pointer */
000006  6845              LDR      r5,[r0,#4]
000008  9501              STR      r5,[sp,#4]
;;;156      float32_t *pStateCurnt;                        /* Points to the current sample of the state */
;;;157      float32_t *ptr1, *ptr2;                        /* Temporary pointers for state and coefficient buffers */
;;;158      float32_t sum0;                                /* Accumulators */
;;;159      float32_t x0, c0;                              /* Temporary variables to hold state and coefficient values */
;;;160      uint32_t i, blkCnt, j;                         /* Loop counters */
;;;161      uint16_t phaseLen = S->phaseLength, tapCnt;    /* Length of each polyphase filter component */
00000a  f8b0c002          LDRH     r12,[r0,#2]
;;;162      float32_t acc0, acc1, acc2, acc3;
;;;163      float32_t x1, x2, x3;
;;;164      uint32_t blkCntN4;
;;;165      float32_t c1, c2, c3;
;;;166    
;;;167      /* S->pState buffer contains previous frame (phaseLen - 1) samples */
;;;168      /* pStateCurnt points to the location where the new input data should be written */
;;;169      pStateCurnt = S->pState + (phaseLen - 1u);
00000e  f1ac0501          SUB      r5,r12,#1
000012  eb040885          ADD      r8,r4,r5,LSL #2
000016  9502              STR      r5,[sp,#8]
;;;170    
;;;171      /* Initialise  blkCnt */
;;;172      blkCnt = blockSize / 4;
000018  ea4f0a93          LSR      r10,r3,#2
;;;173      blkCntN4 = blockSize - (4 * blkCnt);
00001c  f1ca0500          RSB      r5,r10,#0
000020  eb030385          ADD      r3,r3,r5,LSL #2
000024  9300              STR      r3,[sp,#0]
;;;174    
;;;175      /* Samples loop unrolled by 4 */
;;;176      while(blkCnt > 0u)
;;;177      {
;;;178        /* Copy new input sample into the state buffer */
;;;179        *pStateCurnt++ = *pSrc++;
;;;180        *pStateCurnt++ = *pSrc++;
;;;181        *pStateCurnt++ = *pSrc++;
;;;182        *pStateCurnt++ = *pSrc++;
;;;183    
;;;184        /* Address modifier index of coefficient buffer */
;;;185        j = 1u;
;;;186    
;;;187        /* Loop over the Interpolation factor. */
;;;188        i = (S->L);
;;;189    
;;;190        while(i > 0u)
;;;191        {
;;;192          /* Set accumulator to zero */
;;;193          acc0 = 0.0f;
000026  ed9f6a9e          VLDR     s12,|L1.672|
00002a  e0b5              B        |L1.408|
                  |L1.44|
00002c  ecb10a01          VLDM     r1!,{s0}              ;179
000030  eca80a01          VSTM     r8!,{s0}              ;179
000034  ecb10a01          VLDM     r1!,{s0}              ;180
000038  eca80a01          VSTM     r8!,{s0}              ;180
00003c  ecb10a01          VLDM     r1!,{s0}              ;181
000040  eca80a01          VSTM     r8!,{s0}              ;181
000044  ecb10a01          VLDM     r1!,{s0}              ;182
000048  eca80a01          VSTM     r8!,{s0}              ;182
00004c  f04f0b01          MOV      r11,#1                ;185
000050  f8909000          LDRB     r9,[r0,#0]            ;188
000054  e094              B        |L1.384|
                  |L1.86|
000056  eef01a46          VMOV.F32 s3,s12
;;;194          acc1 = 0.0f;
00005a  eeb02a61          VMOV.F32 s4,s3
;;;195          acc2 = 0.0f;
00005e  eef02a61          VMOV.F32 s5,s3
;;;196          acc3 = 0.0f;
000062  eeb03a61          VMOV.F32 s6,s3
;;;197    
;;;198          /* Initialize state pointer */
;;;199          ptr1 = pState;
;;;200    
;;;201          /* Initialize coefficient pointer */
;;;202          ptr2 = pCoeffs + (S->L - j);
000066  7806              LDRB     r6,[r0,#0]
000068  9b01              LDR      r3,[sp,#4]
00006a  eba6050b          SUB      r5,r6,r11
00006e  eb030385          ADD      r3,r3,r5,LSL #2
;;;203    
;;;204          /* Loop over the polyPhase length. Unroll by a factor of 4.        
;;;205           ** Repeat until we've computed numTaps-(4*S->L) coefficients. */
;;;206          tapCnt = phaseLen >> 2u;
000072  ea4f079c          LSR      r7,r12,#2
;;;207    
;;;208          x0 = *(ptr1++);
000076  ed941a00          VLDR     s2,[r4,#0]
00007a  1d25              ADDS     r5,r4,#4
;;;209          x1 = *(ptr1++);
00007c  ecb50a01          VLDM     r5!,{s0}
;;;210          x2 = *(ptr1++);
000080  ecf50a01          VLDM     r5!,{s1}
;;;211    
;;;212          while(tapCnt > 0u)
000084  e047              B        |L1.278|
                  |L1.134|
;;;213          {
;;;214    
;;;215            /* Read the input sample */
;;;216            x3 = *(ptr1++);
000086  ecf53a01          VLDM     r5!,{s7}
;;;217    
;;;218            /* Read the coefficient */
;;;219            c0 = *(ptr2);
00008a  ed934a00          VLDR     s8,[r3,#0]
;;;220    
;;;221            /* Perform the multiply-accumulate */
;;;222            acc0 += x0 * c0;
00008e  eeb05a61          VMOV.F32 s10,s3
000092  ee015a04          VMLA.F32 s10,s2,s8
;;;223            acc1 += x1 * c0;
000096  eef04a42          VMOV.F32 s9,s4
00009a  ee404a04          VMLA.F32 s9,s0,s8
;;;224            acc2 += x2 * c0;
00009e  ee402a84          VMLA.F32 s5,s1,s8
;;;225            acc3 += x3 * c0;
0000a2  eef05a43          VMOV.F32 s11,s6
0000a6  ee435a84          VMLA.F32 s11,s7,s8
;;;226    
;;;227            /* Read the coefficient */
;;;228            c1 = *(ptr2 + S->L);
0000aa  eb030e86          ADD      lr,r3,r6,LSL #2
0000ae  edde1a00          VLDR     s3,[lr,#0]
;;;229    
;;;230            /* Read the input sample */
;;;231            x0 = *(ptr1++);
0000b2  ecb51a01          VLDM     r5!,{s2}
;;;232    
;;;233            /* Perform the multiply-accumulate */
;;;234            acc0 += x1 * c1;
0000b6  ee005a21          VMLA.F32 s10,s0,s3
;;;235            acc1 += x2 * c1;
0000ba  ee404aa1          VMLA.F32 s9,s1,s3
;;;236            acc2 += x3 * c1;
0000be  ee432aa1          VMLA.F32 s5,s7,s3
;;;237            acc3 += x0 * c1;
0000c2  ee415a21          VMLA.F32 s11,s2,s3
;;;238    
;;;239            /* Read the coefficient */
;;;240            c2 = *(ptr2 + S->L * 2);
0000c6  eb030ec6          ADD      lr,r3,r6,LSL #3
0000ca  ed9e2a00          VLDR     s4,[lr,#0]
;;;241    
;;;242            /* Read the input sample */
;;;243            x1 = *(ptr1++);
0000ce  ecb50a01          VLDM     r5!,{s0}
;;;244    
;;;245            /* Perform the multiply-accumulate */
;;;246            acc0 += x2 * c2;
0000d2  ee005a82          VMLA.F32 s10,s1,s4
;;;247            acc1 += x3 * c2;
0000d6  ee434a82          VMLA.F32 s9,s7,s4
;;;248            acc2 += x0 * c2;
0000da  ee412a02          VMLA.F32 s5,s2,s4
;;;249            acc3 += x1 * c2;
0000de  ee405a02          VMLA.F32 s11,s0,s4
;;;250    
;;;251            /* Read the coefficient */
;;;252            c3 = *(ptr2 + S->L * 3);
0000e2  eb060e46          ADD      lr,r6,r6,LSL #1
0000e6  eb030e8e          ADD      lr,r3,lr,LSL #2
0000ea  ed9e3a00          VLDR     s6,[lr,#0]
;;;253    
;;;254            /* Read the input sample */
;;;255            x2 = *(ptr1++);
0000ee  ecf50a01          VLDM     r5!,{s1}
;;;256    
;;;257            /* Perform the multiply-accumulate */
;;;258            acc0 += x3 * c3;
0000f2  eef01a45          VMOV.F32 s3,s10
0000f6  ee431a83          VMLA.F32 s3,s7,s6
;;;259            acc1 += x0 * c3;
0000fa  eeb02a64          VMOV.F32 s4,s9
0000fe  ee012a03          VMLA.F32 s4,s2,s6
;;;260            acc2 += x1 * c3;
000102  ee402a03          VMLA.F32 s5,s0,s6
;;;261            acc3 += x2 * c3;
000106  ee405a83          VMLA.F32 s11,s1,s6
00010a  eeb03a65          VMOV.F32 s6,s11
;;;262    
;;;263    
;;;264            /* Upsampling is done by stuffing L-1 zeros between each sample.        
;;;265             * So instead of multiplying zeros with coefficients,        
;;;266             * Increment the coefficient pointer by interpolation factor times. */
;;;267            ptr2 += 4 * S->L;
00010e  eb031306          ADD      r3,r3,r6,LSL #4
;;;268    
;;;269            /* Decrement the loop counter */
;;;270            tapCnt--;
000112  1e7f              SUBS     r7,r7,#1
000114  b2bf              UXTH     r7,r7
                  |L1.278|
000116  2f00              CMP      r7,#0                 ;212
000118  d1b5              BNE      |L1.134|
;;;271          }
;;;272    
;;;273          /* If the polyPhase length is not a multiple of 4, compute the remaining filter taps */
;;;274          tapCnt = phaseLen % 0x4u;
00011a  f00c0703          AND      r7,r12,#3
;;;275    
;;;276          while(tapCnt > 0u)
00011e  e015              B        |L1.332|
                  |L1.288|
;;;277          {
;;;278    
;;;279            /* Read the input sample */
;;;280            x3 = *(ptr1++);
000120  ecb54a01          VLDM     r5!,{s8}
;;;281    
;;;282            /* Read the coefficient */
;;;283            c0 = *(ptr2);
000124  edd33a00          VLDR     s7,[r3,#0]
;;;284    
;;;285            /* Perform the multiply-accumulate */
;;;286            acc0 += x0 * c0;
000128  ee411a23          VMLA.F32 s3,s2,s7
;;;287            acc1 += x1 * c0;
00012c  ee002a23          VMLA.F32 s4,s0,s7
;;;288            acc2 += x2 * c0;
000130  ee402aa3          VMLA.F32 s5,s1,s7
;;;289            acc3 += x3 * c0;
000134  ee043a23          VMLA.F32 s6,s8,s7
;;;290    
;;;291            /* Increment the coefficient pointer by interpolation factor times. */
;;;292            ptr2 += S->L;
000138  eb030386          ADD      r3,r3,r6,LSL #2
;;;293    
;;;294            /* update states for next sample processing */
;;;295            x0 = x1;
00013c  eeb01a40          VMOV.F32 s2,s0
;;;296            x1 = x2;
000140  eeb00a60          VMOV.F32 s0,s1
;;;297            x2 = x3;
000144  eef00a44          VMOV.F32 s1,s8
;;;298    
;;;299            /* Decrement the loop counter */
;;;300            tapCnt--;
000148  1e7f              SUBS     r7,r7,#1
00014a  b2bf              UXTH     r7,r7
                  |L1.332|
00014c  2f00              CMP      r7,#0                 ;276
00014e  d1e7              BNE      |L1.288|
;;;301          }
;;;302    
;;;303          /* The result is in the accumulator, store in the destination buffer. */
;;;304          *pDst = acc0;
000150  edc21a00          VSTR     s3,[r2,#0]
;;;305          *(pDst + S->L) = acc1;
000154  7803              LDRB     r3,[r0,#0]
000156  eb020383          ADD      r3,r2,r3,LSL #2
00015a  ed832a00          VSTR     s4,[r3,#0]
;;;306          *(pDst + 2 * S->L) = acc2;
00015e  7803              LDRB     r3,[r0,#0]
000160  eb0203c3          ADD      r3,r2,r3,LSL #3
000164  edc32a00          VSTR     s5,[r3,#0]
;;;307          *(pDst + 3 * S->L) = acc3;
000168  7803              LDRB     r3,[r0,#0]
00016a  eb030343          ADD      r3,r3,r3,LSL #1
00016e  eb020383          ADD      r3,r2,r3,LSL #2
000172  ed833a00          VSTR     s6,[r3,#0]
;;;308    
;;;309          pDst++;
000176  1d12              ADDS     r2,r2,#4
;;;310    
;;;311          /* Increment the address modifier index of coefficient buffer */
;;;312          j++;
000178  f10b0b01          ADD      r11,r11,#1
;;;313    
;;;314          /* Decrement the loop counter */
;;;315          i--;
00017c  f1a90901          SUB      r9,r9,#1
                  |L1.384|
000180  f1b90f00          CMP      r9,#0                 ;190
000184  f47faf67          BNE      |L1.86|
;;;316        }
;;;317    
;;;318        /* Advance the state pointer by 1        
;;;319         * to process the next group of interpolation factor number samples */
;;;320        pState = pState + 4;
000188  3410              ADDS     r4,r4,#0x10
;;;321    
;;;322        pDst += S->L * 3;
00018a  7803              LDRB     r3,[r0,#0]
00018c  eb030343          ADD      r3,r3,r3,LSL #1
000190  eb020283          ADD      r2,r2,r3,LSL #2
;;;323    
;;;324        /* Decrement the loop counter */
;;;325        blkCnt--;
000194  f1aa0a01          SUB      r10,r10,#1
                  |L1.408|
000198  f1ba0f00          CMP      r10,#0                ;176
00019c  f47faf46          BNE      |L1.44|
0001a0  e054              B        |L1.588|
                  |L1.418|
;;;326      }
;;;327    
;;;328      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.        
;;;329       ** No loop unrolling is used. */
;;;330    
;;;331      while(blkCntN4 > 0u)
;;;332      {
;;;333        /* Copy new input sample into the state buffer */
;;;334        *pStateCurnt++ = *pSrc++;
0001a2  ecb10a01          VLDM     r1!,{s0}
0001a6  eca80a01          VSTM     r8!,{s0}
;;;335    
;;;336        /* Address modifier index of coefficient buffer */
;;;337        j = 1u;
0001aa  f04f0a01          MOV      r10,#1
;;;338    
;;;339        /* Loop over the Interpolation factor. */
;;;340        i = S->L;
0001ae  f8909000          LDRB     r9,[r0,#0]
;;;341        while(i > 0u)
0001b2  e044              B        |L1.574|
                  |L1.436|
;;;342        {
;;;343          /* Set accumulator to zero */
;;;344          sum0 = 0.0f;
0001b4  eef01a46          VMOV.F32 s3,s12
;;;345    
;;;346          /* Initialize state pointer */
;;;347          ptr1 = pState;
0001b8  4623              MOV      r3,r4
;;;348    
;;;349          /* Initialize coefficient pointer */
;;;350          ptr2 = pCoeffs + (S->L - j);
0001ba  7806              LDRB     r6,[r0,#0]
0001bc  9d01              LDR      r5,[sp,#4]
0001be  eba6070a          SUB      r7,r6,r10
0001c2  eb050587          ADD      r5,r5,r7,LSL #2
;;;351    
;;;352          /* Loop over the polyPhase length. Unroll by a factor of 4.        
;;;353           ** Repeat until we've computed numTaps-(4*S->L) coefficients. */
;;;354          tapCnt = phaseLen >> 2u;
0001c6  ea4f079c          LSR      r7,r12,#2
;;;355          while(tapCnt > 0u)
0001ca  e021              B        |L1.528|
                  |L1.460|
;;;356          {
;;;357    
;;;358            /* Read the coefficient */
;;;359            c0 = *(ptr2);
0001cc  edd50a00          VLDR     s1,[r5,#0]
;;;360    
;;;361            /* Upsampling is done by stuffing L-1 zeros between each sample.        
;;;362             * So instead of multiplying zeros with coefficients,        
;;;363             * Increment the coefficient pointer by interpolation factor times. */
;;;364            ptr2 += S->L;
0001d0  eb050586          ADD      r5,r5,r6,LSL #2
;;;365    
;;;366            /* Read the input sample */
;;;367            x0 = *(ptr1++);
0001d4  ecb30a01          VLDM     r3!,{s0}
;;;368    
;;;369            /* Perform the multiply-accumulate */
;;;370            sum0 += x0 * c0;
0001d8  ee401a20          VMLA.F32 s3,s0,s1
;;;371    
;;;372            /* Read the coefficient */
;;;373            c0 = *(ptr2);
0001dc  edd50a00          VLDR     s1,[r5,#0]
;;;374    
;;;375            /* Increment the coefficient pointer by interpolation factor times. */
;;;376            ptr2 += S->L;
0001e0  eb050586          ADD      r5,r5,r6,LSL #2
;;;377    
;;;378            /* Read the input sample */
;;;379            x0 = *(ptr1++);
0001e4  ecb30a01          VLDM     r3!,{s0}
;;;380    
;;;381            /* Perform the multiply-accumulate */
;;;382            sum0 += x0 * c0;
0001e8  ee401a20          VMLA.F32 s3,s0,s1
;;;383    
;;;384            /* Read the coefficient */
;;;385            c0 = *(ptr2);
0001ec  edd50a00          VLDR     s1,[r5,#0]
;;;386    
;;;387            /* Increment the coefficient pointer by interpolation factor times. */
;;;388            ptr2 += S->L;
0001f0  eb050586          ADD      r5,r5,r6,LSL #2
;;;389    
;;;390            /* Read the input sample */
;;;391            x0 = *(ptr1++);
0001f4  ecb30a01          VLDM     r3!,{s0}
;;;392    
;;;393            /* Perform the multiply-accumulate */
;;;394            sum0 += x0 * c0;
0001f8  ee401a20          VMLA.F32 s3,s0,s1
;;;395    
;;;396            /* Read the coefficient */
;;;397            c0 = *(ptr2);
0001fc  edd50a00          VLDR     s1,[r5,#0]
;;;398    
;;;399            /* Increment the coefficient pointer by interpolation factor times. */
;;;400            ptr2 += S->L;
000200  eb050586          ADD      r5,r5,r6,LSL #2
;;;401    
;;;402            /* Read the input sample */
;;;403            x0 = *(ptr1++);
000204  ecb30a01          VLDM     r3!,{s0}
;;;404    
;;;405            /* Perform the multiply-accumulate */
;;;406            sum0 += x0 * c0;
000208  ee401a20          VMLA.F32 s3,s0,s1
;;;407    
;;;408            /* Decrement the loop counter */
;;;409            tapCnt--;
00020c  1e7f              SUBS     r7,r7,#1
00020e  b2bf              UXTH     r7,r7
                  |L1.528|
000210  2f00              CMP      r7,#0                 ;355
000212  d1db              BNE      |L1.460|
;;;410          }
;;;411    
;;;412          /* If the polyPhase length is not a multiple of 4, compute the remaining filter taps */
;;;413          tapCnt = phaseLen % 0x4u;
000214  f00c0703          AND      r7,r12,#3
;;;414    
;;;415          while(tapCnt > 0u)
000218  e009              B        |L1.558|
                  |L1.538|
;;;416          {
;;;417            /* Perform the multiply-accumulate */
;;;418            sum0 += *(ptr1++) * (*ptr2);
00021a  ecb30a01          VLDM     r3!,{s0}
00021e  edd50a00          VLDR     s1,[r5,#0]
000222  ee401a20          VMLA.F32 s3,s0,s1
;;;419    
;;;420            /* Increment the coefficient pointer by interpolation factor times. */
;;;421            ptr2 += S->L;
000226  eb050586          ADD      r5,r5,r6,LSL #2
;;;422    
;;;423            /* Decrement the loop counter */
;;;424            tapCnt--;
00022a  1e7f              SUBS     r7,r7,#1
00022c  b2bf              UXTH     r7,r7
                  |L1.558|
00022e  2f00              CMP      r7,#0                 ;415
000230  d1f3              BNE      |L1.538|
;;;425          }
;;;426    
;;;427          /* The result is in the accumulator, store in the destination buffer. */
;;;428          *pDst++ = sum0;
000232  ece21a01          VSTM     r2!,{s3}
;;;429    
;;;430          /* Increment the address modifier index of coefficient buffer */
;;;431          j++;
000236  f10a0a01          ADD      r10,r10,#1
;;;432    
;;;433          /* Decrement the loop counter */
;;;434          i--;
00023a  f1a90901          SUB      r9,r9,#1
                  |L1.574|
00023e  f1b90f00          CMP      r9,#0                 ;341
000242  d1b7              BNE      |L1.436|
;;;435        }
;;;436    
;;;437        /* Advance the state pointer by 1        
;;;438         * to process the next group of interpolation factor number samples */
;;;439        pState = pState + 1;
000244  1d24              ADDS     r4,r4,#4
;;;440    
;;;441        /* Decrement the loop counter */
;;;442        blkCntN4--;
000246  9b00              LDR      r3,[sp,#0]
000248  1e5b              SUBS     r3,r3,#1
00024a  9300              STR      r3,[sp,#0]
                  |L1.588|
00024c  9b00              LDR      r3,[sp,#0]            ;331
00024e  2b00              CMP      r3,#0                 ;331
000250  d1a7              BNE      |L1.418|
;;;443      }
;;;444    
;;;445      /* Processing is complete.        
;;;446       ** Now copy the last phaseLen - 1 samples to the satrt of the state buffer.        
;;;447       ** This prepares the state buffer for the next function call. */
;;;448    
;;;449      /* Points to the start of the state buffer */
;;;450      pStateCurnt = S->pState;
000252  6880              LDR      r0,[r0,#8]
;;;451    
;;;452      tapCnt = (phaseLen - 1u) >> 2u;
000254  9902              LDR      r1,[sp,#8]
000256  f3c1018f          UBFX     r1,r1,#2,#16
;;;453    
;;;454      /* copy data */
;;;455      while(tapCnt > 0u)
00025a  e011              B        |L1.640|
                  |L1.604|
;;;456      {
;;;457        *pStateCurnt++ = *pState++;
00025c  ecb40a01          VLDM     r4!,{s0}
000260  eca00a01          VSTM     r0!,{s0}
;;;458        *pStateCurnt++ = *pState++;
000264  ecb40a01          VLDM     r4!,{s0}
000268  eca00a01          VSTM     r0!,{s0}
;;;459        *pStateCurnt++ = *pState++;
00026c  ecb40a01          VLDM     r4!,{s0}
000270  eca00a01          VSTM     r0!,{s0}
;;;460        *pStateCurnt++ = *pState++;
000274  ecb40a01          VLDM     r4!,{s0}
000278  eca00a01          VSTM     r0!,{s0}
;;;461    
;;;462        /* Decrement the loop counter */
;;;463        tapCnt--;
00027c  1e49              SUBS     r1,r1,#1
00027e  b289              UXTH     r1,r1
                  |L1.640|
000280  2900              CMP      r1,#0                 ;455
000282  d1eb              BNE      |L1.604|
;;;464      }
;;;465    
;;;466      tapCnt = (phaseLen - 1u) % 0x04u;
000284  9902              LDR      r1,[sp,#8]
000286  f0010103          AND      r1,r1,#3
;;;467    
;;;468      /* copy data */
;;;469      while(tapCnt > 0u)
00028a  e005              B        |L1.664|
                  |L1.652|
;;;470      {
;;;471        *pStateCurnt++ = *pState++;
00028c  ecb40a01          VLDM     r4!,{s0}
000290  eca00a01          VSTM     r0!,{s0}
;;;472    
;;;473        /* Decrement the loop counter */
;;;474        tapCnt--;
000294  1e49              SUBS     r1,r1,#1
000296  b289              UXTH     r1,r1
                  |L1.664|
000298  2900              CMP      r1,#0                 ;469
00029a  d1f7              BNE      |L1.652|
;;;475      }
;;;476    }
00029c  e8bd8ffe          POP      {r1-r11,pc}
;;;477    
                          ENDP

                  |L1.672|
0002a0  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "..\\..\\SRC\\CMSIS_DSP_4_5\\src\\FilteringFunctions\\arm_fir_interpolate_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_fir_interpolate_f32_c_b477b884____REV16|
#line 129 "..\\..\\SRC\\CMSIS_DSP_4_5\\inc\\core_cmInstr.h"
|__asm___25_arm_fir_interpolate_f32_c_b477b884____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_fir_interpolate_f32_c_b477b884____REVSH|
#line 144
|__asm___25_arm_fir_interpolate_f32_c_b477b884____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_fir_interpolate_f32_c_b477b884____RRX|
#line 300
|__asm___25_arm_fir_interpolate_f32_c_b477b884____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
